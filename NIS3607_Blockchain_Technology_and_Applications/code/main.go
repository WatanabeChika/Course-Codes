package main

import (
	"math/rand"
	"sync"
	"time"
)

// ***Parameters***
// npq = 1e-3
var node_num = 100
var chances_per_round = 10
var hash_probability = 1e-6
var evil_node_ratio = 0.0 // If ==0 then all honest nodes
var selfish_mining = true // If false and evil_node_ratio >0 then forking attack

// Computation abstraction of evil nodes
// See them as one node because they have communication
var evil_node_power = int(evil_node_ratio * float64(node_num) * float64(chances_per_round))
var evil_attack bool = false
var evil *Node = nil

var wg sync.WaitGroup
var mu sync.Mutex
var round = 0

// Chain of blocks
type block struct {
	id       string // Block ID
	source   int    // Node ID
	length   int    // Length of the chain(with a tail of this block)
	time     int    // generated round
	previous *block // Previous block
}

// When in attack, honest and evil nodes can generate blocks in the same round
var r_block *block = nil      // Generated block per round
var evil_r_block *block = nil // Generated block per round by evil node

// Calculate the length of the chain
func length_of_chain(tail *block) int {
	length := 0
	for tail != nil {
		length++
		tail = tail.previous
	}
	return length
}

// Random oracle
func Random(prob float64) bool {
	rand.NewSource(time.Now().UnixNano())
	randomNumber := rand.Float64()
	return randomNumber < prob
}

func main() {
	// Broadcast channel
	tail_chan := make(chan *block)
	// Round signal
	round_chan := make(chan bool)

	// Genesis block
	genesis_block := block{
		id:       "HEAD",
		source:   -1,
		length:   1,
		previous: nil,
	}
	// Initialize the tail of the chain
	tail := &genesis_block

	// Create evil node (No.0)
	if evil_node_power > 0 {
		evil = NewNode(0, true)
		go evil.Run(tail_chan, round_chan)
		node_num = int(float64(node_num)*(float64(1)-evil_node_ratio)) + 1
	} else {
		// No.0 is honest
		node := NewNode(0, false)
		go node.Run(tail_chan, round_chan)
	}
	// Create honest nodes
	for i := 1; i < node_num; i++ {
		node := NewNode(i, false)
		go node.Run(tail_chan, round_chan) // round 0
	}

	// Run (infinite loop)
	if evil_node_ratio == 0 {
		// Simulate 1: all honest nodes
		all_honest(tail, tail_chan, round_chan)
	} else {
		if !selfish_mining {
			// Simulate 2: evil node forking attack
			forking_attack(tail, tail_chan, round_chan)
		} else {
			// Simulate 3: selfish mining attack
			selfish_mining_attack(tail, tail_chan, round_chan)
		}
	}
}

func all_honest(tail *block, tail_chan chan *block, round_chan chan bool) {
	for {
		// Round counter
		round++
		// Round start-signal for all nodes and tell them the current tail
		wg.Add(node_num)
		for i := 0; i < node_num; i++ {
			round_chan <- true
			tail_chan <- tail
		}
		// Wait for all nodes to finish the round
		wg.Wait()

		// Update the longest chain
		if r_block != nil {
			r_block.length = length_of_chain(r_block)
			if tail.length < r_block.length {
				tail = r_block
			}
			r_block = nil
			// Some output
			println("Round:", round)
			println("Tail Block:", tail.id)
			println("Chain Length:", tail.length)
			println("Average Growing Speed:", round/tail.length, "rounds per block")
			println()
		}
	}
}

func forking_attack(tail *block, tail_chan chan *block, round_chan chan bool) {
	// Let honest nodes generate blocks until chain length is up to 5
	for tail.length < 5 {
		round++
		wg.Add(node_num - 1)
		for i := 0; i < node_num-1; i++ {
			round_chan <- true
			tail_chan <- tail
		}
		wg.Wait()

		if r_block != nil {
			r_block.length = length_of_chain(r_block)
			if tail.length < r_block.length {
				tail = r_block
			}
			r_block = nil
			println("Round:", round)
			println("Tail Block:", tail.id)
			println("Chain Length:", tail.length)
			println()
		}
	}

	// Initialize
	println("------Evil node starts forking attack------")
	evil_attack = true
	init_len := tail.length
	evil.tail = tail
	honest_win, evil_win := 0, 0

	// Attack
	for {
		round++
		wg.Add(node_num)
		for i := 0; i < node_num; i++ {
			round_chan <- true
			tail_chan <- tail
		}
		wg.Wait()

		// Block generated by honest nodes
		if r_block != nil {
			r_block.length = length_of_chain(r_block)
			if tail.length < r_block.length {
				tail = r_block
			}
			r_block = nil

			println("Round:", round)
			println("Honest Chain Tail:", tail.id)
			println("Honest Chain Length:", tail.length-init_len)
			println("Evil Chain Tail:", evil.tail.id)
			println("Evil Chain Length:", evil.tail.length-init_len)
			println()
		}
		// Block generated by evil nodes
		if evil_r_block != nil {
			evil.tail.length = length_of_chain(evil_r_block)
			evil_r_block = nil

			println("Round:", round)
			println("Honest Chain Tail:", tail.id)
			println("Honest Chain Length:", tail.length-init_len)
			println("Evil Chain Tail:", evil.tail.id)
			println("Evil Chain Length:", evil.tail.length-init_len)
			println()
		}

		// Check if the attack is successful(6 blocks ahead)
		if tail.length-init_len == 6 {
			honest_win++
			evil.tail = tail
			init_len = tail.length
			println("Honest node wins")
			println("Evil node success rate:", float64(evil_win)/float64(honest_win+evil_win))
			println()
		} else if evil.tail.length-init_len == 6 {
			evil_win++
			evil.tail = tail
			init_len = tail.length
			println("Evil node wins")
			println("Evil node success rate:", float64(evil_win)/float64(honest_win+evil_win))
			println()
		}
	}
}

func selfish_mining_attack(tail *block, tail_chan chan *block, round_chan chan bool) {
	// Let honest nodes generate blocks until chain length is up to 5
	for tail.length < 5 {
		round++
		wg.Add(node_num - 1)
		for i := 0; i < node_num-1; i++ {
			round_chan <- true
			tail_chan <- tail
		}
		wg.Wait()

		if r_block != nil {
			r_block.length = length_of_chain(r_block)
			if tail.length < r_block.length {
				tail = r_block
			}
			r_block = nil
			println("Round:", round)
			println("Tail Block:", tail.id)
			println("Chain Length:", tail.length)
			println()
		}
	}

	// Initialize
	println("------Evil node starts selfish mining attack------")
	evil_attack = true
	evil.tail = tail
	profit := 0
	evil_reserved := false
	var evil_reserved_block *block = nil

	// Attack
	for {
		round++
		wg.Add(node_num)
		for i := 0; i < node_num; i++ {
			round_chan <- true
			tail_chan <- tail
		}
		wg.Wait()

		// Check whether there is reserved block of evil nodes
		if !evil_reserved {
			if r_block != nil {
				// Block generated by honest nodes
				r_block.length = length_of_chain(r_block)
				if tail.length < r_block.length {
					tail = r_block
				}
				r_block = nil
				evil_r_block = nil
				// When no reserved, update realtime tail
				evil.tail = tail

				println("Round:", round)
				println("Tail Block:", tail.id)
				println("Chain Length:", tail.length)
				println()
			} else if evil_r_block != nil {
				// Block generated by evil nodes
				evil.tail.length = length_of_chain(evil_r_block)
				evil_r_block = nil

				// Reserve the block
				evil_reserved_block = evil.tail
				evil_reserved = true

				println("Round:", round)
				println("***RESERVED***")
				println("Evil Reserved Block:", evil_reserved_block.id)
				println("Chain Length:", tail.length)
				println()
			}
		} else {
			if evil_r_block != nil {
				// Evil node get 2 blocks
				evil_r_block.length = length_of_chain(evil_r_block)
				if tail.length < evil_r_block.length {
					tail = evil_r_block
				}
				profit += 2
				r_block = nil
				evil_r_block = nil
				evil_reserved_block = nil
				evil_reserved = false

				println("Round:", round)
				println("Evil Get a New Block:", tail.id)
				println("Evil Profit:", profit)
				println("Chain Length:", tail.length)
				println()

			} else if r_block != nil {
				// Block competition between honest and evil nodes
				if Random(float64(0.5)) {
					// Success of honest node
					r_block.length = length_of_chain(r_block)
					if tail.length < r_block.length {
						tail = r_block
					}
					evil.tail = tail
				} else {
					// Success of evil node
					evil_reserved_block.length = length_of_chain(evil_reserved_block)
					if tail.length < evil_reserved_block.length {
						tail = evil_reserved_block
					}
					profit++
				}
				r_block = nil
				evil_reserved_block = nil
				evil_reserved = false

				println("Round:", round)
				println("Competition Winner Block:", tail.id)
				println("Evil Profit:", profit)
				println("Chain Length:", tail.length)
				println()
			}
		}
	}
}
