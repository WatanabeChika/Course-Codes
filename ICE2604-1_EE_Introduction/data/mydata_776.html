<!DOCTYPE html>
<html>
<head>
<title>polyphase_merge_sort</title>
</head>
<body>
<div class="mw-parser-output">
<p>A <b>polyphase merge sort</b> is a variation of a bottom-up merge sort that sorts a list using an initial uneven distribution of sub-lists (runs), primarily used for external sorting, and is more efficient than an ordinary merge sort when there are fewer than eight external working files (such as a tape drive or a file on a hard drive). A polyphase merge sort is not a stable sort.
</p>

<h2><span class="mw-headline" id="Ordinary_merge_sort">Ordinary merge sort</span><span class="mw-editsection"></span></h2>
<p>A merge sort splits the records of a dataset into sorted runs of records and then repeatedly merges sorted runs into larger sorted runs until only one run, the sorted dataset, remains.
</p><p>An ordinary merge sort using four working files organizes them as a pair of input files and a pair of output files. The dataset is distributed evenly between two of the working files, either as sorted runs or in the simplest case, single records, which can be considered to be sorted runs of size 1. Once all of the dataset is transferred to the two working files, those two working files become the input files for the first merge iteration. Each merge iteration merges runs from the two input working files, alternating the merged output between the two output files, again distributing the merged runs evenly between the two output files (until the final merge iteration). Once all of the runs from the two inputs files are merged and output, then the output files become the input files and vice versa for the next merge iteration. The number of runs decreases by a factor of 2 at each iteration, such as 64, 32, 16, 8, 4, 2, 1. For the final merge iteration, the two input files only have one sorted run (1/2 of the dataset) each, and the merged result is a single sorted run (the sorted dataset) on one of the output files. This is also described at Merge sort § Use with tape drives.
</p><p>If there are only three working files, then an ordinary merge sort merges sorted runs from two working files onto a single working file, then distributes the runs evenly between the two output files. The merge iteration reduces run count by a factor of 2, the redistribute iteration doesn't reduce run count (the factor is 1). Each iteration could be considered to reduce the run count by an average factor of <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;">2</span></span> ≈ 1.41. If there are 5 working files, then the pattern alternates between a 3 way merge and a 2 way merge, for an average factor of <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;">6</span></span> ≈ 2.45.
</p><p>In general, for an even number <i>N</i> of working files, each iteration of an ordinary merge sort reduces run count by a factor of <i>N</i>/2, while for an odd number <i>N</i> of working files, each iteration reduces the run count by an average factor of <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;">(<i>N</i><sup>2</sup>−1)/4</span></span> = <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>N</i><sup>2</sup>−1</span></span>/2.
</p>
<h2><span class="mw-headline" id="Polyphase_merge">Polyphase merge</span><span class="mw-editsection"></span></h2>
<p>For <i>N</i> &lt; 8 working files, a polyphase merge sort achieves a higher effective run count reduction factor by unevenly distributing sorted runs between <i>N</i>−1 working files (explained in next section). Each iteration merges runs from <i>N</i>−1 working files onto a single output working file. When the end of one of the <i>N</i>−1 working files is reached, then it becomes the new output file and what was the output file becomes one of the <i>N</i>−1 working input files, starting a new iteration of polyphase merge sort. Each iteration merges only a fraction of the dataset (about 1/2 to 3/4), except for the last iteration which merges all of the dataset into a single sorted run. The initial distribution is set up so that only one input working file is emptied at a time, except for the final merge iteration which merges <i>N</i>−1 single runs (of varying size, this is explained next) from the <i>N</i>−1 input working files to the single output file, resulting in a single sorted run, the sorted dataset.
</p><p>For each polyphase iteration, the total number of runs follows a pattern similar to a reversed Fibonacci numbers of higher order sequence. With 4 files, and a dataset consisting of 57 runs, the total run count on each iteration would be 57, 31, 17, 9, 5, 3, 1.<sup class="reference" id="cite_ref-Knuth1973_1-0">[1]</sup><sup class="reference" id="cite_ref-2">[2]</sup> Note that except for the last iteration, the run count reduction factor is a bit less than 2, 57/31, 31/17, 17/9, 9/5, 5/3, 3/1, about 1.84 for a 4 file case, but each iteration except the last reduced the run count while processing about 65% of the dataset, so the run count reduction factor per dataset processed during the intermediate iterations is about 1.84 / 0.65 = 2.83. For a dataset consisting of 57 runs of 1 record each, then after the initial distribution, polyphase merge sort moves 232 records during the 6 iterations it takes to sort the dataset, for an overall reduction factor of 2.70 (this is explained in more detail later).
</p><p>After the first polyphase iteration, what was the output file now contains the results of merging <i>N</i>−1 original runs, but the remaining <i>N</i>−2 input working files still contain the remaining original runs, so the second merge iteration produces runs of size (<i>N</i>−1) + (<i>N</i>−2) = (2<i>N</i> − 3) original runs. The third iteration produces runs of size (4<i>N</i> − 7) original runs. With 4 files, the first iteration creates runs of size 3 original runs, the second iteration 5 original runs, the third iteration 9 original runs and so on, following the Fibonacci like pattern, 1, 3, 5, 9, 17, 31, 57, ... , so the increase in run size follows the same pattern as the decrease in run count in reverse. In the example case of 4 files and 57 runs of 1 record each, the last iteration merges 3 runs of size 31, 17, 9, resulting in a single sorted run of size 31+17+9 = 57 records, the sorted dataset. An example of the run counts and run sizes for 4 files, 31 records can be found in table 4.3 of.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="Perfect_3_file_polyphase_merge_sort">Perfect 3 file polyphase merge sort</span><span class="mw-editsection"></span></h2>
<p>It is easiest to look at the polyphase merge starting from its ending conditions and working backwards. At the start of each iteration, there will be two input files and one output file. At the end of the iteration, one input file will have been completely consumed and will become the output file for the next iteration. The current output file will become an input file for the next iteration. The remaining files (just one in the 3 file case) have only been partially consumed and their remaining runs will be input for the next iteration.
</p><p>File 1 just emptied and became the new output file. One run is left on each input tape, and merging those runs together will make the sorted file.
</p>
<pre>File 1 (out):                                           &lt;1 run&gt; *        (the sorted file)
File 2 (in ): ... | &lt;1 run&gt; *               --&gt;     ... &lt;1 run&gt; | *          (consumed)
File 3 (in ):     | &lt;1 run&gt; *                           &lt;1 run&gt; | *          (consumed)

...  possible runs that have already been read
|    marks the read pointer of the file
*    marks end of file
</pre>
<p>Stepping back to the previous iteration, we were reading from 1 and 2. One run is merged from 1 and 2 before file 1 goes empty.  Notice that file 2 is not completely consumed—it has one run left to match the final merge (above).
</p>
<pre>File 1 (in ): ... | &lt;1 run&gt; *                      ... &lt;1 run&gt; | *
File 2 (in ):     | &lt;2 run&gt; *           --&gt;            &lt;1 run&gt; | &lt;1 run&gt; *
File 3 (out):                                          &lt;1 run&gt; *
</pre>
<p>Stepping back another iteration, 2 runs are merged from 1 and 3 before file 3 goes empty.
</p>
<pre>File 1 (in ):     | &lt;3 run&gt;                        ... &lt;2 run&gt; | &lt;1 run&gt; *
File 2 (out):                               --&gt;        &lt;2 run&gt; *
File 3 (in ): ... | &lt;2 run&gt; *                          &lt;2 run&gt; | *
</pre>
<p>Stepping back another iteration, 3 runs are merged from 2 and 3 before file 2 goes empty.
</p>
<pre>File 1 (out):                                          &lt;3 run&gt; *
File 2 (in ): ... | &lt;3 run&gt; *               --&gt;    ... &lt;3 run&gt; | *
File 3 (in ):     | &lt;5 run&gt; *                          &lt;3 run&gt; | &lt;2 run&gt; *
</pre>
<p>Stepping back another iteration, 5 runs are merged from 1 and 2 before file 1 goes empty.
</p>
<pre>File 1 (in ): ... | &lt;5 run&gt; *                      ... &lt;5 run&gt; | *
File 2 (in ):     | &lt;8 run&gt; *               --&gt;        &lt;5 run&gt; | &lt;3 run&gt; *
File 3 (out):                                          &lt;5 run&gt; *
</pre>
<h2><span class="mw-headline" id="Distribution_for_polyphase_merge_sort">Distribution for polyphase merge sort</span><span class="mw-editsection"></span></h2>
<p>Looking at the perfect 3 file case, the number of runs for merged working backwards: 1, 1, 2, 3, 5, ... reveals a Fibonacci sequence. The sequence for more than 3 files is a bit more complicated; for 4 files, starting at the final state and working backwards, the run count pattern is {1,0,0,0}, {0,1,1,1}, {1,0,2,2}, {3,2,0,4}, {7,6,4,0}, {0,13,11,7}, {13,0,24,20}, ... .
</p><p>For everything to work out optimally, the last merge phase should have exactly one run on each input file.  If any input file has more than one run, then another phase would be required. Consequently, the polyphase merge sort needs to be clever about the initial distribution of the input data's runs to the initial output files.  For example, an input file with 13 runs would write 5 runs to file 1 and 8 runs to file 2.
</p><p>In practice, the input file will not have the exact number of runs needed for a perfect distribution. One way to deal with this is by padding the actual distribution with imaginary "dummy runs" to simulate an ideal run distribution.<sup class="reference" id="cite_ref-Knuth1973_1-1">[1]</sup> A dummy run behaves like a run with no records in it. Merging one or more dummy runs with one or more real runs just merges the real runs, and merging one or more dummy runs with no real runs results in a single dummy run. Another approach is to emulate dummy runs as needed during the merge operations.<sup class="reference" id="cite_ref-4">[4]</sup>
</p><p>"Optimal" distribution algorithms require knowing the number of runs in advance. Otherwise, in the more common case where the number of runs is not known in advance, "near optimal" distribution algorithms are used. Some distribution algorithms include rearranging runs.<sup class="reference" id="cite_ref-5">[5]</sup> If the number of runs is known in advance, only a partial distribution is needed before starting the merge phases. For example, consider the 3 file case, starting with <i>n</i> runs in File_1. Define <i>F<sub>i</sub></i> = <i>F</i><sub><i>i</i>−1</sub> + F<sub><i>i</i>−2</sub> as the <i>i</i>th Fibonacci number.  If <i>n</i> = <i>F<sub>i</sub></i>, then move <i>F</i><sub><i>i</i>−2</sub> runs to File_2, leaving <i>F</i><sub><i>i</i>−1</sub> runs remaining on File_1, a perfect run distribution. If <i>F<sub>i</sub></i> &lt; <i>n</i> &lt; <i>F</i><sub><i>i</i>+1</sub>, move <i>n</i>−<i>F<sub>i</sub></i> runs to File_2 and <i>F</i><sub><i>i</i>+1</sub>−<i>n</i> runs to File_3. The first merge iteration merges <i>n</i>−<i>F<sub>i</sub></i> runs from File_1 and File_2, appending the <i>n</i>−<i>F<sub>i</sub></i> merged runs to the <i>F</i><sub><i>i</i>+1</sub>−<i>n</i> runs already moved to File_3. File_1 ends up with <i>F</i><sub><i>i</i>−2</sub> runs remaining, File_2 is emptied, and File_3 ends up with <i>F</i><sub><i>i</i>−1</sub> runs, again a perfect run distribution. For 4 or more files, the math is more complicated, but the concept is the same.
</p>
<h2><span class="mw-headline" id="Comparison_versus_ordinary_merge_sort">Comparison versus ordinary merge sort</span><span class="mw-editsection"></span></h2>
<p>After the initial distribution, an ordinary merge sort using 4 files will sort 16 single record runs in 4 iterations of the entire dataset, moving a total of 64 records in order to sort the dataset after the initial distribution. A polyphase merge sort using 4 files will sort 17 single record runs in 4 iterations, but since each iteration but the last iteration only moves a fraction of the dataset, it only moves a total of 48 records in order to sort the dataset after the initial distribution. In this case, ordinary merge sort factor is 2.0, while polyphase overall factor is ≈2.73.
</p><p>To explain how the reduction factor is related to sort performance, the reduction factor equations are:
</p>
<pre>reduction_factor = exp(number_of_runs*log(number_of_runs)/run_move_count)
run_move_count = number_of_runs * log(number_of_runs)/log(reduction_factor)
run_move_count = number_of_runs * log_reduction_factor(number_of_runs)
</pre>
<p>Using the run move count equation for the above examples: 
</p>
<ul><li>ordinary merge sort → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 16\times \log _{2}(16)=64}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>16</mn>
<mo>×<!-- × --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mn>16</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mn>64</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 16\times \log _{2}(16)=64}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 16\times \log _{2}(16)=64}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8c5c348ca3f0c41b6ea33353cb9be4f860c513dc" style="vertical-align: -0.838ex; width:18.749ex; height:2.843ex;"/></span>,</li>
<li>polyphase merge sort → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 17\times \log _{2.73}(17)=48}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>17</mn>
<mo>×<!-- × --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2.73</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mn>17</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mn>48</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 17\times \log _{2.73}(17)=48}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 17\times \log _{2.73}(17)=48}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d77ef30290856e53786b95fc192ac08a3fc4d556" style="vertical-align: -0.838ex; width:20.85ex; height:2.843ex;"/></span>.</li></ul>
<p>Here is a table of effective reduction factors for polyphase and ordinary merge sort listed by number of files, based on actual sorts of a few million records. This table roughly corresponds to the reduction factor per dataset moved tables shown in fig 3 and fig 4 of polyphase merge sort.pdf
</p>
<pre># files
|     average fraction of data per iteration
|     |     polyphase reduction factor on ideal sized data
|     |     |     ordinary reduction factor on ideal sized data
|     |     |     |
3     .73   1.94  1.41  (sqrt  2)
4     .63   2.68  2.00
5     .58   3.20  2.45  (sqrt  6)
6     .56   3.56  3.00
7     .55   3.80  3.46  (sqrt 12)
8     .54   3.95  4.00
9     .53   4.07  4.47  (sqrt 20)
10    .53   4.15  5.00
11    .53   4.22  5.48  (sqrt 30)
12    .53   4.28  6.00
32    .53   4.87 16.00
</pre>
<p>In general, polyphase merge sort is better than ordinary merge sort when there are fewer than 8 files, while ordinary merge sort starts to become better at around 8 or more files.<sup class="reference" id="cite_ref-6">[6]</sup><sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2">Bradley, James (1982), <span class="cs1-lock-registration" title="Free registration required"><i>File and Data Base Techniques</i></span>, Holt, Rinehart and Winston, ISBN <bdi>0-03-058673-9</bdi></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=File+and+Data+Base+Techniques&amp;rft.pub=Holt%2C+Rinehart+and+Winston&amp;rft.date=1982&amp;rft.isbn=0-03-058673-9&amp;rft.aulast=Bradley&amp;rft.aufirst=James&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Ffiledatabasetech0000brad&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolyphase+merge+sort"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2">Reynolds, Samuel W. (August 1961), "A generalized polyphase merge algorithm", <i>Communications of the ACM</i>, New York, NY: ACM, <b>4</b> (8): 347–349, doi:10.1145/366678.366689, S2CID 28416100</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=A+generalized+polyphase+merge+algorithm&amp;rft.volume=4&amp;rft.issue=8&amp;rft.pages=347-349&amp;rft.date=1961-08&amp;rft_id=info%3Adoi%2F10.1145%2F366678.366689&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A28416100%23id-name%3DS2CID&amp;rft.aulast=Reynolds&amp;rft.aufirst=Samuel+W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolyphase+merge+sort"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2">Sedgewick, Robert (1983), <span class="cs1-lock-registration" title="Free registration required"><i>Algorithms</i></span>, Addison-Wesley, pp. 163–165, ISBN <bdi>0-201-06672-6</bdi></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithms&amp;rft.pages=163-165&amp;rft.pub=Addison-Wesley&amp;rft.date=1983&amp;rft.isbn=0-201-06672-6&amp;rft.aulast=Sedgewick&amp;rft.aufirst=Robert&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Falgorithms00sedg%2Fpage%2F163&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolyphase+merge+sort"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>

<!-- 
NewPP limit report
Parsed by mw2391
Cached time: 20221224064221
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.211 seconds
Real time usage: 0.318 seconds
Preprocessor visited node count: 1070/1000000
Post‐expand include size: 31759/2097152 bytes
Template argument size: 2600/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 21537/5000000 bytes
Lua time usage: 0.122/10.000 seconds
Lua memory usage: 4727822/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  252.021      1 -total
 48.48%  122.168      1 Template:Reflist
 26.53%   66.852      3 Template:Cite_web
 22.85%   57.587      1 Template:Short_description
 16.40%   41.342      1 Template:Sorting
 15.53%   39.151      3 Template:Bare_URL_PDF
 15.47%   38.981      1 Template:Navbox
 13.21%   33.287      3 Template:Fix
 11.86%   29.887      2 Template:Pagetype
  6.97%   17.558      3 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:17509736-0!canonical and timestamp 20221224064221 and revision id 1105616444.
 -->
</div></body>
</html>