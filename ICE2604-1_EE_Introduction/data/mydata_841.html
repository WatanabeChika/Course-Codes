<!DOCTYPE html>
<html>
<head>
<title>recursion</title>
</head>
<body>
<div class="mw-parser-output"><img alt="Page semi-protected" data-file-height="512" data-file-width="512" decoding="async" height="20" src="//upload.wikimedia.org/wikipedia/en/thumb/1/1b/Semi-protection-shackle.svg/20px-Semi-protection-shackle.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/1/1b/Semi-protection-shackle.svg/30px-Semi-protection-shackle.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/1/1b/Semi-protection-shackle.svg/40px-Semi-protection-shackle.svg.png 2x" width="20"/></div><div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p class="mw-empty-elt">
</p>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>

<p><b>Recursion</b> (adjective: <i>recursive</i>) occurs when a thing is defined in terms of itself or of its type. Recursion is used in a variety of disciplines ranging from linguistics to logic. The most common application of recursion is in mathematics and computer science, where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no infinite loop or infinite chain of references ("crock recursion") can occur.
</p>

<h2><span class="mw-headline" id="Formal_definitions">Formal definitions</span></h2>

<p>In mathematics and computer science, a class of objects or methods exhibits recursive behavior when it can be defined by two properties:
</p>
<ul><li><span class="anchor" id="base_case"></span>A simple <i>base case</i> (or cases) — a terminating scenario that does not use recursion to produce an answer</li>
<li><span class="anchor" id="recursive_step"></span>A <i>recursive step</i> — a set of rules that reduces all successive cases toward the base case.</li></ul>
<p>For example, the following is a recursive definition of a person's <i>ancestor</i>. One's ancestor is either:
</p>
<ul><li>One's parent (<i>base case</i>), <i>or</i></li>
<li>One's parent's ancestor (<i>recursive step</i>).</li></ul>
<p>The Fibonacci sequence is another classic example of recursion:
</p>
<dl><dd><span class="texhtml">Fib(0) = 0</span> as base case 1,</dd></dl>
<dl><dd><span class="texhtml">Fib(1) = 1</span> as base case 2,</dd></dl>
<dl><dd>For all integers <span class="texhtml"><i>n</i> &gt; 1</span>, <span class="texhtml">Fib(<i>n</i>) = Fib(<i>n</i> − 1) + Fib(<i>n</i> − 2)</span>.</dd></dl>
<p>Many mathematical axioms are based upon recursive rules. For example, the formal definition of the natural numbers by the Peano axioms can be described as: "Zero is a natural number, and each natural number has a successor, which is also a natural number."<sup class="reference" id="cite_ref-1">[1]</sup> By this base case and recursive rule, one can generate the set of all natural numbers.
</p><p>Other recursively defined mathematical objects include factorials, functions (e.g., recurrence relations), sets (e.g., Cantor ternary set), and fractals.
</p><p>There are various more tongue-in-cheek definitions of recursion; see recursive humor.
</p>
<h2><span class="mw-headline" id="Informal_definition">Informal definition</span></h2>

<p>Recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself. A procedure that goes through recursion is said to be 'recursive'.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>To understand recursion, one must recognize the distinction between a procedure and the running of a procedure. A procedure is a set of steps based on a set of rules, while the running of a procedure involves actually following the rules and performing the steps.
</p><p>Recursion is related to, but not the same as, a reference within the specification of a procedure to the execution of some other procedure.
</p><p>When a procedure is defined as such, this immediately creates the possibility of an endless loop; recursion can only be properly used in a definition if the step in question is skipped in certain cases so that the procedure can complete. Recursion comes in three forms: <i>direct</i>, <i>indirect</i>, and <i>circular</i>. Direct recursion is when a function (A) invokes itself (A references A); indirect recursion occurs when one function (A) invokes (B), function (B) invokes function (C), function (C) invokes (D), etc., until one of the functions in the chain invokes an earlier one. Circular recursion occurs when function (A) and function (B) invoke each other. If an infinite loop occurs in direct, indirect, or circular recursion, it is said to be the condition of "crock recursion." There are basically two ways to prevent crock recursion, either limit the number of times a function may reference itself, or place an absolute limit on the depth of function calls, e.g. if there is a depth limit of 50, any time a procedure calls another, a counter is increased; when it exits, that counter is decreased. Once the counter reaches the limit (in this case, 50) no further procedure calls are allowed; if any attempt to call a 51st function is made, the operation is terminated. Using a recursion limit prevents only crock recursion; placing a call limit, in addition to halting crock recursion, may have the side effect of preventing the execution of legitimate complex procedures which are deeply nested, but not recursive. 
</p><p>But even if it is properly defined, a recursive procedure is not easy for humans to perform, as it requires distinguishing the new from the old, partially executed invocation of the procedure; this requires some administration as to how far various simultaneous instances of the procedures have progressed. For this reason, recursive definitions are very rare in everyday situations.
</p>
<h2><span class="mw-headline" id="In_language">In language</span></h2>
<p>Linguist Noam Chomsky, among many others, has argued that the lack of an upper bound on the number of grammatical sentences in a language, and the lack of an upper bound on grammatical sentence length (beyond practical constraints such as the time available to utter one), can be explained as the consequence of recursion in natural language.<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup>
</p><p>This can be understood in terms of a recursive definition of a syntactic category, such as a sentence. A sentence can have a structure in which what follows the verb is another sentence: <i>Dorothy thinks witches are dangerous</i>, in which the sentence <i>witches are dangerous</i> occurs in the larger one. So a sentence can be defined recursively (very roughly) as something with a structure that includes a noun phrase, a verb, and optionally another sentence. This is really just a special case of the mathematical definition of recursion.
</p><p>This provides a way of understanding the creativity of language—the unbounded number of grammatical sentences—because it immediately predicts that sentences can be of arbitrary length: <i>Dorothy thinks that Toto suspects that Tin Man said that...</i>. There are many structures apart from sentences that can be defined recursively, and therefore many ways in which a sentence can embed instances of one category inside another.<sup class="reference" id="cite_ref-5">[5]</sup> Over the years, languages in general have proved amenable to this kind of analysis.
</p><p>The generally accepted idea that recursion is an essential property of human language has been challenged by Daniel Everett on the basis of his claims about the Pirahã language. Andrew Nevins, David Pesetsky and Cilene Rodrigues are among many who have refuted this challenge.<sup class="reference" id="cite_ref-6">[6]</sup> Literary self-reference can in any case be argued to be different in kind from mathematical or logical recursion.<sup class="reference" id="cite_ref-Drucker2008_7-0">[7]</sup>
</p><p>Recursion plays a crucial role not only in syntax, but also in natural language semantics. The word <i>and</i>, for example, can be construed as a function that can apply to sentence meanings to create new sentences, and likewise for noun phrase meanings, verb phrase meanings, and others. It can also apply to intransitive verbs, transitive verbs, or ditransitive verbs. In order to provide a single denotation for it that is suitably flexible, <i>and</i> is typically defined so that it can take any of these different types of meanings as arguments. This can be done by defining it for a simple case in which it combines sentences, and then defining the other cases recursively in terms of the simple one.<sup class="reference" id="cite_ref-8">[8]</sup>
</p><p>A recursive grammar is a formal grammar that contains recursive production rules.<sup class="reference" id="cite_ref-ns02_9-0">[9]</sup>
</p>
<h3><span class="mw-headline" id="Recursive_humor">Recursive humor</span></h3>

<p>Recursion is sometimes used humorously in computer science, programming, philosophy, or mathematics textbooks, generally by giving a circular definition or self-reference, in which the putative recursive step does not get closer to a base case, but instead leads to an infinite regress. It is not unusual for such books to include a joke entry in their glossary along the lines of:
</p>
<dl><dd>Recursion, <i>see Recursion</i>.<sup class="reference" id="cite_ref-Hunter_10-0">[10]</sup></dd></dl>
<p>A variation is found on page 269 in the index  of some editions of Brian Kernighan and Dennis Ritchie's book <i>The C Programming Language</i>; the index entry recursively references itself ("recursion 86, 139, 141, 182, 202, 269"). Early versions of this joke can be found in <i>Let's talk Lisp</i> by Laurent Siklóssy (published by Prentice Hall PTR on December 1, 1975, with a copyright date of 1976) and in <i>Software Tools</i> by Kernighan and Plauger (published by Addison-Wesley Professional on January 11, 1976). The joke also appears in <i>The UNIX Programming Environment</i> by Kernighan and Pike. It did not appear in the first edition of <i>The C Programming Language</i>. The joke is part of the Functional programming folklore and was already widespread in the functional programming community before the publication of the aforementioned books.
</p><p>Another joke is that "To understand recursion, you must understand recursion."<sup class="reference" id="cite_ref-Hunter_10-1">[10]</sup> In the English-language version of the Google web search engine, when a search for "recursion" is made, the site suggests "Did you mean: <i>recursion</i>."<sup class="reference" id="cite_ref-11">[11]</sup> An alternative form is the following, from Andrew Plotkin: <i>"If you already know what recursion is, just remember the answer. Otherwise, find someone who is standing closer to Douglas Hofstadter than you are; then ask him or her what recursion is."</i>
</p><p>Recursive acronyms are other examples of recursive humor. PHP, for example, stands for "PHP Hypertext Preprocessor", WINE stands for "WINE Is Not an Emulator" GNU stands for "GNU's not Unix", and SPARQL denotes the "SPARQL Protocol and RDF Query Language".
</p>
<h2><span class="mw-headline" id="In_mathematics">In mathematics</span></h2>

<h3><span class="mw-headline" id="Recursively_defined_sets">Recursively defined sets</span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<h4><span class="mw-headline" id="Example:_the_natural_numbers">Example: the natural numbers</span></h4>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The canonical example of a recursively defined set is given by the natural numbers:
</p>
<dl><dd>0 is in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="\mathbb {N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fdf9a96b565ea202d0f4322e9195613fb26a9bed" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span></dd>
<dd>if <i>n</i> is in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="\mathbb {N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fdf9a96b565ea202d0f4322e9195613fb26a9bed" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span>, then <i>n</i> + 1 is in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="\mathbb {N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fdf9a96b565ea202d0f4322e9195613fb26a9bed" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span></dd>
<dd>The set of natural numbers is the smallest set satisfying the previous two properties.</dd></dl>
<p>In mathematical logic, the Peano axioms (or Peano postulates or Dedekind–Peano axioms), are axioms for the natural numbers presented in the 19th century by the German mathematician Richard Dedekind and by the Italian mathematician Giuseppe Peano. The Peano Axioms define the natural numbers referring to a recursive successor function and addition and multiplication as recursive functions.
</p>
<h4><span class="mw-headline" id="Example:_Proof_procedure">Example: Proof procedure</span></h4>
<p>Another interesting example is the set of all "provable" propositions in an axiomatic system that are defined in terms of a proof procedure which is inductively (or recursively) defined as follows:
</p>
<ul><li>If a proposition is an axiom, it is a provable proposition.</li>
<li>If a proposition can be derived from true reachable propositions by means of inference rules, it is a provable proposition.</li>
<li>The set of provable propositions is the smallest set of propositions satisfying these conditions.</li></ul>
<h3><span class="mw-headline" id="Finite_subdivision_rules">Finite subdivision rules</span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Finite subdivision rules are a geometric form of recursion, which can be used to create fractal-like images. A subdivision rule starts with a collection of polygons labelled by finitely many labels, and then each polygon is subdivided into smaller labelled polygons in a way that depends only on the labels of the original polygon. This process can be iterated. The standard `middle thirds' technique for creating the Cantor set is a subdivision rule, as is barycentric subdivision.
</p>
<h3><span class="mw-headline" id="Functional_recursion">Functional recursion</span></h3>
<p>A function may be recursively defined in terms of itself. A familiar example is the Fibonacci number sequence: <i>F</i>(<i>n</i>) = <i>F</i>(<i>n</i> − 1) + <i>F</i>(<i>n</i> − 2).  For such a definition to be useful, it must be reducible to non-recursively defined values: in this case <i>F</i>(0) = 0 and <i>F</i>(1) = 1.
</p><p>A famous recursive function is the Ackermann function, which, unlike the Fibonacci sequence, cannot be expressed without recursion.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (October 2019)">citation needed</span></i>]</sup>
</p>
<h3><span class="mw-headline" id="Proofs_involving_recursive_definitions">Proofs involving recursive definitions</span></h3>
<p>Applying the standard technique of proof by cases to recursively defined sets or functions, as in the preceding sections, yields structural induction — a powerful generalization of mathematical induction widely used to derive proofs in mathematical logic and computer science.
</p>
<h3><span class="mw-headline" id="Recursive_optimization">Recursive optimization</span></h3>
<p>Dynamic programming is an approach to optimization that restates a multiperiod or multistep optimization problem in recursive form. The key result in dynamic programming is the Bellman equation, which writes the value of the optimization problem at an earlier time (or earlier step) in terms of its value at a later time (or later step).
</p>
<h3><span class="mw-headline" id="The_recursion_theorem">The recursion theorem</span></h3>
<p>In set theory, this is a theorem guaranteeing that recursively defined functions exist. Given a set <span class="texhtml mvar" style="font-style:italic;">X</span>, an element <span class="texhtml mvar" style="font-style:italic;">a</span> of <span class="texhtml mvar" style="font-style:italic;">X</span> and a function <span class="texhtml"><i>f</i>: <i>X</i> → <i>X</i></span>, the theorem states that there is a unique function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F:\mathbb {N} \to X}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo>:</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mo stretchy="false">→<!-- → --></mo>
<mi>X</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F:\mathbb {N} \to X}</annotation>
</semantics>
</math></span><img alt="{\displaystyle F:\mathbb {N} \to X}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12e26c5d663cc5a24ab3ceef0bf75ad2c7c626e4" style="vertical-align: -0.338ex; width:10.95ex; height:2.176ex;"/></span> (where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="\mathbb {N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fdf9a96b565ea202d0f4322e9195613fb26a9bed" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span> denotes the set of natural numbers including zero) such that
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F(0)=a}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>a</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F(0)=a}</annotation>
</semantics>
</math></span><img alt="F(0) = a" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e13d054d8df6f9f2770997b66344c4f390bae2d4" style="vertical-align: -0.838ex; width:9.041ex; height:2.843ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F(n+1)=f(F(n))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>F</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F(n+1)=f(F(n))}</annotation>
</semantics>
</math></span><img alt="F(n + 1) = f(F(n))" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/872fa88af5e4b3ca934ba4abee41be187e3d3f94" style="vertical-align: -0.838ex; width:20.079ex; height:2.843ex;"/></span></dd></dl>
<p>for any natural number <span class="texhtml mvar" style="font-style:italic;">n</span>.
</p>
<h4><span class="mw-headline" id="Proof_of_uniqueness">Proof of uniqueness</span></h4>
<p>Take two functions <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F:\mathbb {N} \to X}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo>:</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mo stretchy="false">→<!-- → --></mo>
<mi>X</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F:\mathbb {N} \to X}</annotation>
</semantics>
</math></span><img alt="{\displaystyle F:\mathbb {N} \to X}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12e26c5d663cc5a24ab3ceef0bf75ad2c7c626e4" style="vertical-align: -0.338ex; width:10.95ex; height:2.176ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle G:\mathbb {N} \to X}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>G</mi>
<mo>:</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mo stretchy="false">→<!-- → --></mo>
<mi>X</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle G:\mathbb {N} \to X}</annotation>
</semantics>
</math></span><img alt="{\displaystyle G:\mathbb {N} \to X}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/23a0594749da30b07c384d71c20068c54f02af5a" style="vertical-align: -0.338ex; width:11.036ex; height:2.176ex;"/></span> such that:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F(0)=a}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>a</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F(0)=a}</annotation>
</semantics>
</math></span><img alt="F(0) = a" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e13d054d8df6f9f2770997b66344c4f390bae2d4" style="vertical-align: -0.838ex; width:9.041ex; height:2.843ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle G(0)=a}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>G</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>a</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle G(0)=a}</annotation>
</semantics>
</math></span><img alt="G(0) = a" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e4144e1a9d47560e0b5930da11b91807bde69f5" style="vertical-align: -0.838ex; width:9.127ex; height:2.843ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F(n+1)=f(F(n))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>F</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F(n+1)=f(F(n))}</annotation>
</semantics>
</math></span><img alt="F(n + 1) = f(F(n))" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/872fa88af5e4b3ca934ba4abee41be187e3d3f94" style="vertical-align: -0.838ex; width:20.079ex; height:2.843ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle G(n+1)=f(G(n))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>G</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle G(n+1)=f(G(n))}</annotation>
</semantics>
</math></span><img alt="G(n + 1) = f(G(n))" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e0c178891ef17320110f41eaeb21ab5307f996a2" style="vertical-align: -0.838ex; width:20.251ex; height:2.843ex;"/></span></dd></dl>
<p>where <span class="texhtml mvar" style="font-style:italic;">a</span> is an element of <span class="texhtml mvar" style="font-style:italic;">X</span>.
</p><p>It can be proved by mathematical induction that <span class="texhtml"><i>F</i>(<i>n</i>) = <i>G</i>(<i>n</i>)</span> for all natural numbers 
<span class="texhtml mvar" style="font-style:italic;">n</span>:
</p>
<dl><dd><b>Base Case</b>: <span class="texhtml"><i>F</i>(0) = <i>a</i> = <i>G</i>(0)</span> so the equality holds for <span class="texhtml"><i>n</i> = 0</span>.</dd></dl>
<dl><dd><b>Inductive Step</b>: Suppose <span class="texhtml"><i>F</i>(<i>k</i>) = <i>G</i>(<i>k</i>)</span> for some <span class="nowrap"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k\in \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k\in \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="k\in \mathbb{N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a5bc4b7383031ba693b7433198ead7170954c1d" style="vertical-align: -0.338ex; width:5.73ex; height:2.176ex;"/></span>.</span> Then <span class="texhtml"><i>F</i>(<i>k</i> + 1) = <i>f</i>(<i>F</i>(<i>k</i>)) = <i>f</i>(<i>G</i>(<i>k</i>)) = <i>G</i>(<i>k</i> + 1)</span>.
<dl><dd>Hence <span class="texhtml"><i>F</i>(<i>k</i>) = <i>G</i>(<i>k</i>)</span> implies <span class="texhtml"><i>F</i>(<i>k</i> + 1) = <i>G</i>(<i>k</i> + 1)</span>.</dd></dl></dd></dl>
<p>By induction, <span class="texhtml"><i>F</i>(<i>n</i>) = <i>G</i>(<i>n</i>)</span> for all <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n\in \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n\in \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="n\in \mathbb {N} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d059936e77a2d707e9ee0a1d9575a1d693ce5d0b" style="vertical-align: -0.338ex; width:5.913ex; height:2.176ex;"/></span>.
</p>
<h2><span class="mw-headline" id="In_computer_science">In computer science</span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A common method of simplification is to divide a problem into subproblems of the same type. As a computer programming technique, this is called divide and conquer and is key to the design of many important algorithms. Divide and conquer serves as a top-down approach to problem solving, where problems are solved by solving smaller and smaller instances. A contrary approach is dynamic programming. This approach serves as a bottom-up approach, where problems are solved by solving larger and larger instances, until the desired size is reached.
</p><p>A classic example of recursion is the definition of the factorial function, given here in C code:
</p>

<p>The function calls itself recursively on a smaller version of the input <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">(n - 1)</code> and multiplies the result of the recursive call by <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">n</code>, until reaching the base case, analogously to the mathematical definition of factorial.
</p><p>Recursion in computer programming is exemplified when a function is defined in terms of simpler, often smaller versions of itself. The solution to the problem is then devised by combining the solutions obtained from the simpler versions of the problem. One example application of recursion is in parsers for programming languages. The great advantage of recursion is that an infinite set of possible sentences, designs or other data can be defined, parsed or produced by a finite computer program.
</p><p>Recurrence relations are equations which define one or more sequences recursively. Some specific kinds of recurrence relation can be "solved" to obtain a non-recursive definition (e.g., a closed-form expression).
</p><p>Use of recursion in an algorithm has both advantages and disadvantages.  The main advantage is usually the simplicity of instructions. The main disadvantage is that the memory usage of recursive algorithms may grow very quickly, rendering them impractical for larger instances.
</p>
<h2><span class="mw-headline" id="In_biology">In biology</span></h2>
<p>Shapes that seem to have been created by recursive processes sometimes appear in plants and animals, such as in branching structures in which one large part branches out into two or more similar smaller parts.  One example is Romanesco broccoli.<sup class="reference" id="cite_ref-12">[12]</sup>
</p>
<h2><span class="mw-headline" id="In_art">In art</span></h2>


<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The Russian Doll or Matryoshka doll is a physical artistic example of the recursive concept.<sup class="reference" id="cite_ref-13">[13]</sup>
</p><p>Recursion has been used in paintings since Giotto's <i>Stefaneschi Triptych</i>, made in 1320. Its central panel contains the kneeling figure of Cardinal Stefaneschi, holding up the triptych itself as an offering.<sup class="reference" id="cite_ref-14">[14]</sup><sup class="reference" id="cite_ref-15">[15]</sup> This practice is more generally known as the Droste effect, an example of the Mise en abyme technique.
</p><p>M. C. Escher's <i>Print Gallery</i> (1956) is a print which depicts a distorted city containing a gallery which recursively contains the picture, and so <i>ad infinitum</i>.<sup class="reference" id="cite_ref-16">[16]</sup>
</p>

<h2><span class="mw-headline" id="See_also">See also</span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="References">References</span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Bibliography">Bibliography</span></h2>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="External_links">External links</span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<link href="mw-data:TemplateStyles:r1097025294" rel="mw-deduplicated-inline-style"/>
<ul><li>Recursion - tutorial by Alan Gauld</li>
<li>Zip Files All The Way Down</li>
<li>Nevins, Andrew and David Pesetsky and Cilene Rodrigues. Evidence and Argumentation: A Reply to Everett (2009). Language 85.3: 671--681 (2009)</li></ul>



<!-- 
NewPP limit report
Parsed by mw2414
Cached time: 20221222030929
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.526 seconds
Real time usage: 0.962 seconds
Preprocessor visited node count: 3151/1000000
Post‐expand include size: 143291/2097152 bytes
Template argument size: 3441/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 16/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 84555/5000000 bytes
Lua time usage: 0.292/10.000 seconds
Lua memory usage: 9156804/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  548.411      1 -total
 25.42%  139.390      1 Template:Reflist
 15.59%   85.490      8 Template:Cite_web
 12.98%   71.198      5 Template:Navbox
 10.68%   58.558     15 Template:Cite_book
  9.15%   50.197      1 Template:More_citations_needed
  8.81%   48.320      1 Template:Short_description
  8.36%   45.853      1 Template:Ambox
  7.31%   40.067      1 Template:Fractals
  6.75%   37.004      1 Template:Commons_category
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:25407-0!canonical and timestamp 20221222030928 and revision id 1122883940.
 -->
</div></body>
</html>