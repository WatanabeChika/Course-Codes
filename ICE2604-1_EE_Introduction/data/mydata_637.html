<!DOCTYPE html>
<html>
<head>
<title>move-to-front_heuristic</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>The <b>move-to-front (MTF) transform</b> is an encoding of data (typically a stream of bytes) designed to improve the performance of entropy encoding techniques of compression.  When efficiently implemented, it is fast enough that its benefits usually justify including it as an extra step in data compression algorithm.
</p><p>This algorithm was first published by B. Ryabko under the name of "book stack" in 1980.<sup class="reference" id="cite_ref-1">[1]</sup> Subsequently, it was rediscovered by J.K. Bentley et al. in 1986,<sup class="reference" id="cite_ref-2">[2]</sup> as attested in the explanatory note.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>

<h2><span class="mw-headline" id="The_transform">The transform</span><span class="mw-editsection"></span></h2>
<p>The main idea is that each symbol in the data is replaced by its index in the stack of “recently used symbols”. For example, long sequences of identical symbols are replaced by as many zeroes, whereas when a symbol that has not been used in a long time appears, it is replaced with a large number. Thus at the end the data is transformed into a sequence of integers; if the data exhibits a lot of local correlations, then these integers tend to be small.
</p><p>Let us give a precise description. Assume for simplicity that the symbols in the data are bytes.
Each byte value is encoded by its index in a list of bytes, which changes over the course of the algorithm.  The list is initially in order by byte value (0, 1, 2, 3, ..., 255).  Therefore, the first byte is always encoded by its own value.  However, after encoding a byte, that value is moved to the front of the list before continuing to the next byte.
</p><p>An example will shed some light on how the transform works.  Imagine instead of bytes, we are encoding values in a–z.  We wish to transform the following sequence:
</p>
<pre>bananaaa
</pre>
<p>By convention, the list is initially (abcdefghijklmnopqrstuvwxyz).  The first letter in the sequence is b, which appears at index 1 (the list is indexed from 0 to 25).  We put a 1 to the output stream:
</p>
<pre>1
</pre>
<p>The b moves to the front of the list, producing (bacdefghijklmnopqrstuvwxyz).  The next letter is a, which now appears at index 1.  So we add a 1 to the output stream. We have:
</p>
<pre>1,1
</pre>
<p>and we move the letter a back to the top of the list.  Continuing this way, we find that the sequence is encoded by:
</p>
<pre>1,1,13,1,1,1,0,0
</pre>
<table border="1" class="wikitable">
<tbody><tr>
<th>Iteration
</th>
<th>Sequence
</th>
<th>List
</th></tr>
<tr>
<td><b>b</b>ananaaa
</td>
<td>1
</td>
<td>(abcdefghijklmnopqrstuvwxyz)
</td></tr>
<tr>
<td>b<b>a</b>nanaaa
</td>
<td>1,1
</td>
<td>(bacdefghijklmnopqrstuvwxyz)
</td></tr>
<tr>
<td>ba<b>n</b>anaaa
</td>
<td>1,1,13
</td>
<td>(abcdefghijklmnopqrstuvwxyz)
</td></tr>
<tr>
<td>ban<b>a</b>naaa
</td>
<td>1,1,13,1
</td>
<td>(nabcdefghijklmopqrstuvwxyz)
</td></tr>
<tr>
<td>bana<b>n</b>aaa
</td>
<td>1,1,13,1,1
</td>
<td>(anbcdefghijklmopqrstuvwxyz)
</td></tr>
<tr>
<td>banan<b>a</b>aa
</td>
<td>1,1,13,1,1,1
</td>
<td>(nabcdefghijklmopqrstuvwxyz)
</td></tr>
<tr>
<td>banana<b>a</b>a
</td>
<td>1,1,13,1,1,1,0
</td>
<td>(anbcdefghijklmopqrstuvwxyz)
</td></tr>
<tr>
<td>bananaa<b>a</b>
</td>
<td>1,1,13,1,1,1,0,0
</td>
<td>(anbcdefghijklmopqrstuvwxyz)
</td></tr>
<tr>
<td>Final
</td>
<td>1,1,13,1,1,1,0,0
</td>
<td>(anbcdefghijklmopqrstuvwxyz)
</td></tr></tbody></table>
<p>It is easy to see that the transform is reversible.  Simply maintain the same list and decode by replacing each index in the encoded stream with the letter at that index in the list. Note the difference between this and the encoding method: The index in the list is used directly instead of looking up each value for its index.
</p><p>i.e. you start again with (abcdefghijklmnopqrstuvwxyz). You take the "1" of the encoded block and look it up in the list, which results in "b". Then move the "b" to front which results in (bacdef...). Then take the next "1", look it up in the list, this results in "a", move the "a" to front ... etc.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>Details of implementation are important for performance, particularly for decoding.  For encoding, no clear advantage is gained by using a linked list, so using an array to store the list is acceptable, with worst-case performance O(<var>n</var><var>k</var>), where <var>n</var> is the length of the data to be encoded and <var>k</var> is the number of values (generally a constant for a given implementation).
</p><p>The typical performance is better because frequently-used symbols are more likely to be at the front and will produce earlier hits. This is also the idea behind a Move-to-front self-organizing list.
</p><p>However, for decoding, we can use specialized data structures to greatly improve performance.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="An editor has requested that an example be provided. (February 2012)"><span style="font-style:italic; padding-right:0.15em;">example  needed</span></span></i>]</sup>
</p>
<h3><span class="mw-headline" id="Python">Python</span><span class="mw-editsection"></span></h3>
<p>This is a possible implementation of the move-to-front algorithm in Python.
</p>

<p>The inverse will recover the original text:
</p>

<p>Example output:
</p>

<p>In this example we can see the MTF code taking advantage of the three repetitive <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">i</code>'s in the input word. The common dictionary here, however, is less than ideal since it is initialized with more commonly used ASCII printable characters put after little-used control codes, against the MTF code's design intent of keeping what's commonly used in the front. If one rotates the dictionary to put the more-used characters in earlier places, a better encoding can be obtained:
</p>

<h2><span class="mw-headline" id="Use_in_practical_data_compression_algorithms">Use in practical data compression algorithms</span><span class="mw-editsection"></span></h2>
<p>The MTF transform takes advantage of local correlation of frequencies to reduce the entropy of a message.<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (July 2015)">clarification needed</span></i>]</sup> Indeed, recently used letters stay towards the front of the list; if use of letters exhibits local correlations, this will result in a large number of small numbers such as "0"'s and "1"'s in the output.
</p><p>However, not all data exhibits this type of local correlation, and for some messages, the MTF transform may actually increase the entropy.
</p><p>An important use of the MTF transform is in Burrows–Wheeler transform based compression.  The Burrows–Wheeler transform is very good at producing a sequence that exhibits local frequency correlation from text and certain other special classes of data.  Compression benefits greatly from following up the Burrows–Wheeler transform with an MTF transform before the final entropy-encoding step.
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Confusing plainlinks metadata ambox ambox-style ambox-confusing" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>As an example, imagine we wish to compress Hamlet's soliloquy (<i>To be, or not to be...</i>).  We can calculate the size of this message to be 7033 bits.  Naively, we might try to apply the MTF transform directly.  The result is a message with 7807 bits (higher than the original).  The reason is that English text does not in general exhibit a high level of local frequency correlation.  However, if we first apply the Burrows–Wheeler transform, and then the MTF transform, we get a message with 6187 bits.  Note that the Burrows–Wheeler transform does not decrease the entropy of the message; it only reorders the bytes in a way that makes the MTF transform more effective.
</p><p>One problem with the basic MTF transform is that it makes the same changes for any character, regardless of frequency, which can result in diminished compression as characters that occur rarely may push frequent characters to higher values.  Various alterations and alternatives have been developed for this reason.  One common change is to make it so that characters above a certain point can only be moved to a certain threshold.  Another is to make some algorithm that runs a count of each character's local frequency and uses these values to choose the characters' order at any point.  Many of these transforms still reserve zero for repeat characters, since these are often the most common in data after the Burrows Wheeler Transform.
</p>
<h2><span class="mw-headline" id="Move-to-front_linked-list">Move-to-front linked-list</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<ul><li>The term Move To Front (MTF) is also used in a slightly different context, as a type of a dynamic linked list. In an MTF list, each element is moved to the front when it is accessed.<sup class="reference" id="cite_ref-4">[4]</sup> This ensures that, over time, the more frequently accessed elements are easier to access.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>"Move to front" by Arturo San Emeterio Campos</li></ul>

<!-- 
NewPP limit report
Parsed by mw1368
Cached time: 20221220213213
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.309 seconds
Real time usage: 0.400 seconds
Preprocessor visited node count: 993/1000000
Post‐expand include size: 73436/2097152 bytes
Template argument size: 1310/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 10/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 26876/5000000 bytes
Lua time usage: 0.187/10.000 seconds
Lua memory usage: 4867649/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  331.241      1 -total
 31.49%  104.306      1 Template:Reflist
 26.34%   87.257      6 Template:Navbox
 25.78%   85.389      3 Template:Cite_journal
 24.51%   81.174      1 Template:More_citations_needed
 23.24%   76.981      1 Template:Compression_methods
 20.88%   69.159      2 Template:Ambox
  7.14%   23.656      1 Template:Examples
  5.74%   19.009      1 Template:Fix
  5.31%   17.585      1 Template:Main
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1039739-0!canonical and timestamp 20221220213213 and revision id 1123734182.
 -->
</div></body>
</html>