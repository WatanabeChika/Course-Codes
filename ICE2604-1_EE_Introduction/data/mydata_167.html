<!DOCTYPE html>
<html>
<head>
<title>cactus_stack</title>
</head>
<body>
<div class="mw-parser-output">
<p>In computer science, an <b>in-tree</b> or <b>parent pointer tree</b> is an <span class="texhtml mvar" style="font-style:italic;">N</span>-ary tree data structure in which each node has a pointer to its parent node, but no pointers to child nodes. When used to implement a set of stacks, the structure is called a <b>spaghetti stack</b>, <b>cactus stack</b> or <b>sahuaro stack</b> (after the sahuaro, a kind of cactus).<sup class="reference" id="cite_ref-1">[1]</sup> Parent pointer trees are also used as disjoint-set data structures.
</p><p>The structure can be regarded as a set of singly linked lists that share part of their structure, in particular, their tails. From any node, one can traverse to ancestors of the node, but not to any other node.
</p>

<h2><span class="mw-headline" id="Use_in_compilers">Use in compilers</span><span class="mw-editsection"></span></h2>
<p>A compiler for a language such as C creates a spaghetti stack as it opens and closes symbol tables representing block scopes. When a new block scope is opened, a symbol table is pushed onto a stack. When the closing curly brace is encountered, the scope is closed and the symbol table is popped. But that symbol table is remembered, rather than destroyed. And of course it remembers its higher level "parent" symbol table and so on. Thus when the compiler is later performing translations over the abstract syntax tree, for any given expression, it can fetch the symbol table representing that expression's environment and can resolve references to identifiers. If the expression refers to a variable X, it is first sought after in the leaf symbol table representing the inner-most lexical scope, then in the parent and so on.
</p>
<h2><span class="mw-headline" id="Use_as_call_stacks">Use as call stacks</span><span class="mw-editsection"></span></h2>
<p>The term <i>spaghetti stack</i> is closely associated with implementations of programming languages that support continuations. Spaghetti stacks are used to implement the actual run-time stack containing variable bindings and other environmental features. When continuations must be supported, a function's local variables cannot be destroyed when that function returns: a saved continuation may later re-enter into that function, and will expect not only the variables there to be intact, but it will also expect the entire stack to be present so the function is able to return again. To resolve this problem, stack frames can be dynamically allocated in a spaghetti stack structure, and simply left behind to be garbage collected when no continuations refer to them any longer. This type of structure also solves both the upward and downward funarg problems, as a result first-class lexical closures are readily implemented in that substrate.
</p><p>Examples of languages that use spaghetti stacks are:
</p>
<ul><li>Languages having first-class continuations such as Scheme and Standard ML of New Jersey</li>
<li>Languages where the execution stack can be inspected and modified at runtime such as
<ul><li>Smalltalk</li>
<li>Felix</li>
<li>Cilk</li></ul></li></ul>
<p>Mainframe computers using the Burroughs Large Systems architecture and running the MCP operating system can spawn multiple tasks within the same program. Since these were originally ALGOL-based systems they have to support nested functions and the result is that task creation results in a fork in the stack, which Burroughs informally described as a "saguaro stack.".
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Burroughs Large Systems</li>
<li>Persistent data structure</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2339
Cached time: 20221221222223
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.081 seconds
Real time usage: 0.111 seconds
Preprocessor visited node count: 168/1000000
Post‐expand include size: 2389/2097152 bytes
Template argument size: 84/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 4141/5000000 bytes
Lua time usage: 0.043/10.000 seconds
Lua memory usage: 2293615/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   91.582      1 -total
 97.12%   88.941      1 Template:Reflist
 77.36%   70.846      1 Template:Cite_book
  1.86%    1.707      1 Template:Main_other
  1.79%    1.639      1 Template:Mvar
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2066241-0!canonical and timestamp 20221221222223 and revision id 1128769133.
 -->
</div></body>
</html>