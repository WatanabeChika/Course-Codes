<!DOCTYPE html>
<html>
<head>
<title>quantum_computation</title>
</head>
<body>
<div class="mw-parser-output">
<p class="mw-empty-elt">
</p>

<p><b>Quantum computing</b> is a type of computation whose operations can harness the phenomena of quantum mechanics, such as superposition, interference, and entanglement. Devices that perform quantum computations are known as <b>quantum computers</b>.<sup class="reference" id="cite_ref-Hidary_1-0">[1]</sup><sup class="reference" id="cite_ref-FOOTNOTENielsenChuang20101_2-0">[2]</sup> Though current quantum computers may be too small to outperform usual (classical) computers for practical applications, larger realizations are believed to be capable of solving certain computational problems, such as integer factorization (which underlies RSA encryption), substantially faster than classical computers. The study of quantum computing is a subfield of quantum information science.
</p><p>There are several models of quantum computation with the most widely used being quantum circuits. Other models include the quantum Turing machine, quantum annealing, and adiabatic quantum computation. Most models are based on the quantum bit, or "qubit", which is somewhat analogous to the bit in classical computation. A qubit can be in a 1 or 0 quantum state, or in a superposition of the 1 and 0 states. When it is measured, however, it is always 0 or 1; the probability of either outcome depends on the qubit's quantum state immediately prior to measurement. One model that does not use qubits is continuous variable quantum computation.
</p><p>Efforts towards building a physical quantum computer focus on technologies such as transmons, ion traps and topological quantum computers, which aim to create high-quality qubits.<sup class="reference" id="cite_ref-2018Report_3-0">[3]</sup><sup class="reference nowrap"><span title="Page / location: 2–13">: 2–13 </span></sup> These qubits may be designed differently, depending on the full quantum computer's computing model, as to whether quantum logic gates, quantum annealing, or adiabatic quantum computation are employed. There are currently a number of significant obstacles to constructing useful quantum computers. It is particularly difficult to maintain qubits' quantum states, as they suffer from quantum decoherence. Quantum computers therefore require error correction.<sup class="reference" id="cite_ref-4">[4]</sup><sup class="reference" id="cite_ref-5">[5]</sup>
</p><p>Any computational problem that can be solved by a classical computer can also be solved by a quantum computer.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang201029_6-0">[6]</sup> Conversely, any problem that can be solved by a quantum computer can also be solved by a classical computer, at least in principle given enough time. In other words, quantum computers obey the Church–Turing thesis. This means that while quantum computers provide no additional advantages over classical computers in terms of computability, quantum algorithms for certain problems have significantly lower time complexities than corresponding known classical algorithms. Notably, quantum computers are believed to be able to quickly solve certain problems that no classical computer could solve in any <i>feasible</i> amount of time—a feat known as "quantum supremacy." The study of the computational complexity of problems with respect to quantum computers is known as quantum complexity theory.
</p>

<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Quantum computing began in 1980 when physicist Paul Benioff proposed a quantum mechanical model of the Turing machine.<sup class="reference" id="cite_ref-The_computer_as_a_physical_system_7-0">[7]</sup> Richard Feynman and Yuri Manin later suggested that a quantum computer had the potential to simulate things a classical computer could not feasibly do.<sup class="reference" id="cite_ref-8">[8]</sup><sup class="reference" id="cite_ref-manin1980vychislimoe_9-0">[9]</sup> In 1986 Feynman introduced an early version of the quantum circuit notation.<sup class="reference" id="cite_ref-Feynman-QMC_10-0">[10]</sup> In 1994, Peter Shor developed a quantum algorithm for finding the prime factors of an integer with the potential to decrypt RSA-encrypted communications.<sup class="reference" id="cite_ref-11">[11]</sup> In 1998 Isaac Chuang, Neil Gershenfeld and Mark Kubinec created the first two-qubit quantum computer that could perform computations.<sup class="reference" id="cite_ref-12">[12]</sup><sup class="reference" id="cite_ref-13">[13]</sup> Despite ongoing experimental progress since the late 1990s, most researchers believe that "fault-tolerant quantum computing [is] still a rather distant dream."<sup class="reference" id="cite_ref-preskill2018_14-0">[14]</sup> In 2015, Duke University studies <sup class="reference" id="cite_ref-:1_15-0">[15]</sup><sup class="reference" id="cite_ref-:2_16-0">[16]</sup> estimated that nearly 3 million qubits large fault-tolerant quantum computer could factor 2,048-bit integer in five months. In recent years, investment in quantum computing research has increased in the public and private sectors.<sup class="reference" id="cite_ref-17">[17]</sup><sup class="reference" id="cite_ref-18">[18]</sup> On 23 October 2019, Google AI, in partnership with the U.S. National Aeronautics and Space Administration (NASA), claimed to have performed a quantum computation that was infeasible on any classical computer,<sup class="reference" id="cite_ref-19">[19]</sup><sup class="reference" id="cite_ref-20">[20]</sup><sup class="reference" id="cite_ref-21">[21]</sup> but whether this claim was or is still valid is a topic of active research.<sup class="reference" id="cite_ref-22">[22]</sup><sup class="reference" id="cite_ref-23">[23]</sup>
</p><p>In December 2021 McKinsey &amp; Company analysis states that "..investment dollars are pouring in, and quantum-computing start-ups are proliferating".  They go on to note that "While quantum computing promises to help businesses solve problems that are beyond the reach and speed of conventional high-performance computers, use cases are largely experimental and hypothetical at this early stage."<sup class="reference" id="cite_ref-24">[24]</sup>
</p>
<h2><span class="mw-headline" id="Quantum_information_processing">Quantum information processing</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Computer engineers typically describe a modern computer's operation in terms of classical electrodynamics.
Within these "classical" computers, some components (such as semiconductors and random number generators) may rely on quantum behavior, but these components are not isolated from their environment, so any quantum information quickly decoheres.
While programmers may depend on probability theory when designing a randomized algorithm, quantum mechanical notions like superposition and interference are largely irrelevant for program analysis.
</p><p>Quantum programs, in contrast, rely on precise control of coherent quantum systems.
Physicists describe these systems mathematically using linear algebra.
Complex numbers model probability amplitudes, vectors model quantum states, and matrices model the operations that can be performed on these states.
Programming a quantum computer is then a matter of composing operations in such a way that the resulting program computes a useful result in theory and is implementable in practice.
</p><p>The prevailing model of quantum computation describes the computation in terms of a network of quantum logic gates.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang2010_25-0">[25]</sup> This model is a complex linear-algebraic generalization of boolean circuits.<sup class="reference" id="cite_ref-27">[a]</sup>
</p>
<h3><span class="mw-headline" id="Quantum_information">Quantum information</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A memory consisting of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle n}</annotation>
</semantics>
</math></span><img alt="{\textstyle n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc6e1f880981346a604257ebcacdef24c0aca2d6" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> bits of information has <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle 2^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle 2^{n}}</annotation>
</semantics>
</math></span><img alt="{\textstyle 2^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ed53251d6894434f6541af584e7b8e29db831da" style="vertical-align: -0.338ex; width:2.381ex; height:2.176ex;"/></span> possible states. A vector representing all memory states thus has <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle 2^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle 2^{n}}</annotation>
</semantics>
</math></span><img alt="{\textstyle 2^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ed53251d6894434f6541af584e7b8e29db831da" style="vertical-align: -0.338ex; width:2.381ex; height:2.176ex;"/></span> entries (one for each state). This vector is viewed as a <i>probability vector</i> and represents the fact that the memory is to be found in a particular state.
</p><p>The bits of classical computers are not capable of being in superposition, so one entry must have a value of 1 (i.e. a 100% probability of being in this state) and all other entries would be zero.
</p><p>In quantum mechanics, probability vectors can be generalized to density operators. The quantum state vector formalism is usually introduced first because it is conceptually simpler, and because it can be used instead of the density matrix formalism <i>for pure states,</i> where the whole quantum system is known.
</p><p>We begin by considering a simple memory consisting of only one quantum bit. When measured, this memory may be found in one of two states: the zero state or the one state. We may represent the state of this memory using Dirac notation so that
</p>
A quantum memory may then be found in any quantum superposition <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |\psi \rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>ψ<!-- ψ --></mi>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |\psi \rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |\psi \rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6429c52ea0d0193d2c38a8e455c07026b42769d5" style="vertical-align: -0.838ex; width:3.065ex; height:2.843ex;"/></span> of the two classical states <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |0\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>0</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |0\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |0\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/55f385865bf20d44afef7add01ed2679901e9c4c" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |1\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>1</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |1\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |1\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e02220355a0a3bf0dfe8884b3023a41b86f6cc14" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span>:

The coefficients <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \alpha }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>α<!-- α --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \alpha }</annotation>
</semantics>
</math></span><img alt="{\textstyle \alpha }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0d86dbd6183264b2f8569da1751380b173c7b185" style="vertical-align: -0.338ex; width:1.488ex; height:1.676ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \beta }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>β<!-- β --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \beta }</annotation>
</semantics>
</math></span><img alt="{\textstyle \beta }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a77bfb138e56b5b44f6c8c4ce32a05449d1573d6" style="vertical-align: -0.671ex; width:1.332ex; height:2.509ex;"/></span> are complex numbers. The state <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |\psi \rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>ψ<!-- ψ --></mi>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |\psi \rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |\psi \rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6429c52ea0d0193d2c38a8e455c07026b42769d5" style="vertical-align: -0.838ex; width:3.065ex; height:2.843ex;"/></span> is not itself a probability vector but can be connected with a probability vector via the measurement operation. If the quantum memory is measured to determine whether the state is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |0\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>0</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |0\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |0\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/55f385865bf20d44afef7add01ed2679901e9c4c" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span> or <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |1\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>1</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |1\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |1\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e02220355a0a3bf0dfe8884b3023a41b86f6cc14" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span> (this is known as a computational basis measurement), the zero state would be observed with probability <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |\alpha |^{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>α<!-- α --></mi>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |\alpha |^{2}}</annotation>
</semantics>
</math></span><img alt="{\textstyle |\alpha |^{2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a365e6cc5317c820b13c7254c5d6381932ec1506" style="vertical-align: -0.838ex; width:3.836ex; height:3.343ex;"/></span> and the one state with probability <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |\beta |^{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>β<!-- β --></mi>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |\beta |^{2}}</annotation>
</semantics>
</math></span><img alt="{\textstyle |\beta |^{2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3136067e8eae41e9c08d9fdf842ebdbfc6b4d536" style="vertical-align: -0.838ex; width:3.68ex; height:3.343ex;"/></span>. The numbers <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \alpha }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>α<!-- α --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \alpha }</annotation>
</semantics>
</math></span><img alt="{\textstyle \alpha }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0d86dbd6183264b2f8569da1751380b173c7b185" style="vertical-align: -0.338ex; width:1.488ex; height:1.676ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \beta }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>β<!-- β --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \beta }</annotation>
</semantics>
</math></span><img alt="{\textstyle \beta }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a77bfb138e56b5b44f6c8c4ce32a05449d1573d6" style="vertical-align: -0.671ex; width:1.332ex; height:2.509ex;"/></span> are called probability amplitudes.

<h3><span class="mw-headline" id="Unitary_operators">Unitary operators</span><span class="mw-editsection"></span></h3>
<p><span class="anchor" id="gate-application"></span>The state of this one-qubit quantum memory can be manipulated by applying quantum logic gates, analogous to how classical memory can be manipulated with classical logic gates. One important gate for both classical and quantum computation is the NOT gate, which can be represented by a matrix
</p>
Mathematically, the application of such a logic gate to a quantum state vector is modelled with matrix multiplication. Thus <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle X|0\rangle =|1\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>X</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>0</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>1</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle X|0\rangle =|1\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle X|0\rangle =|1\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3ad136a15790a0f08c8827690617f8b18250809a" style="vertical-align: -0.838ex; width:10.506ex; height:2.843ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle X|1\rangle =|0\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>X</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>1</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>0</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle X|1\rangle =|0\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle X|1\rangle =|0\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/42b498d7c70e077286e2675b6054338b5aa9d606" style="vertical-align: -0.838ex; width:10.506ex; height:2.843ex;"/></span>.
<p>The mathematics of single qubit gates can be extended to operate on multi-qubit quantum memories in two important ways. One way is simply to select a qubit and apply that gate to the target qubit whilst leaving the remainder of the memory unaffected. Another way is to apply the gate to its target only if another part of the memory is in a desired state. These two choices can be illustrated using another example. The possible states of a two-qubit quantum memory are
</p>
The CNOT gate can then be represented using the following matrix:

As a mathematical consequence of this definition, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \operatorname {CNOT} |00\rangle =|00\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>CNOT</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>00</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>00</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \operatorname {CNOT} |00\rangle =|00\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle \operatorname {CNOT} |00\rangle =|00\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ed0a5336f1e26a22df63063316d4b0dbaf266328" style="vertical-align: -0.838ex; width:18.146ex; height:2.843ex;"/></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \operatorname {CNOT} |01\rangle =|01\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>CNOT</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>01</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>01</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \operatorname {CNOT} |01\rangle =|01\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle \operatorname {CNOT} |01\rangle =|01\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b89c86631eaaf54086afc0199de442765d8aa72" style="vertical-align: -0.838ex; width:18.146ex; height:2.843ex;"/></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \operatorname {CNOT} |10\rangle =|11\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>CNOT</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>10</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>11</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \operatorname {CNOT} |10\rangle =|11\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle \operatorname {CNOT} |10\rangle =|11\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/41135fc98eb537e37245efa719378d9f726f5754" style="vertical-align: -0.838ex; width:18.146ex; height:2.843ex;"/></span>, and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \operatorname {CNOT} |11\rangle =|10\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>CNOT</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>11</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>10</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \operatorname {CNOT} |11\rangle =|10\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle \operatorname {CNOT} |11\rangle =|10\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5d5dd1790f487ed75a103c6d09e4aa61d6135bcb" style="vertical-align: -0.838ex; width:18.146ex; height:2.843ex;"/></span>. In other words, the CNOT applies a NOT gate (<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle X}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi>X</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle X}</annotation>
</semantics>
</math></span><img alt="{\textstyle X}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d80c41192705e1a6c6de1d65e16d7f70fbac391" style="vertical-align: -0.338ex; width:1.98ex; height:2.176ex;"/></span> from before) to the second qubit if and only if the first qubit is in the state <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |1\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>1</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |1\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |1\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e02220355a0a3bf0dfe8884b3023a41b86f6cc14" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span>. If the first qubit is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle |0\rangle }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mn>0</mn>
<mo fence="false" stretchy="false">⟩<!-- ⟩ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle |0\rangle }</annotation>
</semantics>
</math></span><img alt="{\textstyle |0\rangle }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/55f385865bf20d44afef7add01ed2679901e9c4c" style="vertical-align: -0.838ex; width:2.714ex; height:2.843ex;"/></span>, nothing is done to either qubit.
<p>In summary, a quantum computation can be described as a network of quantum logic gates and measurements. However, any measurement can be deferred to the end of quantum computation, though this deferment may come at a computational cost, so most quantum circuits depict a network consisting only of quantum logic gates and no measurements.
</p>
<h3><span class="mw-headline" id="Quantum_programming">Quantum programming <span class="anchor" id="Models_of_computation_for_quantum_computing"></span></span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>There are a number of models of computation for quantum computing, distinguished by the basic elements in which the computation is decomposed.
</p>
<h4><span class="mw-headline" id="Gate_array">Gate array <span class="anchor" id="Quantum_circuit"></span><span class="anchor" id="Definition"></span></span><span class="mw-editsection"></span></h4>

<p>A quantum gate array decomposes computation into a sequence of few-qubit quantum gates.
A quantum computation can be described as a network of quantum logic gates and measurements. However, any measurement can be deferred to the end of quantum computation, though this deferment may come at a computational cost, so most quantum circuits depict a network consisting only of quantum logic gates and no measurements.
</p><p>Any quantum computation (which is, in the above formalism, any unitary matrix of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{n}\times 2^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
<mo>×<!-- × --></mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{n}\times 2^{n}}</annotation>
</semantics>
</math></span><img alt="2^{n}\times 2^{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/224a4a2c00116d57f7d93bd1116d1518837f1c28" style="vertical-align: -0.338ex; width:7.602ex; height:2.343ex;"/></span> over <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> qubits) can be represented as a network of quantum logic gates from a fairly small family of gates. A choice of gate family that enables this construction is known as a universal gate set, since a computer that can run such circuits is a universal quantum computer. One common such set includes all single-qubit gates as well as the CNOT gate from above. This means any quantum computation can be performed by executing a sequence of single-qubit gates together with CNOT gates. Though this gate set is infinite, it can be replaced with a finite gate set by appealing to the Solovay-Kitaev theorem.
</p>
<h4><span class="mw-headline" id="Measurement-based_quantum_computing">Measurement-based quantum computing</span><span class="mw-editsection"></span></h4>
<p>A measurement-based quantum computer decomposes computation into a sequence of Bell state measurements and single-qubit quantum gates applied to a highly entangled initial state (a cluster state), using a technique called quantum gate teleportation.
</p>
<h4><span class="mw-headline" id="Adiabatic_quantum_computing">Adiabatic quantum computing</span><span class="mw-editsection"></span></h4>
<p>An adiabatic quantum computer, based on quantum annealing, decomposes computation into a slow continuous transformation of an initial Hamiltonian into a final Hamiltonian, whose ground states contain the solution.<sup class="reference" id="cite_ref-Das_2008_1061–1081_28-0">[27]</sup>
</p>
<h4><span class="mw-headline" id="Topological_quantum_computing">Topological quantum computing</span><span class="mw-editsection"></span></h4>
<p>A topological quantum computer decomposes computation into the braiding of anyons in a 2D lattice.<sup class="reference" id="cite_ref-Nayaketal2008_29-0">[28]</sup>
</p>
<h4><span class="mw-headline" id="Quantum_Turing_machine">Quantum Turing machine</span><span class="mw-editsection"></span></h4>
<p>The quantum Turing machine is theoretically important but the physical implementation of this model is not feasible. All of these models of computation—quantum circuits,<sup class="reference" id="cite_ref-30">[29]</sup> one-way quantum computation,<sup class="reference" id="cite_ref-31">[30]</sup> adiabatic quantum computation,<sup class="reference" id="cite_ref-32">[31]</sup> and topological quantum computation<sup class="reference" id="cite_ref-FLW02_33-0">[32]</sup>—have been shown to be equivalent to the quantum Turing machine; given a perfect implementation of one such quantum computer, it can simulate all the others with no more than polynomial overhead. This equivalence need not hold for practical quantum computers, since the overhead of simulation may be too large to be practical.
</p>
<h2><span class="mw-headline" id="Communication">Communication</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Quantum cryptography could potentially fulfill some of the functions of public key cryptography. Quantum-based cryptographic systems could, therefore, be more secure than traditional systems against quantum hacking.<sup class="reference" id="cite_ref-34">[33]</sup>
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>Progress in finding quantum algorithms typically focuses on this quantum circuit model, though exceptions like the quantum adiabatic algorithm exist. Quantum algorithms can be roughly categorized by the type of speedup achieved over corresponding classical algorithms.<sup class="reference" id="cite_ref-zoo_35-0">[34]</sup>
</p><p>Quantum algorithms that offer more than a polynomial speedup over the best-known classical algorithm include Shor's algorithm for factoring and the related quantum algorithms for computing discrete logarithms, solving Pell's equation, and more generally solving the hidden subgroup problem for abelian finite groups.<sup class="reference" id="cite_ref-zoo_35-1">[34]</sup> These algorithms depend on the primitive of the quantum Fourier transform. No mathematical proof has been found that shows that an equally fast classical algorithm cannot be discovered, although this is considered unlikely.<sup class="reference" id="cite_ref-36">[35]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="The material near this tag may rely on a self-published source. (May 2020)">self-published source?</span></i>]</sup> Certain oracle problems like Simon's problem and the Bernstein–Vazirani problem do give provable speedups, though this is in the quantum query model, which is a restricted model where lower bounds are much easier to prove and doesn't necessarily translate to speedups for practical problems.
</p><p>Other problems, including the simulation of quantum physical processes from chemistry and solid-state physics, the approximation of certain Jones polynomials, and the quantum algorithm for linear systems of equations have quantum algorithms appearing to give super-polynomial speedups and are BQP-complete. Because these problems are BQP-complete, an equally fast classical algorithm for them would imply that <i>no quantum algorithm</i> gives a super-polynomial speedup, which is believed to be unlikely.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang201042_37-0">[36]</sup>
</p><p>Some quantum algorithms, like Grover's algorithm and amplitude amplification, give polynomial speedups over corresponding classical algorithms.<sup class="reference" id="cite_ref-zoo_35-2">[34]</sup> Though these algorithms give comparably modest quadratic speedup, they are widely applicable and thus give speedups for a wide range of problems.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang20107_38-0">[37]</sup> Many examples of provable quantum speedups for query problems are related to Grover's algorithm, including Brassard, Høyer, and Tapp's algorithm for finding collisions in two-to-one functions,<sup class="reference" id="cite_ref-39">[38]</sup> which uses Grover's algorithm, and Farhi, Goldstone, and Gutmann's algorithm for evaluating NAND trees,<sup class="reference" id="cite_ref-40">[39]</sup> which is a variant of the search problem.
</p>
<h3><span class="mw-headline" id="Post-quantum_cryptography">Post-quantum cryptography</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A notable application of quantum computation is for attacks on cryptographic systems that are currently in use. Integer factorization, which underpins the security of public key cryptographic systems, is believed to be computationally infeasible with an ordinary computer for large integers if they are the product of few prime numbers (e.g., products of two 300-digit primes).<sup class="reference" id="cite_ref-41">[40]</sup> By comparison, a quantum computer could efficiently solve this problem using Shor's algorithm to find its factors. This ability would allow a quantum computer to break many of the cryptographic systems in use today, in the sense that there would be a polynomial time (in the number of digits of the integer) algorithm for solving the problem. In particular, most of the popular public key ciphers are based on the difficulty of factoring integers or the discrete logarithm problem, both of which can be solved by Shor's algorithm. In particular, the RSA, Diffie–Hellman, and elliptic curve Diffie–Hellman algorithms could be broken. These are used to protect secure Web pages, encrypted email, and many other types of data. Breaking these would have significant ramifications for electronic privacy and security.
</p><p>Identifying cryptographic systems that may be secure against quantum algorithms is an actively researched topic under the field of <i>post-quantum cryptography</i>.<sup class="reference" id="cite_ref-pqcrypto_survey_42-0">[41]</sup><sup class="reference" id="cite_ref-43">[42]</sup> Some public-key algorithms are based on problems other than the integer factorization and discrete logarithm problems to which Shor's algorithm applies, like the McEliece cryptosystem based on a problem in coding theory.<sup class="reference" id="cite_ref-pqcrypto_survey_42-1">[41]</sup><sup class="reference" id="cite_ref-44">[43]</sup> Lattice-based cryptosystems are also not known to be broken by quantum computers, and finding a polynomial time algorithm for solving the dihedral hidden subgroup problem, which would break many lattice based cryptosystems, is a well-studied open problem.<sup class="reference" id="cite_ref-45">[44]</sup> It has been proven that applying Grover's algorithm to break a symmetric (secret key) algorithm by brute force requires time equal to roughly 2<sup><i>n</i>/2</sup> invocations of the underlying cryptographic algorithm, compared with roughly 2<sup><i>n</i></sup> in the classical case,<sup class="reference" id="cite_ref-bennett_1997_46-0">[45]</sup> meaning that symmetric key lengths are effectively halved: AES-256 would have the same security against an attack using Grover's algorithm that AES-128 has against classical brute-force search (see <i>Key size</i>).
</p>
<h3><span class="mw-headline" id="Search_problems">Search problems <span class="anchor" id="Quantum_search"></span></span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The most well-known example of a problem that allows for a polynomial quantum speedup is <i>unstructured search</i>, which involves finding a marked item out of a list of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> items in a database. This can be solved by Grover's algorithm using <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O({\sqrt {n}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>n</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O({\sqrt {n}})}</annotation>
</semantics>
</math></span><img alt="O({\sqrt {n}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5526ab1252c0f682bbe07c0ad67c0f29de5522b" style="vertical-align: -1.005ex; width:6.913ex; height:3.009ex;"/></span> queries to the database, quadratically fewer than the <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \Omega (n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">Ω<!-- Ω --></mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \Omega (n)}</annotation>
</semantics>
</math></span><img alt="\Omega (n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6becc31c61ad3420a1e4ee9e39c28baf73bda24d" style="vertical-align: -0.838ex; width:4.882ex; height:2.843ex;"/></span> queries required for classical algorithms. In this case, the advantage is not only provable but also optimal: it has been shown that Grover's algorithm gives the maximal possible probability of finding the desired element for any number of oracle lookups.
</p><p>Problems that can be efficiently addressed with Grover's algorithm have the following properties:<sup class="reference" id="cite_ref-47">[46]</sup><sup class="reference" id="cite_ref-48">[47]</sup>
</p>
<ol><li>There is no searchable structure in the collection of possible answers,</li>
<li>The number of possible answers to check is the same as the number of inputs to the algorithm, and</li>
<li>There exists a boolean function that evaluates each input and determines whether it is the correct answer</li></ol>
<p>For problems with all these properties, the running time of Grover's algorithm on a quantum computer scales as the square root of the number of inputs (or elements in the database), as opposed to the linear scaling of classical algorithms. A general class of problems to which Grover's algorithm can be applied<sup class="reference" id="cite_ref-49">[48]</sup> is Boolean satisfiability problem, where the <i>database</i> through which the algorithm iterates is that of all possible answers. An example and possible application of this is a password cracker that attempts to guess a password. Breaking symmetric ciphers with this algorithm is of interest to government agencies.<sup class="reference" id="cite_ref-50">[49]</sup>
</p>
<h3><span class="mw-headline" id="Simulation_of_quantum_systems">Simulation of quantum systems</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Since chemistry and nanotechnology rely on understanding quantum systems, and such systems are impossible to simulate in an efficient manner classically, many<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="The material near this tag possibly uses too-vague attribution or weasel words. (February 2022)">who?</span></i>]</sup> believe quantum simulation will be one of the most important applications of quantum computing.<sup class="reference" id="cite_ref-51">[50]</sup> Quantum simulation could also be used to simulate the behavior of atoms and particles at unusual conditions such as the reactions inside a collider.<sup class="reference" id="cite_ref-52">[51]</sup>
Quantum simulations might be used to predict future paths of particles and protons under superposition in the double-slit experiment.<sup class="reference" id="cite_ref-53">[52]</sup>
About 2% of the annual global energy output is used for nitrogen fixation to produce ammonia for the Haber process in the agricultural fertilizer industry while naturally occurring organisms also produce ammonia. Quantum simulations might be used to understand this process of increasing production.<sup class="reference" id="cite_ref-54">[53]</sup>
</p>
<h3><span class="mw-headline" id="Quantum_annealing">Quantum annealing <span class="anchor" id="Quantum_annealing_and_adiabatic_optimization"></span></span><span class="mw-editsection"></span></h3>
<p>Quantum annealing relies on the adiabatic theorem to undertake calculations. A system is placed in the ground state for a simple Hamiltonian, which slowly evolved to a more complicated Hamiltonian whose ground state represents the solution to the problem in question. The adiabatic theorem states that if the evolution is slow enough the system will stay in its ground state at all times through the process.
</p>
<h3><span class="mw-headline" id="Machine_learning">Machine learning</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Since quantum computers can produce outputs that classical computers cannot produce efficiently, and since quantum computation is fundamentally linear algebraic, some express hope in developing quantum algorithms that can speed up machine learning tasks.<sup class="reference" id="cite_ref-55">[54]</sup><sup class="reference" id="cite_ref-preskill18_56-0">[55]</sup>
For example, the quantum algorithm for linear systems of equations, or "HHL Algorithm", named after its discoverers Harrow, Hassidim, and Lloyd, is believed to provide speedup over classical counterparts.<sup class="reference" id="cite_ref-Quantum_algorithm_for_solving_linear_systems_of_equations_by_Harrow_et_al._57-0">[56]</sup><sup class="reference" id="cite_ref-preskill18_56-1">[55]</sup> Some research groups have recently explored the use of quantum annealing hardware for training Boltzmann machines and deep neural networks.<sup class="reference" id="cite_ref-58">[57]</sup><sup class="reference" id="cite_ref-59">[58]</sup><sup class="reference" id="cite_ref-60">[59]</sup>
</p>
<h3><span class="mw-headline" id="Computational_biology">Computational biology</span><span class="mw-editsection"></span></h3>
<p>In the field of computational biology, quantum computing has the potential to play a big role in solving many biological problems. Given how computational biology is using generic data modeling and storage, its applications to computational biology are expected to arise as well.<sup class="reference" id="cite_ref-61">[60]</sup>
</p>
<h3><span class="mw-headline" id="Computer-aided_drug_design_and_generative_chemistry">Computer-aided drug design and generative chemistry</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Deep generative chemistry models emerge as powerful tools to expedite drug discovery. However, the immense size and complexity of the structural space of all possible drug-like molecules pose significant obstacles, which could be overcome in the future by quantum computers. Quantum computers are naturally good for solving complex quantum many-body problems<sup class="reference" id="cite_ref-62">[61]</sup> and thus may be instrumental in applications involving quantum chemistry.  Therefore, one can expect that quantum-enhanced generative models<sup class="reference" id="cite_ref-63">[62]</sup> including quantum GANs<sup class="reference" id="cite_ref-64">[63]</sup> may eventually be developed into ultimate generative chemistry algorithms. Hybrid architectures combining quantum computers with deep classical networks, such as Quantum Variational Autoencoders, can already be trained on commercially available annealers and used to generate novel drug-like molecular structures.<sup class="reference" id="cite_ref-65">[64]</sup>
</p>
<h2><span class="mw-headline" id="Engineering">Engineering <span class="anchor" id="Developing_physical_quantum_computers"></span></span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Challenges">Challenges</span><span class="mw-editsection"></span></h3>
<p>There are a number of technical challenges in building a large-scale quantum computer.<sup class="reference" id="cite_ref-66">[65]</sup> Physicist David DiVincenzo has listed these requirements for a practical quantum computer:<sup class="reference" id="cite_ref-67">[66]</sup>
</p>
<ul><li>Physically scalable to increase the number of qubits</li>
<li>Qubits that can be initialized to arbitrary values</li>
<li>Quantum gates that are faster than decoherence time</li>
<li>Universal gate set</li>
<li>Qubits that can be read easily</li></ul>
<p>Sourcing parts for quantum computers is also very difficult. Superconducting quantum computers, like those constructed by Google and IBM, need helium-3, a nuclear research byproduct, and special superconducting cables made only by the Japanese company Coax Co.<sup class="reference" id="cite_ref-68">[67]</sup>
</p><p>The control of multi-qubit systems requires the generation and coordination of a large number of electrical signals with tight and deterministic timing resolution. This has led to the development of quantum controllers which enable interfacing with the qubits. Scaling these systems to support a growing number of qubits is an additional challenge.<sup class="reference" id="cite_ref-69">[68]</sup>
</p>
<h4><span class="mw-headline" id="Decoherence">Decoherence <span class="anchor" id="Quantum_decoherence"></span></span><span class="mw-editsection"></span></h4>
<p>One of the greatest challenges involved with constructing quantum computers is controlling or removing quantum decoherence. This usually means isolating the system from its environment as interactions with the external world cause the system to decohere. However, other sources of decoherence also exist. Examples include the quantum gates, and the lattice vibrations and background thermonuclear spin of the physical system used to implement the qubits. Decoherence is irreversible, as it is effectively non-unitary, and is usually something that should be highly controlled, if not avoided. Decoherence times for candidate systems in particular, the transverse relaxation time <i>T</i><sub>2</sub> (for NMR and MRI technology, also called the <i>dephasing time</i>), typically range between nanoseconds and seconds at low temperature.<sup class="reference" id="cite_ref-DiVincenzo_1995_70-0">[69]</sup> Currently, some quantum computers require their qubits to be cooled to 20 millikelvin (usually using a dilution refrigerator<sup class="reference" id="cite_ref-71">[70]</sup>) in order to prevent significant decoherence.<sup class="reference" id="cite_ref-72">[71]</sup> A 2020 study argues that ionizing radiation such as cosmic rays can nevertheless cause certain systems to decohere within milliseconds.<sup class="reference" id="cite_ref-73">[72]</sup>
</p><p>As a result, time-consuming tasks may render some quantum algorithms inoperable, as maintaining the state of qubits for a long enough duration will eventually corrupt the superpositions.<sup class="reference" id="cite_ref-74">[73]</sup>
</p><p>These issues are more difficult for optical approaches as the timescales are orders of magnitude shorter and an often-cited approach to overcoming them is optical pulse shaping. Error rates are typically proportional to the ratio of operating time to decoherence time, hence any operation must be completed much more quickly than the decoherence time.
</p><p>As described in the Quantum threshold theorem, if the error rate is small enough, it is thought to be possible to use quantum error correction to suppress errors and decoherence. This allows the total calculation time to be longer than the decoherence time if the error correction scheme can correct errors faster than decoherence introduces them. An often-cited figure for the required error rate in each gate for fault-tolerant computation is 10<sup>−3</sup>, assuming the noise is depolarizing.
</p><p>Meeting this scalability condition is possible for a wide range of systems. However, the use of error correction brings with it the cost of a greatly increased number of required qubits. The number required to factor integers using Shor's algorithm is still polynomial, and thought to be between <i>L</i> and <i>L</i><sup>2</sup>, where <i>L</i> is the number of digits in the number to be factored; error correction algorithms would inflate this figure by an additional factor of <i>L</i>. For a 1000-bit number, this implies a need for about 10<sup>4</sup> bits without error correction.<sup class="reference" id="cite_ref-75">[74]</sup> With error correction, the figure would rise to about 10<sup>7</sup> bits. Computation time is about <i>L</i><sup>2</sup> or about 10<sup>7</sup> steps and at 1 MHz, about 10 seconds. However, other careful estimates <sup class="reference" id="cite_ref-:1_15-1">[15]</sup><sup class="reference" id="cite_ref-:2_16-1">[16]</sup> lower the qubit count to 3 million for factorizing 2,048-bit integer in 5 months on the trapped-ion quantum computer.
</p><p>A very different approach to the stability-decoherence problem is to create a topological quantum computer with anyons, quasi-particles used as threads and relying on braid theory to form stable logic gates.<sup class="reference" id="cite_ref-76">[75]</sup><sup class="reference" id="cite_ref-77">[76]</sup>
</p>
<h3><span class="mw-headline" id="Quantum_supremacy">Quantum supremacy</span><span class="mw-editsection"></span></h3>
<p><i>Quantum supremacy</i> is a term coined by John Preskill referring to the engineering feat of demonstrating that a programmable quantum device can solve a problem beyond the capabilities of state-of-the-art classical computers.<sup class="reference" id="cite_ref-78">[77]</sup><sup class="reference" id="cite_ref-79">[78]</sup><sup class="reference" id="cite_ref-80">[79]</sup> The problem need not be useful, so some view the quantum supremacy test only as a potential future benchmark.<sup class="reference" id="cite_ref-81">[80]</sup>
</p><p>In October 2019, Google AI Quantum, with the help of NASA, became the first to claim to have achieved quantum supremacy by performing calculations on the Sycamore quantum computer more than 3,000,000 times faster than they could be done on Summit, generally considered the world's fastest computer.<sup class="reference" id="cite_ref-82">[81]</sup><sup class="reference" id="cite_ref-83">[82]</sup><sup class="reference" id="cite_ref-84">[83]</sup> This claim has been subsequently challenged: IBM has stated that Summit can perform samples much faster than claimed,<sup class="reference" id="cite_ref-85">[84]</sup><sup class="reference" id="cite_ref-86">[85]</sup> and researchers have since developed better algorithms for the sampling problem used to claim quantum supremacy, giving substantial reductions to the gap between Sycamore and classical supercomputers<sup class="reference" id="cite_ref-87">[86]</sup><sup class="reference" id="cite_ref-88">[87]</sup><sup class="reference" id="cite_ref-89">[88]</sup> and even beating it.<sup class="reference" id="cite_ref-90">[89]</sup><sup class="reference" id="cite_ref-91">[90]</sup><sup class="reference" id="cite_ref-92">[91]</sup>
</p><p>In December 2020, a group at USTC implemented a type of Boson sampling on 76 photons with a photonic quantum computer Jiuzhang to demonstrate quantum supremacy.<sup class="reference" id="cite_ref-93">[92]</sup><sup class="reference" id="cite_ref-94">[93]</sup><sup class="reference" id="cite_ref-95">[94]</sup> The authors claim that a classical contemporary supercomputer would require a computational time of 600 million years to generate the number of samples their quantum processor can generate in 20 seconds.<sup class="reference" id="cite_ref-:6_96-0">[95]</sup>
On November 16, 2021 at the quantum computing summit IBM presented a 127-qubit microprocessor named IBM Eagle.<sup class="reference" id="cite_ref-97">[96]</sup>
</p>
<h3><span class="mw-headline" id="Skepticism">Skepticism</span><span class="mw-editsection"></span></h3>
<p>Some researchers have expressed skepticism that scalable quantum computers could ever be built, typically because of the issue of maintaining coherence at large scales, but also for other reasons.
</p><p>Bill Unruh doubted the practicality of quantum computers in a paper published in 1994.<sup class="reference" id="cite_ref-98">[97]</sup> Paul Davies argued that a 400-qubit computer would even come into conflict with the cosmological information bound implied by the holographic principle.<sup class="reference" id="cite_ref-99">[98]</sup> Skeptics like Gil Kalai doubt that quantum supremacy will ever be achieved.<sup class="reference" id="cite_ref-100">[99]</sup><sup class="reference" id="cite_ref-101">[100]</sup><sup class="reference" id="cite_ref-102">[101]</sup> Physicist Mikhail Dyakonov has expressed skepticism of quantum computing as follows:
</p>
<dl><dd>"So the number of continuous parameters describing the state of such a useful quantum computer at any given moment must be... about 10<sup>300</sup>... Could we ever learn to control the more than 10<sup>300</sup> continuously variable parameters defining the quantum state of such a system? My answer is simple. <i>No, never.</i>"<sup class="reference" id="cite_ref-103">[102]</sup><sup class="reference" id="cite_ref-104">[103]</sup></dd></dl>
<h3><span class="mw-headline" id="Candidates_for_physical_realizations">Candidates for physical realizations</span><span class="mw-editsection"></span></h3>
<p>For physically implementing a quantum computer, many different candidates are being pursued, among them (distinguished by the physical system used to realize the qubits):
</p>
<ul><li>Superconducting quantum computing<sup class="reference" id="cite_ref-ClarkeWilhelm2008_105-0">[104]</sup><sup class="reference" id="cite_ref-106">[105]</sup> (qubit implemented by the state of nonlinear resonant superconducting circuits containing Josephson junctions)</li>
<li>Trapped ion quantum computer (qubit implemented by the internal state of trapped ions)</li>
<li>Neutral atoms in optical lattices (qubit implemented by internal states of neutral atoms trapped in an optical lattice)<sup class="reference" id="cite_ref-107">[106]</sup><sup class="reference" id="cite_ref-108">[107]</sup></li>
<li>Quantum dot computer, spin-based (e.g. the Loss-DiVincenzo quantum computer<sup class="reference" id="cite_ref-109">[108]</sup>) (qubit given by the spin states of trapped electrons)</li>
<li>Quantum dot computer, spatial-based (qubit given by electron position in double quantum dot)<sup class="reference" id="cite_ref-110">[109]</sup></li>
<li>Quantum computing using engineered quantum wells, which could in principle enable the construction of quantum computers that operate at room temperature<sup class="reference" id="cite_ref-111">[110]</sup><sup class="reference" id="cite_ref-112">[111]</sup></li>
<li>Coupled quantum wire (qubit implemented by a pair of quantum wires coupled by a quantum point contact)<sup class="reference" id="cite_ref-113">[112]</sup><sup class="reference" id="cite_ref-114">[113]</sup><sup class="reference" id="cite_ref-115">[114]</sup></li>
<li>Nuclear magnetic resonance quantum computer (NMRQC) implemented with the nuclear magnetic resonance of molecules in solution, where qubits are provided by nuclear spins within the dissolved molecule and probed with radio waves</li>
<li>Solid-state NMR Kane quantum computers (qubit realized by the nuclear spin state of phosphorus donors in silicon)</li>
<li>Vibrational quantum computer (qubits realized by vibrational superpositions in cold molecules)<sup class="reference" id="cite_ref-116">[115]</sup></li>
<li>Electrons-on-helium quantum computers (qubit is the electron spin)</li>
<li>Cavity quantum electrodynamics (CQED) (qubit provided by the internal state of trapped atoms coupled to high-finesse cavities)</li>
<li>Molecular magnet<sup class="reference" id="cite_ref-117">[116]</sup> (qubit given by spin states)</li>
<li>Fullerene-based ESR quantum computer (qubit based on the electronic spin of atoms or molecules encased in fullerenes)<sup class="reference" id="cite_ref-118">[117]</sup></li>
<li>Nonlinear optical quantum computer (qubits realized by processing states of different modes of light through both linear and nonlinear elements)<sup class="reference" id="cite_ref-qc1988_119-0">[118]</sup><sup class="reference" id="cite_ref-chuang1995_120-0">[119]</sup></li>
<li>Linear optical quantum computer (qubits realized by processing states of different modes of light through linear elements e.g. mirrors, beam splitters and phase shifters)<sup class="reference" id="cite_ref-KLM2001_121-0">[120]</sup></li>
<li>Diamond-based quantum computer<sup class="reference" id="cite_ref-Nizovtsevetal2004_122-0">[121]</sup><sup class="reference" id="cite_ref-123">[122]</sup><sup class="reference" id="cite_ref-124">[123]</sup><sup class="reference" id="cite_ref-Neumannetal2008_125-0">[124]</sup> (qubit realized by the electronic or nuclear spin of nitrogen-vacancy centers in diamond)</li>
<li>Bose-Einstein condensate-based quantum computer<sup class="reference" id="cite_ref-126">[125]</sup><sup class="reference" id="cite_ref-127">[126]</sup></li>
<li>Transistor-based quantum computer – string quantum computers with entrainment of positive holes using an electrostatic trap</li>
<li>Rare-earth-metal-ion-doped inorganic crystal based quantum computers<sup class="reference" id="cite_ref-Ohlsson2002_128-0">[127]</sup><sup class="reference" id="cite_ref-Longdell2004_129-0">[128]</sup> (qubit realized by the internal electronic state of dopants in optical fibers)</li>
<li>Metallic-like carbon nanospheres-based quantum computers<sup class="reference" id="cite_ref-Nafradi2016_130-0">[129]</sup></li></ul>
<p>The large number of candidates demonstrates that quantum computing, despite rapid progress, is still in its infancy.<sup class="reference" id="cite_ref-131">[130]</sup>
</p>
<h2><span class="mw-headline" id="Theory">Theory <span class="anchor" id="Relation_to_computability_and_complexity_theory"></span></span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Computability">Computability <span class="anchor" id="Computability_theory"></span></span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Any computational problem solvable by a classical computer is also solvable by a quantum computer.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang201029_6-1">[6]</sup> Intuitively, this is because it is believed that all physical phenomena, including the operation of classical computers, can be described using quantum mechanics, which underlies the operation of quantum computers.
</p><p>Conversely, any problem solvable by a quantum computer is also solvable by a classical computer. It is possible to simulate both quantum and classical computers manually with just some paper and a pen, if given enough time. More formally, any quantum computer can be simulated by a Turing machine. In other words, quantum computers provide no additional power over classical computers in terms of computability. This means that quantum computers cannot solve undecidable problems like the halting problem and the existence of quantum computers does not disprove the Church–Turing thesis.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang2010126_132-0">[131]</sup>
</p>
<h3><span class="mw-headline" id="Complexity">Complexity <span class="anchor" id="Quantum_complexity_theory"></span></span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>While quantum computers cannot solve any problems that classical computers cannot already solve, it is suspected that they can solve certain problems faster than classical computers. For instance, it is known that quantum computers can efficiently factor integers, while this is not believed to be the case for classical computers.
</p><p>The class of problems that can be efficiently solved by a quantum computer with bounded error is called BQP, for "bounded error, quantum, polynomial time". More formally, BQP is the class of problems that can be solved by a polynomial-time quantum Turing machine with an error probability of at most 1/3. As a class of probabilistic problems, BQP is the quantum counterpart to BPP ("bounded error, probabilistic, polynomial time"), the class of problems that can be solved by polynomial-time probabilistic Turing machines with bounded error.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang201041_133-0">[132]</sup> It is known that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {BPP\subseteq BQP}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">Q</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {BPP\subseteq BQP}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {BPP\subseteq BQP}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/59af787cd2b2478c3c326d722fbffbc7839c1abe" style="vertical-align: -0.505ex; width:12.366ex; height:2.343ex;"/></span> and is widely suspected that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {BQP\subsetneq BPP}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">Q</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊊<!-- ⊊ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {BQP\subsetneq BPP}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {BQP\subsetneq BPP}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/106869205d6945f52c45f002a693dfb27d54574c" style="vertical-align: -0.838ex; width:12.366ex; height:2.676ex;"/></span>, which intuitively would mean that quantum computers are more powerful than classical computers in terms of time complexity.<sup class="reference" id="cite_ref-FOOTNOTENielsenChuang2010201_134-0">[133]</sup>
</p>

<p>The exact relationship of BQP to P, NP, and PSPACE is not known. However, it is known that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {P\subseteq BQP\subseteq PSPACE}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">Q</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">S</mi>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">A</mi>
<mi mathvariant="sans-serif">C</mi>
<mi mathvariant="sans-serif">E</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {P\subseteq BQP\subseteq PSPACE}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {P\subseteq BQP\subseteq PSPACE}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e30ec0b4e850418f5478e8a8e91fd2ccb20d0ebb" style="vertical-align: -0.505ex; width:21.115ex; height:2.343ex;"/></span>; that is, all problems that can be efficiently solved by a deterministic classical computer can also be efficiently solved by a quantum computer, and all problems that can be efficiently solved by a quantum computer can also be solved by a deterministic classical computer with polynomial space resources. It is further suspected that BQP is a strict superset of P, meaning there are problems that are efficiently solvable by quantum computers that are not efficiently solvable by deterministic classical computers. For instance, integer factorization and the discrete logarithm problem are known to be in BQP and are suspected to be outside of P. On the relationship of BQP to NP, little is known beyond the fact that some NP problems that are believed not to be in P are also in BQP (integer factorization and the discrete logarithm problem are both in NP, for example). It is suspected that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {NP\nsubseteq BQP}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">N</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊈<!-- ⊈ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">Q</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {NP\nsubseteq BQP}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {NP\nsubseteq BQP}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/52b2cc3f547f6bad0a6b40df6a38349b52541c28" style="vertical-align: -1.005ex; width:10.976ex; height:3.176ex;"/></span>; that is, it is believed that there are efficiently checkable problems that are not efficiently solvable by a quantum computer. As a direct consequence of this belief, it is also suspected that BQP is disjoint from the class of NP-complete problems (if an NP-complete problem were in BQP, then it would follow from NP-hardness that all problems in NP are in BQP).<sup class="reference" id="cite_ref-BernVazi_135-0">[134]</sup>
</p><p>The relationship of BQP to the basic classical complexity classes can be summarized as follows:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {P\subseteq BPP\subseteq BQP\subseteq PP\subseteq PSPACE}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">B</mi>
<mi mathvariant="sans-serif">Q</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">P</mi>
<mo>⊆<!-- ⊆ --></mo>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">S</mi>
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">A</mi>
<mi mathvariant="sans-serif">C</mi>
<mi mathvariant="sans-serif">E</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {P\subseteq BPP\subseteq BQP\subseteq PP\subseteq PSPACE}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {P\subseteq BPP\subseteq BQP\subseteq PP\subseteq PSPACE}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12cfec97487255f6fc1fb1abea95ca94e770255e" style="vertical-align: -0.505ex; width:34.803ex; height:2.343ex;"/></span></dd></dl>
<p>It is also known that BQP is contained in the complexity class <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \color {Blue}{\mathsf {\#P}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mstyle mathcolor="#2D2F92">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">#<!-- # --></mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \color {Blue}{\mathsf {\#P}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \color {Blue}{\mathsf {\#P}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/48d516f4370781a0dd28004a42ab0a739f20758d" style="vertical-align: -0.671ex; width:3.421ex; height:2.509ex;"/></span> (or more precisely in the associated class of decision problems <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {P^{\#P}}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi mathvariant="sans-serif">P</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">#<!-- # --></mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</msup>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {P^{\#P}}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {P^{\#P}}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73d898ba4f3b6d05becb19c9c072a4b6664f9581" style="vertical-align: -0.338ex; width:4.137ex; height:2.676ex;"/></span>),<sup class="reference" id="cite_ref-BernVazi_135-1">[134]</sup> which is a subclass of PSPACE.
</p><p>It has been speculated that further advances in physics could lead to even faster computers. For instance, it has been shown that a non-local hidden variable quantum computer based on Bohmian Mechanics could implement a search of an <span class="texhtml mvar" style="font-style:italic;">N</span>-item database in at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O({\sqrt[{3}]{N}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mroot>
<mi>N</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</mroot>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O({\sqrt[{3}]{N}})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O({\sqrt[{3}]{N}})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a953364313112d7f3243feb0c59146295a65263d" style="vertical-align: -0.838ex; width:7.582ex; height:3.176ex;"/></span> steps, a slight speedup over Grover's algorithm, which runs in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O({\sqrt {N}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>N</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O({\sqrt {N}})}</annotation>
</semantics>
</math></span><img alt="O({\sqrt  {N}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6a8566840a0a5d4480a0b8ed63d0717c3a89ec9a" style="vertical-align: -0.838ex; width:7.582ex; height:3.176ex;"/></span> steps. Note, however, that neither search method would allow quantum computers to solve NP-complete problems in polynomial time.<sup class="reference" id="cite_ref-auto_136-0">[135]</sup> Theories of quantum gravity, such as M-theory and loop quantum gravity, may allow even faster computers to be built. However, defining computation in these theories is an open problem due to the problem of time; that is, within these physical theories there is currently no obvious way to describe what it means for an observer to submit input to a computer at one point in time and then receive output at a later point in time.<sup class="reference" id="cite_ref-137">[136]</sup><sup class="reference" id="cite_ref-:0_138-0">[137]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<link href="mw-data:TemplateStyles:r1097025294" rel="mw-deduplicated-inline-style"/>
<ul><li>Stanford Encyclopedia of Philosophy: "Quantum Computing" by Amit Hagar and Michael E. Cuffaro.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2">"Quantum computation, theory of", <i>Encyclopedia of Mathematics</i>, EMS Press, 2001 [1994]</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Quantum+computation%2C+theory+of&amp;rft.btitle=Encyclopedia+of+Mathematics&amp;rft.pub=EMS+Press&amp;rft.date=2001&amp;rft_id=https%3A%2F%2Fwww.encyclopediaofmath.org%2Findex.php%3Ftitle%3DQuantum_computation%2C_theory_of&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AQuantum+computing"></span></li>
<li>Quantum computing for the very curious by Andy Matuschak and Michael Nielsen</li></ul>
<dl><dt>Lectures</dt></dl>
<ul><li>Quantum computing for the determined – 22 video lectures by Michael Nielsen</li>
<li>Video Lectures by David Deutsch</li>
<li>Lectures at the Institut Henri Poincaré (slides and videos)</li>
<li>Online lecture on An Introduction to Quantum Computing, Edward Gerjuoy (2008)</li>
<li>Lomonaco, Sam. Four Lectures on Quantum Computing given at Oxford University in July 2006</li></ul>





<!-- 
NewPP limit report
Parsed by mw2337
Cached time: 20221223230829
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 1.648 seconds
Real time usage: 2.126 seconds
Preprocessor visited node count: 11529/1000000
Post‐expand include size: 495856/2097152 bytes
Template argument size: 6344/2097152 bytes
Highest expansion depth: 19/100
Expensive parser function count: 18/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 512060/5000000 bytes
Lua time usage: 1.050/10.000 seconds
Lua memory usage: 10674920/52428800 bytes
Lua Profile:
    recursiveClone <mwInit.lua:41>                                   180 ms       16.7%
    MediaWiki\Extension\Scribunto\Engines\LuaSandbox\LuaSandboxCallback::callParserFunction      120 ms       11.1%
    dataWrapper <mw.lua:672>                                         120 ms       11.1%
    ?                                                                100 ms        9.3%
    MediaWiki\Extension\Scribunto\Engines\LuaSandbox\LuaSandboxCallback::find      100 ms        9.3%
    MediaWiki\Extension\Scribunto\Engines\LuaSandbox\LuaSandboxCallback::sub       80 ms        7.4%
    MediaWiki\Extension\Scribunto\Engines\LuaSandbox\LuaSandboxCallback::preprocess       60 ms        5.6%
    <mw.lua:694>                                                      60 ms        5.6%
    ? <Module:Citation/CS1/Identifiers:532>                           40 ms        3.7%
    (for generator)                                                   40 ms        3.7%
    [others]                                                         180 ms       16.7%
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1538.067      1 -total
 54.25%  834.352      2 Template:Reflist
 28.97%  445.622     82 Template:Cite_journal
 11.91%  183.188     28 Template:Cite_book
  9.53%  146.528     10 Template:Sfn
  5.57%   85.612     24 Template:Cite_web
  4.88%   75.113      7 Template:Navbox
  4.15%   63.855      1 Template:Short_description
  3.27%   50.250      1 Template:Quantum_computing
  3.17%   48.746      2 Template:Sister_project
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:25220-0!canonical and timestamp 20221223230827 and revision id 1129070518.
 -->
</div></body>
</html>