<!DOCTYPE html>
<html>
<head>
<title>counting_sort</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Counting sort</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Sorting Algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n+k)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n+k)}</annotation>
</semantics>
</math></span><img alt="O(n+k)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cebd2e4442e56daa59f3fab79339f952122c29e8" style="vertical-align: -0.838ex; width:9.029ex; height:2.843ex;"/></span>, where k is the range of the non-negative key values.</td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n+k)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n+k)}</annotation>
</semantics>
</math></span><img alt="O(n+k)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cebd2e4442e56daa59f3fab79339f952122c29e8" style="vertical-align: -0.838ex; width:9.029ex; height:2.843ex;"/></span></td></tr></tbody></table>
<p>In computer science, <b>counting sort</b> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that possess distinct key values, and applying prefix sum on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum key value and the minimum key value, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. It is often used as a subroutine in radix sort, another sorting algorithm, which can handle larger keys more efficiently.<sup class="reference" id="cite_ref-clrs_1-0">[1]</sup><sup class="reference" id="cite_ref-edmonds_2-0">[2]</sup><sup class="reference" id="cite_ref-sedgewick_3-0">[3]</sup>
</p><p>Counting sort is not a comparison sort; it uses key values as indexes into an array and the <span class="texhtml">Ω(<i>n</i> log <i>n</i>)</span> lower bound for comparison sorting will not apply.<sup class="reference" id="cite_ref-clrs_1-1">[1]</sup> Bucket sort may be used in lieu of counting sort, and entails a similar time analysis. However, compared to counting sort, bucket sort requires linked lists, dynamic arrays, or a large amount of pre-allocated memory to hold the sets of items within each bucket, whereas counting sort stores a single number (the count of items) per bucket.<sup class="reference" id="cite_ref-knuth_4-0">[4]</sup>
</p>

<h2><span class="mw-headline" id="Input_and_output_assumptions">Input and output assumptions</span><span class="mw-editsection"></span></h2>
<p>In the most general case, the input to counting sort consists of a collection of <span class="texhtml mvar" style="font-style:italic;">n</span> items, each of which has a non-negative integer key whose maximum value is at most <span class="texhtml mvar" style="font-style:italic;">k</span>.<sup class="reference" id="cite_ref-sedgewick_3-1">[3]</sup>
In some descriptions of counting sort, the input to be sorted is assumed to be more simply a sequence of integers itself,<sup class="reference" id="cite_ref-clrs_1-2">[1]</sup> but this simplification does not accommodate many applications of counting sort. For instance, when used as a subroutine in radix sort, the keys for each call to counting sort are individual digits of larger item keys; it would not suffice to return only a sorted list of the key digits, separated from the items.
</p><p>In applications such as in radix sort, a bound on the maximum key value <span class="texhtml mvar" style="font-style:italic;">k</span> will be known in advance, and can be assumed to be part of the input to the algorithm. However, if the value of <span class="texhtml mvar" style="font-style:italic;">k</span> is not already known then it may be computed, as a first step, by an additional loop over the data to determine the maximum key value.
</p><p>The output is an array of the elements ordered by their keys. Because of its application to radix sorting, counting sort must be a stable sort; that is, if two elements share the same key, their relative order in the output array and their relative order in the input array should match.<sup class="reference" id="cite_ref-clrs_1-3">[1]</sup><sup class="reference" id="cite_ref-edmonds_2-1">[2]</sup>
</p>
<h2><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h2>
<p>In pseudocode, the algorithm may be expressed as:
</p>
<pre><b>function</b> CountingSort(input, <i>k</i>)
    
    count ← array of <i>k</i> + 1 zeros
    output ← array of same length as input
    
    <b>for</b> <i>i</i> = 0 <b>to</b> length(input) - 1 <b>do</b>
        <i>j</i> = key(input[<i>i</i>])
        count[<i>j</i>] = count[<i>j</i>] + 1

    <b>for</b> <i>i</i> = 1 <b>to</b> <i>k</i> <b>do</b>
        count[<i>i</i>] = count[<i>i</i>] + count[<i>i</i> - 1]

    <b>for</b> <i>i</i> = length(input) - 1 <b>down to</b> 0 <b>do</b>
        <i>j</i> = key(input[<i>i</i>])
        count[<i>j</i>] = count[<i>j</i>] - 1
        output[count[<i>j</i>]] = input[<i>i</i>]

    <b>return</b> output
</pre>
<p>Here <code>input</code> is the input array to be sorted, <code>key</code> returns the numeric key of each item in the input array, <code>count</code> is an auxiliary array used first to store the numbers of items with each key, and then (after the second loop) to store the positions where items with each key should be placed,
<code>k</code> is the maximum value of the non-negative key values and <code>output</code> is the sorted output array.
</p><p>In summary, the algorithm loops over the items in the first loop, computing a histogram of the number of times each key occurs within the <code>input</code> collection. After that in the second loop, it performs a prefix sum computation on <code>count</code> in order to determine, for each key, the position range where the items having that key should be placed; i.e. items of key <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span> should be placed starting in position <code>count[<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span>]</code>. Finally, in the third loop, it loops over the items of <code>input</code> again, but in reverse order, moving each item into its sorted position in the <code>output</code> array.<sup class="reference" id="cite_ref-clrs_1-4">[1]</sup><sup class="reference" id="cite_ref-edmonds_2-2">[2]</sup><sup class="reference" id="cite_ref-sedgewick_3-2">[3]</sup>
</p><p>The relative order of items with equal keys is preserved here; i.e., this is a stable sort.
</p>
<h2><span class="mw-headline" id="Complexity_analysis">Complexity analysis</span><span class="mw-editsection"></span></h2>
<p>Because the algorithm uses only simple for loops, without recursion or subroutine calls, it is straightforward to analyze. The initialization of the count array, and the second for loop which performs a prefix sum on the count array, each iterate at most <span class="texhtml"><i>k</i> + 1</span> times and therefore take <span class="texhtml"><i>O</i>(<i>k</i>)</span> time. The other two for loops, and the initialization of the output array, each take <span class="texhtml"><i>O</i>(<i>n</i>)</span> time. Therefore, the time for the whole algorithm is the sum of the times for these steps, <span class="texhtml"><i>O</i>(<i>n</i> + <i>k</i>)</span>.<sup class="reference" id="cite_ref-clrs_1-5">[1]</sup><sup class="reference" id="cite_ref-edmonds_2-3">[2]</sup>
</p><p>Because it uses arrays of length <span class="texhtml"><i>k</i> + 1</span> and <span class="texhtml mvar" style="font-style:italic;">n</span>, the total space usage of the algorithm is also <span class="texhtml"><i>O</i>(<i>n</i> + <i>k</i>)</span>.<sup class="reference" id="cite_ref-clrs_1-6">[1]</sup> For problem instances in which the maximum key value is significantly smaller than the number of items, counting sort can be highly space-efficient, as the only storage it uses other than its input and output arrays is the Count array which uses space <span class="texhtml"><i>O</i>(<i>k</i>)</span>.<sup class="reference" id="cite_ref-5">[5]</sup>
</p>
<h2><span class="mw-headline" id="Variant_algorithms">Variant algorithms</span><span class="mw-editsection"></span></h2>
<p>If each item to be sorted is itself an integer, and used as key as well, then the second and third loops of counting sort can be combined; in the second loop, instead of computing the position where items with key <code>i</code> should be placed in the output, simply append <code>Count[i]</code> copies of the number <code>i</code> to the output.
</p><p>This algorithm may also be used to eliminate duplicate keys, by replacing the <code>Count</code> array with a bit vector that stores a <code>one</code> for a key that is present in the input and a <code>zero</code> for a key that is not present. If additionally the items are the integer keys themselves, both second and third loops can be omitted entirely and the bit vector will itself serve as output, representing the values as offsets of the non-<code>zero</code> entries, added to the range's lowest value. Thus the keys are sorted and the duplicates are eliminated in this variant just by being placed into the bit array.
</p><p>For data in which the maximum key size is significantly smaller than the number of data items, counting sort may be parallelized by splitting the input into subarrays of approximately equal size, processing each subarray in parallel to generate a separate count array for each subarray, and then merging the count arrays. When used as part of a parallel radix sort algorithm, the key size (base of the radix representation) should be chosen to match the size of the split subarrays.<sup class="reference" id="cite_ref-6">[6]</sup> The simplicity of the counting sort algorithm and its use of the easily parallelizable prefix sum primitive also make it usable in more fine-grained parallel algorithms.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>As described, counting sort is not an in-place algorithm; even disregarding the count array, it needs separate input and output arrays. It is possible to modify the algorithm so that it places the items into sorted order within the same array that was given to it as the input, using only the count array as auxiliary storage; however, the modified in-place version of counting sort is not stable.<sup class="reference" id="cite_ref-sedgewick_3-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>Although radix sorting itself dates back far longer,
counting sort, and its application to radix sorting, were both invented by Harold H. Seward in 1954.<sup class="reference" id="cite_ref-clrs_1-7">[1]</sup><sup class="reference" id="cite_ref-knuth_4-1">[4]</sup><sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Counting Sort html5 visualization</li>
<li>Demonstration applet from Cardiff University Archived 2013-06-02 at the Wayback Machine</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFKagel2006">Kagel, Art S. (2 June 2006), "counting sort",  in Black, Paul E. (ed.), <i>Dictionary of Algorithms and Data Structures</i>, U.S. National Institute of Standards and Technology<span class="reference-accessdate">, retrieved <span class="nowrap">2011-04-21</span></span></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=counting+sort&amp;rft.btitle=Dictionary+of+Algorithms+and+Data+Structures&amp;rft.pub=U.S.+National+Institute+of+Standards+and+Technology&amp;rft.date=2006-06-02&amp;rft.aulast=Kagel&amp;rft.aufirst=Art+S.&amp;rft_id=https%3A%2F%2Fxlinux.nist.gov%2Fdads%2FHTML%2Fcountingsort.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACounting+sort"></span>.</li></ul>

<!-- 
NewPP limit report
Parsed by mw2307
Cached time: 20221223234519
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.246 seconds
Real time usage: 0.343 seconds
Preprocessor visited node count: 1510/1000000
Post‐expand include size: 39147/2097152 bytes
Template argument size: 1694/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 34687/5000000 bytes
Lua time usage: 0.141/10.000 seconds
Lua memory usage: 5373597/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  272.916      1 -total
 39.56%  107.966      1 Template:Reflist
 34.15%   93.212      9 Template:Citation
 17.62%   48.079      1 Template:Short_description
 14.55%   39.712      1 Template:Sorting
 13.88%   37.870      1 Template:Navbox
  9.74%   26.581      2 Template:Pagetype
  9.68%   26.416      1 Template:Infobox_algorithm
  8.61%   23.497      1 Template:Infobox
  7.02%   19.167      1 Template:Wikibooks
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:99864-0!canonical and timestamp 20221223234518 and revision id 1116038200.
 -->
</div></body>
</html>