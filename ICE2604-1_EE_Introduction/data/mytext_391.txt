finite_state_transducerA finite-state transducer (FST) is a finite-state machine with two memory tapes, following the terminology for Turing machines: an input tape and an output tape. This contrasts with an ordinary finite-state automaton, which has a single tape.  An FST is a type of finite-state automaton (FSA) that maps between two sets of symbols.[1]  An FST is more general than an FSA.  An FSA defines a formal language by defining a set of accepted strings, while an FST defines relations between sets of strings.An FST will read a set of strings on the input tape and generates a set of relations on the output tape.  An FST can be thought of as a translator or relater between strings in a set.In morphological parsing, an example would be inputting a string of letters into the FST, the FST would then output a string of morphemes.External video Finite State Transducers // Karlsruhe Institute of Technology, YouTube videoAn automaton can be said to recognize a string if we view the content of its tape as input.  In other words, the automaton computes a function that maps strings into the set {0,1}.  Alternatively, we can say that an automaton generates strings, which means viewing its tape as an output tape.  On this view, the automaton generates a formal language, which is a set of strings.  The two views of automata are equivalent: the function that the automaton computes is precisely the indicator function of the set of strings it generates.  The class of languages generated by finite automata is known as the class of regular languages.The two tapes of a transducer are typically viewed as an input tape and an output tape.  On this view, a transducer is said to transduce (i.e., translate) the contents of its input tape to its output tape, by accepting a string on its input tape and generating another string on its output tape.  It may do so nondeterministically and it may produce more than one output for each input string.  A transducer may also produce no output for a given input string, in which case it is said to reject the input.  In general, a transducer computes a relation between two formal languages.Each string-to-string finite-state transducer relates the input alphabet Σ to the output alphabet Γ. Relations R on Σ*×Γ* that can be implemented as finite-state transducers are called rational relations. Rational relations that are partial functions, i.e. that relate every input string from Σ* to at most one Γ*, are called rational functions.Finite-state transducers are often used for phonological and morphological analysis in natural language processing research and applications. Pioneers in this field include Ronald Kaplan, Lauri Karttunen, Martin Kay and Kimmo Koskenniemi.[2][]A common way of using transducers is in a so-called "cascade", where transducers for various operations are combined into a single transducer by repeated application of the composition operator (defined below).Formally, a finite transducer T is a 6-tuple () such that: is a finite set, the set of states; is a finite set, called the input alphabet; is a finite set, called the output alphabet; is a subset of , the set of initial states; is a subset of , the set of final states; and (where ε is the empty string) is the transition relation.We can view (Q, δ) as a labeled directed graph, known as the transition graph of T: the set of vertices is Q, and   means that there is a labeled edge going from vertex q to vertex r.  We also say that a is the input label and b the output label of that edge.NOTE: This definition of finite transducer is also called letter transducer (Roche and Schabes 1997); alternative definitions are possible, but can all be converted into transducers following this one.Define the extended transition relation  as the smallest set such that:; for all ; andwhenever  and  then .The extended transition relation is essentially the reflexive transitive closure of the transition graph that has been augmented to take edge labels into account.  The elements of  are known as paths.  The edge labels of a path are obtained by concatenating the edge labels of its constituent transitions in order.The behavior of the transducer T is the rational relation [T] defined as follows:  if and only if there exists  and  such that .  This is to say that T transduces a string  into a string  if there exists a path from an initial state to a final state whose input label is x and whose output label is y.Finite State Transducers can be weighted, where each transition is labelled with a weight in addition to the input and output labels. A Weighted Finite State Transducer (WFST) over a set K of weights can be defined similarly to an unweighted one as an 8-tuple , where: are defined as above; (where ε is the empty string) is the finite set of transitions; maps initial states to weights; maps final states to weights.In order to make certain operations on WFSTs well-defined, it is convenient to require the set of weights to form a semiring.[3] Two typical semirings used in practice are the log semiring and tropical semiring: nondeterministic automata may be regarded as having weights in the Boolean semiring.[4]Stochastic FSTs (also known as probabilistic FSTs or statistical FSTs) are presumably a form of weighted FST.[]The following operations defined on finite automata also apply to finite transducers:Union.  Given transducers  and , there exists a transducer  such that  if and only if  or .Concatenation.  Given transducers  and , there exists a transducer  such that  if and only if there exist  with  and Kleene closure.  Given a transducer , there might exist a transducer  with the following properties:[5]()()and  does not hold unless mandated by (k1) or (k2).Composition. Given a transducer  on alphabets Σ and Γ and a transducer  on alphabets Γ and Δ, there exists a transducer  on Σ and Δ such that  if and only if there exists a string  such that  and . This operation extends to the weighted case.[6]This definition uses the same notation used in mathematics for relation composition. However, the conventional reading for relation composition is the other way around: given two relations  and ,  when there exist some  such that  and Projection to an automaton.  There are two projection functions:  preserves the input tape, and  preserves the output tape.  The first projection,  is defined as follows:Given a transducer , there exists a finite automaton  such that  accepts x if and only if there exists a string y for which The second projection,  is defined similarly.Determinization. Given a transducer , we want to build an equivalent transducer that has a unique initial state and such that no two transitions leaving any state share the same input label. The powerset construction can be extended to transducers, or even weighted transducers, but sometimes fails to halt; indeed, some non-deterministic transducers do not admit equivalent deterministic transducers.[7] Characterizations of determinizable transducers have been proposed[8] along with efficient algorithms to test them:[9] they rely on the semiring used in the weighted case as well as a general property on the structure of the transducer (the twins property).Weight pushing for the weighted case.[10]Minimization for the weighted case.[11]Removal of epsilon-transitions.It is decidable whether the relation [T] of a transducer T is empty.It is decidable whether there exists a string y such that x[T]y for a given string x.It is undecidable whether two transducers are equivalent.[12] Equivalence is however decidable in the special case where the relation [T] of a transducer T is a (partial) function.If one defines the alphabet of labels , finite-state transducers are isomorphic to NDFA over the alphabet , and may therefore be determinized (turned into deterministic finite automata over the alphabet ) and subsequently minimized so that they have the minimum number of states.[]FSTs are used in the lexical analysis phase of compilers to associate semantic value with the discovered tokens.[13]Context-sensitive rewriting rules of the form a → b / c _ d, used in linguistics to model phonological rules and sound change, are computationally equivalent to finite-state transducers, provided that application is nonrecursive, i.e. the rule is not allowed to rewrite the same substring twice.[14]Weighted FSTs found applications in natural language processing, including machine translation, and in machine learning.[15][16] An implementation for part-of-speech tagging can be found as one component of the OpenGrm[17] library.Mealy machineMoore machineMorphological dictionaryfoma (software)Tree transducerOpenFst, an open-source library for FST operations.Finite State Morphology--The Book XFST/ LEXC, a description of Xerox's implementation of finite-state transducers intended for linguistic applications.The Helsinki open source implementation and extension of the Xerox fstFOMA, an open-source implementation of most of the capabilities of the Xerox XFST/ LEXC implementation.Stuttgart Finite State Transducer Tools, another open-source FST toolkitjava FST Framework, an open-source java FST Framework capable of handling OpenFst text format.Vcsn, an open-source platform (C++ &amp; IPython) platform for weighted automata and rational expressions.Jurafsky, Daniel; James H. Martin (2000). . Prentice Hall. pp. 71–83. ISBN 0-13-095069-6.Kornai, Andras (1999). Extended Finite State Models of Language. Cambridge University Press. ISBN 0-521-63198-X.Roche, Emmanuel; Yves Schabes (1997). . MIT Press. pp. 1–65. ISBN 0-262-18182-7.Beesley, Kenneth R.; Lauri Karttunen (2003). Finite State Morphology. Center for the Study of Language and Information. ISBN 1-57586-434-7.Roark, Brian; Richard Sproat (2007). Computational Approaches to Morphology and Syntax. Oxford University Press. ISBN 978-0-19-927478-9.Berstel, Jean (1979). Transductions and Context-free Languages. Teubner Verlag.. Free PDF version