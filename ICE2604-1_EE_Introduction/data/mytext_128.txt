bogosortBogosortClassSortingData structureArrayWorst-case performanceUnbounded (randomized version),  (deterministic version)Best-case performance[1]Average performance[1]Worst-case space complexityIn computer science, bogosort[1][2] (also known as permutation sort, stupid sort,[3] slowsort or bozosort) is a sorting algorithm based on the generate and test paradigm. The function successively generates permutations of its input until it finds one that is sorted. It is not considered useful for sorting, but may be used for educational purposes, to contrast it with more efficient algorithms.Two versions of this algorithm exist: a deterministic version that enumerates all permutations until it hits a sorted one,[2][4] and a randomized version that randomly permutes its input. An analogy for the working of the latter version is to sort a deck of cards by throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. Its name is a portmanteau of the words bogus and sort.[5]The following is a description of the randomized algorithm in pseudocode:while not sorted(deck):    shuffle(deck)Here is the above pseudocode rewritten in Python 3:This code assumes that data is a simple, mutable, array-like data structure—like Python's built-in list—whose elements can be compared without issue.If all elements to be sorted are distinct, the expected number of comparisons performed in the average case by randomized bogosort is asymptotically equivalent to , and the expected number of swaps in the average case equals .[1] The expected number of swaps grows faster than the expected number of comparisons, because if the elements are not in order, this will usually be discovered after only a few comparisons, no matter how many elements there are; but the work of shuffling the collection is proportional to its size. In the worst case, the number of comparisons and swaps are both unbounded, for the same reason that a tossed coin might turn up heads any number of times in a row.The best case occurs if the list as given is already sorted; in this case the expected number of comparisons is , and no swaps at all are carried out.[1]For any collection of fixed size, the expected running time of the algorithm is finite for much the same reason that the infinite monkey theorem holds: there is some probability of getting the right permutation, so given an unbounded number of tries it will almost surely eventually be chosen.is a sorting algorithm introduced in the 2011 Google Code Jam.[6] As long as the list is not in order, a subset of all elements is randomly permuted. If this subset is optimally chosen each time this is performed, the expected value of the total number of times this operation needs to be done is equal to the number of misplaced elements.is an algorithm that was designed not to succeed before the heat death of the universe on any sizable list. It works by recursively calling itself with smaller and smaller copies of the beginning of the list to see if they are sorted.  The base case is a single element, which is always sorted.  For other cases, it compares the last element to the maximum element from the previous elements in the list.  If the last element is greater or equal, it checks if the order of the copy matches the previous version, and if so returns.  Otherwise, it reshuffles the current copy of the list and restarts its recursive check.[7]is another sorting algorithm based on random numbers. If the list is not in order, it picks two items at random and swaps them, then checks to see if the list is sorted. The running time analysis of a bozosort is more difficult, but some estimates are found in H. Gruber's analysis of "perversely awful" randomized sorting algorithms.[1]  is found to be the expected average case.is a pessimal[a] sorting algorithm that is guaranteed to complete in finite time; however, its efficiency can be arbitrarily bad, depending on its configuration. The  algorithm is based on a bad sorting algorithm, . The badsort algorithm accepts two parameters: , which is the list to be sorted, and , which is a recursion depth. At recursion level ,  merely uses a common sorting algorithm, such as bubblesort, to sort its inputs and return the sorted list. That is to say, . Therefore, badsort's time complexity is  if . However, for any ,  first generates , the list of all permutations of . Then,  calculates , and returns the first element of the sorted . To make  truly pessimal,  may be assigned to the value of a computable increasing function such as  (e.g. , where  is Ackermann's function).  Ergo, to sort a list arbitrarily badly, you would execute , where  is the number of elements in . The resulting algorithm has complexity , where  = factorial of  iterated  times. This algorithm can be made as inefficient as one wishes by picking a fast enough growing function .[8]Slowsortis a different humorous sorting algorithm that employs a misguided divide-and-conquer strategy to achieve massive complexity.is a hypothetical sorting algorithm based on bogosort, created as an in-joke among computer scientists. The algorithm generates a random permutation of its input using a quantum source of entropy, checks if the list is sorted, and, if it is not, destroys the universe. Assuming that the many-worlds interpretation holds, the use of this algorithm will result in at least one surviving universe where the input was successfully sorted in  time.[9]is a sorting algorithm that checks if the array is sorted until a miracle occurs. It continually checks the array until it is sorted, never changing the order of the array.[10] Because the order is never altered, the algorithm has a hypothetical time complexity of , but it can still sort through events such as miracles or single-event upsets. Particular care must be taken in the implementation of this algorithm as optimizing compilers may simply transform it into a while(true) loop.Las Vegas algorithmStooge sortBogoSort on WikiWikiWebInefficient sort algorithmsBogosort: an implementation that runs on Unix-like systems, similar to the standard sort program.Bogosort and jmmcg::bogosort]: Simple, yet perverse, C++ implementations of the bogosort algorithm.Bogosort NPM package: bogosort implementation for Node.js ecosystem.Max Sherman Bogo-sort is Sort of Slow, June 2013