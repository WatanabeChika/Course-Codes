<!DOCTYPE html>
<html>
<head>
<title>perfect_hashing</title>
</head>
<body>
<div class="mw-parser-output">


<p>In computer science, a <b>perfect hash function</b> <span class="texhtml mvar" style="font-style:italic;">h</span> for a set <span class="texhtml mvar" style="font-style:italic;">S</span> is a hash function that maps distinct elements in <span class="texhtml mvar" style="font-style:italic;">S</span> to a set of <span class="texhtml mvar" style="font-style:italic;">m</span> integers, with no collisions. In mathematical terms, it is an injective function.
</p><p>Perfect hash functions may be used to implement a lookup table with constant worst-case access time. A perfect hash function can, as any hash function, be used to implement hash tables, with the advantage that no collision resolution has to be implemented. In addition, if the keys are not the data and if it is known that queried keys will be valid, then the keys do not need to be stored in the lookup table, saving space.
</p><p>Disadvantages of perfect hash functions are that <span class="texhtml mvar" style="font-style:italic;">S</span> needs to be known for the construction of the perfect hash function. Non-dynamic perfect hash functions need to be re-constructed if <span class="texhtml mvar" style="font-style:italic;">S</span> changes. For frequently changing <span class="texhtml mvar" style="font-style:italic;">S</span> dynamic perfect hash functions may be used at the cost of additional space.<sup class="reference" id="cite_ref-DynamicPerfectHashing_1-0">[1]</sup> The space requirement to store the perfect hash function is in <span class="texhtml"><i>O</i>(<i>n</i>)</span>.
</p><p>The important performance parameters for perfect hash functions are the evaluation time, which should be constant, the construction time, and the representation size.
</p>

<h2><span class="mw-headline" id="Application">Application</span><span class="mw-editsection"></span></h2>
<p>A perfect hash function with values in a limited range can be used for efficient lookup operations, by placing keys from <span class="texhtml mvar" style="font-style:italic;">S</span> (or other associated values) in a lookup table indexed by the output of the function. One can then test whether a key is present in <span class="texhtml mvar" style="font-style:italic;">S</span>, or look up a value associated with that key, by looking for it at its cell of the table. Each such lookup takes constant time in the worst case.<sup class="reference" id="cite_ref-inventor_2-0">[2]</sup> With perfect hashing, the associated data can be read or written with a single access to the table.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="Performance_of_perfect_hash_functions">Performance of perfect hash functions</span><span class="mw-editsection"></span></h2>
<p>The important performance parameters for perfect hashing are the representation size, the evaluation time, the construction time, and additionally the range requirement <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {m}{n}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>m</mi>
<mi>n</mi>
</mfrac>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {m}{n}}}</annotation>
</semantics>
</math></span><img alt="{\frac {m}{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d48d87468620ad6c70385ddd0d024577ccb559e1" style="vertical-align: -1.838ex; width:2.877ex; height:4.676ex;"/></span>.<sup class="reference" id="cite_ref-CHD_4-0">[4]</sup> The evaluation time can be as fast as <span class="texhtml"><i>O</i>(<i>1</i>)</span>, which is optimal.<sup class="reference" id="cite_ref-inventor_2-1">[2]</sup><sup class="reference" id="cite_ref-CHD_4-1">[4]</sup> The construction time needs to be at least <span class="texhtml"><i>O</i>(<i>n</i>)</span>, because each element in <span class="texhtml mvar" style="font-style:italic;">S</span> needs to be considered, and <span class="texhtml mvar" style="font-style:italic;">S</span> contains <span class="texhtml mvar" style="font-style:italic;">n</span> elements. This lower bound can be achieved in practice.<sup class="reference" id="cite_ref-CHD_4-2">[4]</sup>
</p><p>The lower bound for the representation size depends on <span class="texhtml mvar" style="font-style:italic;">m</span> and <span class="texhtml mvar" style="font-style:italic;">n</span>. Let <span class="texhtml"><i>m</i> = (1+ε) <i>n</i></span> and <span class="texhtml mvar" style="font-style:italic;">h</span> a perfect hash function. A good approximation for the lower bound is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>e</mi>
<mo>−<!-- − --></mo>
<mi>ε<!-- ε --></mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mi>ε<!-- ε --></mi>
</mrow>
<mi>ε<!-- ε --></mi>
</mfrac>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b02a088abd50352f229055b2573a6cb24e70ea05" style="vertical-align: -1.838ex; width:18.035ex; height:5.176ex;"/></span> Bits per element. For minimal perfect hashing, <span class="texhtml">ε = 0</span>, the lower bound is <span class="texhtml">log e ≈ 1.44</span> bits per element.<sup class="reference" id="cite_ref-CHD_4-3">[4]</sup>
</p>
<h2><span class="mw-headline" id="Construction">Construction</span><span class="mw-editsection"></span></h2>
<p>A perfect hash function for a specific set <span class="texhtml mvar" style="font-style:italic;">S</span> that can be evaluated in constant time, and with values in a small range, can be found by a randomized algorithm in a number of operations that is proportional to the size of S.
The original construction of Fredman, Komlós &amp; Szemerédi (1984) uses a two-level scheme to map a set <span class="texhtml mvar" style="font-style:italic;">S</span> of <span class="texhtml mvar" style="font-style:italic;">n</span> elements to a range of <span class="texhtml"><i>O</i>(<i>n</i>)</span> indices, and then map each index to a range of hash values. The first level of their construction chooses a large prime <span class="texhtml mvar" style="font-style:italic;">p</span> (larger than the size of the universe from which <span class="texhtml mvar" style="font-style:italic;">S</span> is drawn), and a parameter <span class="texhtml mvar" style="font-style:italic;">k</span>, and maps each element <span class="texhtml mvar" style="font-style:italic;">x</span> of <span class="texhtml mvar" style="font-style:italic;">S</span> to the index
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle g(x)=(kx{\bmod {p}}){\bmod {n}}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>g</mi>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo lspace="thickmathspace" rspace="thickmathspace">mod</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo lspace="thickmathspace" rspace="thickmathspace">mod</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</mrow>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle g(x)=(kx{\bmod {p}}){\bmod {n}}.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle g(x)=(kx{\bmod {p}}){\bmod {n}}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0eed5c339f42fdccc1685d8d3b1af928e2a3be01" style="vertical-align: -0.838ex; width:26.277ex; height:2.843ex;"/></span></dd></dl>
<p>If <span class="texhtml mvar" style="font-style:italic;">k</span> is chosen randomly, this step is likely to have collisions, but the number of elements <span class="texhtml mvar" style="font-style:italic;">n<sub>i</sub></span> that are simultaneously mapped to the same index <span class="texhtml mvar" style="font-style:italic;">i</span> is likely to be small.
The second level of their construction assigns disjoint ranges of <span class="texhtml"><i>O</i>(<i>n<sub>i</sub></i><sup>2</sup>)</span> integers to each index <span class="texhtml mvar" style="font-style:italic;">i</span>. It uses a second set of linear modular functions, one for each index <span class="texhtml mvar" style="font-style:italic;">i</span>, to map each member <span class="texhtml mvar" style="font-style:italic;">x</span> of <span class="texhtml mvar" style="font-style:italic;">S</span> into the range associated with <span class="texhtml"><i>g</i>(<i>x</i>)</span>.<sup class="reference" id="cite_ref-inventor_2-2">[2]</sup>
</p><p>As Fredman, Komlós &amp; Szemerédi (1984) show, there exists a choice of the parameter <span class="texhtml mvar" style="font-style:italic;">k</span> such that the sum of the lengths of the ranges for the <span class="texhtml mvar" style="font-style:italic;">n</span> different values of <span class="texhtml"><i>g</i>(<i>x</i>)</span> is <span class="texhtml"><i>O</i>(<i>n</i>)</span>. Additionally, for each value of <span class="texhtml"><i>g</i>(<i>x</i>)</span>, there exists a linear modular function that maps the corresponding subset of <span class="texhtml mvar" style="font-style:italic;">S</span> into the range associated with that value. Both <span class="texhtml mvar" style="font-style:italic;">k</span>, and the second-level functions for each value of <span class="texhtml"><i>g</i>(<i>x</i>)</span>, can be found in polynomial time by choosing values randomly until finding one that works.<sup class="reference" id="cite_ref-inventor_2-3">[2]</sup>
</p><p>The hash function itself requires storage space <span class="texhtml"><i>O</i>(<i>n</i>)</span> to store <span class="texhtml mvar" style="font-style:italic;">k</span>, <span class="texhtml mvar" style="font-style:italic;">p</span>, and all of the second-level linear modular functions. Computing the hash value of a given key <span class="texhtml mvar" style="font-style:italic;">x</span> may be performed in constant time by computing <span class="texhtml"><i>g</i>(<i>x</i>)</span>, looking up the second-level function associated with <span class="texhtml"><i>g</i>(<i>x</i>)</span>, and applying this function to <span class="texhtml mvar" style="font-style:italic;">x</span>.
A modified version of this two-level scheme with a larger number of values at the top level can be used to construct a perfect hash function that maps <span class="texhtml mvar" style="font-style:italic;">S</span> into a smaller range of length <span class="texhtml"><i>n</i> + <i>o</i>(<i>n</i>)</span>.<sup class="reference" id="cite_ref-inventor_2-4">[2]</sup>
</p><p>A more recent method for constructing a perfect hash function is described by Belazzougui, Botelho &amp; Dietzfelbinger (2009) as "hash, displace, and compress". Here a first-level hash function <span class="texhtml mvar" style="font-style:italic;">g</span> is also used to map elements onto a range of <span class="texhtml mvar" style="font-style:italic;">r</span> integers. An element <span class="texhtml"><i>x</i> ∈ <i>S</i></span> is stored in the Bucket <span class="texhtml mvar" style="font-style:italic;">B<sub>g(x)</sub></span>.<sup class="reference" id="cite_ref-CHD_4-4">[4]</sup>
</p><p>Then, in descending order of size, each bucket's elements are hashed by a hash function of a sequence of independent fully random hash functions <span class="texhtml">(Φ<sub>1</sub>, Φ<sub>2</sub>, Φ<sub>3</sub>, ...)</span>, starting with <span class="texhtml">Φ<sub>1</sub></span>. If the hash function does not produce any collisions for the bucket, and the resulting values are not yet occupied by other elements from other buckets, the function is chosen for that bucket. If not, the next hash function in the sequence is tested.<sup class="reference" id="cite_ref-CHD_4-5">[4]</sup>
</p><p>To evaluate the perfect hash function <span class="texhtml"><i>h</i>(<i>x</i>)</span> one only has to save the mapping σ of the bucket index <span class="texhtml"><i>g</i>(<i>x</i>)</span> onto the correct hash function in the sequence, resulting in <span class="texhtml">h(x) = Φ<sub>σ(g(x))</sub></span>.<sup class="reference" id="cite_ref-CHD_4-6">[4]</sup>
</p><p>Finally, to reduce the representation size, the (<span class="texhtml">σ(i))<sub>0 ≤ i &lt; r</sub></span> are compressed into a form that still allows the evaluation in <span class="texhtml"><i>O</i>(<i>1</i>)</span>.<sup class="reference" id="cite_ref-CHD_4-7">[4]</sup>
</p><p>This approach needs linear time in <span class="texhtml mvar" style="font-style:italic;">n</span> for construction, and constant evaluation time. The representation size is in <span class="texhtml"><i>O</i>(<i>n</i>)</span>, and depends on the achieved range. For example, with <span class="texhtml"><i>m</i> = 1.23<i>n</i></span> Belazzougui, Botelho &amp; Dietzfelbinger (2009) achieved a representation size between 3.03 bits/key and 1.40 bits/key for their given example set of 10 million entries, with lower values needing a higher computation time. The space lower bound in this scenario is 0.88 bits/key.<sup class="reference" id="cite_ref-CHD_4-8">[4]</sup>
</p>
<h3><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h3>
<pre><b>algorithm</b> <i>hash, displace, and compress</i> <b>is</b>
(1) Split S into buckets <span class="texhtml">B<sub>i</sub> := g<sup>−1</sup>({i})∩S,0 ≤ i &lt; r</span>
(2) Sort buckets B<sub>i</sub> in falling order according to size |B<sub>i</sub>|
(3) Initialize array T[0...m-1] with 0's
(4) <b>for all</b> i<span style="white-space: nowrap;"> </span>∈[r], in the order from (2), <b>do</b>
(5)     <b>for</b> l<span style="white-space: nowrap;"> </span>←<span style="white-space: nowrap;"> </span>1,2,...
(6)         <b>repeat</b> forming K<sub>i</sub><span style="white-space: nowrap;"> </span>←<span style="white-space: nowrap;"> </span>{<span class="texhtml">Φ</span><sub>l</sub>(x)|x<span style="white-space: nowrap;"> </span>∈<span style="white-space: nowrap;"> </span>B<sub>i</sub>}
(6)         <b>until</b> |K<sub>i</sub>|=|B<sub>i</sub>| <b>and</b> K<sub>i</sub>∩{j|T[j]=1}=<span style="white-space: nowrap;"> </span>∅
(7)     <b>let</b> σ(i):= the successful l
(8)     <b>for all</b> j<span style="white-space: nowrap;"> </span>∈<span style="white-space: nowrap;"> </span>K<sub>i</sub> <b>let</b> T[j]:=<span style="white-space: nowrap;"> </span>1
(9) Transform (σ<sub>i</sub>)<sub>0≤i&lt;r</sub> into compressed form, retaining <span class="texhtml"><i>O</i>(<i>1</i>)</span> access.
</pre>
<h2><span class="mw-headline" id="Space_lower_bounds">Space lower bounds</span><span class="mw-editsection"></span></h2>
<p>The use of <span class="texhtml"><i>O</i>(<i>n</i>)</span> words of information to store the function of Fredman, Komlós &amp; Szemerédi (1984) is near-optimal: any perfect hash function that can be calculated in constant time
requires at least a number of bits that is proportional to the size of <span class="texhtml mvar" style="font-style:italic;">S</span>.<sup class="reference" id="cite_ref-5">[5]</sup>
</p><p>For minimal perfect hash functions the information theoretic space lower bound is
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log _{2}e\approx 1.44}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>e</mi>
<mo>≈<!-- ≈ --></mo>
<mn>1.44</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log _{2}e\approx 1.44}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log _{2}e\approx 1.44}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0fd72ec3b460d6cf5434f1a0bb5bb5d24b4b2d15" style="vertical-align: -0.838ex; width:12.729ex; height:2.676ex;"/></span></dd></dl>
<p>bits/key.<sup class="reference" id="cite_ref-CHD_4-9">[4]</sup>
</p><p>For perfect hash functions, it is first assumed that the range of <span class="texhtml mvar" style="font-style:italic;">h</span> is bounded by <span class="texhtml mvar" style="font-style:italic;">n</span> as <span class="texhtml"><i>m</i> = (1+ε) <i>n</i></span>. With the formula given by Belazzougui, Botelho &amp; Dietzfelbinger (2009) and for a universe <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle U\supseteq S}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>U</mi>
<mo>⊇<!-- ⊇ --></mo>
<mi>S</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle U\supseteq S}</annotation>
</semantics>
</math></span><img alt="{\displaystyle U\supseteq S}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/16992fcab6da9089922e110403a580e2df030419" style="vertical-align: -0.505ex; width:6.38ex; height:2.343ex;"/></span> whose size <span class="texhtml">|<i>U</i>| = <i>u</i></span> tends towards infinity, the space lower bounds is
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log _{2}e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>e</mi>
<mo>−<!-- − --></mo>
<mi>ε<!-- ε --></mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mi>ε<!-- ε --></mi>
</mrow>
<mi>ε<!-- ε --></mi>
</mfrac>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log _{2}e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log _{2}e-\varepsilon \log {\frac {1+\varepsilon }{\varepsilon }}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/776f6c7e58c34f514e1be99b98abdf9f15e14e2a" style="vertical-align: -1.838ex; width:19.089ex; height:5.176ex;"/></span></dd></dl>
<p>bits/key, minus <span class="texhtml">log(<i>n</i>)</span> bits overall.<sup class="reference" id="cite_ref-CHD_4-10">[4]</sup>
</p>
<h2><span class="mw-headline" id="Extensions">Extensions</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Memory_address_identity">Memory address identity</span><span class="mw-editsection"></span></h3>
<p>A trivial but pervasive example of perfect hashing is implicit in the (virtual) memory address space of a computer. Since each byte of virtual memory is a distinct, unique, directly addressable storage location, the value of the (starting) address of any object stored in memory can be considered a <i>de-facto</i> perfect hash of that object into the entire memory address range.<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<h3><span class="mw-headline" id="Dynamic_perfect_hashing">Dynamic perfect hashing</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Using a perfect hash function is best in situations where there is a frequently queried large set, <span class="texhtml mvar" style="font-style:italic;">S</span>, which is seldom updated. This is because any modification of the set <span class="texhtml mvar" style="font-style:italic;">S</span> may cause the hash function to no longer be perfect for the modified set. Solutions which update the hash function any time the set is modified are known as dynamic perfect hashing,<sup class="reference" id="cite_ref-DynamicPerfectHashing_1-1">[1]</sup> but these methods are relatively complicated to implement.
</p>
<h3><span class="mw-headline" id="Minimal_perfect_hash_function">Minimal perfect hash function</span><span class="mw-editsection"></span></h3>
<p>A minimal perfect hash function is a perfect hash function that maps <span class="texhtml mvar" style="font-style:italic;">n</span> keys to <span class="texhtml mvar" style="font-style:italic;">n</span> consecutive integers – usually the numbers from <span class="texhtml">0</span> to <span class="texhtml"><i>n</i> − 1</span> or from <span class="texhtml">1</span> to <span class="texhtml mvar" style="font-style:italic;">n</span>.  A more formal way of expressing this is:  Let <span class="texhtml mvar" style="font-style:italic;">j</span> and <span class="texhtml mvar" style="font-style:italic;">k</span> be elements of some finite set <span class="texhtml mvar" style="font-style:italic;">S</span>.  Then <span class="texhtml mvar" style="font-style:italic;">h</span> is a minimal perfect hash function if and only if <span class="texhtml"><i>h</i>(<i>j</i>) = <i>h</i>(<i>k</i>)</span> implies <span class="texhtml"><i>j</i> = <i>k</i></span> (injectivity) and there exists an integer <span class="texhtml mvar" style="font-style:italic;">a</span> such that the range of <span class="texhtml mvar" style="font-style:italic;">h</span> is <span class="texhtml"><i>a</i>..<i>a</i> + |<i>S</i>| − 1</span>. It has been proven that a general purpose minimal perfect hash scheme requires at least <span class="texhtml">lg <i>e</i> ≈ 1.44</span> bits/key.<sup class="reference" id="cite_ref-CHD_4-11">[4]</sup> Although this space bound has been achieved by theoretical works, in practice, the best known minimal perfect hashing schemes require roughly 1.56 bits/key if given enough time.<sup class="reference" id="cite_ref-RecSplit_7-0">[7]</sup>
</p>
<h3><span class="mw-headline" id="k-perfect_hashing">k-perfect hashing</span><span class="mw-editsection"></span></h3>
<p>A hash function is <span class="texhtml mvar" style="font-style:italic;">k</span>-perfect if at most <span class="texhtml mvar" style="font-style:italic;">k</span> elements from <span class="texhtml mvar" style="font-style:italic;">S</span> are mapped onto the same value in the range. The "hash, displace, and compress" algorithm can be used to construct <span class="texhtml mvar" style="font-style:italic;">k</span>-perfect hash functions by allowing up to <span class="texhtml mvar" style="font-style:italic;">k</span> collisions. The changes necessary to accomplish this are minimal, and are underlined in the adapted pseudocode below:
</p>
<pre>(4) <b>for all</b> i<span style="white-space: nowrap;"> </span>∈[r], in the order from (2), <b>do</b>
(5)     <b>for</b> l<span style="white-space: nowrap;"> </span>←<span style="white-space: nowrap;"> </span>1,2,...
(6)         <b>repeat</b> forming K<sub>i</sub><span style="white-space: nowrap;"> </span>←<span style="white-space: nowrap;"> </span>{<span class="texhtml">Φ</span><sub>l</sub>(x)|x<span style="white-space: nowrap;"> </span>∈<span style="white-space: nowrap;"> </span>B<sub>i</sub>}
(6)         <b>until</b> |K<sub>i</sub>|=|B<sub>i</sub>| <b>and</b> K<sub>i</sub>∩{j|<u>T[j]=k</u>}=<span style="white-space: nowrap;"> </span>∅
(7)     <b>let</b> σ(i):= the successful l
(8)     <b>for all</b> j<span style="white-space: nowrap;"> </span>∈<span style="white-space: nowrap;"> </span>K<sub>i</sub> <b>set</b> <u>T[j]←T[j]+1</u>
</pre>
<h3><span class="mw-headline" id="Order_preservation">Order preservation</span><span class="mw-editsection"></span></h3>
<p>A minimal perfect hash function <span class="texhtml mvar" style="font-style:italic;">F</span> is <i>order preserving</i> if keys are given in some order <span class="texhtml"><i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, ..., <i>a</i><sub><i>n</i></sub></span> and for any keys <span class="texhtml"><i>a</i><sub><i>j</i></sub></span> and <span class="texhtml"><i>a</i><sub><i>k</i></sub></span>, <span class="texhtml"><i>j</i> &lt; <i>k</i></span> implies <span class="texhtml"><i>F</i>(<i>a</i><sub><i>j</i></sub>) &lt; F(<i>a</i><sub><i>k</i></sub>)</span>.<sup class="reference" id="cite_ref-8">[8]</sup> In this case, the function value is just the position of each key in the sorted ordering of all of the keys. A simple implementation of order-preserving minimal perfect hash functions with constant access time is to use an (ordinary) perfect hash function or cuckoo hashing to store a lookup table of the positions of each key. If the keys to be hashed are themselves stored in a sorted array, it is possible to store a small number of additional bits per key in a data structure that can be used to compute hash values quickly.<sup class="reference" id="cite_ref-9">[9]</sup> Order-preserving minimal perfect hash functions require necessarily <span class="texhtml"><i>Ω</i>(<i>n</i> log <i>n</i>)</span> bits to be represented.<sup class="reference" id="cite_ref-10">[10]</sup>
</p>
<h2><span class="mw-headline" id="Related_constructions">Related constructions</span><span class="mw-editsection"></span></h2>
<p>A simple alternative to perfect hashing, which also allows dynamic updates, is cuckoo hashing. This scheme maps keys to two or more locations within a range (unlike perfect hashing which maps each key to a single location) but does so in such a way that the keys can be assigned one-to-one to locations to which they have been mapped. Lookups with this scheme are slower, because multiple locations must be checked, but nevertheless take constant worst-case time.<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li>Richard J. Cichelli. <i>Minimal Perfect Hash Functions Made Simple</i>, Communications of the ACM, Vol. 23, Number 1, January 1980.</li>
<li>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. <i>Introduction to Algorithms</i>, Third Edition. MIT Press, 2009. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 978-0262033848. Section 11.5: Perfect hashing, pp. 267, 277–282.</li>
<li>Fabiano C. Botelho, Rasmus Pagh and Nivio Ziviani. "Perfect Hashing for Data Management Applications".</li>
<li>Fabiano C. Botelho and Nivio Ziviani. "External perfect hashing for very large key sets". 16th ACM Conference on Information and Knowledge Management (CIKM07), Lisbon, Portugal, November 2007.</li>
<li>Djamal Belazzougui, Paolo Boldi, Rasmus Pagh, and Sebastiano Vigna. "Monotone minimal perfect hashing: Searching a sorted table with O(1) accesses". In Proceedings of the 20th Annual ACM-SIAM Symposium On Discrete Mathematics (SODA), New York, 2009. ACM Press.</li>
<li>Marshall D. Brain and Alan L. Tharp. "Near-perfect Hashing of Large Word Sets". Software--Practice and Experience, vol. 19(10), 967-078, October 1989. John Wiley &amp; Sons.</li>
<li>Douglas C. Schmidt, GPERF: A Perfect Hash Function Generator, C++ Report, SIGS, Vol. 10, No. 10, November/December, 1998.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>gperf is an Open Source C and C++ perfect hash generator (very fast, but only works for small sets)</li>
<li>Minimal Perfect Hashing (bob algorithm) by Bob Jenkins</li>
<li>cmph: C Minimal Perfect Hashing Library, open source implementations for many (minimal) perfect hashes (works for big sets)</li>
<li>Sux4J: open source monotone minimal perfect hashing in Java</li>
<li>MPHSharp: perfect hashing methods in C#</li>
<li>BBHash: minimal perfect hash function in header-only C++</li>
<li>Perfect::Hash, perfect hash generator in Perl that makes C code. Has a "prior art" section worth looking at.</li></ul>
<!-- 
NewPP limit report
Parsed by mw2316
Cached time: 20221224031026
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.305 seconds
Real time usage: 0.426 seconds
Preprocessor visited node count: 4233/1000000
Post‐expand include size: 42608/2097152 bytes
Template argument size: 4700/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 42043/5000000 bytes
Lua time usage: 0.156/10.000 seconds
Lua memory usage: 5930730/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  318.882      1 -total
 40.41%  128.866      1 Template:Reflist
 32.40%  103.307     10 Template:Citation
 15.96%   50.890      1 Template:Short_description
 14.11%   44.999     49 Template:Math
 11.79%   37.580      6 Template:Harvtxt
  8.33%   26.565      2 Template:Pagetype
  6.59%   21.005     53 Template:Main_other
  6.17%   19.663      1 Template:Main_article
  4.47%   14.246      1 Template:ISBN
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:268162-0!canonical and timestamp 20221224031025 and revision id 1109906535.
 -->
</div></body>
</html>