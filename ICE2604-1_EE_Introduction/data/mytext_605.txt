maximum-flow_problemIn optimization theory, maximum flow problems involve finding a feasible flow through a flow network that obtains the maximum possible flow rate.The maximum flow problem can be seen as a special case of more complex network flow problems, such as the circulation problem. The maximum value of an s-t flow (i.e., flow from source s to sink t) is equal to the minimum capacity of an s-t cut (i.e., cut severing s from t) in the network, as stated in the max-flow min-cut theorem.The maximum flow problem was first formulated in 1954 by T. E. Harris and F. S. Ross as a simplified model of Soviet railway traffic flow.[1][2][3]In 1955, Lester R. Ford, Jr. and Delbert R. Fulkerson created the first known algorithm, the Ford–Fulkerson algorithm.[4][5] In their 1955 paper,[4] Ford and Fulkerson wrote that the problem of Harris and Ross is formulated as follows (see[1] p. 5):Consider a rail network connecting two cities by way of a number of intermediate cities, where each link of the network has a number assigned to it representing its capacity. Assuming a steady state condition, find a maximal flow from one given city to the other.In their book Flows in Network,[5] in 1962, Ford and Fulkerson wrote:It was posed to the authors in the spring of 1955 by T. E. Harris, who, in conjunction with General F. S. Ross (Ret.), had formulated a simplified model of railway traffic flow, and pinpointed this particular problem as the central one suggested by the model [11].where [11] refers to the 1955 secret report Fundamentals of a Method for Evaluating Rail net Capacities by Harris and Ross[3] (see[1] p. 5).Over the years, various improved solutions to the maximum flow problem were discovered, notably the shortest augmenting path algorithm of Edmonds and Karp and independently Dinitz; the blocking flow algorithm of Dinitz; the push-relabel algorithm of Goldberg and Tarjan; and the binary blocking flow algorithm of Goldberg and Rao. The algorithms of Sherman[6] and Kelner, Lee, Orecchia and Sidford,[7][8] respectively, find an approximately optimal maximum flow but only work in undirected graphs.In 2013 James B. Orlin published a paper describing an  algorithm.[9]In 2022 Li Chen, Rasmus Kyng, Yang P. Liu, Richard Peng, Maximilian Probst Gutenberg, and Sushant Sachdeva published an almost-linear time algorithm running in .[10][11]First we establish some notation:Let  be a network with  being the source and the sink of  respectively.If  is function on the edges of  then its value on  is denoted by  or Definition. The capacity of an edge is the maximum amount of flow that can pass through an edge. Formally it is a map Definition. A flow is a map  that satisfies the following:Capacity constraint. The flow of an edge cannot exceed its capacity, in other words:  for all Conservation of flows. The sum of the flows entering a node must equal the sum of the flows exiting that node, except for the source and the sink. Or:Remark. Flows are skew symmetric:  for all Definition. The value of flow is the amount of flow passing from the source to the sink. Formally for a flow  it is given by:Definition. The maximum flow problem is to route as much flow as possible from the source to the sink, in other words find the flow  with maximum value.Note that several maximum flows may exist, and if arbitrary real (or even arbitrary rational) values of flow are permitted (instead of just integers), there is either exactly one maximum flow, or infinitely many, since there are infinitely many linear combinations of the base maximum flows. In other words, if we send  units of flow on edge  in one maximum flow, and  units of flow on  in another maximum flow, then for each  we can send  units on  and route the flow on remaining edges accordingly, to obtain another maximum flow. If flow values can be any real or rational numbers, then there are infinitely many such  values for each pair .The following table lists algorithms for solving the maximum flow problem.MethodComplexityDescriptionLinear programmingConstraints given by the definition of a legal flow. See the linear program here.Ford–Fulkerson algorithmAs long as there is an open path through the residual graph, send the minimum of the residual capacities on the path.The algorithm is only guaranteed to terminate if all weights are rational, in which case the amount added to the flow in each step is at least the greatest common divisor of the weights. Otherwise it is possible that the algorithm will not converge to the maximum value. However, if the algorithm terminates, it is guaranteed to find the maximum value.Edmonds–Karp algorithmA specialization of Ford–Fulkerson, finding augmenting paths with breadth-first search.Dinic's algorithmIn each phase the algorithms builds a layered graph with breadth-first search on the residual graph. The maximum flow in a layered graph can be calculated in  time, and the maximum number of phases is . In networks with unit capacities, Dinic's algorithm terminates in  time.MKM (Malhotra, Kumar, Maheshwari) algorithm[12]A modification of Dinic's algorithm with a different approach to constructing blocking flows. Refer to the original paper.Dinic's algorithm with dynamic treesThe dynamic trees data structure speeds up the maximum flow computation in the layered graph to .General push–relabel algorithm[13]The push relabel algorithm maintains a preflow, i.e. a flow function with the possibility of excess in the vertices. The algorithm runs while there is a vertex with positive excess, i.e. an active vertex in the graph. The push operation increases the flow on a residual edge, and a height function on the vertices controls through which residual edges can flow be pushed. The height function is changed by the relabel operation. The proper definitions of these operations guarantee that the resulting flow function is a maximum flow.Push–relabel algorithm with FIFO vertex selection rule[13]Push-relabel algorithm variant which always selects the most recently active vertex, and performs push operations while the excess is positive and there are admissible residual edges from this vertex.Push–relabel algorithm with maximum distance vertex selection rule[14]Push-relabel algorithm variant which always selects the most distant vertex from  or  (i.e. the highest label vertex) but otherwise proceeds as the FIFO algorithm.Push-relabel algorithm with dynamic trees[13]The algorithm builds limited size trees on the residual graph regarding to the height function. These trees provide multilevel push operations, i.e. pushing along an entire saturating path instead of a single edge.KRT (King, Rao, Tarjan)'s algorithm[15]Binary blocking flow algorithm[16]The value U corresponds to the maximum capacity of the network.James B Orlin's + KRT (King, Rao, Tarjan)'s algorithm[9]Orlin's algorithm solves max-flow in  time for  while KRT solves it in  for .Kathuria-Liu-Sidford algorithm[17]Interior point methods and edge boosting using -norm flows. Builds on earlier algorithm of Madry, which achieved runtime .[18]BLNPSSSW / BLLSSSW algorithm[19][20]Interior point methods and dynamic maintenance of electric flows with expander decompositions.Gao-Liu-Peng algorithm[21]Gao, Liu, and Peng's algorithm revolves around dynamically maintaining the augmenting electrical flows at the core of the interior point method based algorithm from [Mądry JACM ‘16]. This entails designing data structures that, in limited settings, return edges with large electric energy in a graph undergoing resistance updates.Chen, Kyng, Liu, Peng, Gutenberg and Sachdeva's algorithm[10]Chen, Kyng, Liu, Peng, Gutenberg and Sachdeva's algorithm solves maximum flow and minimum-cost flow in almost linear time by building the flow through a sequence of  approximate undirected minimum-ratio cycles, each of which is computed and processed in amortized  time using a dynamic data structure.For additional algorithms, see Goldberg &amp; Tarjan (1988).The integral flow theorem states thatIf each edge in a flow network has integral capacity, then there exists an integral maximal flow.The claim is not only that the value of the flow is an integer, which follows directly from the max-flow min-cut theorem, but that the flow on every edge is integral. This is crucial for many combinatorial applications (see below), where the flow across an edge may encode whether the item corresponding to that edge is to be included in the set sought or not.Given a network  with a set of sources  and a set of sinks  instead of only one source and one sink, we are to find the maximum flow across . We can transform the multi-source multi-sink problem into a maximum flow problem by adding a consolidated source connecting to each vertex in  and a consolidated sink connected by each vertex in  (also known as supersource and supersink) with infinite capacity on each edge (See Fig. 4.1.1.).Given a bipartite graph , we are to find a maximum cardinality matching in , that is a matching that contains the largest possible number of edges. This problem can be transformed into a maximum flow problem by constructing a network , where contains the edges in  directed from  to . for each  and  for each . for each  (See Fig. 4.3.1).Then the value of the maximum flow in  is equal to the size of the maximum matching in , and a maximum cardinality matching can be found by taking those edges that have flow  in an integral max-flow.Given a directed acyclic graph , we are to find the minimum number of vertex-disjoint paths to cover each vertex in . We can construct a bipartite graph  from , where.Then it can be shown that  has a matching  of size  if and only if  has a vertex-disjoint path cover  containing  edges and  paths, where  is the number of vertices in . Therefore, the problem can be solved by finding the maximum cardinality matching in  instead.Assume we have found a matching  of , and constructed the cover  from it. Intuitively, if two vertices  are matched in , then the edge  is contained in . Clearly the number of edges in  is . To see that  is vertex-disjoint, consider the following:Each vertex  in  can either be non-matched in , in which case there are no edges leaving  in ; or it can be matched, in which case there is exactly one edge leaving  in . In either case, no more than one edge leaves any vertex  in .Similarly for each vertex  in  – if it is matched, there is a single incoming edge into  in ; otherwise  has no incoming edges in .Thus no vertex has two incoming or two outgoing edges in , which means all paths in  are vertex-disjoint.To show that the cover  has size , we start with an empty cover and build it incrementally. To add a vertex  to the cover, we can either add it to an existing path, or create a new path of length zero starting at that vertex. The former case is applicable whenever either  and some path in the cover starts at , or  and some path ends at . The latter case is always applicable. In the former case, the total number of edges in the cover is increased by 1 and the number of paths stays the same; in the latter case the number of paths is increased and the number of edges stays the same. It is now clear that after covering all  vertices, the sum of the number of paths and edges in the cover is . Therefore, if the number of edges in the cover is , the number of paths is .Let  be a network. Suppose there is capacity at each node in addition to edge capacity, that is, a mapping  such that the flow  has to satisfy not only the capacity constraint and the conservation of flows, but also the vertex capacity constraintIn other words, the amount of flow passing through a vertex cannot exceed its capacity. To find the maximum flow across , we can transform the problem into the maximum flow problem in the original sense by expanding . First, each  is replaced by  and , where  is connected by edges going into  and  is connected to edges coming out from , then assign capacity  to the edge connecting  and  (see Fig. 4.4.1). In this expanded network, the vertex capacity constraint is removed and therefore the problem can be treated as the original maximum flow problem.Given a directed graph  and two vertices  and , we are to find the maximum number of paths from  to . This problem has several variants:1. The paths must be edge-disjoint. This problem can be transformed to a maximum flow problem by constructing a network  from , with  and  being the source and the sink of  respectively, and assigning each edge a capacity of . In this network, the maximum flow is  iff there are  edge-disjoint paths.2. The paths must be independent, i.e., vertex-disjoint (except for  and ). We can construct a network  from  with vertex capacities, where the capacities of all vertices and all edges are . Then the value of the maximum flow is equal to the maximum number of independent paths from  to .3. In addition to the paths being edge-disjoint and/or vertex disjoint, the paths also have a length constraint: we count only paths whose length is exactly , or at most . Most variants of this problem are NP-complete, except for small values of .[22]A closure of a directed graph is a set of vertices C, such that no edges leave C. The closure problem is the task of finding the maximum-weight or minimum-weight closure in a vertex-weighted directed graph. It may be solved in polynomial time using a reduction to the maximum flow problem.In the baseball elimination problem there are n teams competing in a league. At a specific stage of the league season, wi is the number of wins and ri is the number of games left to play for team i and rij is the number of games left against team j. A team is eliminated if it has no chance to finish the season in the first place. The task of the baseball elimination problem is to determine which teams are eliminated at each point during the season. Schwartz[23] proposed a method which reduces this problem to maximum network flow. In this method a network is created to determine whether team k is eliminated.Let G = (V, E) be a network with  being the source and the sink respectively. One adds a game nodeij – which represents the number of plays between these two teams. We also add a team node for each team and connect each game node  with i &lt; j to V, and connects each of them from s by an edge with capacity rij – which represents the number of plays between these two teams. We also add a team node for each team and connect each game node  with two team nodes i and j to ensure one of them wins. One does not need to restrict the flow value on these edges. Finally, edges are made from team node i to the sink node t and the capacity of  is set to prevent team i from winning more than .Let S be the set of all teams participating in the league and let .In this method it is claimed team k is not eliminated if and only if a flow value of size r(S − {k}) exists in network G. In the mentioned article it is proved that this flow value is the maximum flow value from s to t.In the airline industry a major problem is the scheduling of the flight crews. The airline scheduling problem can be considered as an application of extended maximum network flow. The input of this problem is a set of flights F which contains the information about where and when each flight departs and arrives. In one version of airline scheduling the goal is to produce a feasible schedule with at most k crews.To solve this problem one uses a variation of the circulation problem called bounded circulation which is the generalization of network flow problems, with the added constraint of a lower bound on edge flows.Let G = (V, E) be a network with  as the source and the sink nodes. For the source and destination of every flight i, one adds two nodes to V, node si as the source and node di as the destination node of flight i. One also adds the following edges to E:An edge with capacity [0, 1] between s and each si.An edge with capacity [0, 1] between each di and t.An edge with capacity [1, 1] between each pair of si and di.An edge with capacity [0, 1] between each di and sj, if source sj is reachable with a reasonable amount of time and cost from the destination of flight i.An edge with capacity [0, ∞] between s and t.In the mentioned method, it is claimed and proved that finding a flow value of k in G between s and t is equal to finding a feasible schedule for flight set F with at most k crews.[24]Another version of airline scheduling is finding the minimum needed crews to perform all the flights. To find an answer to this problem, a bipartite graph  is created where each flight has a copy in set A and set B. If the same plane can perform flight j after flight i,  is connected to . A matching in  induces a schedule for F and obviously maximum bipartite matching in this graph produces an airline schedule with minimum number of crews.[24] As it is mentioned in the Application part of this article, the maximum cardinality bipartite matching is an application of maximum flow problem.There are some factories that produce goods and some villages where the goods have to be delivered. They are connected by a networks of roads with each road having a capacity  for maximum goods that can flow through it. The problem is to find if there is a circulation that satisfies the demand.This problem can be transformed into a maximum-flow problem.Add a source node  and add edges from it to every factory node  with capacity  where  is the production rate of factory .Add a sink node  and add edges from all villages  to  with capacity  where  is the demand rate of village .Let G = (V, E) be this new network. There exists a circulation that satisfies the demand if and only if : .If there exists a circulation, looking at the max-flow solution would give the answer as to how much goods have to be sent on a particular road for satisfying the demands.The problem can be extended by adding a lower bound on the flow on some edges.[25]In their book, Kleinberg and Tardos present an algorithm for segmenting an image.[27] They present an algorithm to find the background and the foreground in an image. More precisely, the algorithm takes a bitmap as an input modelled as follows: ai ≥ 0 is the likelihood that pixel i belongs to the foreground, bi ≥ 0 in the likelihood that pixel i belongs to the background, and pij is the penalty if two adjacent pixels i and j are placed one in the foreground and the other in the background. The goal is to find a partition (A, B) of the set of pixels that maximize the following quantity,Indeed, for pixels in A (considered as the foreground), we gain ai; for all pixels in B (considered as the background), we gain bi. On the border, between two adjacent pixels i and j, we loose pij. It is equivalent to minimize the quantitybecauseWe now construct the network whose nodes are the pixel, plus a source and a sink, see Figure on the right. We connect the source to pixel i by an edge of weight ai.  We connect the pixel i to the sink by an edge of weight bi. We connect pixel i to pixel j with weight pij. Now, it remains to compute a minimum cut in that network (or equivalently a maximum flow). The last figure shows a minimum cut.1. In the minimum-cost flow problem, each edge (u,v) also has a cost-coefficient auv in addition to its capacity. If the flow through the edge is fuv, then the total cost is auvfuv.  It is required to find a flow of a given size d, with the smallest cost. In most variants, the cost-coefficients may be either positive or negative. There are various polynomial-time algorithms for this problem.2. The maximum-flow problem can be augmented by disjunctive constraints: a negative disjunctive constraint says that a certain pair of edges cannot simultaneously have a nonzero flow; a positive disjunctive constraints says that, in a certain pair of edges, at least one must have a nonzero flow. With negative constraints, the problem becomes strongly NP-hard even for simple networks. With positive constraints, the problem is polynomial if fractional flows are allowed, but may be strongly NP-hard when the flows must be integral.[28]Joseph Cheriyan and Kurt Mehlhorn (1999). "An analysis of the highest-level selection rule in the preflow-push max-flow algorithm". Information Processing Letters. 69 (5): 239–242. CiteSeerX . doi:10.1016/S0020-0190(99)00019-8.Daniel D. Sleator and Robert E. Tarjan (1983). "A data structure for dynamic trees" . Journal of Computer and System Sciences. 26 (3): 362–391. doi:10.1016/0022-0000(83)90006-5. ISSN 0022-0000.Eugene Lawler (2001). "4. Network Flows". Combinatorial Optimization: Networks and Matroids. Dover. pp. 109–177. ISBN 978-0-486-41453-9.