<!DOCTYPE html>
<html>
<head>
<title>Cook's_theorem</title>
</head>
<body>
<div class="mw-parser-output">
<p>In computational complexity theory, the <b>Cook–Levin theorem</b>, also known as <b>Cook's theorem</b>, states that the Boolean satisfiability problem is NP-complete.  That is, it is in NP, and any problem in NP can be reduced in polynomial time by a deterministic Turing machine to the Boolean satisfiability problem.
</p><p>The theorem is named after Stephen Cook and Leonid Levin.
</p><p>An important consequence of this theorem is that if there exists a deterministic polynomial-time algorithm for solving Boolean satisfiability, then every NP problem can be solved by a deterministic polynomial-time algorithm.  The question of whether such an algorithm for Boolean satisfiability exists is thus equivalent to the P versus NP problem, which is widely considered the most important unsolved problem in theoretical computer science.
</p>

<h2><span class="mw-headline" id="Contributions">Contributions</span><span class="mw-editsection"></span></h2>
<p>The concept of NP-completeness was developed in the late 1960s and early 1970s in parallel by researchers in North America and the USSR.
In 1971, Stephen Cook published his paper "The complexity of theorem proving procedures"<sup class="reference" id="cite_ref-1">[1]</sup> in conference proceedings of the newly founded ACM Symposium on Theory of Computing. Richard Karp's subsequent paper, "Reducibility among
combinatorial problems",<sup class="reference" id="cite_ref-Karp_2-0">[2]</sup> generated renewed interest in Cook's paper by providing a list of 21 NP-complete problems. Cook and Karp each received a Turing Award for this work.
</p><p>The theoretical interest in NP-completeness was also enhanced by the work of Theodore P. Baker, John Gill, and Robert Solovay who showed, in 1975, that solving NP-problems in oracle machine models requires exponential time. That is, there exists an oracle <i>A</i> such that, for all subexponential deterministic-time complexity classes T, the relativized complexity class NP<sup><i>A</i></sup> is not a subset of T<sup><i>A</i></sup>. In particular, for this oracle, P<sup><i>A</i></sup> ≠ NP<sup><i>A</i></sup>.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>In the USSR, a result equivalent to Baker, Gill, and Solovay's was published in 1969 by M. Dekhtiar.<sup class="reference" id="cite_ref-4">[4]</sup> Later Leonid Levin's paper, "Universal search problems",<sup class="reference" id="cite_ref-5">[5]</sup> was published in 1973, although it was mentioned in talks and submitted for publication a few years earlier.
</p><p>Levin's approach was slightly different from Cook's and Karp's in that he considered search problems, which require finding solutions rather than simply determining existence. He provided six such NP-complete search problems, or <i>universal problems</i>.
Additionally he found for each of these problems an algorithm that solves it in optimal time (in particular, these algorithms run in polynomial time if and only if P = NP).
</p>
<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"></span></h2>
<p>A decision problem is <i>in NP</i> if it can be solved by a non-deterministic algorithm in polynomial time.
</p><p>An <i>instance of the Boolean satisfiability problem</i> is a Boolean expression that combines Boolean variables using Boolean operators.
</p><p>An expression is <i>satisfiable</i> if there is some assignment of truth values to the variables that makes the entire expression true.
</p>
<h2><span class="mw-headline" id="Idea">Idea</span><span class="mw-editsection"></span></h2>
<p>Given any decision problem in NP, construct a non-deterministic machine that solves it in polynomial time. Then for each input to that machine, build a Boolean expression that computes whether when that specific input is passed to the machine, the machine runs correctly, and the machine halts and answers "yes". Then the expression can be satisfied if and only if there is a way for the machine to run correctly and answer "yes", so the satisfiability of the constructed expression is equivalent to asking whether or not the machine will answer "yes".
</p>
<h2><span class="mw-headline" id="Proof">Proof</span><span class="mw-editsection"></span></h2>

<p><i>This proof is based on the one given by Garey and Johnson.</i><sup class="reference" id="cite_ref-Garey_6-0">[6]</sup>
</p><p>There are two parts to proving that the Boolean satisfiability problem (SAT) is NP-complete. One is to show that SAT is an NP problem. The other is to show that every NP problem can be reduced to an instance of a SAT problem by a polynomial-time many-one reduction.
</p><p>SAT is in NP because any assignment of Boolean values to Boolean variables that is claimed to satisfy the given expression can be <i>verified</i> in polynomial time by a deterministic Turing machine. (The statements <i><b>verifiable</b> in polynomial time by a <b>deterministic</b> Turing machine</i> and <i><b>solvable</b> in polynomial time by a <b>non-deterministic</b> Turing machine</i> are equivalent, and the proof can be found in many textbooks, for example Sipser's <i>Introduction to the Theory of Computation</i>, section 7.3., as well as in the Wikipedia article on NP).
</p><p>Now suppose that a given problem in NP can be solved by the nondeterministic Turing machine <span class="texhtml"><i>M</i> = (<i>Q</i>, Σ, <i>s</i>, <i>F</i>, δ)</span>, where <i>Q</i> is the set of states, Σ is the alphabet of tape symbols, <span class="texhtml"><i>s</i> ∈ <i>Q</i></span> is the initial state, <span class="texhtml"><i>F</i> ⊆ <i>Q</i></span> is the set of accepting states, and <span class="texhtml">δ ⊆ ((<i>Q</i> \ <i>F</i>) × Σ) × (<i>Q</i> × Σ × {−1, +1})</span> is the transition relation. Suppose further that <i>M</i> accepts or rejects an instance of the problem in time <i>p</i>(<i>n</i>) where <i>n</i> is the size of the instance and <i>p</i> is a polynomial function.
</p><p>For each input, <span class="texhtml mvar" style="font-style:italic;">I</span>, we specify a Boolean expression that is satisfiable if and only if the machine <i>M</i> accepts <span class="texhtml mvar" style="font-style:italic;">I</span>.
</p><p>The Boolean expression uses the variables set out in the following table. Here, <span class="texhtml"><i>q</i> ∈ <i>Q</i>, −<i>p</i>(<i>n</i>) ≤ <i>i</i> ≤ <i>p</i>(<i>n</i>), <i>j</i> ∈ Σ</span>, and <span class="texhtml">0 ≤ <i>k</i> ≤ <i>p</i>(<i>n</i>)</span>.
</p>
<table class="wikitable">
<tbody><tr>
<th>Variables
</th>
<th>Intended interpretation
</th>
<th>How many?
</th></tr>
<tr>
<td><i>T<sub>i,j,k</sub></i>
</td>
<td>True if tape cell <i>i</i> contains symbol <i>j</i> at step <i>k</i> of the computation.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td><i>H<sub>i,k</sub></i>
</td>
<td>True if the <i>M</i><span class="nowrap" style="padding-left:0.1em;">'</span>s read/write head is at tape cell <i>i</i> at step <i>k</i> of the computation.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td><i>Q<sub>q,k</sub></i>
</td>
<td>True if <i>M</i> is in state <i>q</i> at step <i>k</i> of the computation.
</td>
<td>O(<i>p</i>(<i>n</i>))
</td></tr></tbody></table>
<p>Define the Boolean expression <i>B</i> to be the conjunction of the sub-expressions in the following table, for all <span class="texhtml">−<i>p</i>(<i>n</i>) ≤ <i>i</i> ≤ <i>p</i>(<i>n</i>)</span> and <span class="texhtml">0 ≤ <i>k</i> ≤ <i>p</i>(<i>n</i>)</span>:
</p>
<table class="wikitable">
<tbody><tr>
<th>Expression
</th>
<th>Conditions
</th>
<th>Interpretation
</th>
<th>How many?
</th></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T_{i,j,0}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo>,</mo>
<mn>0</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T_{i,j,0}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T_{i,j,0}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29181927730e6a6bc1eecb835178e49a8448d238" style="vertical-align: -1.005ex; width:4.571ex; height:2.843ex;"/></span>
</td>
<td>Tape cell <i>i</i> initially contains symbol <i>j</i>
</td>
<td>Initial contents of the tape.  For <i>i</i> &gt; <i>n</i>-1 and <i>i</i> &lt; 0, outside of the actual input <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle I}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>I</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle I}</annotation>
</semantics>
</math></span><img alt="I" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/535ea7fc4134a31cbe2251d9d3511374bc41be9f" style="vertical-align: -0.338ex; width:1.172ex; height:2.176ex;"/></span>, the initial symbol is the special default/blank symbol.
</td>
<td>O(<i>p</i>(<i>n</i>))
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{s,0}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>s</mi>
<mo>,</mo>
<mn>0</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{s,0}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{s,0}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a61e8a2b009588140dc0fc85545369d577e8719b" style="vertical-align: -1.005ex; width:4.121ex; height:2.843ex;"/></span>
</td>
<td>
</td>
<td>Initial state of <i>M</i>.
</td>
<td>1
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle H_{0,0}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>H</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
<mo>,</mo>
<mn>0</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle H_{0,0}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle H_{0,0}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3655904fa5f242794e700f4f0cbfea5f049f2d65" style="vertical-align: -1.005ex; width:4.265ex; height:2.843ex;"/></span>
</td>
<td>
</td>
<td>Initial position of read/write head.
</td>
<td>1
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \neg T_{i,j,k}\lor \neg T_{i,j',k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">¬<!-- ¬ --></mi>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>∨<!-- ∨ --></mo>
<mi mathvariant="normal">¬<!-- ¬ --></mi>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<msup>
<mi>j</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \neg T_{i,j,k}\lor \neg T_{i,j',k}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \neg T_{i,j,k}\lor \neg T_{i,j',k}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4f70c47d831e3035dc655e18bb9dd52ec0945e82" style="vertical-align: -1.171ex; width:15.427ex; height:3.009ex;"/></span>
</td>
<td><i>j</i> ≠ <i>j′</i>
</td>
<td>At most one symbol per tape cell.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \bigvee _{j\in \Sigma }T_{i,j,k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo>⋁<!-- ⋁ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
<mo>∈<!-- ∈ --></mo>
<mi mathvariant="normal">Σ<!-- Σ --></mi>
</mrow>
</munder>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \bigvee _{j\in \Sigma }T_{i,j,k}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \bigvee _{j\in \Sigma }T_{i,j,k}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/20fc7ab5cf64313d8256f5b20c1302cfb451d436" style="vertical-align: -3.338ex; margin-left: -0.019ex; width:7.972ex; height:5.843ex;"/></span>
</td>
<td>
</td>
<td>At least one symbol per tape cell.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T_{i,j,k}\land T_{i,j',k+1}\rightarrow H_{i,k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<msup>
<mi>j</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo stretchy="false">→<!-- → --></mo>
<msub>
<mi>H</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T_{i,j,k}\land T_{i,j',k+1}\rightarrow H_{i,k}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T_{i,j,k}\land T_{i,j',k+1}\rightarrow H_{i,k}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a5955b1d9dc20e5d50807ece03da97498eed907c" style="vertical-align: -1.171ex; width:22.085ex; height:3.009ex;"/></span>
</td>
<td><i>j</i> ≠ <i>j′</i>
</td>
<td>Tape remains unchanged unless written.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td>¬<i>Q<sub>q,k</sub></i> ∨ ¬<i>Q<sub>q′,k</sub></i>
</td>
<td><i>q</i> ≠ <i>q′</i>
</td>
<td>Only one state at a time.
</td>
<td>O(<i>p</i>(<i>n</i>))
</td></tr>
<tr>
<td>¬<i>H<sub>i,k</sub></i> ∨ ¬<i>H<sub>i′,k</sub></i>
</td>
<td><i>i</i> ≠ <i>i′</i>
</td>
<td>Only one head position at a time.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>3</sup>)
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\begin{array}{l}(H_{i,k}\land Q_{q,k}\land T_{i,\sigma ,k})\to \\\bigvee _{((q,\sigma ),(q',\sigma ',d))\in \delta }(H_{i+d,\ k+1}\land Q_{q',\ k+1}\land T_{i,\ \sigma ',\ k+1})\end{array}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mtable columnalign="left" columnspacing="1em" rowspacing="4pt">
<mtr>
<mtd>
<mo stretchy="false">(</mo>
<msub>
<mi>H</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>q</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>σ<!-- σ --></mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo stretchy="false">→<!-- → --></mo>
</mtd>
</mtr>
<mtr>
<mtd>
<munder>
<mo>⋁<!-- ⋁ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mi>σ<!-- σ --></mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mo stretchy="false">(</mo>
<msup>
<mi>q</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>σ<!-- σ --></mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo>∈<!-- ∈ --></mo>
<mi>δ<!-- δ --></mi>
</mrow>
</munder>
<mo stretchy="false">(</mo>
<msub>
<mi>H</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>+</mo>
<mi>d</mi>
<mo>,</mo>
<mtext> </mtext>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi>q</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mtext> </mtext>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mtext> </mtext>
<msup>
<mi>σ<!-- σ --></mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mtext> </mtext>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mtd>
</mtr>
</mtable>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\begin{array}{l}(H_{i,k}\land Q_{q,k}\land T_{i,\sigma ,k})\to \\\bigvee _{((q,\sigma ),(q',\sigma ',d))\in \delta }(H_{i+d,\ k+1}\land Q_{q',\ k+1}\land T_{i,\ \sigma ',\ k+1})\end{array}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\begin{array}{l}(H_{i,k}\land Q_{q,k}\land T_{i,\sigma ,k})\to \\\bigvee _{((q,\sigma ),(q',\sigma ',d))\in \delta }(H_{i+d,\ k+1}\land Q_{q',\ k+1}\land T_{i,\ \sigma ',\ k+1})\end{array}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3b6a3bd9679d38c63b9851bb0d1a545295f2b9bb" style="vertical-align: -2.838ex; width:47.61ex; height:6.843ex;"/></span>
</td>
<td><i>k</i>&lt;<i>p</i>(<i>n</i>)
</td>
<td>Possible transitions at computation step <i>k</i> when head is at position <i>i</i>.
</td>
<td>O(<i>p</i>(<i>n</i>)<sup>2</sup>)
</td></tr>
<tr>
<td><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \bigvee _{0\leq k\leq p(n)}\bigvee _{f\in F}Q_{f,k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo>⋁<!-- ⋁ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
<mo>≤<!-- ≤ --></mo>
<mi>k</mi>
<mo>≤<!-- ≤ --></mo>
<mi>p</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</munder>
<munder>
<mo>⋁<!-- ⋁ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>f</mi>
<mo>∈<!-- ∈ --></mo>
<mi>F</mi>
</mrow>
</munder>
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>f</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \bigvee _{0\leq k\leq p(n)}\bigvee _{f\in F}Q_{f,k}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \bigvee _{0\leq k\leq p(n)}\bigvee _{f\in F}Q_{f,k}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35345590c7e7f31fb7f9690b055f6ed1e831139f" style="vertical-align: -3.505ex; width:15.622ex; height:6.009ex;"/></span>
</td>
<td>
</td>
<td>Must finish in an accepting state, not later than in step <i>p</i>(<i>n</i>).
</td>
<td>1
</td></tr></tbody></table>
<p>If there is an accepting computation for <i>M</i> on input <i>I</i>, then <i>B</i> is satisfiable by assigning <i>T</i><sub><i>i,j,k</i></sub>, <i>H</i><sub><i>i,k</i></sub> and <i>Q</i><sub><i>i,k</i></sub> their intended interpretations. On the other hand, if <i>B</i> is satisfiable, then there is an accepting computation for <i>M</i> on input <i>I</i> that follows the steps indicated by the assignments to the variables.
</p><p>There are <i>O</i>(<i>p</i>(<i>n</i>)<sup>2</sup>) Boolean variables, each encodeable in space <span class="texhtml"><i>O</i>(log <i>p</i>(<i>n</i>))</span>. The number of clauses is <i>O</i>(<i>p</i>(<i>n</i>)<sup>3</sup>) so the size of <i>B</i> is <i>O</i>(log(<i>p</i>(<i>n</i>))<i>p</i>(<i>n</i>)<sup>3</sup>). Thus the transformation is certainly a polynomial-time many-one reduction, as required.
</p>
<h2><span class="mw-headline" id="Complexity">Complexity</span><span class="mw-editsection"></span></h2>
<p>While the above method encodes a non-deterministic Turing machine in complexity <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log(p(n))p(n)^{3})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mi>p</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<msup>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log(p(n))p(n)^{3})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(\log(p(n))p(n)^{3})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fc8fa42ac4d414a9f72fc71fd7ae0226efcf0756" style="vertical-align: -0.838ex; width:18.165ex; height:3.176ex;"/></span>, the literature describes more sophisticated approaches in complexity <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(p(n)\log(p(n)))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(p(n)\log(p(n)))}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(p(n)\log(p(n)))}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0d85954d751285ff6ea58aace75d5387f6ead4b6" style="vertical-align: -0.838ex; width:17.498ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-7">[7]</sup><sup class="reference" id="cite_ref-8">[8]</sup><sup class="reference" id="cite_ref-9">[9]</sup><sup class="reference" id="cite_ref-10">[10]</sup><sup class="reference" id="cite_ref-11">[11]</sup> The quasilinear result first appeared seven years after Cook's original publication.
</p><p>Generalized versions of boolean satisfiability have encodings with stronger bounds still: quantified boolean formulas (QBF's) encode non-deterministic Turing machines in polynomial complexity to the machine's space bound (as opposed to time bound), and dependency quantified boolean formulas (DQBF's) encode non-deterministic Turing machines in an ideal logarithmic complexity to the machine's space bound.<sup class="reference" id="cite_ref-12">[12]</sup><sup class="reference" id="cite_ref-13">[13]</sup>
</p>
<h2><span class="mw-headline" id="Consequences">Consequences</span><span class="mw-editsection"></span></h2>
<p>The proof shows that any problem in NP can be reduced in polynomial time (in fact, logarithmic space suffices) to an instance of the Boolean satisfiability problem. This means that if the Boolean satisfiability problem could be solved in polynomial time by a deterministic Turing machine, then all problems in NP could be solved in polynomial time, and so the complexity class NP would be equal to the complexity class P.
</p><p>The significance of NP-completeness was made clear by the publication in 1972 of Richard Karp's landmark paper, "Reducibility among combinatorial problems", in which he showed that 21 diverse combinatorial and graph theoretical problems, each infamous for its intractability, are NP-complete.<sup class="reference" id="cite_ref-Karp_2-1">[2]</sup>
</p><p>Karp showed each of his problems to be NP-complete by reducing another problem (already shown to be NP-complete) to that problem.  For example, he showed the problem 3SAT (the Boolean satisfiability problem for expressions in conjunctive normal form with exactly three variables or negations of variables per clause) to be NP-complete by showing how to reduce (in polynomial time) any instance of SAT to an equivalent instance of 3SAT.  (First you modify the proof of the Cook–Levin theorem, so that the resulting formula is in conjunctive normal form, then you introduce new variables to split clauses with more than 3 atoms.  For example, the clause (A ∨ B ∨ C ∨ D) can be replaced by the conjunction of clauses (A ∨ B ∨ Z) ∧ (¬Z ∨ C ∨ D), where Z is a new variable that will not be used anywhere else in the expression.  Clauses with fewer than three atoms can be padded; for example, A can be replaced by (A ∨ A ∨ A), and  (A ∨ B) can be replaced by (A ∨ B ∨ B) ).
</p><p>Garey and Johnson presented more than 300 NP-complete problems in their book <i>Computers and Intractability: A Guide to the Theory of NP-Completeness</i>,<sup class="reference" id="cite_ref-Garey_6-1">[6]</sup> and new problems are still being discovered to be within that complexity class.
</p><p>Although many practical instances of SAT can be solved by heuristic methods, the question of whether there is a deterministic polynomial-time algorithm for SAT (and consequently all other NP-complete problems) is still a famous unsolved problem, despite decades of intense effort by complexity theorists, mathematical logicians, and others.  For more details, see the article P versus NP problem.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2385
Cached time: 20221223233311
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.206 seconds
Real time usage: 0.309 seconds
Preprocessor visited node count: 1311/1000000
Post‐expand include size: 26942/2097152 bytes
Template argument size: 1773/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 39793/5000000 bytes
Lua time usage: 0.103/10.000 seconds
Lua memory usage: 5616238/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  203.828      1 -total
 64.24%  130.947      1 Template:Reflist
 34.79%   70.921      3 Template:Cite_book
 25.06%   51.079      1 Template:Short_description
 16.89%   34.425      8 Template:Cite_journal
 14.18%   28.893      2 Template:Pagetype
  6.36%   12.960     12 Template:Main_other
  5.31%   10.830      9 Template:Math
  4.80%    9.785      1 Template:SDcat
  2.06%    4.194      1 Template:Cite_conference
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:663047-0!canonical and timestamp 20221223233311 and revision id 1122730911.
 -->
</div></body>
</html>