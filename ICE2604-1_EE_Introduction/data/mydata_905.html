<!DOCTYPE html>
<html>
<head>
<title>Shift-Or</title>
</head>
<body>
<div class="mw-parser-output"><p>The <b>bitap algorithm</b> (also known as the <b>shift-or</b>, <b>shift-and</b> or <b>Baeza-Yates–Gonnet</b> algorithm) is an approximate string matching algorithm. The algorithm tells whether a given text contains a substring which is "approximately equal" to a given pattern, where approximate equality is defined in terms of Levenshtein distance –  if the substring and pattern are within a given distance <i>k</i> of each other, then the algorithm considers them equal. The algorithm  begins by precomputing a set of bitmasks containing one bit for each element of the pattern. Then it is able to do most of the work with bitwise operations, which are extremely fast.
</p><p>The bitap algorithm is perhaps best known as one of the underlying algorithms of the Unix utility agrep, written by Udi Manber, Sun Wu, and Burra Gopal. Manber and Wu's original paper gives extensions of the algorithm to deal with fuzzy matching of general regular expressions.
</p><p>Due to the data structures required by the algorithm, it performs best on patterns less than a constant length (typically the word length of the machine in question), and also prefers inputs over a small alphabet. Once it has been implemented for a given alphabet and word length <i>m</i>, however, its running time is completely predictable – it runs in O(<i>mn</i>) operations, no matter the structure of the text or the pattern.
</p><p>The bitap algorithm for exact string searching was invented by Bálint Dömölki in 1964<sup class="reference plainlinks nourlexpansion" id="ref_Domolki64">[1]</sup><sup class="reference plainlinks nourlexpansion" id="ref_Domolki68">[2]</sup> and extended by R. K. Shyamasundar in 1977<sup class="reference plainlinks nourlexpansion" id="ref_shyamasundar77">[3]</sup>, before being reinvented by Ricardo Baeza-Yates and Gaston Gonnet<sup class="reference plainlinks nourlexpansion" id="ref_BYG92">[4]</sup> in 1989 (one chapter of first author's PhD thesis<sup class="reference plainlinks nourlexpansion" id="ref_BY89">[5]</sup>) which also extended it to handle classes of characters, wildcards, and mismatches. In 1991, it was extended by Manber and Wu <sup class="reference plainlinks nourlexpansion" id="ref_Manber91">[6]</sup><sup class="reference plainlinks nourlexpansion" id="ref_Manber92">[7]</sup> to handle also insertions and deletions (full fuzzy string searching). This algorithm was later improved by Baeza-Yates and Navarro in 1996.<sup class="reference plainlinks nourlexpansion" id="ref_BN96">[8]</sup>
</p>

<h2><span class="mw-headline" id="Exact_searching">Exact <span dir="ltr" lang="id">searching</span></span><span class="mw-editsection"></span></h2>
<p>The bitap algorithm for exact string searching, in full generality, looks like this in pseudocode:
</p>
<pre><b>algorithm</b> bitap_search <b>is</b>
    <b>input:</b> <i>text</i> as a string.
           <i>pattern</i> as a string.
    <b>output:</b> string
    <i>m</i> := length(<i>pattern</i>)

    <b>if</b> <i>m</i> = 0 <b>then</b>
        <b>return</b> <i>text</i>

    /* Initialize the bit array R. */
    <i>R</i> := <b>new</b> array[<i>m</i>+1] <b>of</b> bit, initially all 0
    <i>R</i>[0] := 1

    <b>for</b> <i>i</i> := 0; <i>i</i> &lt; length(<i>text</i>); <i>i</i> += 1 <b>do</b>
        /* Update the bit array. */
        <b>for</b> <i>k</i> := <i>m</i>; <i>k</i> ≥ 1; <i>k</i> -= 1 <b>do</b>
            <i>R</i>[k] := <i>R</i>[<i>k</i> - 1] &amp; (<i>text</i>[<i>i</i>] = <i>pattern</i>[<i>k</i> - 1])

        <b>if</b> <i>R</i>[<i>m</i>] <b>then</b>
            <b>return</b> (<i>text</i> + <i>i</i> - <i>m</i>) + 1

    <b>return</b> null
</pre>
<p>Bitap distinguishes itself from other well-known string searching algorithms in its natural mapping onto simple bitwise operations, as in the following modification of the above program. Notice that in this implementation, counterintuitively, each bit with value zero indicates a match, and each bit with value 1 indicates a non-match. The same algorithm can be written with the intuitive semantics for 0 and 1, but in that case we must introduce another instruction into the inner loop to set <code>R |= 1</code>. In this implementation, we take advantage of the fact that left-shifting a value shifts in zeros on the right, which is precisely the behavior we need.
</p><p>Notice also that we require <code>CHAR_MAX</code> additional bitmasks in order to convert the <code>(text[i] == pattern[k-1])</code> condition in the general implementation into bitwise operations. Therefore, the bitap algorithm performs better when applied to inputs over smaller alphabets.
</p>

<h2><span class="mw-headline" id="Fuzzy_searching">Fuzzy searching</span><span class="mw-editsection"></span></h2>
<p>To perform fuzzy string searching using the bitap algorithm, it is necessary to extend the bit array <i>R</i> into a second dimension. Instead of having a single array <i>R</i> that changes over the length of the text, we now have <i>k</i> distinct arrays <i>R</i><sub>1..<i>k</i></sub>. Array <i>R<sub>i</sub></i> holds a representation of the prefixes of <i>pattern</i> that match any suffix of the current string with <i>i</i> or fewer errors. In this context, an "error" may be an insertion, deletion, or substitution; see Levenshtein distance for more information on these operations.
</p><p>The implementation below performs fuzzy matching (returning the first match with up to <i>k</i> errors) using the fuzzy bitap algorithm. However, it only pays attention to substitutions, not to insertions or deletions – in other words, a Hamming distance of <i>k</i>. As before, the semantics of 0 and 1 are reversed from their conventional meanings.
</p>

<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>agrep</li>
<li>TRE (computing)</li></ul>
<h2><span class="mw-headline" id="External_links_and_references">External links and references</span><span class="mw-editsection"></span></h2>
<ol><li><style data-mw-deduplicate="TemplateStyles:r1041539562">.mw-parser-output .citation{word-wrap:break-word}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}</style><span class="citation wikicite" id="endnote_Domolki64"><b>^</b></span>  Bálint Dömölki, An algorithm for syntactical analysis, Computational Linguistics 3, Hungarian Academy of Science pp. 29–46, 1964.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_Domolki68"><b>^</b></span>  Bálint Dömölki, A universal compiler system based on production rules, BIT Numerical Mathematics, 8(4), pp 262–275, 1968. <style data-mw-deduplicate="TemplateStyles:r1067248974">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style>doi:10.1007/BF01933436</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_shyamasundar77"><b>^</b></span>  R. K. Shyamasundar, Precedence parsing using Dömölki's algorithm, International Journal of Computer Mathematics, 6(2)pp 105–114, 1977.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_BY89"><b>^</b></span>  Ricardo Baeza-Yates. "Efficient Text Searching." PhD Thesis, University of Waterloo, Canada, May 1989.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_Manber91"><b>^</b></span>  Udi Manber, Sun Wu. "Fast text searching with errors." Technical Report TR-91-11. Department of Computer Science, University of Arizona, Tucson, June 1991. (gzipped PostScript)</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_BYG92"><b>^</b></span>  Ricardo Baeza-Yates, Gastón H. Gonnet. "A New Approach to Text Searching." <i>Communications of the ACM</i>, 35(10): pp. 74–82, October 1992.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_Manber92"><b>^</b></span>  Udi Manber, Sun Wu. "Fast text search allowing errors." <i>Communications of the ACM</i>, 35(10): pp. 83–91, October 1992, <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>doi:10.1145/135239.135244.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_BN96"><b>^</b></span>  R. Baeza-Yates and G. Navarro. A faster algorithm for approximate string matching. In Dan Hirchsberg and Gene Myers, editors, <i>Combinatorial Pattern Matching</i> (CPM'96), LNCS 1075, pages 1–23, Irvine, CA, June 1996.</li>
<li><link href="mw-data:TemplateStyles:r1041539562" rel="mw-deduplicated-inline-style"/><span class="citation wikicite" id="endnote_M99"><b>^</b></span>  G. Myers. "A fast bit-vector algorithm for approximate string matching based on dynamic programming." <i>Journal of the ACM</i> 46 (3), May 1999, 395–415.</li>
<li>libbitap, a free implementation that shows how the algorithm can easily be extended for most regular expressions. Unlike the code above, it places no limit on the pattern length.</li>
<li>Ricardo Baeza-Yates, Berthier Ribeiro-Neto. <i>Modern Information Retrieval</i>. 1999. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-39829-X.</li>
<li>bitap.py - Python implementation of Bitap algorithm with Wu-Manber modifications.</li></ol>

<!-- 
NewPP limit report
Parsed by mw2313
Cached time: 20221220211514
Cache expiry: 1814400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.129 seconds
Real time usage: 0.555 seconds
Preprocessor visited node count: 643/1000000
Post‐expand include size: 16927/2097152 bytes
Template argument size: 461/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 2/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 31416/5000000 bytes
Lua time usage: 0.036/10.000 seconds
Lua memory usage: 1348274/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  511.116      1 -total
  8.65%   44.226      2 Template:Doi
  7.96%   40.671      1 Template:Strings
  7.58%   38.735      1 Template:Navbox
  6.61%   33.805      3 Template:Catalog_lookup_link
  3.32%   16.967      1 Template:ISBN
  1.62%    8.255      9 Template:Note
  0.77%    3.950      3 Template:Yesno-no
  0.67%    3.422      8 Template:Ref
  0.50%    2.559      4 Template:Yesno
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2242223-0!canonical and timestamp 20221220211513 and revision id 1063296095.
 -->
</div></body>
</html>