<!DOCTYPE html>
<html>
<head>
<title>minimum_spanning_tree</title>
</head>
<body>
<div class="mw-parser-output">
<p class="mw-empty-elt">
</p>

<p>A <b>minimum spanning tree</b> (<b>MST</b>) or <b>minimum weight spanning tree</b> is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.<sup class="reference" id="cite_ref-Numpy_and_Scipy_Documentation_—_Numpy_and_Scipy_documentation_1-0">[1]</sup> That is, it is a spanning tree whose sum of edge weights is as small as possible.<sup class="reference" id="cite_ref-NetworkX_2.6.2_documentation_2-0">[2]</sup> More generally, any edge-weighted undirected graph (not necessarily connected) has a <b>minimum spanning forest</b>, which is a union of the minimum spanning trees for its connected components.
</p><p>There are many use cases for minimum spanning trees. One example is a telecommunications company trying to lay cable in a new neighborhood. If it is constrained to bury the cable only along certain paths (e.g. roads), then there would be a graph containing the points (e.g. houses) connected by those paths. Some of the paths might be more expensive, because they are longer, or require the cable to be buried deeper; these paths would be represented by edges with larger weights. Currency is an acceptable unit for edge weight – there is no requirement for edge lengths to obey normal rules of geometry such as the triangle inequality. A <i>spanning tree</i> for that graph would be a subset of those paths that has no cycles but still connects every house; there might be several spanning trees possible. A <i>minimum spanning tree</i> would be one with the lowest total cost, representing the least expensive path for laying the cable.
</p>

<h2><span class="mw-headline" id="Properties">Properties</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Possible_multiplicity">Possible multiplicity</span><span class="mw-editsection"></span></h3>
<p>If there are <span class="texhtml mvar" style="font-style:italic;">n</span> vertices in the graph, then each spanning tree has <span class="texhtml"><i>n</i> − 1</span> edges.
</p>

<p>There may be several minimum spanning trees of the same weight; in particular, if all the edge weights of a given graph are the same, then every spanning tree of that graph is minimum.
</p>
<h3><span class="mw-headline" id="Uniqueness">Uniqueness</span><span class="mw-editsection"></span></h3>
<p><i>If each edge has a distinct weight then there will be only one, unique minimum spanning tree</i>. This is true in many realistic situations, such as the telecommunications company example above, where it's unlikely any two paths have <i>exactly</i> the same cost. This generalizes to spanning forests as well.
</p><p>Proof:
</p>
<ol><li>Assume the contrary, that there are two different MSTs <span class="texhtml mvar" style="font-style:italic;">A</span> and <span class="texhtml mvar" style="font-style:italic;">B</span>.</li>
<li>Since <span class="texhtml mvar" style="font-style:italic;">A</span> and <span class="texhtml mvar" style="font-style:italic;">B</span> differ despite containing the same nodes, there is at least one edge that belongs to one but not the other.  Among such edges, let <span class="texhtml"><i>e</i><sub>1</sub></span> be the one with least weight; this choice is unique because the edge weights are all distinct.  Without loss of generality, assume <span class="texhtml"><i>e</i><sub>1</sub></span> is in <span class="texhtml mvar" style="font-style:italic;">A</span>.</li>
<li>As <span class="texhtml mvar" style="font-style:italic;">B</span> is an MST, <span class="texhtml">{<i>e</i><sub>1</sub>} ∪ <i>B</i></span> must contain a cycle <span class="texhtml mvar" style="font-style:italic;">C</span> with <span class="texhtml"><i>e</i><sub>1</sub></span>.</li>
<li>As a tree, <span class="texhtml mvar" style="font-style:italic;">A</span> contains no cycles, therefore <span class="texhtml mvar" style="font-style:italic;">C</span> must have an edge <span class="texhtml"><i>e</i><sub>2</sub></span> that is not in <span class="texhtml mvar" style="font-style:italic;">A</span>.</li>
<li>Since <span class="texhtml"><i>e</i><sub>1</sub></span> was chosen as the unique lowest-weight edge among those belonging to exactly one of <span class="texhtml mvar" style="font-style:italic;">A</span> and <span class="texhtml mvar" style="font-style:italic;">B</span>, the weight of <span class="texhtml"><i>e</i><sub>2</sub></span> must be greater than the weight of <span class="texhtml"><i>e</i><sub>1</sub></span>.</li>
<li>As <span class="texhtml"><i>e</i><sub>1</sub></span> and <span class="texhtml"><i>e</i><sub>2</sub></span> are part of the cycle <span class="texhtml mvar" style="font-style:italic;">C</span>, replacing <span class="texhtml"><i>e</i><sub>2</sub></span> with <span class="texhtml"><i>e</i><sub>1</sub></span> in <span class="texhtml mvar" style="font-style:italic;">B</span> therefore yields a spanning tree with a smaller weight.</li>
<li>This contradicts the assumption that <span class="texhtml mvar" style="font-style:italic;">B</span> is an MST.</li></ol>
<p>More generally, if the edge weights are not all distinct then only the (multi-)set of weights in minimum spanning trees is certain to be unique; it is the same for all minimum spanning trees.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h3><span class="mw-headline" id="Minimum-cost_subgraph">Minimum-cost subgraph</span><span class="mw-editsection"></span></h3>
<p>If the weights are <i>positive</i>, then a minimum spanning tree is in fact a minimum-cost subgraph connecting all vertices, since subgraphs containing cycles necessarily have more total weight.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (July 2020)">citation needed</span></i>]</sup>
</p>
<h3><span class="mw-headline" id="Cycle_property">Cycle property</span><span class="mw-editsection"></span></h3>
<p><i>For any cycle <span class="texhtml mvar" style="font-style:italic;">C</span> in the graph, if the weight of an edge <span class="texhtml mvar" style="font-style:italic;">e</span> of <span class="texhtml mvar" style="font-style:italic;">C</span> is larger than any of the individual weights of all other edges of <span class="texhtml mvar" style="font-style:italic;">C</span>, then this edge cannot belong to an MST.</i>
</p><p>Proof: Assume the contrary, i.e. that <span class="texhtml mvar" style="font-style:italic;">e</span> belongs to an MST <span class="texhtml"><i>T</i><sub>1</sub></span>. Then deleting <span class="texhtml mvar" style="font-style:italic;">e</span> will break <span class="texhtml"><i>T</i><sub>1</sub></span> into two subtrees with the two ends of <span class="texhtml mvar" style="font-style:italic;">e</span> in different subtrees. The remainder of <span class="texhtml mvar" style="font-style:italic;">C</span> reconnects the subtrees, hence there is an edge <span class="texhtml mvar" style="font-style:italic;">f</span> of <span class="texhtml mvar" style="font-style:italic;">C</span> with ends in different subtrees, i.e., it reconnects the subtrees into a tree <span class="texhtml"><i>T</i><sub>2</sub></span> with weight less than that of <span class="texhtml"><i>T</i><sub>1</sub></span>, because the weight of <span class="texhtml mvar" style="font-style:italic;">f</span> is less than the weight of <span class="texhtml mvar" style="font-style:italic;">e</span>.
</p>
<h3><span class="mw-headline" id="Cut_property">Cut property</span><span class="mw-editsection"></span></h3>

<p><i>For any cut <span class="texhtml mvar" style="font-style:italic;">C</span> of the graph, if the weight of an edge <span class="texhtml mvar" style="font-style:italic;">e</span> in the cut-set of <span class="texhtml mvar" style="font-style:italic;">C</span> is strictly smaller than the weights of all other edges of the cut-set of <span class="texhtml mvar" style="font-style:italic;">C</span>, then this edge belongs to all MSTs of the graph.</i>
</p><p>Proof: Assume that there is an MST <span class="texhtml mvar" style="font-style:italic;">T</span> that does not contain <span class="texhtml mvar" style="font-style:italic;">e</span>. Adding <span class="texhtml mvar" style="font-style:italic;">e</span> to <span class="texhtml mvar" style="font-style:italic;">T</span> will produce a cycle, that crosses the cut once at <span class="texhtml mvar" style="font-style:italic;">e</span> and crosses back at another edge <span class="texhtml mvar" style="font-style:italic;">e'</span>. Deleting <span class="texhtml mvar" style="font-style:italic;">e'</span> we get a spanning tree <span class="texhtml"><i>T</i>∖{<i>e' </i>} ∪ {<i>e</i>} </span> of strictly smaller weight than <span class="texhtml mvar" style="font-style:italic;">T</span>. This contradicts the assumption that <span class="texhtml mvar" style="font-style:italic;">T</span> was a MST.
</p><p>By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.
</p>
<h3><span class="mw-headline" id="Minimum-cost_edge">Minimum-cost edge</span><span class="mw-editsection"></span></h3>
<p><i>If the minimum cost edge <span class="texhtml mvar" style="font-style:italic;">e</span> of a graph is unique, then this edge is included in any MST.</i>
</p><p>Proof: if <span class="texhtml mvar" style="font-style:italic;">e</span> was not included in the MST, removing any of the (larger cost) edges in the cycle formed after adding <span class="texhtml mvar" style="font-style:italic;">e</span> to the MST, would yield a spanning tree of smaller weight.
</p>
<h3><span class="mw-headline" id="Contraction">Contraction</span><span class="mw-editsection"></span></h3>
<p>If <span class="texhtml mvar" style="font-style:italic;">T</span> is a tree of MST edges, then we can <i>contract</i> <span class="texhtml mvar" style="font-style:italic;">T</span> into a single vertex while maintaining the invariant that the MST of the contracted graph plus <span class="texhtml mvar" style="font-style:italic;">T</span> gives the MST for the graph before contraction.<sup class="reference" id="cite_ref-PettieRamachandran2002_4-0">[4]</sup>
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>In all of the algorithms below, <span class="texhtml mvar" style="font-style:italic;">m</span> is the number of edges in the graph and <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of vertices.
</p>
<h3><span class="mw-headline" id="Classic_algorithms">Classic algorithms</span><span class="mw-editsection"></span></h3>
<p>The first algorithm for finding a minimum spanning tree was developed by Czech scientist Otakar Borůvka in 1926 (see Borůvka's algorithm). Its purpose was an efficient electrical coverage of Moravia.  The algorithm proceeds in a sequence of stages. In each stage, called <i>Boruvka step</i>, it identifies a forest <span class="texhtml mvar" style="font-style:italic;">F</span> consisting of the minimum-weight edge incident to each vertex in the graph <span class="texhtml mvar" style="font-style:italic;">G</span>, then forms the graph <span class="texhtml"><i>G</i><sub>1</sub> = <i>G</i> \ <i>F</i></span> as the input to the next step. Here <span class="texhtml"><i>G</i> \ <i>F</i></span> denotes the graph derived from <span class="texhtml mvar" style="font-style:italic;">G</span> by contracting edges in <span class="texhtml mvar" style="font-style:italic;">F</span> (by the Cut property, these edges belong to the MST). Each Boruvka step takes linear time. Since the number of vertices is reduced by at least half in each step, Boruvka's algorithm takes <span class="texhtml"><i>O</i>(<i>m</i> log <i>n</i>)</span> time.<sup class="reference" id="cite_ref-PettieRamachandran2002_4-1">[4]</sup>
</p><p>A second algorithm is Prim's algorithm, which was invented by Vojtěch Jarník in 1930 and rediscovered by Prim in 1957 and Dijkstra in 1959. Basically, it grows the MST (<span class="texhtml mvar" style="font-style:italic;">T</span>) one edge at a time. Initially, <span class="texhtml mvar" style="font-style:italic;">T</span> contains an arbitrary vertex. In each step, <span class="texhtml mvar" style="font-style:italic;">T</span> is augmented with a least-weight edge <span class="texhtml">(<i>x</i>,<i>y</i>)</span> such that <span class="texhtml mvar" style="font-style:italic;">x</span> is in <span class="texhtml mvar" style="font-style:italic;">T</span> and <span class="texhtml mvar" style="font-style:italic;">y</span> is not yet in <span class="texhtml mvar" style="font-style:italic;">T</span>. By the  Cut property, all edges added to <span class="texhtml mvar" style="font-style:italic;">T</span> are in the MST. Its run-time is either <span class="texhtml"><i>O</i>(<i>m</i> log <i>n</i>)</span> or <span class="texhtml"><i>O</i>(<i>m</i> + <i>n</i> log <i>n</i>)</span>, depending on the data-structures used.
</p><p>A third algorithm commonly in use is Kruskal's algorithm, which also takes <span class="texhtml"><i>O</i>(<i>m</i> log <i>n</i>)</span> time.
</p><p>A fourth algorithm, not as commonly used, is the reverse-delete algorithm, which is the reverse of Kruskal's algorithm. Its runtime is <span class="texhtml">O(<i>m</i> log <i>n</i> (log log <i>n</i>)<sup>3</sup>)</span>.
</p><p>All four of these are greedy algorithms. Since they run in polynomial time, the problem of finding such trees is in <b>FP</b>, and related decision problems such as determining whether a particular edge is in the MST or determining if the minimum total weight exceeds a certain value are in <b>P</b>.
</p>
<h3><span class="mw-headline" id="Faster_algorithms">Faster algorithms</span><span class="mw-editsection"></span></h3>
<p>Several researchers have tried to find more computationally-efficient algorithms.
</p><p>In a comparison model, in which the only allowed operations on edge weights are pairwise comparisons, Karger, Klein &amp; Tarjan (1995) found a linear time randomized algorithm based on a combination of Borůvka's algorithm and the reverse-delete algorithm.<sup class="reference" id="cite_ref-5">[5]</sup><sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>The fastest non-randomized comparison-based algorithm with known complexity, by Bernard Chazelle, is based on the soft heap, an approximate priority queue.<sup class="reference" id="cite_ref-Chazelle2000_7-0">[7]</sup><sup class="reference" id="cite_ref-8">[8]</sup> Its running time is <span class="texhtml"><i>O</i>(<i>m</i> α(<i>m</i>,<i>n</i>))</span>, where <span class="texhtml">α</span> is the classical functional inverse of the Ackermann function. The function <span class="texhtml">α</span> grows extremely slowly, so that for all practical purposes it may be considered a constant no greater than 4; thus Chazelle's algorithm takes very close to linear time.
</p>
<h3><span class="mw-headline" id="Linear-time_algorithms_in_special_cases">Linear-time algorithms in special cases</span><span class="mw-editsection"></span></h3>
<h4><span class="mw-headline" id="Dense_graphs">Dense graphs</span><span class="mw-editsection"></span></h4>
<p>If the graph is dense (i.e. <span class="texhtml"><i>m</i>/<i>n</i> ≥ log log log <i>n</i>)</span>, then a deterministic algorithm by Fredman and Tarjan finds the MST in time <span class="texhtml">O(<i>m</i>)</span>.<sup class="reference" id="cite_ref-9">[9]</sup> The algorithm executes a number of phases. Each phase executes Prim's algorithm many times, each for a limited number of steps. The run-time of each phase is <span class="texhtml">O(<i>m</i> + <i>n</i>)</span>. If the number of vertices before a phase is <span class="texhtml mvar" style="font-style:italic;">n'</span>, the number of vertices remaining after a phase is at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\tfrac {n'}{2^{m/n'}}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mfrac>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>m</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
</mrow>
</msup>
</mfrac>
</mstyle>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\tfrac {n'}{2^{m/n'}}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\tfrac {n'}{2^{m/n'}}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/356552ae33a77c574cd6bbb40de6ff82361c1536" style="vertical-align: -1.838ex; width:4.962ex; height:4.509ex;"/></span>. Hence, at most <span class="texhtml">log*<i>n</i></span> phases are needed, which gives a linear run-time for dense graphs.<sup class="reference" id="cite_ref-PettieRamachandran2002_4-2">[4]</sup>
</p><p>There are other algorithms that work in linear time on dense graphs.<sup class="reference" id="cite_ref-Chazelle2000_7-1">[7]</sup><sup class="reference" id="cite_ref-10">[10]</sup>
</p>
<h4><span class="mw-headline" id="Integer_weights">Integer weights</span><span class="mw-editsection"></span></h4>
<p>If the edge weights are integers represented in binary, then deterministic algorithms are known that solve the problem in <span class="texhtml"><i>O</i>(<i>m</i> + <i>n</i>)</span> integer operations.<sup class="reference" id="cite_ref-11">[11]</sup>
Whether the problem can be solved <i>deterministically</i> for a <i>general graph</i> in <i>linear time</i> by a comparison-based algorithm remains an open question.
</p>
<h3><span class="mw-headline" id="Decision_trees">Decision trees</span><span class="mw-editsection"></span></h3>
<p>Given graph <span class="texhtml mvar" style="font-style:italic;">G</span> where the nodes and edges are fixed but the weights are unknown, it is possible to construct a binary decision tree (DT) for calculating the MST for any permutation of weights. Each internal node of the DT contains a comparison between two edges, e.g. "Is the weight of the edge between <span class="texhtml mvar" style="font-style:italic;">x</span> and <span class="texhtml mvar" style="font-style:italic;">y</span> larger than the weight of the edge between <span class="texhtml mvar" style="font-style:italic;">w</span> and <span class="texhtml mvar" style="font-style:italic;">z</span>?". The two children of the node correspond to the two possible answers "yes" or "no". In each leaf of the DT, there is a list of edges from <span class="texhtml mvar" style="font-style:italic;">G</span> that correspond to an MST. The runtime complexity of a DT is the largest number of queries required to find the MST, which is just the depth of the DT. A DT for a graph <span class="texhtml mvar" style="font-style:italic;">G</span> is called <i>optimal</i> if it has the smallest depth of all correct DTs for <span class="texhtml mvar" style="font-style:italic;">G</span>.
</p><p>For every integer <span class="texhtml mvar" style="font-style:italic;">r</span>, it is possible to find optimal decision trees for all graphs on <span class="texhtml mvar" style="font-style:italic;">r</span> vertices by brute-force search. This search proceeds in two steps.
</p><p><b>A. Generating all potential DTs</b>
</p>
<ul><li>There are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{r \choose 2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mrow>
<mrow class="MJX-TeXAtom-OPEN">
<mo maxsize="1.2em" minsize="1.2em">(</mo>
</mrow>
<mfrac linethickness="0">
<mi>r</mi>
<mn>2</mn>
</mfrac>
<mrow class="MJX-TeXAtom-CLOSE">
<mo maxsize="1.2em" minsize="1.2em">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{r \choose 2}}</annotation>
</semantics>
</math></span><img alt="2^{{r \choose 2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c077a8a00f4121cdc8862190b85d45a9e8ed459" style="vertical-align: -0.338ex; width:4.025ex; height:3.843ex;"/></span> different graphs on  <span class="texhtml mvar" style="font-style:italic;">r</span> vertices.</li>
<li>For each graph, an MST can always be found using <span class="texhtml"><i>r</i>(<i>r</i> – 1)</span> comparisons, e.g. by Prim's algorithm.</li>
<li>Hence, the depth of an optimal DT is less than <span class="texhtml"><i>r</i><sup>2</sup></span>.</li>
<li>Hence, the number of internal nodes in an optimal DT is less than <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{r^{2}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{r^{2}}}</annotation>
</semantics>
</math></span><img alt="2^{r^{2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a819535078b65377c83f880224e9ac4e6af267aa" style="vertical-align: -0.338ex; width:2.968ex; height:3.009ex;"/></span>.</li>
<li>Every internal node compares two edges. The number of edges is at most <span class="texhtml"><i>r</i><sup>2</sup></span> so the different number of comparisons is at most <span class="texhtml"><i>r</i><sup>4</sup></span>.</li>
<li>Hence, the number of potential DTs is less than<p><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {(r^{4})}^{(2^{r^{2}})}=r^{2^{(r^{2}+2)}}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>4</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>=</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</mrow>
</msup>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {(r^{4})}^{(2^{r^{2}})}=r^{2^{(r^{2}+2)}}.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {(r^{4})}^{(2^{r^{2}})}=r^{2^{(r^{2}+2)}}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/27913284628391287702902c5d1b3ae5aba69478" style="vertical-align: -0.838ex; width:17.972ex; height:4.509ex;"/></span></p></li></ul>
<p><b>B. Identifying the correct DTs</b>
To check if a DT is correct, it should be checked on all possible permutations of the edge weights.
</p>
<ul><li>The number of such permutations is at most <span class="texhtml">(<i>r</i><sup>2</sup>)!</span>.</li>
<li>For each permutation, solve the MST problem on the given graph using any existing algorithm, and compare the result to the answer given by the DT.</li>
<li>The running time of any MST algorithm is at most <span class="texhtml"><i>r</i><sup>2</sup></span>, so the total time required to check all permutations is at most <span class="texhtml">(<i>r</i><sup>2</sup> + 1)!</span>.</li></ul>
<p>Hence, the total time required for finding an optimal DT for <i>all</i> graphs with <span class="texhtml mvar" style="font-style:italic;">r</span> vertices is:<sup class="reference" id="cite_ref-PettieRamachandran2002_4-3">[4]</sup>
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{r \choose 2}\cdot r^{2^{(r^{2}+2)}}\cdot (r^{2}+1)!,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mrow>
<mrow class="MJX-TeXAtom-OPEN">
<mo maxsize="1.2em" minsize="1.2em">(</mo>
</mrow>
<mfrac linethickness="0">
<mi>r</mi>
<mn>2</mn>
</mfrac>
<mrow class="MJX-TeXAtom-CLOSE">
<mo maxsize="1.2em" minsize="1.2em">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
<mo>⋅<!-- ⋅ --></mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</mrow>
</msup>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>!</mo>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{r \choose 2}\cdot r^{2^{(r^{2}+2)}}\cdot (r^{2}+1)!,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2^{r \choose 2}\cdot r^{2^{(r^{2}+2)}}\cdot (r^{2}+1)!,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/80ba8525b936bb77a09868fd4e184f139133b81f" style="vertical-align: -0.838ex; width:23.005ex; height:4.343ex;"/></span></dd></dl>
<p>which is less than
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{2^{r^{2}+o(r)}}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mi>o</mi>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</mrow>
</msup>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{2^{r^{2}+o(r)}}.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2^{2^{r^{2}+o(r)}}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7a804f488e2a3a55d4cf1e3ade0c068216b32148" style="vertical-align: -0.338ex; width:7.756ex; height:3.509ex;"/></span></dd></dl>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<h3><span class="mw-headline" id="Optimal_algorithm">Optimal algorithm</span><span class="mw-editsection"></span></h3>
<p>Seth Pettie and Vijaya Ramachandran have found a provably optimal deterministic comparison-based minimum spanning tree algorithm.<sup class="reference" id="cite_ref-PettieRamachandran2002_4-4">[4]</sup> The following is a simplified description of the algorithm.
</p>
<ol><li>Let <span class="texhtml"><i>r</i> = log log log <i>n</i></span>, where <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of vertices. Find all optimal decision trees on <span class="texhtml mvar" style="font-style:italic;">r</span> vertices. This can be done in time <span class="texhtml"><i>O</i>(<i>n</i>)</span> (see Decision trees above).</li>
<li>Partition the graph to components with at most <span class="texhtml mvar" style="font-style:italic;">r</span> vertices in each component. This partition uses a soft heap, which "corrupts" a small number of the edges of the graph.</li>
<li>Use the optimal decision trees to find an MST for the uncorrupted subgraph within each component.</li>
<li>Contract each connected component spanned by the MSTs to a single vertex, and apply any algorithm which works on dense graphs in time <span class="texhtml"><i>O</i>(<i>m</i>)</span> to the contraction of the uncorrupted subgraph</li>
<li>Add back the corrupted edges to the resulting forest to form a subgraph guaranteed to contain the minimum spanning tree, and smaller by a constant factor than the starting graph. Apply the optimal algorithm recursively to this graph.</li></ol>
<p>The runtime of all steps in the algorithm is <span class="texhtml"><i>O</i>(<i>m</i>)</span>, <i>except for the step of using the decision trees</i>. The runtime of this step is unknown, but it has been proved that it is optimal - no algorithm can do better than the optimal decision tree. Thus, this algorithm has the peculiar property that it is <i>provably optimal</i> although its runtime complexity is <i>unknown</i>.
</p>
<h3><span class="mw-headline" id="Parallel_and_distributed_algorithms">Parallel and distributed algorithms</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Research has also considered parallel algorithms for the minimum spanning tree problem.
With a linear number of processors it is possible to solve the problem in <span class="texhtml"><i>O</i>(log <i>n</i>)</span> time.<sup class="reference" id="cite_ref-12">[12]</sup><sup class="reference" id="cite_ref-13">[13]</sup>
Bader &amp; Cong (2006) demonstrate an algorithm that can compute MSTs 5 times faster on 8 processors than an optimized sequential algorithm.<sup class="reference" id="cite_ref-14">[14]</sup>
</p><p>Other specialized algorithms have been designed for computing minimum spanning trees of a graph so large that most of it must be stored on disk at all times. These <i>external storage</i> algorithms, for example as described in "Engineering an External Memory Minimum Spanning Tree Algorithm" by Roman, Dementiev et al.,<sup class="reference" id="cite_ref-15">[15]</sup> can operate, by authors' claims,  as little as 2 to 5 times slower than a traditional in-memory algorithm. They rely on efficient external storage sorting algorithms and on graph contraction techniques for reducing the graph's size efficiently.
</p><p>The problem can also be approached in a distributed manner.  If each node is considered a computer and no node knows anything except its own connected links, one can still calculate the distributed minimum spanning tree.
</p>
<h2><span class="mw-headline" id="MST_on_complete_graphs">MST on complete graphs</span><span class="mw-editsection"></span></h2>
<p>Alan M. Frieze showed that given a complete graph on <i>n</i> vertices, with edge weights that are independent identically distributed random variables with distribution function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F}</annotation>
</semantics>
</math></span><img alt="F" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/545fd099af8541605f7ee55f08225526be88ce57" style="vertical-align: -0.338ex; width:1.741ex; height:2.176ex;"/></span> satisfying <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F'(0)&gt;0}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mi>F</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
<mo>&gt;</mo>
<mn>0</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F'(0)&gt;0}</annotation>
</semantics>
</math></span><img alt="F'(0)&gt;0" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/22813ad123b73c17ee8704115c2b4fe8432ab529" style="vertical-align: -0.838ex; width:9.732ex; height:3.009ex;"/></span>, then as <i>n</i> approaches +∞ the expected weight of the MST approaches <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \zeta (3)/F'(0)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ζ<!-- ζ --></mi>
<mo stretchy="false">(</mo>
<mn>3</mn>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<msup>
<mi>F</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \zeta (3)/F'(0)}</annotation>
</semantics>
</math></span><img alt="\zeta (3)/F'(0)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fc14654ed5fa44f1a20abc50b9465a41b84e69a1" style="vertical-align: -0.838ex; width:10.701ex; height:3.009ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \zeta }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ζ<!-- ζ --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \zeta }</annotation>
</semantics>
</math></span><img alt="\zeta " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d5c3916703cae7938143d38865f78f27faadd4ae" style="vertical-align: -0.671ex; width:1.095ex; height:2.509ex;"/></span> is the Riemann zeta function (more specifically is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \zeta (3)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ζ<!-- ζ --></mi>
<mo stretchy="false">(</mo>
<mn>3</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \zeta (3)}</annotation>
</semantics>
</math></span><img alt="\zeta (3)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3088978098c7b90b2754a9d9b0b994d873e1755c" style="vertical-align: -0.838ex; width:4.067ex; height:2.843ex;"/></span> Apéry's constant). Frieze and Steele also proved convergence in probability. Svante Janson proved a central limit theorem for weight of the MST.
</p><p>For uniform random weights in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle [0,1]}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle [0,1]}</annotation>
</semantics>
</math></span><img alt="[0,1]" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/738f7d23bb2d9642bab520020873cccbef49768d" style="vertical-align: -0.838ex; width:4.653ex; height:2.843ex;"/></span>, the exact expected size of the minimum spanning tree has been computed for small complete graphs.<sup class="reference" id="cite_ref-16">[16]</sup>
</p>
<table class="wikitable">
<tbody><tr>
<th>Vertices
</th>
<th>Expected size
</th>
<th>Approximate expected size
</th></tr>
<tr>
<td>2
</td>
<td>
</td>
<td>0.5
</td></tr>
<tr>
<td>3
</td>
<td>
</td>
<td>0.75
</td></tr>
<tr>
<td>4
</td>
<td>
</td>
<td>0.8857143
</td></tr>
<tr>
<td>5
</td>
<td>
</td>
<td>0.9664502
</td></tr>
<tr>
<td>6
</td>
<td>
</td>
<td>1.0183151
</td></tr>
<tr>
<td>7
</td>
<td>
</td>
<td>1.053716
</td></tr>
<tr>
<td>8
</td>
<td>
</td>
<td>1.0790588
</td></tr>
<tr>
<td>9
</td>
<td>
</td>
<td>1.0979027
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Minimum spanning trees have direct applications in the design of networks, including computer networks, telecommunications networks, transportation networks, water supply networks, and electrical grids (which they were first invented for, as mentioned above).<sup class="reference" id="cite_ref-17">[17]</sup> They are invoked as subroutines in algorithms for other problems, including the Christofides algorithm for approximating the traveling salesman problem,<sup class="reference" id="cite_ref-18">[18]</sup> approximating the multi-terminal minimum cut problem (which is equivalent in the single-terminal case to the maximum flow problem),<sup class="reference" id="cite_ref-19">[19]</sup>
and approximating the minimum-cost weighted perfect matching.<sup class="reference" id="cite_ref-20">[20]</sup>
</p><p>Other practical applications based on minimal spanning trees include:
</p>
<ul><li>Taxonomy.<sup class="reference" id="cite_ref-21">[21]</sup></li>
<li>Cluster analysis: clustering points in the plane,<sup class="reference" id="cite_ref-22">[22]</sup> single-linkage clustering (a method of hierarchical clustering),<sup class="reference" id="cite_ref-23">[23]</sup> graph-theoretic clustering,<sup class="reference" id="cite_ref-24">[24]</sup> and clustering gene expression data.<sup class="reference" id="cite_ref-25">[25]</sup></li>
<li>Constructing trees for broadcasting in computer networks.<sup class="reference" id="cite_ref-26">[26]</sup></li>
<li>Image registration<sup class="reference" id="cite_ref-27">[27]</sup> and segmentation<sup class="reference" id="cite_ref-28">[28]</sup> – see minimum spanning tree-based segmentation.</li>
<li>Curvilinear feature extraction in computer vision.<sup class="reference" id="cite_ref-29">[29]</sup></li>
<li>Handwriting recognition of mathematical expressions.<sup class="reference" id="cite_ref-30">[30]</sup></li>
<li>Circuit design: implementing efficient multiple constant multiplications, as used in finite impulse response filters.<sup class="reference" id="cite_ref-31">[31]</sup></li>
<li>Regionalisation of socio-geographic areas, the grouping of areas into homogeneous, contiguous regions.<sup class="reference" id="cite_ref-32">[32]</sup></li>
<li>Comparing ecotoxicology data.<sup class="reference" id="cite_ref-33">[33]</sup></li>
<li>Topological observability in power systems.<sup class="reference" id="cite_ref-34">[34]</sup></li>
<li>Measuring homogeneity of two-dimensional materials.<sup class="reference" id="cite_ref-35">[35]</sup></li>
<li>Minimax process control.<sup class="reference" id="cite_ref-36">[36]</sup></li>
<li>Minimum spanning trees can also be used to describe financial markets.<sup class="reference" id="cite_ref-37">[37]</sup><sup class="reference" id="cite_ref-38">[38]</sup> A correlation matrix can be created by calculating a coefficient of correlation between any two stocks. This matrix can be represented topologically as a complex network and a minimum spanning tree can be constructed to visualize relationships.</li></ul>
<h2><span class="mw-headline" id="Related_problems">Related problems</span><span class="mw-editsection"></span></h2>

<p>The problem of finding the Steiner tree of a subset of the vertices, that is, minimum tree that spans the given subset, is known to be NP-Complete.<sup class="reference" id="cite_ref-39">[39]</sup>
</p><p>A related problem is the <i>k</i>-minimum spanning tree (<i>k</i>-MST), which is the tree that spans some subset of <i>k</i> vertices in the graph with minimum weight.
</p><p>A set of <i>k-smallest spanning trees</i> is a subset of <i>k</i> spanning trees (out of all possible spanning trees) such that no spanning tree outside the subset has smaller weight.<sup class="reference" id="cite_ref-40">[40]</sup><sup class="reference" id="cite_ref-41">[41]</sup><sup class="reference" id="cite_ref-42">[42]</sup>  (Note that this problem is unrelated to the <i>k</i>-minimum spanning tree.)
</p><p>The Euclidean minimum spanning tree is a spanning tree of a graph with edge weights corresponding to the Euclidean distance between vertices which are points in the plane (or space).
</p><p>The rectilinear minimum spanning tree is a spanning tree of a graph with edge weights corresponding to the rectilinear distance between vertices which are points in the plane (or space).
</p><p>In the distributed model, where each node is considered a computer and no node knows anything except its own connected links, one can consider distributed minimum spanning tree. The mathematical definition of the problem is the same but there are different approaches for a solution.
</p><p>The capacitated minimum spanning tree is a tree that has a marked node (origin, or root) and each of the subtrees attached to the node contains no more than a <i>c</i> nodes. <i>c</i> is called a tree capacity. Solving CMST optimally is NP-hard,<sup class="reference" id="cite_ref-43">[43]</sup> but good heuristics such as Esau-Williams and Sharma produce solutions close to optimal in polynomial time.
</p><p>The degree constrained minimum spanning tree is a minimum spanning tree in which each vertex is connected to no more than <i>d</i> other vertices, for some given number <i>d</i>. The case <i>d</i> = 2 is a special case of the traveling salesman problem, so the degree constrained minimum spanning tree is NP-hard in general.
</p><p>For directed graphs, the minimum spanning tree problem is called the Arborescence problem and can be solved in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(E+V\log V)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>E</mi>
<mo>+</mo>
<mi>V</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>V</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(E+V\log V)}</annotation>
</semantics>
</math></span><img alt="O(E + V \log V)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/53baa00b4d2c1e5be2788d692c5e910d681e7795" style="vertical-align: -0.838ex; width:15.519ex; height:2.843ex;"/></span> time using the Chu–Liu/Edmonds algorithm.
</p><p>A <b>maximum spanning tree</b> is a spanning tree with weight greater than or equal to the weight of every other spanning tree.
Such a tree can be found with algorithms such as Prim's or Kruskal's after multiplying the edge weights by -1 and solving
the MST problem on the new graph. A path in the maximum spanning tree is the widest path in the graph between its two endpoints: among all possible paths, it maximizes the weight of the minimum-weight edge.<sup class="reference" id="cite_ref-44">[44]</sup>
Maximum spanning trees find applications in parsing algorithms for natural languages<sup class="reference" id="cite_ref-45">[45]</sup>
and in training algorithms for conditional random fields.
</p><p>The <b>dynamic MST</b> problem concerns the update of a previously computed MST after an edge weight change in the original graph or the insertion/deletion of a vertex.<sup class="reference" id="cite_ref-46">[46]</sup><sup class="reference" id="cite_ref-47">[47]</sup><sup class="reference" id="cite_ref-48">[48]</sup>
</p><p>The minimum labeling spanning tree problem is to find a spanning tree with least types of labels if each edge in a graph is associated with a label from a finite label set instead of a weight.<sup class="reference" id="cite_ref-49">[49]</sup>
</p><p>A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a <b>minimum bottleneck spanning tree</b> (or <b>MBST</b>) if the graph does not contain a spanning tree with a smaller bottleneck edge weight. A MST is necessarily a MBST (provable by the cut property), but a MBST is not necessarily a MST.<sup class="reference" id="cite_ref-50">[50]</sup><sup class="reference" id="cite_ref-51">[51]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li>Otakar Boruvka on Minimum Spanning Tree Problem (translation of both 1926 papers, comments, history) (2000) Jaroslav Nešetřil, Eva Milková, Helena Nesetrilová. (Section 7 gives his algorithm, which looks like a cross between Prim's and Kruskal's.)</li>
<li>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. <i>Introduction to Algorithms</i>, Second Edition. MIT Press and McGraw-Hill, 2001. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-262-03293-7. Chapter 23: Minimum Spanning Trees, pp. 561–579.</li>
<li>Eisner, Jason (1997). State-of-the-art algorithms for minimum spanning trees: A tutorial discussion. Manuscript, University of Pennsylvania, April. 78 pp.</li>
<li>Kromkowski, John David. "Still Unmelted after All These Years", in Annual Editions, Race and Ethnic Relations, 17/e (2009 McGraw Hill) (Using minimum spanning tree as method of demographic analysis of ethnic diversity across the United States).</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Implemented in BGL, the Boost Graph Library</li>
<li>The Stony Brook Algorithm Repository - Minimum Spanning Tree codes</li>
<li>Implemented in QuickGraph for .Net</li></ul>
<!-- 
NewPP limit report
Parsed by mw2393
Cached time: 20221223232520
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.627 seconds
Real time usage: 0.790 seconds
Preprocessor visited node count: 7005/1000000
Post‐expand include size: 131610/2097152 bytes
Template argument size: 8376/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 4/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 164413/5000000 bytes
Lua time usage: 0.355/10.000 seconds
Lua memory usage: 8784216/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  640.690      1 -total
 49.20%  315.203      1 Template:Reflist
 16.25%  104.142     23 Template:Citation
 12.51%   80.138      5 Template:Cite_web
  9.06%   58.029     13 Template:Cite_journal
  8.90%   56.998      1 Template:Short_description
  8.24%   52.804      2 Template:Harvtxt
  7.66%   49.088     50 Template:Math
  5.25%   33.629      1 Template:Commons_category
  4.95%   31.701      1 Template:Sister_project
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:41795-0!canonical and timestamp 20221223232519 and revision id 1128869717.
 -->
</div></body>
</html>