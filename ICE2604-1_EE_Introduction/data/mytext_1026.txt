tournament_sortTournament sortClassSorting algorithmData structureArrayWorst-case performanceO(n log n)Average performanceO(n log n)Tournament sort is a sorting algorithm.  It improves upon the naive selection sort by using a priority queue to find the next element in the sort.  In the naive selection sort, it takes O(n) operations to select the next element of n elements; in a tournament sort, it takes O(log n) operations (after building the initial tournament in O(n)).  Tournament sort is a variation of heapsort.Tournament replacement selection sorts are used to gather the initial runs for external sorting algorithms. Conceptually, an external file is read and its elements are pushed into the priority queue until the queue is full. Then the minimum element is pulled from the queue and written as part of the first run. The next input element is read and pushed into the queue, and the min is selected again and added to the run. There's a small trick that if the new element being pushed into the queue is less than the last element added to the run, then the element's sort value is increased so it will be part of the next run. On average, a run will be 100% longer than the capacity of the priority queue.[1]Tournament sorts may also be used in N-way merges.The name comes from its similarity to a single-elimination tournament where there are many players (or teams) that play in two-sided matches. Each match compares the players, and the winning player is promoted to play a match at the next level up. The hierarchy continues until the final match determines the ultimate winner. The tournament determines the best player, but the player who was beaten in the final match may not be the second best – he may be inferior to other players the winner bested.The following is an implementation of tournament sort in Haskell, based on Scheme code by Stepanov and Kershenbaum.[2]Kershenbaum et al 1988, "Higher Order Imperative Programming"