<!DOCTYPE html>
<html>
<head>
<title>phonetic_coding</title>
</head>
<body>
<div class="mw-parser-output"><p>A <b>phonetic algorithm</b> is an algorithm for indexing of words by their pronunciation. Most phonetic algorithms were developed for English and are not useful for indexing words in other languages.<sup class="reference" id="cite_ref-1">[1]</sup> Because English spelling varies significantly depending on multiple factors, such as the word's origin and usage over time and borrowings from other languages, phonetic algorithms necessarily take into account numerous rules and exceptions.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>

<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>Among the best-known phonetic algorithms are:
</p>
<ul><li>Soundex, which was developed to encode surnames for use in censuses. Soundex codes are four-character strings composed of a single letter followed by three numbers.</li>
<li>Daitch–Mokotoff Soundex, which is a refinement of Soundex designed to better match surnames of Slavic and Germanic origin. Daitch–Mokotoff Soundex codes are strings composed of six numeric digits.</li>
<li>Cologne phonetics: This is similar to Soundex, but more suitable for German words.</li>
<li>Metaphone and Double Metaphone which are suitable for use with most English words, not just names. Metaphone algorithms are the basis for many popular spell checkers.</li>
<li>New York State Identification and Intelligence System (NYSIIS), which maps similar phonemes to the same letter. The result is a string that can be pronounced by the reader without decoding.</li>
<li>Match Rating Approach developed by Western Airlines in 1977 - this algorithm has an encoding and range comparison technique.</li>
<li>Caverphone, created to assist in data matching between late 19th century and early 20th century electoral rolls, optimized for accents present in parts of New Zealand.</li></ul>
<h2><span class="mw-headline" id="Common_uses">Common uses</span><span class="mw-editsection"></span></h2>
<ul><li>Spell checkers can often contain phonetic algorithms. The Metaphone algorithm, for example, can take an incorrectly spelled word and create a code. The code is then looked up in directory for words with the same or similar Metaphone. Words that have the same or similar Metaphone become possible alternative spellings.</li>
<li>Search functionality will often use phonetic algorithms to find results that don't match exactly the term(s) used in the search. Searching for names can be difficult as there are often multiple alternative spellings for names. An example is the name Claire. It has two alternatives, Clare/Clair, which are both pronounced the same. Searching for one spelling wouldn't show results for the two others. Using Soundex all three variations produce the same Soundex code, C460. By searching names based on the Soundex code all three variations will be returned.</li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Approximate string matching</li>
<li>Hamming distance</li>
<li>Levenshtein distance</li>
<li>Damerau–Levenshtein distance</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><img alt="Public Domain" class="noviewer" data-file-height="196" data-file-width="196" decoding="async" height="12" src="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/12px-PD-icon.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/18px-PD-icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/24px-PD-icon.svg.png 2x" width="12"/> This article incorporates public domain material from <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs1" id="CITEREFPaul_E._Black">Paul E. Black. "phonetic coding". <i>Dictionary of Algorithms and Data Structures</i>. NIST.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Dictionary+of+Algorithms+and+Data+Structures&amp;rft.atitle=phonetic+coding&amp;rft.au=Paul+E.+Black&amp;rft_id=https%3A%2F%2Fxlinux.nist.gov%2Fdads%2FHTML%2FphoneticCoding.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APhonetic+algorithm"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Algorithm for converting words to phonemes and back.</li>
<li>StringMetric project a Scala library of phonetic algorithms.</li>
<li>clj-fuzzy project a Clojure library of phonetic algorithms.</li>
<li>SoundexBR library of phonetic algorithm implemented in R.</li>
<li>Talisman a JavaScript library collecting various phonetic algorithms that one can try online.</li></ul>
<!-- 
NewPP limit report
Parsed by mw1378
Cached time: 20221214135615
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.165 seconds
Real time usage: 0.196 seconds
Preprocessor visited node count: 368/1000000
Post‐expand include size: 10794/2097152 bytes
Template argument size: 239/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 9573/5000000 bytes
Lua time usage: 0.097/10.000 seconds
Lua memory usage: 3033122/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  169.289      1 -total
 77.37%  130.983      1 Template:Reflist
 62.03%  105.003      2 Template:Cite_book
 22.56%   38.194      1 Template:DADS
 21.62%   36.601      3 Template:If_empty
  3.14%    5.315      1 Template:Delink
  2.07%    3.512      1 Template:Link_if_exists
  1.17%    1.981      1 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:36712-0!canonical and timestamp 20221214135614 and revision id 1055316513.
 -->
</div></body>
</html>