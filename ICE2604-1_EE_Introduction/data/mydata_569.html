<!DOCTYPE html>
<html>
<head>
<title>linear_search</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><style data-mw-deduplicate="TemplateStyles:r1086701767">.mw-parser-output .multiple-issues-text{width:95%;margin:0.2em 0}.mw-parser-output .multiple-issues-text>.mw-collapsible-content{margin-top:0.3em}.mw-parser-output .compact-ambox .ambox{border:none;border-collapse:collapse;background-color:transparent;margin:0 0 0 1.6em!important;padding:0!important;width:auto;display:block}body.mediawiki .mw-parser-output .compact-ambox .ambox.mbox-small-left{font-size:100%;width:auto;margin:0}.mw-parser-output .compact-ambox .ambox .mbox-text{padding:0!important;margin:0!important}.mw-parser-output .compact-ambox .ambox .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:disc}.mw-parser-output .compact-ambox .ambox .mbox-image,.mw-parser-output .compact-ambox .ambox .mbox-imageright,.mw-parser-output .compact-ambox .ambox .mbox-empty-cell,.mw-parser-output .compact-ambox .hide-when-compact{display:none}</style><table class="box-Multiple_issues plainlinks metadata ambox ambox-content ambox-multiple_issues compact-ambox" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Linear search</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Search algorithm</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row">Best-case performance</th><td class="infobox-data"><i>O</i>(1)</td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data"><i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><i>O</i>(1) iterative</td></tr></tbody></table>
<p>In computer science, a <b>linear search</b> or <b>sequential search</b> is a method for finding an element within a list. It sequentially checks each element of the list until a match is found or the whole list has been searched.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.1_("Sequential_search")_1-0'>[1]</sup>
</p><p>A linear search runs in at worst linear time and makes at most <span class="texhtml"><i>n</i></span> comparisons, where <span class="texhtml"><i>n</i></span> is the length of the list. If each element is equally likely to be searched, then linear search has an average case of <span class="texhtml"><style data-mw-deduplicate="TemplateStyles:r1050945101">.mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="sfrac tion" role="math"><span class="num"><i>n+1</i></span><span class="sr-only">/</span><span class="den">2</span></span></span> comparisons, but the average case can be affected if the search probabilities for each element vary. Linear search is rarely practical because other search algorithms and schemes, such as the binary search algorithm and hash tables, allow significantly faster searching for all but short lists.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.2_("Searching_by_Comparison_Of_Keys")_2-0'>[2]</sup>
</p>

<h2><span class="mw-headline" id="Algorithm">Algorithm</span><span class="mw-editsection"></span></h2>
<p>A linear search sequentially checks each element of the list until it finds an element that matches the target value. If the algorithm reaches the end of the list, the search terminates unsuccessfully.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.1_("Sequential_search")_1-1'>[1]</sup>
</p>
<h3><span class="mw-headline" id="Basic_algorithm">Basic algorithm</span><span class="mw-editsection"></span></h3>
<p>Given a list <span class="texhtml"><i>L</i></span> of <span class="texhtml"><i>n</i></span> elements with values or records <span class="texhtml"><i>L</i><sub>0</sub> .... <i>L</i><sub><i>n</i>−1</sub></span>, and target value <span class="texhtml"><i>T</i></span>, the following subroutine uses linear search to find the index of the target <span class="texhtml"><i>T</i></span> in <span class="texhtml"><i>L</i></span>.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.1_("Sequential_search"),_subsection_"Algorithm_B"_3-0'>[3]</sup>
</p>
<ol><li>Set <span class="texhtml"><i>i</i></span> to 0.</li>
<li>If <span class="texhtml"><i>L</i><sub><i>i</i></sub> = <i>T</i></span>, the search terminates successfully; return <span class="texhtml"><i>i</i></span>.</li>
<li>Increase <span class="texhtml"><i>i</i></span> by 1.</li>
<li>If <span class="texhtml"><i>i</i> &lt; <i>n</i></span>, go to step 2. Otherwise, the search terminates unsuccessfully.</li></ol>
<h3><span class="mw-headline" id="With_a_sentinel">With a sentinel</span><span class="mw-editsection"></span></h3>
<p>The basic algorithm above makes two comparisons per iteration: one to check if <span class="texhtml"><i>L</i><sub><i>i</i></sub></span> equals <i>T</i>, and the other to check if <span class="texhtml"><i>i</i></span> still points to a valid index of the list. By adding an extra record <span class="texhtml"><i>L</i><sub><i>n</i></sub></span> to the list (a sentinel value) that equals the target, the second comparison can be eliminated until the end of the search, making the algorithm faster. The search will reach the sentinel if the target is not contained within the list.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.1_("Sequential_search"),_subsection_"Algorithm_Q"_4-0'>[4]</sup>
</p>
<ol><li>Set <span class="texhtml"><i>i</i></span> to 0.</li>
<li>If <span class="texhtml"><i>L</i><sub><i>i</i></sub> = <i>T</i></span>, go to step 4.</li>
<li>Increase <span class="texhtml"><i>i</i></span> by 1 and go to step 2.</li>
<li>If <span class="texhtml"><i>i</i> &lt; <i>n</i></span>, the search terminates successfully; return <span class="texhtml"><i>i</i></span>. Else, the search terminates unsuccessfully.</li></ol>
<h3><span class="mw-headline" id="In_an_ordered_table">In an ordered table</span><span class="mw-editsection"></span></h3>
<p>If the list is ordered such that <span class="texhtml"><i>L</i><sub>0</sub> ≤ <i>L</i><sub>1</sub> ... ≤ <i>L</i><sub><i>n</i>−1</sub></span>, the search can establish the absence of the target more quickly by concluding the search once <span class="texhtml"><i>L</i><sub><i>i</i></sub></span> exceeds the target. This variation requires a sentinel that is greater than the target.<sup class="reference" id='cite_ref-FOOTNOTEKnuth1998§6.1_("Sequential_search"),_subsection_"Algorithm_T"_5-0'>[5]</sup>
</p>
<ol><li>Set <span class="texhtml"><i>i</i></span> to 0.</li>
<li>If <span class="texhtml"><i>L</i><sub><i>i</i></sub> ≥ <i>T</i></span>, go to step 4.</li>
<li>Increase <span class="texhtml"><i>i</i></span> by 1 and go to step 2.</li>
<li>If <span class="texhtml"><i>L</i><sub><i>i</i></sub> = <i>T</i></span>, the search terminates successfully; return <span class="texhtml"><i>i</i></span>. Else, the search terminates unsuccessfully.</li></ol>
<h2><span class="mw-headline" id="Analysis">Analysis</span><span class="mw-editsection"></span></h2>
<p>For a list with <i>n</i> items, the best case is when the value is equal to the first element of the list, in which case only one comparison is needed. The worst case is when the value is not in the list (or occurs only once at the end of the list), in which case <i>n</i> comparisons are needed.
</p><p>If the value being sought occurs <i>k</i> times in the list, and all orderings of the list are equally likely, the expected number of comparisons is
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\begin{cases}n&amp;{\mbox{if }}k=0\\[5pt]\displaystyle {\frac {n+1}{k+1}}&amp;{\mbox{if }}1\leq k\leq n.\end{cases}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow>
<mo>{</mo>
<mtable columnalign="left left" columnspacing="1em" displaystyle="false" rowspacing="0.7em 0.2em">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
<mtd>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mtext>if </mtext>
</mstyle>
</mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mtd>
</mtr>
<mtr>
<mtd>
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mrow>
</mstyle>
</mtd>
<mtd>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mtext>if </mtext>
</mstyle>
</mrow>
<mn>1</mn>
<mo>≤<!-- ≤ --></mo>
<mi>k</mi>
<mo>≤<!-- ≤ --></mo>
<mi>n</mi>
<mo>.</mo>
</mtd>
</mtr>
</mtable>
<mo fence="true" stretchy="true" symmetric="true"></mo>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\begin{cases}n&amp;{\mbox{if }}k=0\\[5pt]\displaystyle {\frac {n+1}{k+1}}&amp;{\mbox{if }}1\leq k\leq n.\end{cases}}}</annotation>
</semantics>
</math></span><img alt="{\begin{cases}n&amp;{\mbox{if }}k=0\\[5pt]\displaystyle {\frac  {n+1}{k+1}}&amp;{\mbox{if }}1\leq k\leq n.\end{cases}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6c31d35edb255baee3eeb7111ce8a1f7d44a3878" style="vertical-align: -4.171ex; width:23.925ex; height:9.509ex;"/></span></dd></dl>
<p>For example, if the value being sought occurs once in the list, and all orderings of the list are equally likely, the expected number of comparisons is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {n+1}{2}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {n+1}{2}}}</annotation>
</semantics>
</math></span><img alt="{\frac  {n+1}2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4453d9f4a784834dcbdd7d1dfbe8724094d940dc" style="vertical-align: -1.838ex; width:6.234ex; height:5.176ex;"/></span>. However, if it is <i>known</i> that it occurs once, then at most <i>n</i> - 1 comparisons are needed, and the expected number of comparisons is 
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \displaystyle {\frac {(n+2)(n-1)}{2n}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
</mfrac>
</mrow>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \displaystyle {\frac {(n+2)(n-1)}{2n}}}</annotation>
</semantics>
</math></span><img alt="\displaystyle {\frac  {(n+2)(n-1)}{2n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4248051700ad53a6fd05eef0ffa35498b42dfb9c" style="vertical-align: -1.838ex; width:15.25ex; height:5.676ex;"/></span></dd></dl>
<p>(for example, for <i>n</i> = 2 this is 1, corresponding to a single if-then-else construct).
</p><p>Either way, asymptotically the worst-case cost and the expected cost of linear search are both O(<i>n</i>).
</p>
<h3><span class="mw-headline" id="Non-uniform_probabilities">Non-uniform probabilities</span><span class="mw-editsection"></span></h3>
<p>The performance of linear search improves if the desired value is more likely to be near the beginning of the list than to its end.  Therefore, if some values are much more likely to be searched than others,  it is desirable to place them at the beginning of the list.
</p><p>In particular, when the list items are arranged in order of decreasing probability, and these probabilities are geometrically distributed, the cost of linear search is only O(1). <sup class="reference" id="cite_ref-knuth_6-0">[6]</sup>
</p>
<h2><span class="mw-headline" id="Application">Application</span><span class="mw-editsection"></span></h2>
<p>Linear search is usually very simple to implement, and is practical when the list has only a few elements, or when performing a single search in an un-ordered list.
</p><p>When many values have to be searched in the same list, it often pays to pre-process the list in order to use a faster method. For example, one may sort the list and use binary search, or build an efficient search data structure from it. Should the content of the list change frequently, repeated re-organization may be more trouble than it is worth.
</p><p>As a result, even though in theory other search algorithms may be faster than linear search (for instance binary search), in practice even on medium-sized arrays (around 100 items or less) it might be infeasible to use anything else. On larger arrays, it only makes sense to use other, faster search methods if the data is large enough, because the initial time to prepare (sort) the data is comparable to many linear searches.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Ternary search</li>
<li>Hash table</li>
<li>Linear search problem</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Citations">Citations</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h3><span class="mw-headline" id="Works">Works</span><span class="mw-editsection"></span></h3>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFKnuth1998">Knuth, Donald (1998). <i>Sorting and Searching</i>. The Art of Computer Programming. Vol. 3 (2nd ed.). Reading, MA: Addison-Wesley Professional.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Sorting+and+Searching&amp;rft.place=Reading%2C+MA&amp;rft.series=The+Art+of+Computer+Programming&amp;rft.edition=2nd&amp;rft.pub=Addison-Wesley+Professional&amp;rft.date=1998&amp;rft.aulast=Knuth&amp;rft.aufirst=Donald&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALinear+search"></span> <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-89685-0</li></ul>
<!-- 
NewPP limit report
Parsed by mw2339
Cached time: 20221220210810
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.292 seconds
Real time usage: 0.410 seconds
Preprocessor visited node count: 2762/1000000
Post‐expand include size: 58882/2097152 bytes
Template argument size: 13410/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 21908/5000000 bytes
Lua time usage: 0.166/10.000 seconds
Lua memory usage: 6224950/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  343.889      1 -total
 34.84%  119.808      3 Template:Ambox
 23.23%   79.875      1 Template:Reflist
 22.35%   76.873      1 Template:Multiple_issues
 18.96%   65.211      2 Template:Cite_book
 17.52%   60.252      1 Template:Short_description
 13.91%   47.852      1 Template:Refimprove
 11.29%   38.820      6 Template:Sfn
 10.22%   35.143     29 Template:Math
  9.60%   33.028      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:18171-0!canonical and timestamp 20221220210809 and revision id 1125243789.
 -->
</div></body>
</html>