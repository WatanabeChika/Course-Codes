<!DOCTYPE html>
<html>
<head>
<title>R-tree</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">R-tree</th></tr><tr><th class="infobox-label" scope="row">Type</th><td class="infobox-data">tree</td></tr><tr><th class="infobox-label" scope="row">Invented</th><td class="infobox-data">1984</td></tr><tr><th class="infobox-label" scope="row">Invented by</th><td class="infobox-data">Antonin Guttman</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
O(<i>log<sub>M</sub>n</i>)</td><td class="infobox-data infobox-data-b">
O(<i>n</i>)<sup class="reference" id="cite_ref-1">[1]</sup></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
</td><td class="infobox-data infobox-data-b">
O(<i>n</i>)</td></tr></tbody></table></td></tr></tbody></table>


<p><b>R-trees</b> are tree data structures used for spatial access methods, i.e., for indexing multi-dimensional information such as geographical coordinates, rectangles or polygons. The R-tree was proposed by Antonin Guttman in 1984<sup class="reference" id="cite_ref-guttman_2-0">[2]</sup> and has found significant use in both theoretical and applied contexts.<sup class="reference" id="cite_ref-rtree-book_3-0">[3]</sup> A common real-world usage for an R-tree might be to store spatial objects such as restaurant locations or the polygons that typical maps are made of: streets, buildings, outlines of lakes, coastlines, etc. and then find answers quickly to queries such as "Find all museums within 2 km of my current location", "retrieve all road segments within 2 km of my location" (to display them in a navigation system) or "find the nearest gas station" (although not taking roads into account). The R-tree can also accelerate nearest neighbor search<sup class="reference" id="cite_ref-4">[4]</sup> for various distance metrics, including great-circle distance.<sup class="reference" id="cite_ref-geodetic_5-0">[5]</sup>
</p>

<h2><span class="mw-headline" id="R-tree_idea">R-tree idea</span><span class="mw-editsection"></span></h2>
<p>The key idea of the data structure is to group nearby objects and represent them with their minimum bounding rectangle in the next higher level of the tree; the "R" in R-tree is for rectangle. Since all objects lie within this bounding rectangle, a query that does not intersect the bounding rectangle also cannot intersect any of the contained objects. At the leaf level, each rectangle describes a single object; at higher levels the aggregation includes an increasing number of objects. This can also be seen as an increasingly coarse approximation of the data set.
</p><p>Similar to the B-tree, the R-tree is also a balanced search tree (so all leaf nodes are at the same depth), organizes the data in pages, and is designed for storage on disk (as used in databases). Each page can contain a maximum number of entries, often denoted as <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle M}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>M</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle M}</annotation>
</semantics>
</math></span><img alt="M" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" style="vertical-align: -0.338ex; width:2.442ex; height:2.176ex;"/></span>. It also guarantees a minimum fill (except for the root node), however best performance has been experienced with a minimum fill of 30%–40% of the maximum number of entries (B-trees guarantee 50% page fill, and B*-trees even 66%). The reason for this is the more complex balancing required for spatial data as opposed to linear data stored in B-trees.
</p><p>As with most trees, the searching algorithms (e.g., intersection, containment, nearest neighbor search) are rather simple. The key idea is to use the bounding boxes to decide whether or not to search inside a subtree. In this way, most of the nodes in the tree are never read during a search. Like B-trees, R-trees are suitable for large data sets and databases, where nodes can be paged to memory when needed, and the whole tree cannot be kept in main memory. Even if data can be fit in memory (or cached), the R-trees in most practical applications will usually provide performance advantages over naive check of all objects when the number of objects is more than few hundred or so. However, for in-memory applications, there are similar alternatives that can provide slightly better performance or be simpler to implement in practice. To maintain in-memory computing for R-tree in a computer cluster where computing nodes are connected by a network, researchers have used RDMA (Remote Direct Memory Access) to implement data-intensive applications under R-tree in a distributed environment.<sup class="reference" id="cite_ref-6">[6]</sup> This approach is scalable for increasingly large applications and achieves high throughput and low latency performance for R-tree.  
</p><p>The key difficulty of R-tree is to build an efficient tree that on one hand is balanced (so the leaf nodes are at the same height) on the other hand the rectangles do not cover too much empty space and do not overlap too much (so that during search, fewer subtrees need to be processed). For example, the original idea for inserting elements to obtain an efficient tree is to always insert into the subtree that requires least enlargement of its bounding box. Once that page is full, the data is split into two sets that should cover the minimal area each. Most of the research and improvements for R-trees aims at improving the way the tree is built and can be grouped into two objectives: building an efficient tree from scratch (known as bulk-loading) and performing changes on an existing tree (insertion and deletion).
</p><p>R-trees do not guarantee good worst-case performance, but generally perform well with real-world data.<sup class="reference" id="cite_ref-7">[7]</sup> While more of theoretical interest, the (bulk-loaded) Priority R-tree variant of the R-tree is worst-case optimal,<sup class="reference" id="cite_ref-prtree_8-0">[8]</sup> but due to the increased complexity, has not received much attention in practical applications so far.
</p><p>When data is organized in an R-tree, the neighbors within a given distance r and the k nearest neighbors (for any L<sup>p</sup>-Norm) of all points can efficiently be computed using a spatial join.<sup class="reference" id="cite_ref-9">[9]</sup><sup class="reference" id="cite_ref-10">[10]</sup> This is beneficial for many algorithms based on such queries, for example the Local Outlier Factor. DeLi-Clu,<sup class="reference" id="cite_ref-11">[11]</sup> Density-Link-Clustering is a cluster analysis algorithm that uses the R-tree structure for a similar kind of spatial join to efficiently compute an OPTICS clustering.
</p>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"></span></h2>
<ul><li>Priority R-tree</li>
<li>R*-tree</li>
<li>R+ tree</li>
<li>RR* tree</li>
<li>Hilbert R-tree</li>
<li>X-tree</li></ul>
<h2><span class="mw-headline" id="Algorithm">Algorithm</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Data_layout">Data layout</span><span class="mw-editsection"></span></h3>
<p>Data in R-trees is organized in pages that can have a variable number of entries (up to some pre-defined maximum, and usually above a minimum fill). Each entry within a non-leaf node stores two pieces of data: a way of identifying a child node, and the bounding box of all entries within this child node. Leaf nodes store the data required for each child, often a point or bounding box representing the child and an external identifier for the child. For point data, the leaf entries can be just the points themselves. For polygon data (that often requires the storage of large polygons) the common setup is to store only the MBR (minimum bounding rectangle) of the polygon along with a unique identifier in the tree.
</p>
<h3><span class="mw-headline" id="Search">Search</span><span class="mw-editsection"></span></h3>
<p>In range searching, the input is a search rectangle (Query box). Searching is quite similar to searching in a B+ tree. The search starts from the root node of the tree. Every internal node contains a set of rectangles and pointers to the corresponding child node and every leaf node contains the rectangles of spatial objects (the pointer to some spatial object can be there). For every rectangle in a node, it has to be decided if it overlaps the search rectangle or not. If yes, the corresponding child node has to be searched also. Searching is done like this in a recursive manner until all overlapping nodes have been traversed. When a leaf node is reached, the contained bounding boxes (rectangles) are tested against the search rectangle and their objects (if there are any) are put into the result set if they lie within the search rectangle.
</p><p>For priority search such as nearest neighbor search, the query consists of a point or rectangle. The root node is inserted into the priority queue. Until the queue is empty or the desired number of results have been returned the search continues by processing the nearest entry in the queue. Tree nodes are expanded and their children reinserted. Leaf entries are returned when encountered in the queue.<sup class="reference" id="cite_ref-12">[12]</sup> This approach can be used with various distance metrics, including great-circle distance for geographic data.<sup class="reference" id="cite_ref-geodetic_5-1">[5]</sup>
</p>
<h3><span class="mw-headline" id="Insertion">Insertion</span><span class="mw-editsection"></span></h3>
<p>To insert an object, the tree is traversed recursively from the root node. At each step, all rectangles in the current directory node are examined, and a candidate is chosen using a heuristic such as choosing the rectangle which requires least enlargement. The search then descends into this page, until reaching a leaf node. If the leaf node is full, it must be split before the insertion is made. Again, since an exhaustive search is too expensive, a heuristic is employed to split the node into two. Adding the newly created node to the previous level, this level can again overflow, and these overflows can propagate up to the root node; when this node also overflows, a new root node is created and the tree has increased in height.
</p>
<h4><span class="mw-headline" id="Choosing_the_insertion_subtree">Choosing the insertion subtree</span><span class="mw-editsection"></span></h4>
<p>The algorithm needs to decide in which subtree to insert. When a data object is fully contained in a single rectangle, the choice is clear.  When there are multiple options or rectangles in need of enlargement, the choice can have a significant impact on the performance of the tree.
</p><p>The objects are inserted into the subtree that needs the least enlargement. A Mixture heuristic is employed throughout. What happens next is it tries to minimize the overlap (in case of ties, prefer least enlargement and then least area); at the higher levels, it behaves similar to the R-tree, but on ties again preferring the subtree with smaller area. The decreased overlap of rectangles in the R*-tree is one of the key benefits over the traditional R-tree.
</p>
<h4><span class="mw-headline" id="Splitting_an_overflowing_node">Splitting an overflowing node</span><span class="mw-editsection"></span></h4>
<p>Finally, the X-tree<sup class="reference" id="cite_ref-xtree2_13-0">[13]</sup> can be seen as a R*-tree variant that can also decide to not split a node, but construct a so-called super-node containing all the extra entries, when it doesn't find a good split (in particular for high-dimensional data).
</p>
<h3><span class="mw-headline" id="Deletion">Deletion</span><span class="mw-editsection"></span></h3>
<p>Deleting an entry from a page may require updating the bounding rectangles of parent pages. However, when a page is underfull, it will not be balanced with its neighbors. Instead, the page will be dissolved and all its children (which may be subtrees, not only leaf objects) will be reinserted. If during this process the root node has a single element, the tree height can decrease.
</p>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Expand_section plainlinks metadata ambox mbox-small-left ambox-content" role="presentation"><tbody><tr><td class="mbox-image"><img alt="[icon]" data-file-height="31" data-file-width="44" decoding="async" height="14" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/30px-Wiki_letter_w_cropped.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/40px-Wiki_letter_w_cropped.svg.png 2x" width="20"/></td><td class="mbox-text"></td></tr></tbody></table>
<h3><span class="mw-headline" id="Bulk-loading">Bulk-loading</span><span class="mw-editsection"></span></h3>
<ul><li>Nearest-X: Objects are sorted by their first coordinate ("X") and then split into pages of the desired size.</li>
<li>Packed Hilbert R-tree: variation of Nearest-X, but sorting using the Hilbert value of the center of a rectangle instead of using the X coordinate. There is no guarantee the pages will not overlap.</li>
<li>Sort-Tile-Recursive (STR):<sup class="reference" id="cite_ref-14">[14]</sup> Another variation of Nearest-X, that estimates the total number of leaves required as <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l=\lceil {\text{number of objects}}/{\text{capacity}}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mtext>number of objects</mtext>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mtext>capacity</mtext>
</mrow>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l=\lceil {\text{number of objects}}/{\text{capacity}}\rceil }</annotation>
</semantics>
</math></span><img alt="l=\lceil {\text{number of objects}}/{\text{capacity}}\rceil " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6c3fbcf62709eba7c05620fbeb51918a0ebe7d57" style="vertical-align: -0.838ex; width:33.326ex; height:2.843ex;"/></span>, the required split factor in each dimension to achieve this as <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle s=\lceil l^{1/d}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>s</mi>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<msup>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>d</mi>
</mrow>
</msup>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle s=\lceil l^{1/d}\rceil }</annotation>
</semantics>
</math></span><img alt="s=\lceil l^{{1/d}}\rceil " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/51772bdc30a1bd90f72befdafc257ec49fc64937" style="vertical-align: -0.838ex; width:9.683ex; height:3.343ex;"/></span>, then repeatedly splits each dimensions successively into <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle s}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>s</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle s}</annotation>
</semantics>
</math></span><img alt="s" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/01d131dfd7673938b947072a13a9744fe997e632" style="vertical-align: -0.338ex; width:1.09ex; height:1.676ex;"/></span> equal sized partitions using 1-dimensional sorting. The resulting pages, if they occupy more than one page, are again bulk-loaded using the same algorithm. For point data, the leaf nodes will not overlap, and "tile" the data space into approximately equal sized pages.</li>
<li>Overlap Minimizing Top-down (OMT):<sup class="reference" id="cite_ref-15">[15]</sup> Improvement over STR using a top-down approach which minimizes overlaps between slices and improves query performance.</li>
<li>Priority R-tree</li></ul>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Expand_section plainlinks metadata ambox mbox-small-left ambox-content" role="presentation"><tbody><tr><td class="mbox-image"><img alt="[icon]" data-file-height="31" data-file-width="44" decoding="async" height="14" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/30px-Wiki_letter_w_cropped.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/40px-Wiki_letter_w_cropped.svg.png 2x" width="20"/></td><td class="mbox-text"></td></tr></tbody></table>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Segment tree</li>
<li>Interval tree – A degenerate R-tree for one dimension (usually time).</li>
<li>K-d tree</li>
<li>Bounding volume hierarchy</li>
<li>Spatial index</li>
<li>GiST</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li><img alt="" class="noviewer" data-file-height="1376" data-file-width="1024" decoding="async" height="16" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/12px-Commons-logo.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/18px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/24px-Commons-logo.svg.png 2x" width="12"/> Media related to R-tree at Wikimedia Commons</li></ul>


<!-- 
NewPP limit report
Parsed by mw2363
Cached time: 20221220214801
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.337 seconds
Real time usage: 0.493 seconds
Preprocessor visited node count: 1766/1000000
Post‐expand include size: 72951/2097152 bytes
Template argument size: 1402/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 4/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 58447/5000000 bytes
Lua time usage: 0.207/10.000 seconds
Lua memory usage: 6871114/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  379.900      1 -total
 21.62%   82.116      5 Template:Cite_book
 13.82%   52.494      1 Template:Short_description
 11.28%   42.834      2 Template:Expand_section
 10.42%   39.587      2 Template:Navbox
 10.32%   39.198      1 Template:CS-Trees
  9.98%   37.922      2 Template:Ambox
  9.15%   34.750      1 Template:Infobox_data_structure
  8.38%   31.854      1 Template:Infobox
  7.12%   27.039      5 Template:Cite_conference
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:865249-0!canonical and timestamp 20221220214801 and revision id 1127042729.
 -->
</div></body>
</html>