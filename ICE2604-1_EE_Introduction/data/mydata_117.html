<!DOCTYPE html>
<html>
<head>
<title>bit_vector</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>A <b>bit array</b> (also known as <b>bitmask</b>,<sup class="reference" id="cite_ref-linux_1-0">[1]</sup> <b>bit map</b>, <b>bit set</b>, <b>bit string</b>, or <b>bit vector</b>) is an array data structure that compactly stores bits. It can be used to implement a simple set data structure. A bit array is effective at exploiting bit-level parallelism in hardware to perform operations quickly. A typical bit array stores <i>kw</i> bits, where <i>w</i> is the number of bits in the unit of storage, such as a byte or word, and <i>k</i> is some nonnegative integer. If <i>w</i> does not divide the number of bits to be stored, some space is wasted due to internal fragmentation.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>A bit array is a mapping from some domain (almost always a range of integers) to values in the set {0, 1}. The values can be interpreted as dark/light, absent/present, locked/unlocked, valid/invalid, et cetera. The point is that there are only two possible values, so they can be stored in one bit. As with other arrays, the access to a single bit can be managed by applying an index to the array. Assuming its size (or length) to be <i>n</i> bits, the array can be used to specify a subset of the domain (e.g. {0, 1, 2, ..., <i>n</i>−1}), where a 1-bit indicates the presence and a 0-bit the absence of a number in the set. This set data structure uses about <i>n</i>/<i>w</i> words of space, where <i>w</i> is the number of bits in each machine word. Whether the least significant bit (of the word) or the most significant bit indicates the smallest-index number is largely irrelevant, but the former tends to be preferred (on little-endian machines).
</p>
<h2><span class="mw-headline" id="Basic_operations">Basic operations</span><span class="mw-editsection"></span></h2>
<p>Although most machines are not able to address individual bits in memory, nor have instructions to manipulate single bits, each bit in a word can be singled out and manipulated using bitwise operations. In particular:
</p>
<ul><li>OR  to set a bit to one: 11101010 OR 00000100 = 11101110</li>
<li>AND to set a bit to zero: 11101010 AND 11111101 = 11101000</li>
<li>AND to determine if a bit is set, by zero-testing :
<dl><dd>11101010 AND 00000001 = 00000000 = 0</dd>
<dd>11101010 AND 00000010 = 00000010 ≠ 0</dd></dl></li>
<li>XOR to invert or toggle a bit:
<dl><dd>11101010 XOR 00000100 = 11101110</dd>
<dd>11101110 XOR 00000100 = 11101010</dd></dl></li>
<li>NOT to invert all bits.
<dl><dd>NOT 10110010 = 01001101</dd></dl></li></ul>
<p>To obtain the bit mask needed for these operations, we can use a bit shift operator to shift the number 1 to the left by the appropriate number of places, as well as bitwise negation if necessary.
</p><p>Given two bit arrays of the same size representing sets, we can compute their union, intersection, and set-theoretic difference using <i>n</i>/<i>w</i> simple bit operations each (2<i>n</i>/<i>w</i> for difference), as well as the complement of either:
</p>
<pre><b>for</b> i <b>from</b> 0 <b>to</b> n/w-1
    complement_a[i] := <b>not</b> a[i]
    union[i]        := a[i] <b>or</b> b[i]
    intersection[i] := a[i] <b>and</b> b[i]
    difference[i]   := a[i] <b>and</b> (<b>not</b> b[i])
</pre>
<p>If we wish to iterate through the bits of a bit array, we can do this efficiently using a doubly nested loop that loops through each word, one at a time. Only <i>n</i>/<i>w</i> memory accesses are required:
</p>
<pre><b>for</b> i <b>from</b> 0 to n/w-1
    index := 0    // if needed
    word := a[i]
    <b>for</b> b <b>from</b> 0 to w-1
        value := word <b>and</b> 1 ≠ 0
        word := word shift right 1
        // do something with value
        index := index + 1    // if needed
</pre>
<p>Both of these code samples exhibit ideal locality of reference, which will subsequently receive large performance boost from a data cache. If a cache line is <i>k</i> words, only about <i>n</i>/<i>wk</i> cache misses will occur.
</p>
<h2><span class="mw-headline" id="More_complex_operations">More complex operations</span><span class="mw-editsection"></span></h2>
<p>As with character strings it is straightforward to define <i>length</i>, <i>substring</i>, lexicographical <i>compare</i>, <i>concatenation</i>, <i>reverse</i> operations. The implementation of some of these operations is sensitive to endianness.
</p>
<h3><span id="Population_.2F_Hamming_weight"></span><span class="mw-headline" id="Population_/_Hamming_weight">Population / Hamming weight</span><span class="mw-editsection"></span></h3>
<p>If we wish to find the number of 1 bits in a bit array, sometimes called the population count or Hamming weight, there are efficient branch-free algorithms that can compute the number of bits in a word using a series of simple bit operations. We simply run such an algorithm on each word and keep a running total. Counting zeros is similar. See the Hamming weight article for examples of an efficient implementation.
</p>
<h3><span class="mw-headline" id="Inversion">Inversion</span><span class="mw-editsection"></span></h3>
<p>Vertical flipping of a one-bit-per-pixel image, or some FFT algorithms, requires flipping the bits of individual words (so <code>b31 b30 ... b0</code> becomes <code>b0 ... b30 b31</code>).
When this operation is not available on the processor, it's still possible to proceed by successive passes, in this example on 32 bits:
</p>

<h3><span class="mw-headline" id="Find_first_one">Find first one</span><span class="mw-editsection"></span></h3>
<p>The find first set or <i>find first one</i> operation identifies the index or position of the 1-bit with the smallest index in an array, and has widespread hardware support (for arrays not larger than a word) and efficient algorithms for its computation. When a priority queue is stored in a bit array, find first one can be used to identify the highest priority element in the queue. To expand a word-size <i>find first one</i> to longer arrays, one can find the first nonzero word and then run <i>find first one</i> on that word. The related operations <i>find first zero</i>, <i>count leading zeros</i>, <i>count leading ones</i>, <i>count trailing zeros</i>, <i>count trailing ones</i>, and <i>log base 2</i> (see find first set) can also be extended to a bit array in a straightforward manner.
</p>
<h2><span class="mw-headline" id="Compression">Compression</span><span class="mw-editsection"></span></h2>
<p>A bit array is the most dense storage for "random" bits, that is, where each bit is equally likely to be 0 or 1, and each one is independent. But most data are not random, so it may be possible to store it more compactly. For example, the data of a typical fax image is not random and can be compressed. Run-length encoding is commonly used to compress these long streams. However, most compressed data formats are not so easy to access randomly; also by compressing bit arrays too aggressively we run the risk of losing the benefits due to bit-level parallelism (vectorization). Thus, instead of compressing bit arrays as streams of bits, we might compress them as streams of bytes or words (see Bitmap index (compression)).
</p>
<h2><span class="mw-headline" id="Advantages_and_disadvantages">Advantages and disadvantages</span><span class="mw-editsection"></span></h2>
<p>Bit arrays, despite their simplicity, have a number of marked advantages over other data structures for the same problems:
</p>
<ul><li>They are extremely compact; no other data structures can store <i>n</i> independent pieces of data in <i>n</i>/<i>w</i> words.</li>
<li>They allow small arrays of bits to be stored and manipulated in the register set for long periods of time with no memory accesses.</li>
<li>Because of their ability to exploit bit-level parallelism, limit memory access, and maximally use the data cache, they often outperform many other data structures on practical data sets, even those that are more asymptotically efficient.</li></ul>
<p>However, bit arrays aren't the solution to everything. In particular:
</p>
<ul><li>Without compression, they are wasteful set data structures for sparse sets (those with few elements compared to their range) in both time and space. For such applications, compressed bit arrays, Judy arrays, tries, or even Bloom filters should be considered instead.</li>
<li>Accessing individual elements can be expensive and difficult to express in some languages. If random access is more common than sequential and the array is relatively small, a byte array may be preferable on a machine with byte addressing. A word array, however, is probably not justified due to the huge space overhead and additional cache misses it causes, unless the machine only has word addressing.</li></ul>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Because of their compactness, bit arrays have a number of applications in areas where space or efficiency is at a premium. Most commonly, they are used to represent a simple group of boolean flags or an ordered sequence of boolean values.
</p><p>Bit arrays are used for priority queues, where the bit at index <i>k</i> is set if and only if <i>k</i> is in the queue; this data structure is used, for example, by the Linux kernel, and benefits strongly from a find-first-zero operation in hardware.
</p><p>Bit arrays can be used for the allocation of memory pages, inodes, disk sectors, etc. In such cases, the term <i>bitmap</i> may be used. However, this term is frequently used to refer to raster images, which may use multiple bits per pixel.
</p><p>Another application of bit arrays is the Bloom filter, a probabilistic set data structure that can store large sets in a small space in exchange for a small probability of error. It is also possible to build probabilistic hash tables based on bit arrays that accept either false positives or false negatives.
</p><p>Bit arrays and the operations on them are also important for constructing succinct data structures, which use close to the minimum possible space. In this context, operations like finding the <i>n</i>th 1 bit or counting the number of 1 bits up to a certain position become important.
</p><p>Bit arrays are also a useful abstraction for examining streams of compressed data, which often contain elements that occupy portions of bytes or are not byte-aligned. For example, the compressed Huffman coding representation of a single 8-bit character can be anywhere from 1 to 255 bits long.
</p><p>In information retrieval, bit arrays are a good representation for the posting lists of very frequent terms. If we compute the gaps between adjacent values in a list of strictly increasing integers and encode them using unary coding, the result is a bit array with a 1 bit in the <i>n</i>th position if and only if <i>n</i> is in the list. The implied probability of a gap of <i>n</i> is 1/2<sup><i>n</i></sup>. This is also the special case of Golomb coding where the parameter M is 1; this parameter is only normally selected when <span class="texhtml">−log(2 − <i>p</i>) / log(1 − <i>p</i>) ≤ 1</span>, or roughly the term occurs in at least 38% of documents.
</p>
<h2><span class="mw-headline" id="Language_support">Language support</span><span class="mw-editsection"></span></h2>
<p>The APL programming language fully supports bit arrays of arbitrary shape and size as a Boolean datatype distinct from integers. All major implementations (Dyalog APL, APL2, APL Next, NARS2000, Gnu APL, etc.) pack the bits densely into whatever size the machine word is. Bits may be accessed individually via the usual indexing notation (A[3]) as well as through all of the usual primitive functions and operators where they are often operated on using a special case algorithm such as summing the bits via a table lookup of bytes.
</p><p>The C programming language's <i>bit fields</i>, pseudo-objects found in structs with size equal to some number of bits, are in fact small bit arrays; they are limited in that they cannot span words. Although they give a convenient syntax, the bits are still accessed using bytewise operators on most machines, and they can only be defined statically (like C's static arrays, their sizes are fixed at compile-time). It is also a common idiom for C programmers to use words as small bit arrays and access bits of them using bit operators. A widely available header file included in the X11 system, xtrapbits.h, is “a portable way for systems to define bit field manipulation of arrays of bits.” A more explanatory description of aforementioned approach can be found in the comp.lang.c faq.
</p><p>In C++, although individual <code>bool</code>s typically occupy the same space as a byte or an integer, the STL type <code>vector&lt;bool&gt;</code> is a partial template specialization in which bits are packed as a space efficiency optimization. Since bytes (and not bits) are the smallest addressable unit in C++, the [] operator does <i>not</i> return a reference to an element, but instead returns a proxy reference. This might seem a minor point, but it means that <code>vector&lt;bool&gt;</code> is <i>not</i> a standard STL container, which is why the use of <code>vector&lt;bool&gt;</code> is generally discouraged. Another unique STL class, <code>bitset</code>,<sup class="reference" id="cite_ref-c++_2-0">[2]</sup> creates a vector of bits fixed at a particular size at compile-time, and in its interface and syntax more resembles the idiomatic use of words as bit sets by C programmers. It also has some additional power, such as the ability to efficiently count the number of bits that are set. The Boost C++ Libraries provide a <code>dynamic_bitset</code> class<sup class="reference" id="cite_ref-boost_3-0">[3]</sup> whose size is specified at run-time.
</p><p>The D programming language provides bit arrays in its standard library, Phobos, in <code>std.bitmanip</code>. As in C++, the [] operator does not return a reference, since individual bits are not directly addressable on most hardware, but instead returns a <code>bool</code>.
</p><p>In Java, the class <code>BitSet</code> creates a bit array that is then manipulated with functions named after bitwise operators familiar to C programmers. Unlike the <code>bitset</code> in C++, the Java <code>BitSet</code> does not have a "size" state (it has an effectively infinite size, initialized with 0 bits); a bit can be set or tested at any index. In addition, there is a class <code>EnumSet</code>, which represents a Set of values of an enumerated type internally as a bit vector, as a safer alternative to bit fields.
</p><p>The .NET Framework supplies a <code>BitArray</code> collection class. It stores bits using an array of type <code>int</code> (each element in the array usually represents 32 bits).<sup class="reference" id="cite_ref-4">[4]</sup> The class supports random access and bitwise operators, can be iterated over, and its <code>Length</code> property can be changed to grow or truncate it.
</p><p>Although Standard ML has no support for bit arrays, Standard ML of New Jersey has an extension, the <code>BitArray</code> structure, in its SML/NJ Library. It is not fixed in size and supports set operations and bit operations, including, unusually, shift operations.
</p><p>Haskell likewise currently lacks standard support for bitwise operations, but both GHC and Hugs provide a <code>Data.Bits</code> module with assorted bitwise functions and operators, including shift and rotate operations and an "unboxed" array over boolean values may be used to model a Bit array, although this lacks support from the former module.
</p><p>In Perl, strings can be used as expandable bit arrays. They can be manipulated using the usual bitwise operators (<code>~ | &amp; ^</code>),<sup class="reference" id="cite_ref-5">[5]</sup> and individual bits can be tested and set using the <i>vec</i> function.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>In Ruby, you can access (but not set) a bit of an integer (<code>Fixnum</code> or <code>Bignum</code>) using the bracket operator (<code>[]</code>), as if it were an array of bits.
</p><p>Apple's Core Foundation library contains CFBitVector and CFMutableBitVector structures.
</p><p>PL/I supports arrays of <i>bit strings</i> of arbitrary length, which may be either fixed-length or varying. The array elements may be <i>aligned</i>— each element begins on a byte or word boundary— or <i>unaligned</i>— elements immediately follow each other with no padding.
</p><p>PL/pgSQL and PostgreSQL's SQL support <i>bit strings</i> as native type. There are two SQL bit types: <code>bit(<i><code>n</code></i>)</code> and <code>bit varying(<i><code>n</code></i>)</code>, where <i><code>n</code></i> is a positive integer.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>Hardware description languages such as VHDL, Verilog, and SystemVerilog natively support bit vectors as these are used to model storage elements like flip-flops, hardware busses and hardware signals in general. In hardware verification languages such as OpenVera, <i>e</i> and SystemVerilog, bit vectors are used to sample values from the hardware models, and to represent data that is transferred to hardware during simulations.
</p><p>Common Lisp provides a one-dimensional <code>bit-vector</code> implementation as a special case of the built-in <code>array</code>, acting in a dual capacity as a class and a type specifier.<sup class="reference" id="cite_ref-8">[8]</sup> Being a derivative of the array, it relies on the general <code>make-array</code> function to be configured with an element type of <code>bit</code>, which optionally permits the bit vector to be designated as dynamically resizable. The <code>bit-vector</code>, however, is not infinite in extent. A more restricted <code>simple-bit-vector</code> type exists, which explicitly excludes the dynamic characteristics.<sup class="reference" id="cite_ref-9">[9]</sup> Bit vectors are represented as, and can be constructed in a more concise fashion by, the <i>reader macro</i> <code>#*<i>bits</i></code>.<sup class="reference" id="cite_ref-10">[10]</sup> In addition to the general functions applicable to all arrays, dedicated operations exist for bit vectors. Single bits may be accessed and modified using the <code>bit</code> and <code>sbit</code> functions<sup class="reference" id="cite_ref-11">[11]</sup> and an extensive number of logical operations is supported.<sup class="reference" id="cite_ref-12">[12]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Arithmetic logic unit</li>
<li>Binary code</li>
<li>Binary numeral system</li>
<li>Bitboard Chess and similar games.</li>
<li>Bit field</li>
<li>Bitmap index</li>
<li>Bitstream</li>
<li>Finite field of 2 elements, or GF(2)</li>
<li>Judy array</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>mathematical bases by Pr. D.E.Knuth</li>
<li>vector&lt;bool&gt; Is Nonconforming, and Forces Optimization Choice</li>
<li>vector&lt;bool&gt;: More Problems, Better Solutions</li></ul>

<!-- 
NewPP limit report
Parsed by mw2333
Cached time: 20221224002353
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.242 seconds
Real time usage: 0.322 seconds
Preprocessor visited node count: 971/1000000
Post‐expand include size: 35194/2097152 bytes
Template argument size: 868/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 37524/5000000 bytes
Lua time usage: 0.144/10.000 seconds
Lua memory usage: 5069900/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  275.301      1 -total
 38.81%  106.844      1 Template:Reflist
 32.71%   90.054     12 Template:Cite_web
 21.94%   60.395      1 Template:Short_description
 20.06%   55.231      1 Template:More_citations_needed
 18.55%   51.070      1 Template:Ambox
 14.64%   40.313      1 Template:Data_structures
 13.87%   38.183      1 Template:Navbox
 11.26%   30.990      2 Template:Pagetype
  6.55%   18.019      4 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1189937-0!canonical and timestamp 20221224002353 and revision id 1122710440.
 -->
</div></body>
</html>