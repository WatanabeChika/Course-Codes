<!DOCTYPE html>
<html>
<head>
<title>van_Emde-Boas_priority_queue</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Tone plainlinks metadata ambox ambox-style ambox-Tone" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">van Emde Boas tree</th></tr><tr><th class="infobox-label" scope="row">Type</th><td class="infobox-data">Non-binary tree</td></tr><tr><th class="infobox-label" scope="row">Invented</th><td class="infobox-data">1975</td></tr><tr><th class="infobox-label" scope="row">Invented by</th><td class="infobox-data">Peter van Emde Boas</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Space</th><td class="infobox-data infobox-data-a">
<span class="texhtml"><i>O</i>(<i>M</i>)</span></td><td class="infobox-data infobox-data-b">
<span class="texhtml"><i>O</i>(<i>M</i>)</span></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td><td class="infobox-data infobox-data-b">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td><td class="infobox-data infobox-data-b">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Delete</th><td class="infobox-data infobox-data-a">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td><td class="infobox-data infobox-data-b">
<span class="texhtml"><i>O</i>(log log <i>M</i>)</span></td></tr></tbody></table></td></tr></tbody></table>
<p>A <b>van Emde Boas tree</b> (<small>Dutch pronunciation: </small><span class="IPA" lang="nl-Latn-fonipa" title="Representation in the International Phonetic Alphabet (IPA)">[vɑn ˈɛmdə ˈboːɑs]</span>), also known as a <b>vEB tree</b> or <b>van Emde Boas priority queue</b>, is a tree data structure which implements an associative array with <span class="texhtml"><i>m</i></span>-bit integer keys. It was invented by a team led by Dutch computer scientist Peter van Emde Boas in 1975.<sup class="reference" id="cite_ref-1">[1]</sup> It performs all operations in <span class="texhtml"><i>O</i>(log <i>m</i>)</span> time, or equivalently in <span class="texhtml"><i>O</i>(log log <i>M</i>)</span> time, where <span class="texhtml"><i>M</i> = 2<sup><i>m</i></sup></span> is the largest element that can be stored in the tree. The parameter <span class="texhtml"><i>M</i></span> is not to be confused with the actual number of elements stored in the tree, by which the performance of other tree data-structures is often measured. 
</p><p>The vEB tree has poor space efficiency. For example, for storing 32-bit integers (i.e., when <span class="texhtml"><i>m</i>=32</span>), it requires <span class="texhtml"><i>M</i>=2<sup>32</sup></span> bits of storage. However, similar data structures with equally good time efficiency and space <span class="texhtml"><i>O</i>(<i>n</i>)</span> exist, where <span class="texhtml"><i>n</i></span> is the number of stored elements. 
</p>

<h2><span class="mw-headline" id="Supported_operations">Supported operations</span><span class="mw-editsection"></span></h2>
<p>A vEB supports the operations of an <i>ordered associative array</i>, which includes the usual associative array operations along with two more <i>order</i> operations, <i>FindNext</i> and <i>FindPrevious</i>:<sup class="reference" id="cite_ref-2">[2]</sup>
</p>
<ul><li><i>Insert</i>: insert a key/value pair with an <span class="texhtml"><i>m</i></span>-bit key</li>
<li><i>Delete</i>: remove the key/value pair with a given key</li>
<li><i>Lookup</i>: find the value associated with a given key</li>
<li><i>FindNext</i>: find the key/value pair with the smallest key which is greater than a given <span class="texhtml"><i>k</i></span></li>
<li><i>FindPrevious</i>: find the key/value pair with the largest key which is smaller than a given <span class="texhtml"><i>k</i></span></li></ul>
<p>A vEB tree also supports the operations <i>Minimum</i> and <i>Maximum</i>, which return the minimum and maximum element stored in the tree respectively.<sup class="reference" id="cite_ref-3">[3]</sup> These both run in <span class="texhtml"><i>O</i>(1)</span> time, since the minimum and maximum element are stored as attributes in each tree.
</p>
<h2><span class="mw-headline" id="Function">Function</span><span class="mw-editsection"></span></h2>
<p> For the sake of simplicity, let <span class="texhtml">log<sub>2</sub> <i>m</i> = <i>k</i></span> for some integer <i>k</i>.  Define <span class="texhtml"><i>M</i> = 2<sup><i>m</i></sup></span>.  A vEB tree <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">T</span> over the universe <span class="texhtml">{0, ..., <i>M</i>−1</span>} has a root node that stores an array <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children</span> of length <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>.  <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> is a pointer to a vEB tree that is responsible for the values <span class="texhtml">{<i>i</i><span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>, ..., (<i>i</i>+1)<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>−1</span>}.  Additionally, <i>T</i> stores two values <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max</span> as well as an auxiliary vEB tree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span>.
</p><p>Data is stored in a vEB tree as follows: The smallest value currently in the tree is stored in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> and largest value is stored in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max</span>.  Note that <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> is not stored anywhere else in the vEB tree, while <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max</span> is. If <i>T</i> is empty then we use the convention that <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max=−1</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min=M</span>.  Any other value <i>x</i> is stored in the subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> where <span class="texhtml"><i>i</i> = ⌊<i>x</i>/<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>⌋</span>.  The auxiliary tree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span> keeps track of which children are non-empty, so <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span> contains the value <i>j</i> if and only if <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[j]</span> is non-empty.
</p>
<h3><span class="mw-headline" id="FindNext">FindNext</span><span class="mw-editsection"></span></h3>
<p>The operation <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">FindNext(T, x)</span> that searches for the successor of an element <i>x</i> in a vEB tree proceeds as follows: If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced"><i>x</i>&lt;T.min</span> then the search is complete, and the answer is <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span>.  If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x≥T.max</span> then the next element does not exist, return M. Otherwise, let <span class="texhtml"><i>i</i> = ⌊<i>x</i>/<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>⌋</span>.  If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x&lt;T.children[i].max</span> then the value being searched for is contained in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> so the search proceeds recursively in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span>.  Otherwise, we search for the successor of the value <i>i</i> in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span>.  This gives us the index <i>j</i> of the first subtree that contains an element larger than <i>x</i>.  The algorithm then returns <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[j].min</span>. The element found on the children level needs to be composed with the high bits to form a complete next element.
</p>
<pre><b>function</b> FindNext(T, x)
    <b>if</b> x &lt; T.min <b>then</b>
        <b>return</b> T.min
    <b>if</b> x ≥ T.max <b>then</b> <i>// no next element</i>
        <b>return</b> M
    i = floor(x/<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>)
    lo = x mod <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>
    
    <b>if</b> lo &lt; T.children[i].max <b>then</b>
        <b>return</b> (<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span> i) + FindNext(T.children[i], lo)
    j = FindNext(T.aux, i)
    <b>return</b> (<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span> j) + T.children[j].min
<b>end</b>
</pre>
<p>Note that, in any case, the algorithm performs <span class="texhtml"><i>O</i>(1)</span> work and then possibly recurses on a subtree over a universe of size <span class="texhtml"><i>M</i><sup><style data-mw-deduplicate="TemplateStyles:r1050945101">.mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="sfrac tion" role="math"><span class="num">1</span><span class="sr-only">/</span><span class="den">2</span></span></sup></span> (an <span class="texhtml"><link href="mw-data:TemplateStyles:r1050945101" rel="mw-deduplicated-inline-style"/><span class="sfrac tion" role="math"><span class="num"><i>m</i></span><span class="sr-only">/</span><span class="den">2</span></span></span> bit universe). This gives a recurrence for the running time of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T(m)=T(m/2)+O(1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T(m)=T(m/2)+O(1)}</annotation>
</semantics>
</math></span><img alt="T(m)=T(m/2) + O(1)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bbcbd5fc0273d9d162e966ef4db6d59a36a4ccfb" style="vertical-align: -0.838ex; width:23.981ex; height:2.843ex;"/></span>, which resolves to <span class="texhtml"><i>O</i>(log <i>m</i>) = <i>O</i>(log log <i>M</i>)</span>.
</p>
<h3><span class="mw-headline" id="Insert">Insert</span><span class="mw-editsection"></span></h3>
<p>The call <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">insert(T, x)</span> that inserts a value <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x</span> into a vEB tree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T</span> operates as follows:
</p>
<ol><li>If <i>T</i> is empty then we set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min = T.max = x</span> and we are done.</li>
<li>Otherwise, if <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x&lt;T.min</span> then we insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> into the subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> responsible for <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> and then set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min = x</span>.  If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> was previously empty, then we also insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> into <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span></li>
<li>Otherwise, if <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x&gt;T.max</span> then we insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x</span> into the subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> responsible for <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x</span> and then set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max = x</span>.  If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> was previously empty, then we also insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> into <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span></li>
<li>Otherwise, <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min&lt; x &lt; T.max</span> so we insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x</span> into the subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> responsible for <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x</span>.  If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> was previously empty, then we also insert <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">i</span> into <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span>.</li></ol>
<p>In code:
</p>
<pre><b>function</b> Insert(T, x)
    <b>if</b> T.min &gt; T.max <b>then</b> <i>// T is empty</i>
        T.min = T.max = x;
        <b>return</b>
    <b>if</b> x &lt; T.min <b>then</b>
        swap(x, T.min)
    <b>if</b> x &gt; T.max <b>then</b>
        T.max = x
    i = floor(x / <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>)
    lo = x mod <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>
    Insert(T.children[i], lo)
    <b>if</b> T.children[i].min == T.children[i].max <b>then</b>
        Insert(T.aux, i)
<b>end</b>
</pre>
<p>The key to the efficiency of this procedure is that inserting an element into an empty vEB tree takes <span class="texhtml"><i>O</i>(1)</span> time.  So, even though the algorithm sometimes makes two recursive calls, this only occurs when the first recursive call was into an empty subtree.  This gives the same running time recurrence of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T(m)=T(m/2)+O(1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T(m)=T(m/2)+O(1)}</annotation>
</semantics>
</math></span><img alt="T(m)=T(m/2) + O(1)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bbcbd5fc0273d9d162e966ef4db6d59a36a4ccfb" style="vertical-align: -0.838ex; width:23.981ex; height:2.843ex;"/></span> as before.
</p>
<h3><span class="mw-headline" id="Delete">Delete</span><span class="mw-editsection"></span></h3>
<p>Deletion from vEB trees is the trickiest of the operations. The call <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">Delete(T, x)</span> that deletes a value <i>x</i> from a vEB tree T operates as follows:
</p>
<ol><li>If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min = T.max = x</span> then <i>x</i> is the only element stored in the tree and we set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min = M</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max = −1</span> to indicate that the tree is empty.</li>
<li>Otherwise, if <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x == T.min</span> then we need to find the second-smallest value <i>y</i> in the vEB tree, delete it from its current location, and set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min=y</span>.  The second-smallest value <i>y</i> is <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[T.aux.min].min</span>, so it can be found in <span class="texhtml"><i>O</i>(1)</span> time.  We delete <i>y</i> from the subtree that contains it.</li>
<li>If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x≠T.min</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x≠T.max</span> then we delete x from the subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> that contains <i>x</i>.</li>
<li>If <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">x == T.max</span> then we will need to find the second-largest value <i>y</i> in the vEB tree and set <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.max=y</span>. We start by deleting x as in previous case. Then value <i>y</i> is either <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.min</span> or <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[T.aux.max].max</span>, so it can be found in <span class="texhtml"><i>O</i>(1)</span> time.</li>
<li>In any of the above cases, if we delete the last element <i>x</i> or <i>y</i> from any subtree <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> then we also delete <i>i</i> from <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.aux</span>.</li></ol>
<p>In code:
</p>
<pre><b>function</b> Delete(T, x)
    <b>if</b> T.min == T.max == x <b>then</b>
        T.min = M
        T.max = −1
        <b>return</b>
    <b>if</b> x == T.min <b>then</b>
        hi = T.aux.min * <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>
        j = T.aux.min
        T.min = x = hi + T.children[j].min
    i = floor(x / <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>)
    lo = x mod <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>
    Delete(T.children[i], lo)
    <b>if</b> T.children[i] is empty <b>then</b>
        Delete(T.aux, i)
    <b>if</b> x == T.max <b>then</b>
        <b>if</b> T.aux is empty <b>then</b>
            T.max = T.min
        <b>else</b>
            hi = T.aux.max * <span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>M</i></span></span>
            j = T.aux.max
            T.max = hi + T.children[j].max
<b>end</b>
</pre>
<p>Again, the efficiency of this procedure hinges on the fact that deleting from a vEB tree that contains only one element takes only constant time.  In particular, the second Delete call only executes if <i>x</i> was the only element in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">T.children[i]</span> prior to the deletion.
</p>
<h3><span class="mw-headline" id="Discussion">Discussion</span><span class="mw-editsection"></span></h3>
<p>The assumption that <span class="texhtml">log <i>m</i></span> is an integer is unnecessary.  The operations <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x{\sqrt {M}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x{\sqrt {M}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle x{\sqrt {M}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/140e5492b9e270f491fe69e0c3ae93d34cd95ea0" style="vertical-align: -0.671ex; width:5.708ex; height:3.009ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x{\bmod {\sqrt {M}}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo lspace="thickmathspace" rspace="thickmathspace">mod</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x{\bmod {\sqrt {M}}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle x{\bmod {\sqrt {M}}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3cdd2ef54491660d58abaa69aa3a88f6592f123c" style="vertical-align: -0.671ex; width:11.389ex; height:3.009ex;"/></span> can be replaced by taking only higher-order <span class="texhtml">⌈<i>m</i>/2⌉</span> and the lower-order <span class="texhtml">⌊<i>m</i>/2⌋</span> bits of <span class="texhtml mvar" style="font-style:italic;">x</span>, respectively.  On any existing machine, this is more efficient than division or remainder computations.
</p><p>In practical implementations, especially on machines with <i>shift-by-k</i> and <i>find first zero</i> instructions, performance can further be improved by switching to a bit array once <span class="texhtml mvar" style="font-style:italic;">m</span> equal to the word size (or a small multiple thereof) is reached. Since all operations on a single word are constant time, this does not affect the asymptotic performance, but it does avoid the majority of the pointer storage and several pointer dereferences, achieving a significant practical savings in time and space with this trick.
</p><p>An obvious optimization of vEB trees is to discard empty subtrees. This makes vEB trees quite compact when they contain many elements, because no subtrees are created until something needs to be added to them. Initially, each element added creates about <span class="texhtml">log(<i>m</i>)</span> new trees containing about <span class="texhtml"><i>m</i>/2</span> pointers all together. As the tree grows, more and more subtrees are reused, especially the larger ones. In a full tree of <span class="texhtml"><i>M</i></span> elements, only <span class="texhtml">O(<i>M</i>)</span> space is used. Moreover, unlike a binary search tree, most of this space is being used to store data: even for billions of elements, the pointers in a full vEB tree number in the thousands.
</p><p>The implementation described above uses pointers and occupies a total space of <span class="texhtml"><i>O</i>(<i>M</i>) = <i>O</i>(2<sup><i>m</i></sup>)</span>, proportional to the size of the key universe. This can be seen as follows. The recurrence is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle S(M)=O({\sqrt {M}})+({\sqrt {M}}+1)\cdot S({\sqrt {M}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>S</mi>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>⋅<!-- ⋅ --></mo>
<mi>S</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle S(M)=O({\sqrt {M}})+({\sqrt {M}}+1)\cdot S({\sqrt {M}})}</annotation>
</semantics>
</math></span><img alt="S(M)=O({\sqrt  {M}})+({\sqrt  {M}}+1)\cdot S({\sqrt  {M}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cdb45e97ad6e2aad45a2b6cd14ac3b74c35cb870" style="vertical-align: -0.838ex; width:39.206ex; height:3.176ex;"/></span>.
Resolving that would lead to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle S(M)\in (1+{\sqrt {M}})^{\log \log M}+\log \log M\cdot O({\sqrt {M}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>S</mi>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
<mo>∈<!-- ∈ --></mo>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
<msup>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>M</mi>
</mrow>
</msup>
<mo>+</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>M</mi>
<mo>⋅<!-- ⋅ --></mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>M</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle S(M)\in (1+{\sqrt {M}})^{\log \log M}+\log \log M\cdot O({\sqrt {M}})}</annotation>
</semantics>
</math></span><img alt="S(M)\in (1+{\sqrt  {M}})^{{\log \log M}}+\log \log M\cdot O({\sqrt  {M}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/517516cc31e97bf13b4b46755126fb781a847cfd" style="vertical-align: -0.838ex; width:47.358ex; height:3.176ex;"/></span>.
One can, fortunately, also show that <span class="texhtml"><i>S</i>(<i>M</i>) = <i>M</i>−2</span> by induction.<sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<h3><span class="mw-headline" id="Similar_structures">Similar structures</span><span class="mw-editsection"></span></h3>
<p>The <span class="texhtml"><i>O</i>(<i>M</i>)</span> space usage of vEB trees is an enormous overhead unless a large fraction of the universe of keys is being stored. This is one reason why vEB trees are not popular in practice. This limitation can be addressed by changing the array used to store children to another data structure. One possibility is to use only a fixed number of bits per level, which results in a trie.  Alternatively, each array may be replaced by a hash table, reducing the space to <span class="texhtml"><i>O</i>(<i>n</i>)</span> (where <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of elements stored in the data structure) at the expense of making the data structure randomized. Other data structures including x-fast tries and y-fast tries have comparable update and query times to vEB trees and also use randomized hash tables to reduce the space to <span class="texhtml"><i>O</i>(<i>n</i> log <i>M</i>)</span> and <span class="texhtml"><i>O</i>(<i>n</i>)</span> respectively.
</p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"></span></h2>
<p>There is a verified implementation in Isabelle (proof assistant).<sup class="reference" id="cite_ref-5">[5]</sup> Both functional correctness and time bounds are proved.
Efficient imperative Standard ML code can be generated.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Integer sorting</li>
<li>Predecessor problem</li>
<li>Fusion tree</li>
<li>Tango tree</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h3><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>

<!-- 
NewPP limit report
Parsed by mw2331
Cached time: 20221220224515
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.322 seconds
Real time usage: 0.437 seconds
Preprocessor visited node count: 5180/1000000
Post‐expand include size: 58215/2097152 bytes
Template argument size: 8974/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 31279/5000000 bytes
Lua time usage: 0.132/10.000 seconds
Lua memory usage: 3788403/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  332.669      1 -total
 31.24%  103.928      1 Template:Reflist
 17.70%   58.876      2 Template:Cite_web
 16.01%   53.270     47 Template:Math
 15.05%   50.080      1 Template:Tone
 13.32%   44.325      1 Template:Infobox_data_structure
 12.54%   41.709      1 Template:Infobox
 11.61%   38.618      1 Template:CS_trees
 11.07%   36.842      1 Template:Navbox
  9.53%   31.706      1 Template:ISBN
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1189425-0!canonical and timestamp 20221220224514 and revision id 1116729928.
 -->
</div></body>
</html>