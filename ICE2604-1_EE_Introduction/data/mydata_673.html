<!DOCTYPE html>
<html>
<head>
<title>NP-hard</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In computational complexity theory, <b>NP-hardness</b> (non-deterministic polynomial-time hardness) is the defining property of a class of problems that are informally "at least as hard as the hardest problems in NP". A simple example of an NP-hard problem is the subset sum problem.
</p><p>A more precise specification is: a problem <i>H</i> is NP-hard when every problem <i>L</i> in NP can be reduced in polynomial time to <i>H</i>; that is, assuming a solution for <i>H</i> takes 1 unit time, <i>H</i><span class="nowrap" style="padding-left:0.1em;">'</span>s solution can be used to solve <i>L</i> in polynomial time.<sup class="reference" id="cite_ref-Leeuwen_1-0">[1]</sup><sup class="reference" id="cite_ref-2">[2]</sup> As a consequence, finding a polynomial time algorithm to solve any NP-hard problem would give polynomial time algorithms for all the problems in NP. As it is suspected that P≠NP, it is unlikely that such an algorithm exists.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>It is suspected that there are no polynomial-time algorithms for NP-hard problems, but that has not been proven.<sup class="reference" id="cite_ref-4">[4]</sup> Moreover, the class P, in which all problems can be solved in polynomial time, is contained in the NP class.<sup class="reference" id="cite_ref-5">[5]</sup>
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>A decision problem <i>H</i> is NP-hard when for every problem <i>L</i> in NP, there is a polynomial-time many-one reduction from <i>L</i> to <i>H</i>.<sup class="reference" id="cite_ref-Leeuwen_1-1">[1]</sup><sup class="reference nowrap"><span title="Page / location: 80">: 80 </span></sup>
An equivalent definition is to require that every problem <i>L</i> in NP can be solved in polynomial time by an oracle machine with an oracle for <i>H</i>.<sup class="reference" id="cite_ref-6">[6]</sup> Informally, an algorithm can be thought of that calls such an oracle machine as a subroutine for solving <i>H</i> and solves <i>L</i> in polynomial time if the subroutine call takes only one step to compute.
</p><p>Another definition is to require that there be a polynomial-time reduction from an NP-complete problem <i>G</i> to <i>H</i>.<sup class="reference" id="cite_ref-Leeuwen_1-2">[1]</sup><sup class="reference nowrap"><span title="Page / location: 91">: 91 </span></sup> As any problem <i>L</i> in NP reduces in polynomial time to <i>G</i>, <i>L</i> reduces in turn to <i>H</i> in polynomial time so this new definition implies the previous one. Awkwardly, it does not restrict the class NP-hard to decision problems, and it also includes search problems or optimization problems.
</p>
<h2><span class="mw-headline" id="Consequences">Consequences</span><span class="mw-editsection"></span></h2>
<p>If P ≠ NP, then NP-hard problems could not be solved in polynomial time.
</p><p>Some NP-hard optimization problems can be polynomial-time approximated up to some constant approximation ratio (in particular, those in APX) or even up to any approximation ratio (those in PTAS or FPTAS).
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>An example of an NP-hard problem is the decision subset sum problem: given a set of integers, does any non-empty subset of them add up to zero? That is a decision problem and happens to be NP-complete. Another example of an NP-hard problem is the optimization problem of finding the least-cost cyclic route through all nodes of a weighted graph. This is commonly known as the travelling salesman problem.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>There are decision problems that are <i>NP-hard</i> but not <i>NP-complete</i> such as the halting problem. That is the problem which asks "given a program and its input, will it run forever?" That is a <i>yes</i>/<i>no</i> question and so is a decision problem. It is easy to prove that the halting problem is NP-hard but not NP-complete. For example, the Boolean satisfiability problem can be reduced to the halting problem by transforming it to the description of a Turing machine that tries all truth value assignments and when it finds one that satisfies the formula it halts and otherwise it goes into an infinite loop. It is also easy to see that the halting problem is not in <i>NP</i> since all problems in NP are decidable in a finite number of operations, but the halting problem, in general, is undecidable. There are also NP-hard problems that are neither <i>NP-complete</i> nor <i>Undecidable</i>. For instance, the language of true quantified Boolean formulas is decidable in polynomial space, but not in non-deterministic polynomial time (unless NP = PSPACE).<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<h2><span class="mw-headline" id="NP-naming_convention">NP-naming convention</span><span class="mw-editsection"></span></h2>
<p>NP-hard problems do not have to be elements of the complexity class NP.
As NP plays a central role in computational complexity, it is used as the basis of several classes:
</p>
<dl><dt>NP</dt>
<dd>Class of computational decision problems for which any given <i>yes</i>-solution can be verified as a solution in polynomial time by a deterministic Turing machine (or <i>solvable</i> by a <i>non-deterministic</i> Turing machine in polynomial time).</dd>
<dt>NP-hard</dt>
<dd>Class of problems which are at least as hard as the hardest problems in NP. Problems that are NP-hard do not have to be elements of NP; indeed, they may not even be decidable.</dd>
<dt>NP-complete</dt>
<dd>Class of decision problems which contains the hardest problems in NP. Each NP-complete problem has to be in NP.</dd>
<dt>NP-easy</dt>
<dd>At most as hard as NP, but not necessarily in NP.</dd>
<dt>NP-equivalent</dt>
<dd>Decision problems that are both NP-hard and NP-easy, but not necessarily in NP.</dd>
<dt>NP-intermediate</dt>
<dd>If P and NP are different, then there exist decision problems in the region of NP that fall between P and the NP-complete problems. (If P and NP are the same class, then NP-intermediate problems do not exist because in this case every NP-complete problem would fall in P, and by definition, every problem in NP can be reduced to an NP-complete problem.)</dd></dl>
<h2><span class="mw-headline" id="Application_areas">Application areas</span><span class="mw-editsection"></span></h2>
<p>NP-hard problems are often tackled with rules-based languages in areas including:
</p>
<ul><li>Approximate computing</li>
<li>Configuration</li>
<li>Cryptography</li>
<li>Data mining</li>
<li>Decision support</li>
<li>Phylogenetics</li>
<li>Planning</li>
<li>Process monitoring and control</li>
<li>Rosters or schedules</li>
<li>Routing/vehicle routing</li>
<li>Scheduling</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFMichael_R._Garey_and_David_S._Johnson1979">Michael R. Garey and David S. Johnson (1979). <i>Computers and Intractability: A Guide to the Theory of NP-Completeness</i>. W.H. Freeman. ISBN <bdi>0-7167-1045-5</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computers+and+Intractability%3A+A+Guide+to+the+Theory+of+NP-Completeness&amp;rft.pub=W.H.+Freeman&amp;rft.date=1979&amp;rft.isbn=0-7167-1045-5&amp;rft.au=Michael+R.+Garey+and+David+S.+Johnson&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ANP-hardness"></span></li></ul>

<!-- 
NewPP limit report
Parsed by mw2327
Cached time: 20221223233824
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.293 seconds
Real time usage: 0.372 seconds
Preprocessor visited node count: 1198/1000000
Post‐expand include size: 27343/2097152 bytes
Template argument size: 454/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 29526/5000000 bytes
Lua time usage: 0.173/10.000 seconds
Lua memory usage: 4974582/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  315.792      1 -total
 44.86%  141.662      1 Template:Reflist
 29.72%   93.859      4 Template:Cite_book
 17.12%   54.053      1 Template:ComplexityClasses
 15.99%   50.489      1 Template:Navbox
 15.93%   50.306      1 Template:Short_description
 10.43%   32.943      2 Template:Rp
  9.38%   29.629      2 Template:R/superscript
  8.78%   27.738      2 Template:Pagetype
  7.47%   23.602      1 Template:For
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:54681-0!canonical and timestamp 20221223233823 and revision id 1098421480.
 -->
</div></body>
</html>