<!DOCTYPE html>
<html>
<head>
<title>stack_tree</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In computer science, a <b>binary tree</b> is a k-ary <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k=2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
<mo>=</mo>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k=2}</annotation>
</semantics>
</math></span><img alt="k=2" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0bd301789e1f25a3da4be297ff637754ebee5f5d" style="vertical-align: -0.338ex; width:5.472ex; height:2.176ex;"/></span> tree data structure in which each node has at most two children, which are referred to as the <i><style data-mw-deduplicate="TemplateStyles:r1023754711">.mw-parser-output .vanchor>:target~.vanchor-text{background-color:#b1d2ff}</style><span class="vanchor"><span id="left_child"></span><span class="vanchor-text">left child</span></span></i> and the <i><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="right_child"></span><span class="vanchor-text">right child</span></span></i>.  A recursive definition using just set theory notions is that a (non-empty) binary tree is a tuple (<i>L</i>, <i>S</i>, <i>R</i>), where <i>L</i> and <i>R</i> are binary trees or the empty set and <i>S</i> is a singleton set containing the root.<sup class="reference" id="cite_ref-GarnierTaylor2009_1-0">[1]</sup> Some authors allow the binary tree to be the empty set as well.<sup class="reference" id="cite_ref-Skiena2009_2-0">[2]</sup>
</p><p>From a graph theory perspective, binary (and K-ary) trees as defined here are arborescences.<sup class="reference" id="cite_ref-Knuth1997_3-0">[3]</sup> A binary tree may thus be also called a <b>bifurcating arborescence</b><sup class="reference" id="cite_ref-Knuth1997_3-1">[3]</sup>—a term which appears in some very old programming books,<sup class="reference" id="cite_ref-Flores1971_4-0">[4]</sup> before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an undirected, rather than a directed graph, in which case a binary tree is an ordered, rooted tree.<sup class="reference" id="cite_ref-5">[5]</sup> Some authors use <b>rooted binary tree</b> instead of <i>binary tree</i> to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted.<sup class="reference" id="cite_ref-Mazur2010_6-0">[6]</sup> A binary tree is a special case of an ordered K-ary tree, where <i>K</i> is 2.
</p><p>In mathematics, what is termed <i>binary tree</i> can vary significantly from author to author. Some use the definition commonly used in computer science,<sup class="reference" id="cite_ref-oem_7-0">[7]</sup> but others define it as every non-leaf having exactly two children and don't necessarily order (as left/right) the children either.<sup class="reference" id="cite_ref-Foulds1992_8-0">[8]</sup>
</p><p>In computing, binary trees are used in two very different ways:
</p>
<ul><li>First, as a means of accessing nodes based on some value or label associated with each node.<sup class="reference" id="cite_ref-Makinson2009b_9-0">[9]</sup> Binary trees labelled this way are used to implement binary search trees and binary heaps, and are used for efficient searching and sorting. The designation of non-root nodes as left or right child even when there is only one child present matters in some of these applications, in particular, it is significant in binary search trees.<sup class="reference" id="cite_ref-Gross2007_10-0">[10]</sup> However, the arrangement of particular nodes into the tree is not part of the conceptual information. For example, in a normal binary search tree the placement of nodes depends almost entirely on the order in which they were added, and can be re-arranged (for example by balancing) without changing the meaning.</li>
<li>Second, as a representation of data with a relevant bifurcating structure. In such cases, the particular arrangement of nodes under and/or to the left or right of other nodes is part of the information (that is, changing it would change the meaning). Common examples occur with Huffman coding and cladograms. The everyday division of documents into chapters, sections, paragraphs, and so on is an analogous example with n-ary rather than binary trees.</li></ul>

<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Recursive_definition">Recursive definition</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Cleanup_rewrite plainlinks metadata ambox ambox-content" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>To actually define a binary tree in general, we must allow for the possibility that only one of the children may be empty. An artifact, which in some textbooks is called an <i>extended binary tree,</i> is needed for that purpose. An extended binary tree is thus recursively defined as:<sup class="reference" id="cite_ref-Rosen2011_11-0">[11]</sup>
</p>
<ul><li>the empty set is an extended binary tree</li>
<li>if T<sub>1</sub> and T<sub>2</sub> are extended binary trees, then denote by T<sub>1</sub> • T<sub>2</sub> the extended binary tree obtained by <span class="cleanup-needed-content" style="padding-left:0.1em; padding-right:0.1em; color:#595959; border:1px solid #DDD;">adding a root <i>r</i> connected to the left to T<sub>1</sub> and to the right to T<sub>2</sub></span><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (May 2020)">clarification needed</span> where did the 'r' go in the 'T<sub>1</sub> • T<sub>2</sub>' symbol</i>]</sup>  by adding edges when these sub-trees are non-empty.</li></ul>
<p>Another way of imagining this construction (and understanding the terminology) is to consider instead of the empty set a different type of node—for instance square nodes if the regular ones are circles.<sup class="reference" id="cite_ref-HuShing2002_12-0">[12]</sup>
</p>
<h3><span class="mw-headline" id="Using_graph_theory_concepts">Using graph theory concepts</span><span class="mw-editsection"></span></h3>
<p>A binary tree is a rooted tree that is also an ordered tree (a.k.a. plane tree) in which every node has at most two children. A rooted tree naturally imparts a notion of levels (distance from the root), thus for every node a notion of children may be defined as the nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes it possible to distinguish a left child from a right child.<sup class="reference" id="cite_ref-HsuLin2008_13-0">[13]</sup> But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.
</p><p>The necessary distinction can be made by first partitioning the edges, i.e., defining the binary tree as triplet (V, E<sub>1</sub>, E<sub>2</sub>), where (V, E<sub>1</sub> ∪ E<sub>2</sub>) is a rooted tree (equivalently arborescence) and E<sub>1</sub> ∩ E<sub>2</sub> is empty, and also requiring that for all <i>j</i> ∈ { 1, 2 } every node has at most one E<sub><i>j</i></sub> child.<sup class="reference" id="cite_ref-FlumGrohe2006_14-0">[14]</sup> A more informal way of making the distinction is to say, quoting the Encyclopedia of Mathematics, that "every node has a left child, a right child, neither, or both" and to specify that these "are all different" binary trees.<sup class="reference" id="cite_ref-oem_7-1">[7]</sup>
</p>
<h2><span class="mw-headline" id="Types_of_binary_trees">Types of binary trees</span><span class="mw-editsection"></span></h2>
<p>Tree terminology is not well-standardized and so varies in the literature.
</p>
<ul><li>A <b><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="rooted"></span><span class="vanchor-text">rooted</span></span></b> binary tree has a root node and every node has at most two children.</li></ul>


<ul><li>A <b><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="full"></span><span class="vanchor-text">full</span></span></b> binary tree (sometimes referred to as a <b>proper</b><sup class="reference" id="cite_ref-15">[15]</sup> or <b>plane</b> or <b>strict</b> binary tree)<sup class="reference" id="cite_ref-16">[16]</sup><sup class="reference" id="cite_ref-17">[17]</sup> is a tree in which every node has either 0 or 2 children. Another way of defining a full binary tree is a recursive definition. A full binary tree is either:<sup class="reference" id="cite_ref-Rosen2011_11-1">[11]</sup>
<ul><li>A single vertex.</li>
<li>A tree whose root node has two subtrees, both of which are full binary trees.</li></ul></li>
<li>A <b><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="perfect"></span><span class="vanchor-text">perfect</span></span></b> binary tree is a binary tree in which all interior nodes have two children <i>and</i> all leaves have the same <i>depth</i> or same <i>level</i>.<sup class="reference" id="cite_ref-18">[18]</sup> An example of a perfect binary tree is the (non-incestuous) ancestry chart of a person to a given depth, as each person has exactly two biological parents (one mother and one father). Provided the ancestry chart always displays the mother and the father on the same side for a given node, their sex can be seen as an analogy of left and right children, <i>children</i> being understood here as an algorithmic term.</li>
<li>A <b><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="complete"></span><span class="vanchor-text">complete</span></span></b> binary tree is a binary tree in which every level, <i>except possibly the last</i>, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup><i>h</i></sup> nodes at the last level <i>h</i>.<sup class="reference" id="cite_ref-complete_binary_tree_19-0">[19]</sup> A perfect tree is therefore always complete but a complete tree is not necessarily perfect. An alternative definition is a perfect tree whose rightmost leaves (perhaps all) have been removed. Some authors use the term <b>complete</b> to refer instead to a <b>perfect</b> binary tree as defined above, in which case they call this type of tree (with a possibly not filled last level) an <b>almost complete</b> binary tree or <b>nearly complete</b> binary tree.<sup class="reference" id="cite_ref-almost_complete_binary_tree_20-0">[20]</sup><sup class="reference" id="cite_ref-nearly_complete_binary_tree_21-0">[21]</sup> A complete binary tree can be efficiently represented using an array.<sup class="reference" id="cite_ref-complete_binary_tree_19-1">[19]</sup></li></ul>

<ul><li>In the <b>infinite complete</b> binary tree, every node has two children (and so the set of levels is countably infinite).  The set of all nodes is countably infinite, but the set of all infinite paths from the root is uncountable, having the cardinality of the continuum. That's because these paths correspond by an order-preserving bijection to the points of the Cantor set, or (using the example of a Stern–Brocot tree) to the set of positive irrational numbers.</li>
<li>A <b>balanced</b> binary tree is a binary tree structure in which the left and right subtrees of every node differ in height by no more than 1.<sup class="reference" id="cite_ref-22">[22]</sup> One may also consider binary trees where no leaf is much farther away from the root than any other leaf. (Different balancing schemes allow different definitions of "much farther".<sup class="reference" id="cite_ref-23">[23]</sup>)</li>
<li>A <b>degenerate</b> (or <b>pathological</b>) tree is where each parent node has only one associated child node.<sup class="reference" id="cite_ref-24">[24]</sup> This means that the tree will behave like a linked list data structure.</li></ul>
<h2><span class="mw-headline" id="Properties_of_binary_trees">Properties of binary trees</span><span class="mw-editsection"></span></h2>
<ul><li>The number of nodes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> in a full binary tree is at least <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2h+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>h</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2h+1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2h+1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29cf886c7e158d979280e2f2543017776723b063" style="vertical-align: -0.505ex; width:6.504ex; height:2.343ex;"/></span> and at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{h+1}-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>h</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{h+1}-1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2^{h+1}-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/942650818fce75c77b1e2b0941ca54e01434bdbf" style="vertical-align: -0.505ex; width:8.445ex; height:2.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle h}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>h</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle h}</annotation>
</semantics>
</math></span><img alt="h" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b26be3e694314bc90c3215047e4a2010c6ee184a" style="vertical-align: -0.338ex; width:1.339ex; height:2.176ex;"/></span> is the height of the tree. A tree consisting of only a root node has a height of 0.</li>
<li>The number of leaf nodes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l}</annotation>
</semantics>
</math></span><img alt="l" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac" style="vertical-align: -0.338ex; width:0.693ex; height:2.176ex;"/></span> in a perfect binary tree, is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l=(n+1)/2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l=(n+1)/2}</annotation>
</semantics>
</math></span><img alt="l=(n+1)/2" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/52f9a12bb66ec9a46656d9f008dfce4219375897" style="vertical-align: -0.838ex; width:13.324ex; height:2.843ex;"/></span> because the number of non-leaf (a.k.a. internal) nodes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mi>l</mi>
<mo>=</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>l</mi>
<mo stretchy="false">)</mo>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>l</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo>=</mo>
<mi>l</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1}</annotation>
</semantics>
</math></span><img alt="n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3c680ab535c09730df31abcac66dfe98f93215b5" style="vertical-align: -3.171ex; width:38.461ex; height:7.843ex;"/></span>.</li>
<li>This means that a full binary tree with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l}</annotation>
</semantics>
</math></span><img alt="l" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac" style="vertical-align: -0.338ex; width:0.693ex; height:2.176ex;"/></span> leaves has <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n=2l-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>=</mo>
<mn>2</mn>
<mi>l</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n=2l-1}</annotation>
</semantics>
</math></span><img alt="n=2l-1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6c6e89428a9bb787bd2d029f3bb0740c75c45da3" style="vertical-align: -0.505ex; width:10.352ex; height:2.343ex;"/></span> nodes.</li>
<li>In a <b>balanced</b> full binary tree, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>h</mi>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>l</mi>
<mo stretchy="false">)</mo>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
<mo>+</mo>
<mn>1</mn>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo stretchy="false">)</mo>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
<mo>+</mo>
<mn>1</mn>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil }</annotation>
</semantics>
</math></span><img alt="h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0c2c3b8d442f7a10ba77ef6ddd5dc42f9a85c9ef" style="vertical-align: -0.838ex; width:57.963ex; height:2.843ex;"/></span> (see ceiling function).<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (September 2018)">citation needed</span></i>]</sup></li>
<li>In a <b>perfect</b> full binary tree, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l=2^{h}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>h</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l=2^{h}}</annotation>
</semantics>
</math></span><img alt="l=2^{h}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0c75a8ef2ff68abf9711a5952953e0ee7ab98284" style="vertical-align: -0.338ex; width:6.133ex; height:2.676ex;"/></span> thus <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n=2^{h+1}-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>h</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n=2^{h+1}-1}</annotation>
</semantics>
</math></span><img alt="n=2^{h+1}-1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3558d5feb47029b11259917bbb81b6c14a5da484" style="vertical-align: -0.505ex; width:12.938ex; height:2.843ex;"/></span>.</li>
<li>The number of null links (i.e., absent children of the nodes) in a binary tree of <i>n</i> nodes is (<i>n</i>+1).</li>
<li>The number of internal nodes in a <b>complete</b> binary tree of <i>n</i> nodes is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lfloor n/2\rfloor }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lfloor n/2\rfloor }</annotation>
</semantics>
</math></span><img alt="\lfloor n/2\rfloor " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c86b5dc915aaa6792f2a7d3ed1c165c555256c7a" style="vertical-align: -0.838ex; width:5.784ex; height:2.843ex;"/></span>.</li>
<li>For any non-empty binary tree with <i>n</i><sub>0</sub> leaf nodes and <i>n</i><sub>2</sub> nodes of degree 2, <i>n</i><sub>0</sub> = <i>n</i><sub>2</sub> + 1.<sup class="reference" id="cite_ref-25">[25]</sup></li></ul>
<h2><span class="mw-headline" id="Combinatorics">Combinatorics</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Unreferenced_section plainlinks metadata ambox ambox-content ambox-Unreferenced" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In combinatorics one considers the problem of counting the number of full binary trees of a given size.  Here the trees have no values attached to their nodes (this would just multiply the number of possible trees by an easily determined factor), and trees are distinguished only by their structure; however, the left and right child of any node are distinguished (if they are different trees, then interchanging them will produce a tree distinct from the original one). The size of the tree is taken to be the number <i>n</i> of internal nodes (those with two children); the other nodes are leaf nodes and there are <span class="texhtml"><i>n</i> + 1</span> of them. The number of such binary trees of size <i>n</i> is equal to the number of ways of fully parenthesizing a string of <span class="texhtml"><i>n</i> + 1</span> symbols (representing leaves) separated by <i>n</i> binary operators (representing internal nodes), to determine the argument subexpressions of each operator. For instance for <span class="texhtml"><i>n</i> = 3</span> one has to parenthesize a string like <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle X*X*X*X}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle X*X*X*X}</annotation>
</semantics>
</math></span><img alt="X*X*X*X" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/566156aef575e6ff5ca67b2611ab3fcd127a0c0e" style="vertical-align: -0.338ex; width:14.504ex; height:2.176ex;"/></span>, which is possible in five ways:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle ((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo>,</mo>
<mspace width="2em"></mspace>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo>,</mo>
<mspace width="2em"></mspace>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>∗<!-- ∗ --></mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mspace width="2em"></mspace>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mo stretchy="false">(</mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mspace width="2em"></mspace>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo>∗<!-- ∗ --></mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle ((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).}</annotation>
</semantics>
</math></span><img alt="((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X))." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d1b88609c3c6537a0d6a7fabfecfd42aad4ab145" style="vertical-align: -0.838ex; width:113.977ex; height:2.843ex;"/></span></dd></dl>
<p>The correspondence to binary trees should be obvious, and the addition of redundant parentheses (around an already parenthesized expression or around the full expression) is disallowed (or at least not counted as producing a new possibility).
</p><p>There is a unique binary tree of size 0 (consisting of a single leaf), and any other binary tree is characterized by the pair of its left and right children; if these have sizes <i>i</i> and <i>j</i> respectively, the full tree has size <span class="texhtml"><i>i</i> + <i>j</i> + 1</span>. Therefore, the number <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation>
</semantics>
</math></span><img alt="C_{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" style="vertical-align: -0.671ex; width:2.88ex; height:2.509ex;"/></span> of binary trees of size <i>n</i> has the following recursive description <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C_{0}=1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
</mrow>
</msub>
<mo>=</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C_{0}=1}</annotation>
</semantics>
</math></span><img alt="C_{0}=1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f16d74f9b1af01a229f5b576167e4f1d7969c83" style="vertical-align: -0.671ex; width:6.977ex; height:2.509ex;"/></span>, and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mstyle displaystyle="false" scriptlevel="0">
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo>=</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo>−<!-- − --></mo>
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}}</annotation>
</semantics>
</math></span><img alt="\textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08ba36c0b93072eb89e77290c4f4188741f8f60b" style="vertical-align: -1.005ex; width:21.427ex; height:3.509ex;"/></span> for any positive integer <i>n</i>. It follows that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation>
</semantics>
</math></span><img alt="C_{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" style="vertical-align: -0.671ex; width:2.88ex; height:2.509ex;"/></span> is the Catalan number of index <i>n</i>.
</p><p>The above parenthesized strings should not be confused with the set of words of length 2<i>n</i> in the Dyck language, which consist only of parentheses in such a way that they are properly balanced. The number of such strings satisfies the same recursive description (each Dyck word of length 2<i>n</i> is determined by the Dyck subword enclosed by the initial '(' and its matching ')' together with the Dyck subword remaining after that closing parenthesis, whose lengths 2<i>i</i> and 2<i>j</i> satisfy <span class="texhtml"><i>i</i> + <i>j</i> + 1 = <i>n</i></span>); this number is therefore also the Catalan number <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation>
</semantics>
</math></span><img alt="C_{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" style="vertical-align: -0.671ex; width:2.88ex; height:2.509ex;"/></span>. So there are also five Dyck words of length 6:
</p>
<dl><dd><span class="texhtml">()()(),     ()(()),     (())(),     (()()),     ((()))</span></dd></dl>
<p>These Dyck words do not correspond to binary trees in the same way. Instead, they are related by the following recursively defined bijection: the Dyck word equal to the empty string corresponds to the binary tree of size 0 with only one leaf. Any other Dyck word can be written as (<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation>
</semantics>
</math></span><img alt="w_{1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span>)<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation>
</semantics>
</math></span><img alt="w_{2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation>
</semantics>
</math></span><img alt="w_{1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span>,<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation>
</semantics>
</math></span><img alt="w_{2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span> are themselves (possibly empty) Dyck words and where the two written parentheses are matched. The bijection is then defined by letting the words <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation>
</semantics>
</math></span><img alt="w_{1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle w_{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation>
</semantics>
</math></span><img alt="w_{2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" style="vertical-align: -0.671ex; width:2.718ex; height:2.009ex;"/></span> correspond to the binary trees that are the left and right children of the root.
</p><p>A bijective correspondence can also be defined as follows: enclose the Dyck word in an extra pair of parentheses, so that the result can be interpreted as a Lisp list expression (with the empty list () as only occurring atom); then the dotted-pair expression for that proper list is a fully parenthesized expression (with NIL as symbol and '.' as operator) describing the corresponding binary tree (which is, in fact, the internal representation of the proper list).
</p><p>The ability to represent binary trees as strings of symbols and parentheses implies that binary trees can represent the elements of a free magma on a singleton set.
</p>
<h2><span class="mw-headline" id="Methods_for_storing_binary_trees">Methods for storing binary trees</span><span class="mw-editsection"></span></h2>
<p>Binary trees can be constructed from programming language primitives in several ways.
</p>
<h3><span class="mw-headline" id="Nodes_and_references">Nodes and references</span><span class="mw-editsection"></span></h3>
<p>In a language with records and references, binary trees are typically constructed by having a tree node structure which contains some data and references to its left child and its right child. Sometimes it also contains a reference to its unique parent. If a node has fewer than two children, some of the child pointers may be set to a special null value, or to a special sentinel node.
</p><p>This method of storing binary trees wastes a fair bit of memory, as the pointers will be null (or point to the sentinel) more than half the time; a more conservative representation alternative is threaded binary tree.<sup class="reference" id="cite_ref-Samanta2004_26-0">[26]</sup>
</p><p>In languages with tagged unions such as ML, a tree node is often a tagged union of two types of nodes, one of which is a 3-tuple of data, left child, and right child, and the other of which is a "leaf" node, which contains no data and functions much like the null value in a language with pointers. For example, the following line of code in OCaml (an ML dialect) defines a binary tree that stores a character in each node.<sup class="reference" id="cite_ref-Scott2009_27-0">[27]</sup>
</p>

<h3><span class="mw-headline" id="Arrays">Arrays</span><span class="mw-editsection"></span></h3>
<p>Binary trees can also be stored in breadth-first order as an implicit data structure in arrays, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index <i>i</i>, its children are found at indices <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i+1}</annotation>
</semantics>
</math></span><img alt="2i+1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" style="vertical-align: -0.505ex; width:5.968ex; height:2.343ex;"/></span> (for the left child) and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i+2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
<mo>+</mo>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i+2}</annotation>
</semantics>
</math></span><img alt="2i+2" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a756deaef520ee23fe2b1232c90957f55ec9d92b" style="vertical-align: -0.505ex; width:5.968ex; height:2.343ex;"/></span> (for the right), while its parent (if any) is found at index <i><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow>
<mo>⌊</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mi>i</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>⌋</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }</annotation>
</semantics>
</math></span><img alt="\left\lfloor {\frac {i-1}{2}}\right\rfloor " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35dc2d601bbd9aff8f1ed1c4b2323122f2403317" style="vertical-align: -2.505ex; width:8.352ex; height:6.176ex;"/></span></i> (assuming the root has index zero). Alternatively, with a 1-indexed array, the implementation is simplified with children found at <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i}</annotation>
</semantics>
</math></span><img alt="2i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/717fa22d62566808b398d03504bc04a9599da936" style="vertical-align: -0.338ex; width:1.965ex; height:2.176ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i+1}</annotation>
</semantics>
</math></span><img alt="2i+1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" style="vertical-align: -0.505ex; width:5.968ex; height:2.343ex;"/></span>, and parent found at <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lfloor i/2\rfloor }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<mi>i</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lfloor i/2\rfloor }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \lfloor i/2\rfloor }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3dfc70beb8478160c4f60e393a9eaa1cfdb090c2" style="vertical-align: -0.838ex; width:5.192ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-28">[28]</sup> This method benefits from more compact storage and better locality of reference, particularly during a preorder traversal. However, it is expensive to grow<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (December 2020)">citation needed</span></i>]</sup> and wastes space proportional<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (December 2020)">citation needed</span></i>]</sup> to 2<sup><i>h</i></sup> - <i>n</i> for a tree of depth <i>h</i> with <i>n</i> nodes.
</p><p>This method of storage is often used for binary heaps.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (December 2020)">citation needed</span></i>]</sup>
</p>

<h2><span class="mw-headline" id="Encodings">Encodings</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Succinct_encodings">Succinct encodings</span><span class="mw-editsection"></span></h3>
<p>A succinct data structure is one which occupies close to minimum possible space, as established by information theoretical lower bounds. The number of different binary trees on <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> nodes is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathrm {C} _{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="normal">C</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathrm {C} _{n}}</annotation>
</semantics>
</math></span><img alt="\mathrm {C} _{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c9cd15d2dd0b4299b0ae5953cff1274b283f239e" style="vertical-align: -0.671ex; width:2.897ex; height:2.509ex;"/></span>, the <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span>th Catalan number (assuming we view trees with identical <i>structure</i> as identical). For large <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span>, this is about <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 4^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>4</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 4^{n}}</annotation>
</semantics>
</math></span><img alt="4^{{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bcdd6057d8f9857a7d45670ced53881c2e312f34" style="vertical-align: -0.338ex; width:2.381ex; height:2.343ex;"/></span>; thus we need at least about <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log _{2}4^{n}=2n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msup>
<mn>4</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
<mo>=</mo>
<mn>2</mn>
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log _{2}4^{n}=2n}</annotation>
</semantics>
</math></span><img alt="\log _{2}4^{n}=2n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/967f4edcd69d8a66cc4f77b9117c10596058c503" style="vertical-align: -0.838ex; width:12.45ex; height:2.843ex;"/></span> bits to encode it. A succinct binary tree therefore would occupy <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2n+o(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>n</mi>
<mo>+</mo>
<mi>o</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2n+o(n)}</annotation>
</semantics>
</math></span><img alt="2n+o(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bb0b9882cca56b0c10216f0ca56dbb97e827b17f" style="vertical-align: -0.838ex; width:9.729ex; height:2.843ex;"/></span> bits.
</p><p>One simple representation which meets this bound is to visit the nodes of the tree in preorder, outputting "1" for an internal node and "0" for a leaf.<sup class="reference" id="cite_ref-29">[29]</sup> If the tree contains data, we can simply simultaneously store it in a consecutive array in preorder. This function accomplishes this:
</p>
<pre><b>function</b> EncodeSuccinct(<i>node</i> n, <i>bitstring</i> structure, <i>array</i> data) {
    <b>if</b> n = <i>nil</i> <b>then</b>
        append 0 to structure;
    <b>else</b>
        append 1 to structure;
        append n.data to data;
        EncodeSuccinct(n.left, structure, data);
        EncodeSuccinct(n.right, structure, data);
}
</pre>
<p>The string <i>structure</i> has only <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2n+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2n+1}</annotation>
</semantics>
</math></span><img alt="2n+1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ca410f731fe4c7c444330343afb1d1850eadaea" style="vertical-align: -0.505ex; width:6.56ex; height:2.343ex;"/></span> bits in the end, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> is the number of (internal) nodes; we don't even have to store its length. To show that no information is lost, we can convert the output back to the original tree like this:
</p>
<pre><b>function</b> DecodeSuccinct(<i>bitstring</i> structure, <i>array</i> data) {
    remove first bit of <i>structure</i> and put it in <i>b</i>
    <b>if</b> b = 1 <b>then</b>
        create a new node <i>n</i>
        remove first element of data and put it in n.data
        n.left = DecodeSuccinct(structure, data)
        n.right = DecodeSuccinct(structure, data)
        <b>return</b> n
    <b>else</b>
        <b>return</b> nil
}
</pre>
<p>More sophisticated succinct representations allow not only compact storage of trees but even useful operations on those trees directly while they're still in their succinct form.
</p>
<h3><span class="mw-headline" id="Encoding_general_trees_as_binary_trees">Encoding general trees as binary trees</span><span class="mw-editsection"></span></h3>
<p>There is a one-to-one mapping between general ordered trees and binary trees, which in particular is used by Lisp to represent general ordered trees as binary trees. To convert a general ordered tree to a binary tree, we only need to represent the general tree in left-child right-sibling way. The result of this representation will automatically be a binary tree if viewed from a different perspective. Each node <i>N</i> in the ordered tree corresponds to a node <i>N' </i> in the binary tree; the <i>left</i> child of <i>N' </i> is the node corresponding to the first child of <i>N</i>, and the <i>right</i> child of <i>N' </i> is the node corresponding to <i>N</i><span class="nowrap" style="padding-left:0.1em;">'</span>s next sibling --- that is, the next node in order among the children of the parent of <i>N</i>. This binary tree representation of a general order tree is sometimes also referred to as a left-child right-sibling binary tree (also known as LCRS tree, doubly chained tree, filial-heir chain).
</p><p>One way of thinking about this is that each node's children are in a linked list, chained together with their <i>right</i> fields, and the node only has a pointer to the beginning or head of this list, through its <i>left</i> field.
</p><p>For example, in the tree on the left, A has the 6 children {B,C,D,E,F,G}.  It can be converted into the binary tree on the right.
</p>

<p>The binary tree can be thought of as the original tree tilted sideways, with the black left edges representing <i>first child</i> and the blue right edges representing <i>next sibling</i>.  The leaves of the tree on the left would be written in Lisp as:
</p>
<dl><dd>(((N O) I J) C D ((P) (Q)) F (M))</dd></dl>
<p>which would be implemented in memory as the binary tree on the right, without any letters on those nodes that have a left child.
</p>
<h2><span class="mw-headline" id="Common_operations">Common operations</span><span class="mw-editsection"></span></h2>

<p>There are a variety of different operations that can be performed on binary trees. Some are mutator operations, while others simply return useful information about the tree.
</p>
<h3><span class="mw-headline" id="Insertion">Insertion</span><span class="mw-editsection"></span></h3>
<p>Nodes can be inserted into binary trees in between two other nodes or added after a leaf node. In binary trees, a node that is inserted is specified as to whose child it will be.
</p>
<h4><span class="mw-headline" id="Leaf_nodes">Leaf nodes</span><span class="mw-editsection"></span></h4>
<p>To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.
</p>
<h4><span class="mw-headline" id="Internal_nodes">Internal nodes</span><span class="mw-editsection"></span></h4>

<p>Insertion on internal nodes is slightly more complex than on leaf nodes. Say that the internal node is node A and that node B is the child of A. (If the insertion is to insert a right child, then B is the right child of A, and similarly with a left child insertion.) A assigns its child to the new node and the new node assigns its parent to A. Then the new node assigns its child to B and B assigns its parent as the new node.
</p>
<h3><span class="mw-headline" id="Deletion">Deletion</span><span class="mw-editsection"></span></h3>
<p>Deletion is the process whereby a node is removed from the tree.  Only certain nodes in a binary tree can be removed unambiguously.<sup class="reference" id="cite_ref-rice_30-0">[30]</sup>
</p>
<h4><span class="mw-headline" id="Node_with_zero_or_one_children">Node with zero or one children</span><span class="mw-editsection"></span></h4>

<p>Suppose that the node to delete is node A. If A has no children, deletion is accomplished by setting the child of A's parent to null. If A has one child, set the parent of A's child to A's parent and set the child of A's parent to A's child.
</p>
<h4><span class="mw-headline" id="Node_with_two_children">Node with two children</span><span class="mw-editsection"></span></h4>
<p>In a binary tree, a node with two children cannot be deleted unambiguously.<sup class="reference" id="cite_ref-rice_30-1">[30]</sup> However, in certain binary trees (including binary search trees) these nodes <i>can</i> be deleted, though with a rearrangement of the tree structure.
</p>
<h3><span class="mw-headline" id="Traversal">Traversal</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Pre-order, in-order, and post-order traversal visit each node in a tree by recursively visiting each node in the left and right subtrees of the root.
</p>
<h4><span class="mw-headline" id="Depth-first_order">Depth-first order</span><span class="mw-editsection"></span></h4>
<p>In depth-first order, we always attempt to visit the node farthest from the root node that we can, but with the caveat that it must be a child of a node we have already visited. Unlike a depth-first search on graphs, there is no need to remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See depth-first search for more information.
</p>
<h4><span class="mw-headline" id="Breadth-first_order">Breadth-first order</span><span class="mw-editsection"></span></h4>
<p>Contrasting with depth-first order is breadth-first order, which always attempts to visit the node closest to the root that it has not already visited. See breadth-first search for more information. Also called a <i>level-order traversal</i>.
</p><p>In a complete binary tree, a node's breadth-index (<i>i</i> − (2<sup><i>d</i></sup> − 1)) can be used as traversal instructions from the root. Reading bitwise from left to right, starting at bit <i>d</i> − 1, where <i>d</i> is the node's distance from the root (<i>d</i> = ⌊log<sub>2</sub>(<i>i</i>+1)⌋) and the node in question is not the root itself (<i>d</i> &gt; 0). When the breadth-index is masked at bit <i>d</i> − 1, the bit values <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">0</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">1</span> mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating a complete binary tree this way versus each node having pointer/s to its sibling/s.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Citations">Citations</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h3><span class="mw-headline" id="Bibliography">Bibliography</span><span class="mw-editsection"></span></h3>
<ul><li>Donald Knuth. <i>The Art of Computer Programming vol 1. Fundamental Algorithms</i>, Third Edition. Addison-Wesley, 1997. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-89683-4. Section 2.3, especially subsections 2.3.1–2.3.2 (pp. 318–348).</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>binary trees entry in the FindStat database</li>
<li>Binary Tree Proof by Induction</li>
<li>Balanced binary search tree on array How to create bottom-up an Ahnentafel list, or a balanced binary search tree on array</li>
<li>Binary trees and Implementation of the same with working code examples</li>
<li>Binary Tree JavaScript Implementation with source code</li></ul>


<!-- 
NewPP limit report
Parsed by mw2412
Cached time: 20221223231509
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.517 seconds
Real time usage: 0.755 seconds
Preprocessor visited node count: 4084/1000000
Post‐expand include size: 88724/2097152 bytes
Template argument size: 7122/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 9/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 100685/5000000 bytes
Lua time usage: 0.272/10.000 seconds
Lua memory usage: 7613770/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  529.092      1 -total
 39.87%  210.929      1 Template:Reflist
 24.40%  129.072     19 Template:Cite_book
  8.94%   47.276      1 Template:Short_description
  7.81%   41.315      1 Template:CS-Trees
  7.32%   38.712      1 Template:Commons_category
  7.25%   38.372      1 Template:Cleanup_rewrite
  7.11%   37.593      1 Template:Navbox
  6.96%   36.816      2 Template:Ambox
  6.92%   36.617      1 Template:Sister_project
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:4321-0!canonical and timestamp 20221223231509 and revision id 1118415242.
 -->
</div></body>
</html>