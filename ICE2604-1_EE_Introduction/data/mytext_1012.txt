threaded_binary_treeGraph and treesearch algorithmsα–β pruningBacktrackingBeam searchBest-first searchBranch &amp; boundBreadth-First Search (BFS)British MuseumDepth-First Search (DFS)Hill climbingIterative Deepening DFS (IDDFS)Lexicographic BFSShortest pathA*B*Bellman–FordBidirectional searchD*Dijkstra'sFloyd–WarshallFringe searchIterative Deepening (IDA*)Johnson'sJump point searchKruskal'sLifelong Planning A* (LPA*)PathfindingSMA*ListsGraph algorithmsSearch algorithmsList of graph algorithmsRelated topicsDynamic programmingGraph coloringGraph traversalMinimum spanning treeSearch gamesThreaded binary treeTree traversalIn computing, a threaded binary tree is a binary tree variant that facilitates traversal in a particular order (often the same order already defined for the tree).An entire binary search tree can be easily traversed in order of the main key, but given only a pointer to a node, finding the node which comes next may be slow or impossible. For example, leaf nodes by definition have no descendants, so given only a pointer to a leaf node no other node can be reached. A threaded tree adds extra information in some or all nodes, so that for any given single node the "next" node can be found quickly, allowing tree traversal without recursion and the extra storage (proportional to the tree's depth) that recursion requires."A binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node."[1]This assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called "threads", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.Trees, including (but not limited to) binary search trees, can be used to store items in a particular order, such as the value of some property stored in each node, often called a key. One useful operation on such a tree is traversal: visiting all the items in order of the key.A simple recursive traversal algorithm that visits each node of a binary search tree is the following. Assume  is a pointer to a node, or . "Visiting"  can mean performing any action on the node  or its contents.One problem with this algorithm is that, because of its recursion, it uses stack space proportional to the height of a tree. If the tree is fairly balanced, this amounts to  space for a tree containing  elements. In the worst case, when the tree takes the form of a chain, the height of the tree is  so the algorithm takes  space. A second problem is that all traversals must begin at the root when nodes have pointers only to their children. It is common to have a pointer to a particular node, but that is not sufficient to get back to the rest of the tree unless extra information is added, such as thread pointers.In this approach, it may not be possible to tell whether the left and/or right pointers in a given node actually point to children, or are a consequence of threading. If the distinction is necessary, adding a single bit to each node is enough to record it.In a 1968 textbook, Donald Knuth asked whether a non-recursive algorithm for in-order traversal exists, that uses no stack and leaves the tree unmodified.[2] One of the solutions to this problem is tree threading, presented by Joseph M. Morris in 1979.[3][4]In the 1969 follow-up edition,[5] Knuth attributed the threaded tree representation to Perlis and Thornton (1960).[6]Another way to achieve similar goals is to include a pointer in every node, to that node's parent node. Given that, the "next" node can always be reached. "right" pointers are still null whenever there are no right children. To find the "next" node from a node whose right pointer is null, walk up through "parent" pointers until reaching a node whose right pointer is not null, and is not the child you just came up from. That node is the "next" node, and after it come its descendants on the right.It is also possible to discover the parent of a node from a threaded binary tree, without explicit use of parent pointers or a stack, although it is slower. To see this, consider a node k with right child r.  Then the left pointer of r must be either a child or a thread back to k. In the case that r has a left child, that left child must in turn have either a left child of its own or a thread back to k, and so on for all successive left children.  So by following the chain of left pointers from r, we will eventually find a thread pointing back to k.  The situation is symmetrically similar when q is the left child of p—we can follow q's right children to a thread pointing ahead to p.In Python:Single threaded: each node is threaded towards either the in-order predecessor or successor (left or right).Double threaded: each node is threaded towards both the in-order predecessor and successor (left and right).Threads are reference to the predecessors and successors of the node according to an inorder traversal. In-order traversal of the threaded tree is A,B,C,D,E,F,G,H,I, the predecessor of E is D, the successor of E is F.Let's make the Threaded Binary tree out of a normal binary tree:The in-order traversal for the above tree is — D B A E C. So, the respective Threaded Binary tree will be --In an m-way threaded binary tree with n nodes, there are n×m − (n−1) void links.GNU libavl 2.0.2, Section on threaded binary search trees