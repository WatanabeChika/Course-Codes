<!DOCTYPE html>
<html>
<head>
<title>s-t_cut</title>
</head>
<body>
<div class="mw-parser-output">
<p>In graph theory, a <b>cut</b> is a partition of the vertices of a graph into two disjoint subsets.<sup class="reference" id="cite_ref-networkx.algorithms.cuts.cut_size_1-0">[1]</sup> Any cut determines a <b>cut-set</b>, the set of edges that have one endpoint in each subset of the partition. These edges are said to <b>cross</b> the cut. In a connected graph, each cut-set determines a unique cut, and in some cases cuts are identified with their cut-sets rather than with their vertex partitions.
</p><p>In a flow network, an <b>s–t cut</b> is a cut that requires the <i>source</i> and the <i>sink</i> to be in different subsets, and its <i>cut-set</i> only consists of edges going from the source's side to the sink's side. The <i>capacity</i> of an s–t cut is defined as the sum of the capacity of each edge in the <i>cut-set</i>.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>A <b>cut</b> <span class="texhtml"><i>C</i> = (<i>S</i>,<i>T</i>)</span> is a partition of <span class="texhtml mvar" style="font-style:italic;">V</span> of a graph <span class="texhtml"><i>G</i> = (<i>V</i>,<i>E</i>)</span> into two subsets <span class="texhtml mvar" style="font-style:italic;">S</span> and <span class="texhtml mvar" style="font-style:italic;">T</span>.
The <b>cut-set</b> of a cut <span class="texhtml"><i>C</i> = (<i>S</i>,<i>T</i>)</span> is the set <span class="texhtml">{(<i>u</i>,<i>v</i>) ∈ <i>E</i> | <i>u</i> ∈ <i>S</i>, <i>v</i> ∈ <i>T</i>} </span> of edges that have one endpoint in <span class="texhtml mvar" style="font-style:italic;">S</span> and the other endpoint in <span class="texhtml mvar" style="font-style:italic;">T</span>.
If <span class="texhtml mvar" style="font-style:italic;">s</span> and <span class="texhtml mvar" style="font-style:italic;">t</span> are specified vertices of the graph <span class="texhtml mvar" style="font-style:italic;">G</span>,  then an <b><span class="texhtml mvar" style="font-style:italic;">s–t</span> cut</b> is a cut in which <span class="texhtml mvar" style="font-style:italic;">s</span> belongs to the set <span class="texhtml mvar" style="font-style:italic;">S</span> and <span class="texhtml mvar" style="font-style:italic;">t</span> belongs to the set <span class="texhtml mvar" style="font-style:italic;">T</span>.
</p><p>In an unweighted undirected graph, the <i>size</i> or <i>weight</i> of a cut is the number of edges crossing the cut. In a weighted graph, the <b>value</b> or <b>weight</b> is defined by the sum of the weights of the edges crossing the cut.
</p><p>A <b>bond</b> is a cut-set that does not have any other cut-set as a proper subset.
</p>
<h2><span class="mw-headline" id="Minimum_cut">Minimum cut</span><span class="mw-editsection"></span></h2>

<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>A cut is <i>minimum</i> if the size or weight of the cut is not larger than the size of any other cut. The illustration on the right shows a minimum cut: the size of this cut is 2, and there is no cut of size 1 because the graph is bridgeless.
</p><p>The max-flow min-cut theorem proves that the maximum network flow and the sum of the cut-edge weights of any minimum cut that separates the source and the sink are equal. There are polynomial-time methods to solve the min-cut problem, notably the Edmonds–Karp algorithm.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>
<h2><span class="mw-headline" id="Maximum_cut">Maximum cut</span><span class="mw-editsection"></span></h2>

<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A cut is <i>maximum</i> if the size of the cut is not smaller than the size of any other cut. The illustration on the right shows a maximum cut: the size of the cut is equal to 5, and there is no cut of size 6, or |<i>E</i>| (the number of edges), because the graph is not bipartite (there is an odd cycle).
</p><p>In general, finding a maximum cut is computationally hard.<sup class="reference" id="cite_ref-3">[3]</sup>
The max-cut problem is one of Karp's 21 NP-complete problems.<sup class="reference" id="cite_ref-4">[4]</sup>
The max-cut problem is also APX-hard, meaning that there is no polynomial-time approximation scheme for it unless P = NP.<sup class="reference" id="cite_ref-5">[5]</sup>
However, it can be approximated to within a constant approximation ratio using semidefinite programming.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>Note that min-cut and max-cut are <i>not</i> dual problems in the linear programming sense, even though one gets from one problem to other by changing min to max in the objective function. The max-flow problem is the dual of the min-cut problem.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h2><span class="mw-headline" id="Sparsest_cut">Sparsest cut</span><span class="mw-editsection"></span></h2>
<p>The <b>sparsest cut problem</b> is to bipartition the vertices so as to minimize the ratio of the number of edges across the cut divided by the number of vertices in the smaller half of the partition.  This objective function favors solutions that are both sparse (few edges crossing the cut) and balanced (close to a bisection). The problem is known to be NP-hard, and the best known approximation algorithm is an <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O({\sqrt {\log n}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O({\sqrt {\log n}})}</annotation>
</semantics>
</math></span><img alt="O({\sqrt {\log n}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/58b1d20a1b443edfa6026d56d2bc324dc29158e2" style="vertical-align: -1.171ex; width:10.66ex; height:3.509ex;"/></span> approximation due to Arora, Rao &amp; Vazirani (2009).<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<h2><span class="mw-headline" id="Cut_space">Cut space</span><span class="mw-editsection"></span></h2>
<p>The family of all cut sets of an undirected graph is known as the <b>cut space</b> of the graph. It forms a vector space over the two-element finite field of arithmetic modulo two, with the symmetric difference of two cut sets as the vector addition operation, and is the orthogonal complement of the cycle space.<sup class="reference" id="cite_ref-gy_9-0">[9]</sup><sup class="reference" id="cite_ref-diestel_10-0">[10]</sup> If the edges of the graph are given positive weights, the minimum weight basis of the cut space can be described by a tree on the same vertex set as the graph, called the Gomory–Hu tree.<sup class="reference" id="cite_ref-11">[11]</sup> Each edge of this tree is associated with a bond in the original graph, and the minimum cut between two nodes <i>s</i> and <i>t</i> is the minimum weight bond among the ones associated with the path from <i>s</i> to <i>t</i> in the tree.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Connectivity (graph theory)</li>
<li>Graph cuts in computer vision</li>
<li>Split (graph theory)</li>
<li>Vertex separator</li>
<li>Bridge (graph theory)</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2386
Cached time: 20221224012536
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.211 seconds
Real time usage: 0.305 seconds
Preprocessor visited node count: 1141/1000000
Post‐expand include size: 22968/2097152 bytes
Template argument size: 1061/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 34319/5000000 bytes
Lua time usage: 0.131/10.000 seconds
Lua memory usage: 7073698/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  246.800      1 -total
 54.16%  133.672      1 Template:Reflist
 27.52%   67.913      1 Template:Cite_web
 20.34%   50.208      1 Template:Short_description
 18.77%   46.328     10 Template:Citation
 11.93%   29.445      1 Template:Harvtxt
 11.67%   28.796      2 Template:Pagetype
  8.09%   19.956      2 Template:Main
  4.78%   11.787      7 Template:Main_other
  3.75%    9.253      1 Template:SDcat
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2180494-0!canonical and timestamp 20221224012535 and revision id 1097329463.
 -->
</div></body>
</html>