<!DOCTYPE html>
<html>
<head>
<title>best-first_search</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p><b>Best-first search</b> is a class of search algorithms, which explore a graph by expanding the most promising node chosen according to a specified rule.
</p><p>Judea Pearl described the best-first search as estimating the promise of node <i>n</i> by a "heuristic evaluation function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n)}</annotation>
</semantics>
</math></span><img alt="f(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c1c49fad1eccc4e9af1e4f23f32efdc3ac4da973" style="vertical-align: -0.838ex; width:4.483ex; height:2.843ex;"/></span> which, in general, may depend on the description of <i>n</i>, the description of the goal, the information gathered by the search up to that point, and most importantly, on any extra knowledge about the problem domain."<sup class="reference" id="cite_ref-1">[1]</sup><sup class="reference" id="cite_ref-RN03_2-0">[2]</sup>
</p><p>Some authors have used "best-first search" to refer specifically to a search with a heuristic that attempts to predict how close the end of a path is to a solution (or, goal), so that paths which are judged to be closer to a solution (or, goal) are extended first. This specific type of search is called <i>greedy best-first search</i><sup class="reference" id="cite_ref-RN03_2-1">[2]</sup> or <i>pure heuristic search</i>.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>Efficient selection of the current best candidate for extension is typically implemented using a priority queue.
</p><p>The A* search algorithm is an example of a best-first search algorithm, as is B*. Best-first algorithms are often used for path finding in combinatorial search. Neither A* nor B* is a greedy best-first search, as they incorporate the distance from the start in addition to estimated distances to the goal.
</p>

<h2><span class="mw-headline" id="Greedy_BFS">Greedy BFS</span><span class="mw-editsection"></span></h2>
<p>Using a greedy algorithm, expand the first successor of the parent. After a successor is generated:<sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<ol><li>If the successor's heuristic is better than its parent, the successor is set at the front of the queue (with the parent reinserted directly behind it), and the loop restarts.</li>
<li>Else, the successor is inserted into the queue (in a location determined by its heuristic value). The procedure will evaluate the remaining successors (if any) of the parent.</li></ol>
<p>Below is a pseudocode example of this algorithm, where <b>queue</b> represents a priority queue which orders nodes based on their heuristic distances from the goal. This implementation keeps track of visited nodes, and can therefore be used for undirected graphs. It can be modified to retrieve the path.
</p>
<pre><b>procedure</b> GBS(start, target) <b>is</b>:
  mark start as visited
  add start to queue
  <b>while</b> queue <b>is</b> <b>not</b> empty <b>do</b>:
    current_node ← vertex of queue with min distance to target
    remove current_node from queue
    <b>foreach</b> neighbor n of current_node <b>do</b>:
      <b>if</b> n <b>not</b> <b>in</b> visited <b>then</b>:
        <b>if</b> n <b>is</b> target:
          <b>return</b> n
        <b>else</b>:
          mark n as visited
          add n to queue
  <b>return</b> failure 
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Beam search</li>
<li>A* search algorithm</li>
<li>Dijkstra's algorithm</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Wikibooks: Artificial Intelligence: Best-First Search</li></ul>
<!-- 
NewPP limit report
Parsed by mw2293
Cached time: 20221220210653
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.111 seconds
Real time usage: 0.162 seconds
Preprocessor visited node count: 216/1000000
Post‐expand include size: 11235/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 6/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 10228/5000000 bytes
Lua time usage: 0.074/10.000 seconds
Lua memory usage: 2707438/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  120.595      1 -total
 48.34%   58.299      1 Template:Russell_Norvig_2003
 47.14%   56.851      1 Template:Citation
 44.03%   53.097      1 Template:Tree_search_algorithm
 41.43%   49.962      1 Template:Sidebar
  4.54%    5.470      1 Template:Cite_encyclopedia
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:148271-0!canonical and timestamp 20221220210653 and revision id 1074258180.
 -->
</div></body>
</html>