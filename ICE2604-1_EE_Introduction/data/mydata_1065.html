<!DOCTYPE html>
<html>
<head>
<title>uncomputable_function</title>
</head>
<body>
<div class="mw-parser-output">
<p><b>Computable functions</b> are the basic objects of study in computability theory. Computable functions are the formalized analogue of the intuitive notion of algorithms, in the sense that a function is computable if there exists an algorithm that can do the job of the function, i.e. given an input of the function domain it can return the corresponding output. Computable functions are used to discuss computability without referring to any concrete model of computation such as Turing machines or register machines. Any definition, however, must make reference to some specific model of computation but all valid definitions yield the same class of functions.
Particular models of computability that give rise to the set of computable functions are the Turing-computable functions and the general recursive functions.
</p><p>Before the precise definition of computable function, mathematicians often used the informal term <i>effectively calculable</i>.   This term has since come to be identified with the computable functions. Note that the effective computability of these functions does not imply that they can be <i>efficiently</i> computed (i.e. computed within a reasonable amount of time). In fact, for some effectively calculable functions it can be shown that any algorithm that computes them will be very inefficient in the sense that the running time of the algorithm increases exponentially (or even superexponentially) with the length of the input. The fields of feasible computability and computational complexity study functions that can be computed efficiently.
</p><p>According to the Church–Turing thesis, computable functions are exactly the functions that can be calculated using a mechanical calculation device given unlimited amounts of time and storage space. Equivalently, this thesis states that a function is computable if and only if it has an algorithm.  Note that an algorithm in this sense is understood to be a sequence of steps a person with unlimited time and an unlimited supply of pen and paper could follow.
</p><p>The Blum axioms can be used to define an abstract computational complexity theory on the set of computable functions. In computational complexity theory, the problem of determining the complexity of a computable function is known as a function problem.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Computability of a function is an informal notion. One way to describe it is to say that a function is computable if its value can be obtained by an effective procedure. With more rigor, a function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f:\mathbb {N} ^{k}\rightarrow \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo>:</mo>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
<mo stretchy="false">→<!-- → --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f:\mathbb {N} ^{k}\rightarrow \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="f:{\mathbb  N}^{k}\rightarrow {\mathbb  N}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/093f78de2a24bc3f255b95655e98045f9eae0a37" style="vertical-align: -0.671ex; width:11.275ex; height:3.009ex;"/></span>
is computable if and only if there is an effective procedure that, given any <span class="texhtml mvar" style="font-style:italic;">k</span>-tuple <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbf {x} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbf {x} }</annotation>
</semantics>
</math></span><img alt="\mathbf {x} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/32adf004df5eb0a8c7fd8c0b6b7405183c5a5ef2" style="vertical-align: -0.338ex; width:1.411ex; height:1.676ex;"/></span> of natural numbers, will produce the value <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(\mathbf {x} )}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(\mathbf {x} )}</annotation>
</semantics>
</math></span><img alt="f({\mathbf  x})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e41ea95e6949bf4cef6426116364ba87e0fdcd60" style="vertical-align: -0.838ex; width:4.499ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-1">[1]</sup> In agreement with this definition, the remainder of this article presumes that computable functions take finitely many natural numbers as arguments and produce a value which is a single natural number.
</p><p>As counterparts to this informal description, there exist multiple formal, mathematical definitions. The class of computable functions can be defined in many equivalent models of computation, including
</p>
<ul><li>Turing machines</li>
<li>μ-recursive functions</li>
<li>Lambda calculus</li>
<li>Post machines (Post–Turing machines and tag machines).</li>
<li>Register machines</li></ul>
<p>Although these models use different representations for the functions, their inputs, and their outputs, translations exist between any two models, and so every model describes essentially the same class of functions, giving rise to the opinion that formal computability is both natural and not too narrow.<sup class="reference" id="cite_ref-2">[2]</sup> These functions are sometimes referred to as "recursive", to contrast with the informal term "computable",<sup class="reference" id="cite_ref-3">[3]</sup> a distinction stemming from a 1934 discussion between Kleene and Gödel.<sup class="reference" id="cite_ref-4">[4]</sup><sup>p.6</sup>
</p><p>For example, one can formalize computable functions as μ-recursive functions, which are partial functions that take finite tuples of natural numbers and return a single natural number (just as above).  They are the smallest class of partial functions that includes the constant, successor, and projection functions, and is closed under composition, primitive recursion, and the μ operator.
</p><p>Equivalently, computable functions can be formalized as functions which can be calculated by an idealized computing agent such as a Turing machine or a register machine. Formally speaking, a partial function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f:\mathbb {N} ^{k}\rightarrow \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo>:</mo>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
<mo stretchy="false">→<!-- → --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f:\mathbb {N} ^{k}\rightarrow \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="f:{\mathbb  N}^{k}\rightarrow {\mathbb  N}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/093f78de2a24bc3f255b95655e98045f9eae0a37" style="vertical-align: -0.671ex; width:11.275ex; height:3.009ex;"/></span> can be calculated if and only if there exists a computer program with the following properties:
</p>
<ol><li>If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(\mathbf {x} )}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(\mathbf {x} )}</annotation>
</semantics>
</math></span><img alt="f({\mathbf  x})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e41ea95e6949bf4cef6426116364ba87e0fdcd60" style="vertical-align: -0.838ex; width:4.499ex; height:2.843ex;"/></span> is defined, then the program will terminate on the input <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbf {x} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbf {x} }</annotation>
</semantics>
</math></span><img alt="\mathbf {x} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/32adf004df5eb0a8c7fd8c0b6b7405183c5a5ef2" style="vertical-align: -0.338ex; width:1.411ex; height:1.676ex;"/></span> with the value <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(\mathbf {x} )}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(\mathbf {x} )}</annotation>
</semantics>
</math></span><img alt="f({\mathbf  x})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e41ea95e6949bf4cef6426116364ba87e0fdcd60" style="vertical-align: -0.838ex; width:4.499ex; height:2.843ex;"/></span> stored in the computer memory.</li>
<li>If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(\mathbf {x} )}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(\mathbf {x} )}</annotation>
</semantics>
</math></span><img alt="f({\mathbf  x})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e41ea95e6949bf4cef6426116364ba87e0fdcd60" style="vertical-align: -0.838ex; width:4.499ex; height:2.843ex;"/></span> is undefined, then the program never terminates on the input <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbf {x} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbf {x} }</annotation>
</semantics>
</math></span><img alt="\mathbf {x} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/32adf004df5eb0a8c7fd8c0b6b7405183c5a5ef2" style="vertical-align: -0.338ex; width:1.411ex; height:1.676ex;"/></span>.</li></ol>
<h2><span class="mw-headline" id="Characteristics_of_computable_functions">Characteristics of computable functions</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The basic characteristic of a computable function is that there must be a finite procedure (an algorithm) telling how to compute the function.  The models of computation listed above give different interpretations of what a procedure is and how it is used, but these interpretations share many properties.  The fact that these models give equivalent classes of computable functions stems from the fact that each model is capable of reading and mimicking a procedure for any of the other models, much as a compiler is able to read instructions in one computer language and emit instructions in another language.
</p><p>Enderton [1977] gives the following characteristics of a procedure for computing a computable function; similar characterizations have been given by Turing [1936], Rogers [1967], and others.
</p>
<ul><li>"There must be exact instructions (i.e. a program), finite in length, for the procedure." Thus every computable function must have a finite program that completely describes how the function is to be computed.  It is possible to compute the function by just following the instructions; no guessing or special insight is required.</li>
<li>"If the procedure is given a <i>k</i>-tuple <b>x</b> in the domain of <i>f</i>, then after a finite number of discrete steps the procedure must terminate and produce <i>f</i>(<b>x</b>)." Intuitively, the procedure proceeds step by step, with a specific rule to cover what to do at each step of the calculation.  Only finitely many steps can be carried out before the value of the function is returned.</li>
<li>"If the procedure is given a <i>k</i>-tuple <b>x</b> which is not in the domain of <i>f</i>, then the procedure might go on forever, never halting.  Or it might get stuck at some point (i.e., one of its instructions cannot be executed), but it must not pretend to produce a value for <i>f</i> at <b>x</b>." Thus if a value for <i>f</i>(<b>x</b>) is ever found, it must be the correct value. It is not necessary for the computing agent to distinguish correct outcomes from incorrect ones because the procedure is defined as correct if and only if it produces an outcome.</li></ul>
<p>Enderton goes on to list several clarifications of these 3 requirements of the procedure for a computable function:
</p>
<ol><li>The procedure must theoretically work for arbitrarily large arguments. It is not assumed that the arguments are smaller than the number of atoms in the Earth, for example.</li>
<li>The procedure is required to halt after finitely many steps in order to produce an output, but it may take arbitrarily many steps before halting. No time limitation is assumed.</li>
<li>Although the procedure may use only a finite amount of storage space during a successful computation, there is no bound on the amount of space that is used.  It is assumed that additional storage space can be given to the procedure whenever the procedure asks for it.</li></ol>
<p>To summarise, based on this view a function is computable if:
</p>

<p>The field of computational complexity studies functions with prescribed bounds on the time and/or space allowed in a successful computation.
</p>
<h2><span class="mw-headline" id="Computable_sets_and_relations">Computable sets and relations</span><span class="mw-editsection"></span></h2>
<p>A set <span class="texhtml"><var>A</var></span> of natural numbers is called <b>computable</b> (synonyms: <b>recursive</b>, <b>decidable</b>) if there is a computable, total function <span class="texhtml"><i>f</i></span> such that for any natural number <span class="texhtml"><var>n</var></span>, <span class="texhtml"><i>f</i>(<var>n</var>) = 1</span> if <span class="texhtml"><var>n</var></span> is in <span class="texhtml"><var>A</var></span> and <span class="texhtml"><i>f</i>(<var>n</var>) = 0</span> if <span class="texhtml"><var>n</var></span> is not in <span class="texhtml"><var>A</var></span>.
</p><p>A set of natural numbers is called <b>computably enumerable</b> (synonyms: <b>recursively enumerable</b>, <b>semidecidable</b>) if there is a computable function <span class="texhtml"><i>f</i></span> such that for each number <span class="texhtml"><var>n</var></span>, <span class="texhtml"><i>f</i>(<var>n</var>)</span> is defined if and only if <span class="texhtml"><var>n</var></span> is in the set.  Thus a set is computably enumerable if and only if it is the domain of some computable function.  The word <i>enumerable</i> is used because the following are equivalent for a nonempty subset <span class="texhtml"><var>B</var></span> of the natural numbers:
</p>
<ul><li><span class="texhtml"><var>B</var></span> is the domain of a computable function.</li>
<li><span class="texhtml"><var>B</var></span> is the range of a total computable function.  If <span class="texhtml"><var>B</var></span> is infinite then the function can be assumed to be injective.</li></ul>
<p>If a set <span class="texhtml"><var>B</var></span> is the range of a function <span class="texhtml"><i>f</i></span> then the function can be viewed as an
enumeration of <span class="texhtml"><var>B</var></span>, because the list <span class="texhtml"><i>f</i>(0), <i>f</i>(1), ...</span> will include every element of <span class="texhtml"><var>B</var></span>.
</p><p>Because each finitary relation on the natural numbers can be identified with a corresponding set of finite sequences of natural numbers, the notions of <b>computable relation</b> and <b>computably enumerable relation</b> can be defined from their analogues for sets.
</p>
<h2><span class="mw-headline" id="Formal_languages">Formal languages</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/><p><i></i>
</p><p>In computability theory in computer science, it is common to consider formal languages.   An <b>alphabet</b> is an arbitrary set.  A <b>word</b> on an alphabet is a finite sequence of symbols from the alphabet; the same symbol may be used more than once.  For example, binary strings are exactly the words on the alphabet <span class="texhtml">{0, 1} </span>.  A <b>language</b> is a subset of the collection of all words on a fixed alphabet. For example, the collection of all binary strings that contain exactly 3 ones is a language over the binary alphabet.
</p><p>A key property of a formal language is the level of difficulty required to decide whether a given word is in the language.  Some coding system must be developed to allow a computable function to take an arbitrary word in the language as input; this is usually considered routine.  A language is called <b>computable</b> (synonyms: <b>recursive</b>, <b>decidable</b>) if there is a computable function <span class="texhtml"><i>f</i></span> such that for each word <span class="texhtml"><var>w</var></span> over the alphabet, <span class="texhtml"><i>f</i>(<var>w</var>) = 1</span> if the word is in the language and <span class="texhtml"><i>f</i>(<var>w</var>) = 0</span> if the word is not in the language. Thus a language is computable just in case there is a procedure that is able to correctly tell whether arbitrary words are in the language.
</p><p>A language is <b>computably enumerable</b> (synonyms: <b>recursively enumerable</b>, <b>semidecidable</b>) if there is a computable function <span class="texhtml"><i>f</i></span> such that <span class="texhtml"><i>f</i>(<var>w</var>)</span> is defined if and only if the word <span class="texhtml"><var>w</var></span> is in the language.  The term <i>enumerable</i> has the same etymology as in computably enumerable sets of natural numbers.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>The following functions are computable:
</p>
<ul><li>Each function with a finite domain; e.g., any finite sequence of natural numbers.</li>
<li>Each constant function <i>f</i> : <b>N</b><sup><i>k</i></sup> → <b>N</b>,  <i>f</i>(<i>n</i><sub>1</sub>,...<i>n</i><sub><i>k</i></sub>) := <i>n</i>.</li>
<li>Addition <i>f</i> : <b>N</b><sup>2</sup> → <b>N</b>, <i>f</i>(<i>n</i><sub>1</sub>,<i>n</i><sub><i>2</i></sub>) := <i>n</i><sub>1</sub> + <i>n</i><sub>2</sub></li>
<li>The greatest common divisor of two numbers</li>
<li>A Bézout coefficient of two numbers</li>
<li>The smallest prime factor of a number</li></ul>
<p>If <i>f</i> and <i>g</i> are computable, then so are: <i>f</i> + <i>g</i>, <i>f</i> * <i>g</i>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \color {Blue}f\circ g}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mstyle mathcolor="#2D2F92">
<mi>f</mi>
<mo>∘<!-- ∘ --></mo>
<mi>g</mi>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \color {Blue}f\circ g}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \color {Blue}f\circ g}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9bc7cb6de47eaf3003200d5334bcfdfa76f60f4b" style="vertical-align: -0.671ex; width:4.589ex; height:2.509ex;"/></span> if
<i>f</i> is unary, max(<i>f</i>,<i>g</i>), min(<i>f</i>,<i>g</i>), <span class="texhtml">arg max{<i>y</i> ≤ <i>f</i>(<i>x</i>)}</span>  and many more combinations.
</p><p>The following examples illustrate that a function may be computable though it is not known which algorithm computes it.
</p>
<ul><li>The function <i>f</i> such that <i>f</i>(<i>n</i>) = 1 if there is a sequence of <i>at least n</i> consecutive fives in the decimal expansion of <span class="texhtml mvar" style="font-style:italic;">π</span>, and <i>f</i>(<i>n</i>) = 0 otherwise, is computable. (The function <i>f</i> is either the constant 1 function, which is computable, or else there is a <i>k</i> such that <i>f</i>(<i>n</i>) = 1 if <i>n</i> &lt; <i>k</i> and <i>f</i>(<i>n</i>) = 0 if <i>n</i> ≥ <i>k</i>.  Every such function is computable.  It is not known whether there are arbitrarily long runs of fives in the decimal expansion of π, so we don't know <i>which</i> of those functions is <i>f</i>.  Nevertheless, we know that the function <i>f</i> must be computable.)</li>
<li>Each finite segment of an <i>un</i>computable sequence of natural numbers (such as the Busy Beaver function Σ) is computable.  E.g., for each natural number <i>n</i>, there exists an algorithm that computes the finite sequence Σ(0), Σ(1), Σ(2), ..., Σ(<i>n</i>) — in contrast to the fact that there is no algorithm that computes the <i>entire</i> Σ-sequence, i.e. Σ(<i>n</i>) for all <i>n</i>. Thus, "Print 0, 1, 4, 6, 13" is a trivial algorithm to compute Σ(0), Σ(1), Σ(2), Σ(3), Σ(4); similarly, for any given value of <i>n</i>, such a trivial algorithm <i>exists</i> (even though it may never be <i>known</i> or produced by anyone) to compute Σ(0), Σ(1), Σ(2), ..., Σ(<i>n</i>).</li></ul>
<h2><span id="Church.E2.80.93Turing_thesis"></span><span class="mw-headline" id="Church–Turing_thesis">Church–Turing thesis</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The <b>Church–Turing thesis</b> states that any function computable from a procedure possessing the three properties listed above is a computable function.  Because these three properties are not formally stated, the Church–Turing thesis cannot be proved.  The following facts are often taken as evidence for the thesis:
</p>
<ul><li>Many equivalent models of computation are known, and they all give the same definition of computable function (or a weaker version, in some instances).</li>
<li>No stronger model of computation which is generally considered to be effectively calculable has been proposed.</li></ul>
<p>The Church–Turing thesis is sometimes used in proofs to justify that a particular function is computable by giving a concrete description of a procedure for the computation.  This is permitted because it is believed that all such uses of the thesis can be removed by the tedious process of writing a formal procedure for the function in some model of computation.
</p>
<h2><span class="mw-headline" id="Provability">Provability</span><span class="mw-editsection"></span></h2>
<p>Given a function (or, similarly, a set), one may be interested not only if it is computable, but also whether this can be <i>proven</i> in a particular proof system (usually first order Peano arithmetic). A function that can be proven to be computable is called <b>provably total</b>.
</p><p>The set of provably total functions is recursively enumerable: one can enumerate all the provably total functions by enumerating all their corresponding proofs, that prove their computability. This can be done by enumerating all the proofs of the proof system and ignoring irrelevant ones.
</p>
<h3><span class="mw-headline" id="Relation_to_recursively_defined_functions">Relation to recursively defined functions</span><span class="mw-editsection"></span></h3>
<p>In a function defined by a recursive definition, each value is defined by a fixed first-order formula of other, previously defined values of the same function or other functions, which might be simply constants. A subset of these is the primitive recursive functions. Every such function is provably total: For such a k-ary function <i>f</i>, each value <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n_{1},n_{2}...n_{k})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<msub>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<msub>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>.</mo>
<mo>.</mo>
<mo>.</mo>
<msub>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n_{1},n_{2}...n_{k})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(n_{1},n_{2}...n_{k})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/32aadcf6cdb5e1241d2bf24741fc0f72fc07f8b5" style="vertical-align: -0.838ex; width:14.605ex; height:2.843ex;"/></span> can be computed by following the definition backwards, iteratively, and after finite number of iteration (as can be easily proven), a constant is reached.
</p><p>The converse is not true, as not every provably total function is primitive recursive. Indeed, one can enumerate all the primitive recursive functions and define a function <i>en</i> such that for all <i>n</i>, <i>m</i>: <i>en</i>(<i>n</i>,<i>m</i>) = <i>f</i><sub><i>n</i></sub>(<i>m</i>), where <i>f</i><sub><i>n</i></sub> is the n-th primitive recursive function (for k-ary functions, this will be set to <i>f</i><sub><i>n</i></sub>(<i>m</i>,<i>m</i>...<i>m</i>)). Now, <i>g</i>(<i>n</i>) = <i>en</i>(<i>n</i>,<i>n</i>)+1 is provably total but not primitive recursive, by a diagonalization argument: had there been a <i>j</i> such that <i>g</i> = <i>f</i><sub><i>j</i></sub>, we would have got <i>g</i>(<i>j</i>) = <i>en</i>(<i>j</i>,<i>j</i>)+1 = <i>f</i><sub><i>j</i></sub> (<i>j</i>)+1= <i>g</i>(<i>j</i>)+1, a contradiction. (The Gödel numbers of all primitive recursive functions <i>can</i> be enumerated by a primitive recursive function, though the primitive recursive functions' values cannot.)
</p><p>One such function, which is provable total but not primitive recursive, is the Ackermann function: since it is recursively defined, it is indeed easy to prove its computability (However, a similar diagonalization argument can also be built for all functions defined by recursive definition; thus, there are provable total functions that cannot be defined recursively<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (June 2016)">citation needed</span></i>]</sup>).
</p>
<h3><span class="mw-headline" id="Total_functions_that_are_not_provably_total">Total functions that are not provably total</span><span class="mw-editsection"></span></h3>
<p>In a sound proof system, every provably total function is indeed total, but the converse is not true: in every first-order proof system that is strong enough and sound (including Peano arithmetic), one can prove (in another proof system) the existence of total functions that cannot be proven total in the proof system.
</p><p>If the total computable functions are enumerated via the Turing machines that produces them, then the above statement can be shown, if the proof system is sound, by a similar diagonalization argument to that used above, using the enumeration of provably total functions given earlier. One uses a Turing machine that enumerates the relevant proofs, and for every input <i>n</i> calls  <i>f</i><sub><i>n</i></sub>(<i>n</i>) (where <i>f</i><sub><i>n</i></sub> is <i>n</i>-th function by <i>this</i> enumeration) by invoking the Turing machine that computes it according to the n-th proof. Such a Turing machine is guaranteed to halt if the proof system is sound.
</p>
<h2><span class="mw-headline" id="Uncomputable_functions_and_unsolvable_problems">Uncomputable functions and unsolvable problems</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Every computable function has a finite procedure giving explicit, unambiguous instructions on how to compute it. Furthermore, this procedure has to be encoded in the finite alphabet used by the computational model, so there are only countably many computable functions. For example, functions may be encoded using a string of bits (the alphabet <span class="texhtml">Σ = {0, 1</span>}).
</p><p>The real numbers are uncountable so most real numbers are not computable.  See computable number. The set of finitary functions on the natural numbers is uncountable so most are not computable.  Concrete examples of such functions are Busy beaver, Kolmogorov complexity, or any function that outputs the digits of a noncomputable number, such as Chaitin's constant.
</p><p>Similarly, most subsets of the natural numbers are not computable. The halting problem was the first such set to be constructed. The Entscheidungsproblem, proposed by David Hilbert, asked whether there is an effective procedure to determine which mathematical statements (coded as natural numbers) are true.  Turing and Church independently showed in the 1930s that this set of natural numbers is not computable.  According to the Church–Turing thesis, there is no effective procedure (with an algorithm) which can perform these computations.
</p>
<h2><span class="mw-headline" id="Extensions_of_computability">Extensions of computability</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Relative_computability">Relative computability</span><span class="mw-editsection"></span></h3>
<p>The notion of computability of a function can be relativized to an arbitrary set of natural numbers <i>A</i>.  A function <i>f</i> is defined to be <b>computable in <i>A</i></b> (equivalently <b><i>A</i>-computable</b> or <b>computable relative to <i>A</i></b>) when it satisfies the definition of a computable function with modifications allowing access to <i>A</i> as an oracle.  As with the concept of a computable function relative computability can be given equivalent definitions in many different models of computation.  This is commonly accomplished by supplementing the model of computation with an additional primitive operation which asks whether a given integer is a member of <i>A</i>.  We can also talk about <i>f</i> being <b>computable in <i>g</i></b> by identifying <i>g</i> with its graph.
</p>
<h3><span class="mw-headline" id="Higher_recursion_theory">Higher recursion theory</span><span class="mw-editsection"></span></h3>
<p>Hyperarithmetical theory studies those sets that can be computed from a computable ordinal number of iterates of the Turing jump of the empty set.  This is equivalent to sets defined by both a universal and existential formula in the language of second order arithmetic and to some models of Hypercomputation.  Even more general recursion theories have been studied, such as <b>E-recursion theory</b> in which any set can be used as an argument to an E-recursive function.
</p>
<h3><span class="mw-headline" id="Hyper-computation">Hyper-computation</span><span class="mw-editsection"></span></h3>
<p>Although the Church–Turing thesis states that the computable functions include all functions with algorithms, it is possible to consider broader classes of functions that relax the requirements that algorithms must possess.  The field of Hypercomputation studies models of computation that go beyond normal Turing computation.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Computable number</li>
<li>Effective method</li>
<li>Theory of computation</li>
<li>Recursion theory</li>
<li>Turing degree</li>
<li>Arithmetical hierarchy</li>
<li>Hypercomputation</li>
<li>Super-recursive algorithm</li>
<li>Semicomputable function</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li>Cutland, Nigel. <i>Computability</i>. Cambridge University Press, 1980.</li>
<li>Enderton, H.B. Elements of recursion theory.  <i>Handbook of Mathematical Logic</i> (North-Holland 1977) pp. 527–566.</li>
<li>Rogers, H.  <i>Theory of recursive functions and effective computation</i> (McGraw–Hill 1967).</li>
<li>Turing, A. (1937), On Computable Numbers, With an Application to the Entscheidungsproblem. <i>Proceedings of the London Mathematical Society</i>, Series 2, Volume 42 (1937), p.230–265. Reprinted in M. Davis (ed.), <i>The Undecidable</i>, Raven Press, Hewlett, NY, 1965.</li></ul>


<!-- 
NewPP limit report
Parsed by mw2269
Cached time: 20221223231755
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.395 seconds
Real time usage: 0.556 seconds
Preprocessor visited node count: 2529/1000000
Post‐expand include size: 85695/2097152 bytes
Template argument size: 4145/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 7/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 15196/5000000 bytes
Lua time usage: 0.178/10.000 seconds
Lua memory usage: 4422619/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  376.433      1 -total
 25.51%   96.042      5 Template:Navbox
 24.68%   92.894      1 Template:Reflist
 20.73%   78.024      2 Template:Cite_book
 18.44%   69.419      1 Template:Short_description
 13.05%   49.110      1 Template:ComplexityClasses
 10.87%   40.902      1 Template:Mathematical_logic
 10.80%   40.654     32 Template:Math
 10.47%   39.421      2 Template:Pagetype
  9.34%   35.165      1 Template:Citation_needed
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1139338-0!canonical and timestamp 20221223231755 and revision id 1122713957.
 -->
</div></body>
</html>