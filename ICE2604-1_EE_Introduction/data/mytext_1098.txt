Viterbi_algorithmThe Viterbi algorithm is a dynamic programming algorithm for obtaining the maximum a posteriori probability estimate of the most likely sequence of hidden states—called the Viterbi path—that results in a sequence of observed events, especially in the context of Markov information sources and hidden Markov models (HMM).The algorithm has found universal application in decoding the convolutional codes used in both CDMA and GSM digital cellular, dial-up modems, satellite, deep-space communications, and 802.11 wireless LANs. It is now also commonly used in speech recognition, speech synthesis, diarization,[1] keyword spotting, computational linguistics, and bioinformatics. For example, in speech-to-text (speech recognition), the acoustic signal is treated as the observed sequence of events, and a string of text is considered to be the "hidden cause" of the acoustic signal. The Viterbi algorithm finds the most likely string of text given the acoustic signal.The Viterbi algorithm is named after Andrew Viterbi, who proposed it in 1967 as a decoding algorithm for convolutional codes over noisy digital communication links.[2] It has, however, a history of multiple invention, with at least seven independent discoveries, including those by Viterbi, Needleman and Wunsch, and Wagner and Fischer.[3] It was introduced to Natural Language Processing as a method of part-of-speech tagging as early as 1987.Viterbi path and Viterbi algorithm have become standard terms for the application of dynamic programming algorithms to maximization problems involving probabilities.[3]For example, in statistical parsing a dynamic programming algorithm can be used to discover the single most likely context-free derivation (parse) of a string, which is commonly called the "Viterbi parse".[4][5][6] Another application is in target tracking, where the track is computed that assigns a maximum likelihood to a sequence of observations.[7]A generalization of the Viterbi algorithm, termed the max-sum algorithm (or max-product algorithm) can be used to find the most likely assignment of all or some subset of latent variables in a large number of graphical models, e.g. Bayesian networks, Markov random fields and conditional random fields.  The latent variables need, in general, to be connected in a way somewhat similar to a hidden Markov model (HMM), with a limited number of connections between variables and some type of linear structure among the variables.  The general algorithm involves message passing and is substantially similar to the belief propagation algorithm (which is the generalization of the forward-backward algorithm).With the algorithm called iterative Viterbi decoding one can find the subsequence of an observation that matches best (on average) to a given hidden Markov model. This algorithm is proposed by Qi Wang et al. to deal with turbo code.[8] Iterative Viterbi decoding works by iteratively invoking a modified Viterbi algorithm, reestimating the score for a filler until convergence.An alternative algorithm, the Lazy Viterbi algorithm, has been proposed.[9] For many applications of practical interest, under reasonable noise conditions, the lazy decoder (using Lazy Viterbi algorithm) is much faster than the original Viterbi decoder (using Viterbi algorithm). While the original Viterbi algorithm calculates every node in the trellis of possible outcomes, the Lazy Viterbi algorithm maintains a prioritized list of nodes to evaluate in order, and the number of calculations required is typically fewer (and never more) than the ordinary Viterbi algorithm for the same result. However, it is not so easy[] to parallelize in hardware.This algorithm generates a path , which is a sequence of states  that generate the observations  with , where  is the number of possible observations in the observation space .Two 2-dimensional tables of size  are constructed:Each element  of  stores the probability of the most likely path so far  with  that generates .Each element  of  stores  of the most likely path so far  The table entries  are filled by increasing order of :,,with  and  as defined below. Note that  does not need to appear in the latter expression, as it's non-negative and independent of  and thus does not affect the argmax.InputThe observation space ,the state space ,an array of initial probabilities  such that  stores the probability that ,a sequence of observations   such that  if the observation at time  is ,transition matrix  of size  such that  stores the transition probability of transiting from state  to state ,emission matrix  of size  such that  stores the probability of observing  from  state .OutputThe most likely hidden state sequence function VITERBI    for each state  do                    end for    for each observation  do        for each state  do                                end for    end for            for  do                    end for    return end functionRestated in a succinct near-Python:function viterbi   Tm: transition matrix   Em: emission matrix          To hold probability of each state given each observation        To hold backpointer to best prior state    for s in :                Determine each hidden state's probability at time 0…            for o in :              …and after, tracking each state's most likely prior state, k        for s in :                                                Find k of best final state    for o in :      Backtrack from last observation                        Insert previous state on most likely path                              Use backpointer to find best previous state    return ExplanationSuppose we are given a hidden Markov model (HMM) with state space , initial probabilities  of being in state  and transition probabilities  of transitioning from state  to state .  Say, we observe outputs .  The most likely state sequence  that produces the observations is given by the recurrence relations[10]Here  is the probability of the most probable state sequence  responsible for the first  observations that have  as its final state.  The Viterbi path can be retrieved by saving back pointers that remember which state  was used in the second equation.  Let  be the function that returns the value of  used to compute  if , or  if .  ThenHere we're using the standard definition of arg max.The complexity of this implementation is . A better estimation exists if the maximum in the internal loop is instead found by iterating only over states that directly link to the current state (i.e. there is an edge from  to ). Then using amortized analysis one can show that the complexity is , where  is the number of edges in the graph.Consider a village where all villagers are either healthy or have a fever, and only the village doctor can determine whether each has a fever. The doctor diagnoses fever by asking patients how they feel. The villagers may only answer that they feel normal, dizzy, or cold.The doctor believes that the health condition of the patients operates as a discrete Markov chain. There are two states, "Healthy" and "Fever", but the doctor cannot observe them directly; they are hidden from the doctor. On each day, there is a certain chance that a patient will tell the doctor "I feel normal", "I feel cold", or "I feel dizzy", depending on the patient's health condition.The observations (normal, cold, dizzy) along with a hidden state (healthy, fever) form a hidden Markov model (HMM), and can be represented as follows in the Python programming language:In this piece of code, start_p represents the doctor's belief about which state the HMM is in when the patient first visits (all the doctor knows is that the patient tends to be healthy). The particular probability distribution used here is not the equilibrium one, which is (given the transition probabilities) approximately {'Healthy': 0.57, 'Fever': 0.43}. The transition_p represents the change of the health condition in the underlying Markov chain. In this example, a patient who is healthy today has only a 30% chance of having a fever tomorrow. The emit_p represents how likely each possible observation (normal, cold, or dizzy) is, given the underlying condition (healthy or fever). A patient who is healthy has a 50% chance of feeling normal; one who has a fever has a 60% chance of feeling dizzy.A patient visits three days in a row, and the doctor discovers that the patient feels normal on the first day, cold on the second day, and dizzy on the third day. The doctor has a question: what is the most likely sequence of health conditions of the patient that would explain these observations? This is answered by the Viterbi algorithm.The function viterbi takes the following arguments: obs is the sequence of observations, e.g. ['normal', 'cold', 'dizzy']; states is the set of hidden states; start_p is the start probability; trans_p are the transition probabilities; and emit_p are the emission probabilities.  For simplicity of code, we assume that the observation sequence obs is non-empty and that  trans_p[i] [j] and emit_p[i] [j] is defined for all states i,j.In the running example, the forward/Viterbi algorithm is used as follows:The output of the script isThis reveals that the observations ['normal', 'cold', 'dizzy'] were most likely generated by states ['Healthy', 'Healthy', 'Fever']. In other words, given the observed activities, the patient was most likely to have been healthy on the first day and also on the second day (despite feeling cold that day), and only to have contracted a fever on the third day.The operation of Viterbi's algorithm can be visualized by means of atrellis diagram. The Viterbi path is essentially the shortestpath through this trellis.The soft output Viterbi algorithm (SOVA) is a variant of the classical Viterbi algorithm.SOVA differs from the classical Viterbi algorithm in that it uses a modified path metric which takes into account the a priori probabilities of the input symbols, and produces a soft output indicating the reliability of the decision.The first step in the SOVA is the selection of the survivor path, passing through one unique node at each time instant, t. Since each node has 2 branches converging at it (with one branch being chosen to form the Survivor Path, and the other being discarded), the difference in the branch metrics (or cost) between the chosen and discarded branches indicate the amount of error in the choice.This cost is accumulated over the entire sliding window (usually equals at least five constraint lengths), to indicate the soft output measure of reliability of the hard bit decision of the Viterbi algorithm.Expectation–maximization algorithmBaum–Welch algorithmForward-backward algorithmForward algorithmError-correcting codeViterbi decoderHidden Markov modelPart-of-speech taggingA* search algorithmViterbi AJ (April 1967). "Error bounds for convolutional codes and an asymptotically optimum decoding algorithm". IEEE Transactions on Information Theory. 13 (2): 260–269. doi:10.1109/TIT.1967.1054010. (note: the Viterbi decoding algorithm is described in section IV.) Subscription required.Feldman J, Abou-Faycal I, Frigo M (2002). "A Fast Maximum-Likelihood Decoder for Convolutional Codes". Proceedings IEEE 56th Vehicular Technology Conference. Vehicular Technology Conference. Vol. 1. pp. 371–375. CiteSeerX . doi:10.1109/VETECF.2002.1040367. ISBN 978-0-7803-7467-6. S2CID 9783963.Forney GD (March 1973). "The Viterbi algorithm". Proceedings of the IEEE. 61 (3): 268–278. doi:10.1109/PROC.1973.9030. Subscription required.Press, WH; Teukolsky, SA; Vetterling, WT; Flannery, BP (2007). "Section 16.2. Viterbi Decoding". Numerical Recipes: The Art of Scientific Computing (3rd ed.). New York: Cambridge University Press. ISBN 978-0-521-88068-8.Rabiner LR (February 1989). "A tutorial on hidden Markov models and selected applications in speech recognition". Proceedings of the IEEE. 77 (2): 257–286. CiteSeerX . doi:10.1109/5.18626. S2CID 13618539. (Describes the forward algorithm and Viterbi algorithm for HMMs).Shinghal, R. and Godfried T. Toussaint, "Experiments in text recognition with the modified Viterbi algorithm," IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. PAMI-l, April 1979, pp. 184–193.Shinghal, R. and Godfried T. Toussaint, "The sensitivity of the modified Viterbi algorithm to the source statistics," IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. PAMI-2, March 1980, pp. 181–185.Implementations in Java, F#, Clojure, C# on WikibooksTutorial on convolutional coding with viterbi decoding, by Chip FlemingA tutorial for a Hidden Markov Model toolkit (implemented in C) that contains a description of the Viterbi algorithmViterbi algorithm by Dr. Andrew J. Viterbi (scholarpedia.org).Mathematica has an implementation as part of its support for stochastic processesSusa signal processing framework provides the C++ implementation for Forward error correction codes and channel equalization here.C++C#JavaJava 8Julia (HMMBase.jl)PerlPrologHaskellGoSFIHMM includes code for Viterbi decoding.