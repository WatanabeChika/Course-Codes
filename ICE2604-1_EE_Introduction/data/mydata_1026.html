<!DOCTYPE html>
<html>
<head>
<title>tournament_sort</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Tournament sort</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Sorting algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data">O(<i>n</i> log <i>n</i>)</td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data">O(<i>n</i> log <i>n</i>)</td></tr></tbody></table>
<p><b>Tournament sort</b> is a sorting algorithm.  It improves upon the naive selection sort by using a priority queue to find the next element in the sort.  In the naive selection sort, it takes O(<i>n</i>) operations to select the next element of <i>n</i> elements; in a tournament sort, it takes O(log <i>n</i>) operations (after building the initial tournament in O(<i>n</i>)).  Tournament sort is a variation of heapsort.
</p>

<h2><span class="mw-headline" id="Common_application">Common application</span><span class="mw-editsection"></span></h2>
<p>Tournament replacement selection sorts are used to gather the initial runs for external sorting algorithms. Conceptually, an external file is read and its elements are pushed into the priority queue until the queue is full. Then the minimum element is pulled from the queue and written as part of the first run. The next input element is read and pushed into the queue, and the min is selected again and added to the run. There's a small trick that if the new element being pushed into the queue is less than the last element added to the run, then the element's sort value is increased so it will be part of the next run. On average, a run will be 100% longer than the capacity of the priority queue.<sup class="reference" id="cite_ref-1">[1]</sup>
</p><p>Tournament sorts may also be used in N-way merges.
</p>
<h2><span class="mw-headline" id="Etymology">Etymology</span><span class="mw-editsection"></span></h2>
<p>The name comes from its similarity to a single-elimination tournament where there are many players (or teams) that play in two-sided matches. Each match compares the players, and the winning player is promoted to play a match at the next level up. The hierarchy continues until the final match determines the ultimate winner. The tournament determines the best player, but the player who was beaten in the final match may not be the second best – he may be inferior to other players the winner bested.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>The following is an implementation of tournament sort in Haskell, based on Scheme code by Stepanov and Kershenbaum.<sup class="reference" id="cite_ref-Stepanov1986_2-0">[2]</sup>
</p>

<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<ul><li>Kershenbaum et al 1988, "Higher Order Imperative Programming"</li></ul>

<!-- 
NewPP limit report
Parsed by mw2307
Cached time: 20221221040700
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.189 seconds
Real time usage: 0.259 seconds
Preprocessor visited node count: 405/1000000
Post‐expand include size: 26767/2097152 bytes
Template argument size: 96/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 21734/5000000 bytes
Lua time usage: 0.120/10.000 seconds
Lua memory usage: 3165036/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  215.745      1 -total
 35.54%   76.686      1 Template:Refimprove
 28.43%   61.336      1 Template:Cite_techreport
 27.51%   59.343      1 Template:Ambox
 19.92%   42.972      1 Template:Sorting
 18.91%   40.798      1 Template:Navbox
 14.40%   31.077      1 Template:Infobox_Algorithm
 11.10%   23.950      1 Template:Infobox
  5.35%   11.551      1 Template:Find_sources_mainspace
  2.11%    4.558      1 Template:PAGENAMEBASE
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:24118010-0!canonical and timestamp 20221221040700 and revision id 1075774615.
 -->
</div></body>
</html>