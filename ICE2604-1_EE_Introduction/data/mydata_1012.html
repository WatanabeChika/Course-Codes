<!DOCTYPE html>
<html>
<head>
<title>threaded_binary_tree</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Cleanup_rewrite plainlinks metadata ambox ambox-content" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>

<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p>In computing, a <b>threaded binary tree</b> is a binary tree variant that facilitates traversal in a particular order (often the same order already defined for the tree).
</p><p>An entire binary search tree can be easily traversed in order of the main key, but given only a pointer to a node, finding the node which comes next may be slow or impossible. For example, leaf nodes by definition have no descendants, so given only a pointer to a leaf node no other node can be reached. A threaded tree adds extra information in some or all nodes, so that for any given single node the "next" node can be found quickly, allowing tree traversal without recursion and the extra storage (proportional to the tree's depth) that recursion requires.
</p>

<h2><span class="mw-headline" id="Threading">Threading</span><span class="mw-editsection"></span></h2>
<blockquote>
<p>"A binary tree is <i>threaded</i> by making all right child pointers that would normally be null point to the in-order successor of the node (<b>if</b> it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node."<sup class="reference" id="cite_ref-1">[1]</sup>
</p>
</blockquote>
<p>This assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called "threads", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.
</p>
<h2><span class="mw-headline" id="Motivation">Motivation</span><span class="mw-editsection"></span></h2>
<p>Trees, including (but not limited to) binary search trees, can be used to store items in a particular order, such as the value of some property stored in each node, often called a key. One useful operation on such a tree is <i>traversal</i>: visiting all the items in order of the key.
</p><p>A simple recursive traversal algorithm that visits each node of a binary search tree is the following. Assume <span class="texhtml mvar" style="font-style:italic;">t</span> is a pointer to a node, or <span class="texhtml">nil</span>. "Visiting" <span class="texhtml mvar" style="font-style:italic;">t</span> can mean performing any action on the node <span class="texhtml mvar" style="font-style:italic;">t</span> or its contents.
</p>

<p>One problem with this algorithm is that, because of its recursion, it uses stack space proportional to the height of a tree. If the tree is fairly balanced, this amounts to <span class="texhtml"><i>O</i>(log <i>n</i>)</span> space for a tree containing <span class="texhtml mvar" style="font-style:italic;">n</span> elements. In the worst case, when the tree takes the form of a chain, the height of the tree is <span class="texhtml mvar" style="font-style:italic;">n</span> so the algorithm takes <span class="texhtml"><i>O</i>(<i>n</i>)</span> space. A second problem is that all traversals must begin at the root when nodes have pointers only to their children. It is common to have a pointer to a particular node, but that is not sufficient to get back to the rest of the tree unless extra information is added, such as thread pointers.
</p><p>In this approach, it may not be possible to tell whether the left and/or right pointers in a given node actually point to children, or are a consequence of threading. If the distinction is necessary, adding a single bit to each node is enough to record it.
</p><p>In a 1968 textbook, Donald Knuth asked whether a non-recursive algorithm for in-order traversal exists, that uses no stack and leaves the tree unmodified.<sup class="reference" id="cite_ref-2">[2]</sup> One of the solutions to this problem is tree threading, presented by Joseph M. Morris in 1979.<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup>
In the 1969 follow-up edition,<sup class="reference" id="cite_ref-5">[5]</sup> Knuth attributed the threaded tree representation to Perlis and Thornton (1960).<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<h3><span class="mw-headline" id="Relation_to_parent_pointers">Relation to parent pointers</span><span class="mw-editsection"></span></h3>
<p>Another way to achieve similar goals is to include a pointer in every node, to that node's parent node. Given that, the "next" node can always be reached. "right" pointers are still null whenever there are no right children. To find the "next" node from a node whose right pointer is null, walk up through "parent" pointers until reaching a node whose right pointer is not null, and is not the child you just came up from. That node is the "next" node, and after it come its descendants on the right.
</p><p>It is also possible to discover the parent of a node from a threaded binary tree, without explicit use of parent pointers or a stack, although it is slower. To see this, consider a node <i>k</i> with right child <i>r</i>.  Then the left pointer of <i>r</i> must be either a child or a thread back to <i>k</i>. In the case that <i>r</i> has a left child, that left child must in turn have either a left child of its own or a thread back to <i>k</i>, and so on for all successive left children.  So by following the chain of left pointers from <i>r</i>, we will eventually find a thread pointing back to <i>k</i>.  The situation is symmetrically similar when <i>q</i> is the left child of <i>p</i>—we can follow <i>q'</i>s right children to a thread pointing ahead to <i>p</i>.
</p><p>
In Python:</p>
<h2><span class="mw-headline" id="Types">Types</span><span class="mw-editsection"></span></h2>
<ol><li>Single threaded: each node is threaded towards <b>either</b> the in-order predecessor <b>or</b> successor (left <b>or</b> right).</li>
<li>Double threaded: each node is threaded towards <b>both</b> the in-order predecessor <b>and</b> successor (left <b>and</b> right).</li></ol>
<h2><span class="mw-headline" id="The_array_of_in-order_traversal">The array of in-order traversal</span><span class="mw-editsection"></span></h2>
<p>Threads are reference to the predecessors and successors of the node according to an inorder traversal. 
</p><p>In-order traversal of the threaded tree is <code>A,B,C,D,E,F,G,H,I</code>, the predecessor of <code>E</code> is <code>D</code>, the successor of <code>E</code> is <code>F</code>.
</p><p><img alt="ThreadTree Inorder Array.png" data-file-height="122" data-file-width="478" decoding="async" height="122" src="//upload.wikimedia.org/wikipedia/commons/1/1f/ThreadTree_Inorder_Array.png" width="478"/>
</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>
<p><img alt="ThreadTree Inorder Array123456789.png" data-file-height="297" data-file-width="372" decoding="async" height="297" src="//upload.wikimedia.org/wikipedia/commons/2/2c/ThreadTree_Inorder_Array123456789.png" width="372"/>
</p><p>Let's make the Threaded Binary tree out of a normal binary tree:
</p><p><img alt="Normal Binary Tree.png" data-file-height="317" data-file-width="423" decoding="async" height="317" src="//upload.wikimedia.org/wikipedia/commons/6/6a/Normal_Binary_Tree.png" width="423"/>
</p><p>The in-order traversal for the above tree is — D B A E C. So, the respective Threaded Binary tree will be --
</p><p><img alt="Threaded Binary Tree.png" data-file-height="324" data-file-width="483" decoding="async" height="324" src="//upload.wikimedia.org/wikipedia/commons/8/8b/Threaded_Binary_Tree.png" width="483"/>
</p>
<h2><span class="mw-headline" id="Null_links">Null links</span><span class="mw-editsection"></span></h2>
<p>In an <i>m</i>-way threaded binary tree with <i>n</i> nodes, there are <b><i>n</i>×<i>m</i> − (<i>n</i>−1)</b> void links.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>GNU libavl 2.0.2, Section on threaded binary search trees</li></ul>
<!-- 
NewPP limit report
Parsed by mw2335
Cached time: 20221220211310
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.201 seconds
Real time usage: 0.498 seconds
Preprocessor visited node count: 997/1000000
Post‐expand include size: 20864/2097152 bytes
Template argument size: 618/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 26034/5000000 bytes
Lua time usage: 0.103/10.000 seconds
Lua memory usage: 4371488/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  450.859      1 -total
 22.83%  102.919      1 Template:Reflist
 13.86%   62.507      1 Template:Cleanup-rewrite
 10.62%   47.862      1 Template:Ambox
  9.96%   44.926      2 Template:Cite_book
  8.77%   39.540      1 Template:Graph_search_algorithm
  8.31%   37.456      1 Template:Sidebar
  7.15%   32.254      1 Template:ISBN
  5.88%   26.498      1 Template:Catalog_lookup_link
  2.84%   12.807      3 Template:Cite_journal
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:4262609-0!canonical and timestamp 20221220211310 and revision id 1117927884.
 -->
</div></body>
</html>