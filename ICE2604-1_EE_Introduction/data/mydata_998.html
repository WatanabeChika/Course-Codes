<!DOCTYPE html>
<html>
<head>
<title>supersink</title>
</head>
<body>
<div class="mw-parser-output">
<p>In graph theory, a <b>flow network</b> (also known as a <b>transportation network</b>) is a directed graph where each edge has a <b>capacity</b> and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge. Often in operations research, a directed graph is called a <b>network</b>, the vertices are called <b>nodes</b> and the edges are called <b>arcs</b>.  A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it, unless it is a <b>source</b>, which has only outgoing flow, or <b>sink</b>, which has only incoming flow. A network can be used to model traffic in a computer network, circulation with demands, fluids in pipes, currents in an electrical circuit, or anything similar in which something travels through a network of nodes.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>A <b>network</b> is a graph <span class="texhtml"><i>G</i> = (<i>V</i>, <i>E</i>)</span>, where <span class="texhtml"><i>V</i></span> is a set of vertices and <span class="texhtml"><i>E</i></span> is a set of <span class="texhtml"><i>V</i></span>'s edges – a subset of <span class="texhtml"><i>V</i> × <i>V</i></span> – together with a non-negative function <span class="texhtml"><i>c</i>: <i>V</i> × <i>V</i> → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {R} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {R} }</annotation>
</semantics>
</math></span><img alt="\mathbb {R} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span><sub>∞</sub></span>, called the <b>capacity</b> function. Without loss of generality, we may assume that if <span class="texhtml">(<i>u</i>, <i>v</i>) ∈ <i>E</i></span> then <span class="texhtml">(<i>v</i>, <i>u</i>)</span> is also a member of <span class="texhtml mvar" style="font-style:italic;">E</span>, since if <span class="texhtml">(<i>v</i>, <i>u</i>) ∉ <i>E</i></span> then we may add <span class="texhtml">(<i>v</i>, <i>u</i>)</span> to <i>E</i> and then set <span class="texhtml"><i>c</i>(<i>v</i>, <i>u</i>) = 0</span>.
</p><p>If two nodes in <span class="texhtml mvar" style="font-style:italic;">G</span> are distinguished, a source <span class="texhtml mvar" style="font-style:italic;">s</span> and a sink <span class="texhtml mvar" style="font-style:italic;">t</span>, then <span class="texhtml">(<i>G</i>, <i>c</i>, <i>s</i>, <i>t</i>)</span> is called a <b>flow network</b>.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Flows">Flows</span><span class="mw-editsection"></span></h2>
<p>There are various notions of a flow function that can be defined in a flow graph. Flow functions model the net flow of units between pairs of nodes, and are useful when asking questions such as <i>what is the maximum number of units that can be transferred from the source node s to the sink node t?</i> The simplest example of a flow function is  known as a pseudo-flow.
</p>
<dl><dd>A <b>pseudo-flow</b> is a function <span class="texhtml"><i>f</i> : <i>V</i> × <i>V</i> → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {R} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {R} }</annotation>
</semantics>
</math></span><img alt="\mathbb {R} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span></span> that satisfies the following two constraints for all nodes <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span>:
<ul><li><i>Skew symmetry</i>: Only encode the net flow of units between a pair of nodes <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span> (see intuition below), that is: <span class="texhtml"><i>f</i> (<i>u</i>, <i>v</i>) = −<i>f</i> (<i>v</i>, <i>u</i>)</span>.</li>
<li><i>Capacity constraint</i>: An arc's flow cannot exceed its capacity, that is: <span class="texhtml"><i>f</i> (<i>u</i>, <i>v</i>) ≤ <i>c</i>(<i>u</i>, <i>v</i>)</span>.</li></ul></dd></dl>
<p><br/>
Given a pseudo-flow <span class="texhtml mvar" style="font-style:italic;">f</span> in a flow network, it is often useful to consider the net flow entering a given node <span class="texhtml mvar" style="font-style:italic;">u</span>, that is, the sum of the flows entering <span class="texhtml mvar" style="font-style:italic;">u</span>. The <b>excess</b> function <span class="texhtml"><i>x</i><sub><i>f</i></sub> : <i>V</i> → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {R} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {R} }</annotation>
</semantics>
</math></span><img alt="\mathbb {R} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span></span> is defined by <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>u</i>) = Σ<sub><i>v</i> ∈ <i>V</i></sub> <i>f</i> (<i>v</i>, <i>u</i>)</span>. A node <span class="texhtml mvar" style="font-style:italic;">u</span> is said to be <b>active</b> if <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>u</i>) &gt; 0</span>, <b>deficient</b> if <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>u</i>) &lt; 0</span> or <b>conserving</b> if <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>u</i>) = 0</span>.
</p><p>These final definitions lead to two strengthenings of the definition of a pseudo-flow:
</p>
<dl><dd>A <b>pre-flow</b> is a pseudo-flow that, for all <span class="texhtml"><i>v</i> ∈ <i>V</i> \{<i>s</i></span>}, satisfies the additional constraint:
<ul><li><i>Non-deficient flows</i>: The net flow <i>entering</i> the node <span class="texhtml mvar" style="font-style:italic;">v</span> is non-negative, except for the source, which "produces" flow. That is: <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>v</i>) ≥ 0</span> for all <span class="texhtml"><i>v</i> ∈ <i>V</i> \{<i>s</i></span>}.</li></ul></dd></dl>
<dl><dd>A <b>feasible flow</b>, or just a <b>flow</b>, is a pseudo-flow that, for all <span class="texhtml"><i>v</i> ∈ <i>V</i> \{<i>s</i>, <i>t</i></span>}, satisfies the additional constraint:
<ul><li><i>Flow conservation</i>: The net flow <i>entering</i> the node <span class="texhtml mvar" style="font-style:italic;">v</span> is 0, except for the source, which "produces" flow, and the sink, which "consumes" flow. That is: <span class="texhtml"><i>x</i><sub><i>f</i></sub> (<i>v</i>) = 0</span> for all <span class="texhtml"><i>v</i> ∈ <i>V</i> \{<i>s</i>, <i>t</i></span>}.</li></ul></dd></dl>
<p><br/>
The <b>value</b> of a feasible flow <span class="texhtml mvar" style="font-style:italic;">f</span>, denoted <span class="texhtml">| <i>f</i> |</span>, is the net flow into the sink <span class="texhtml mvar" style="font-style:italic;">t</span> of the flow network. That is, <span class="texhtml">| <i>f</i> | = <i>x</i><sub><i>f</i></sub> (<i>t</i>)</span>.
</p>
<h2><span class="mw-headline" id="Intuition">Intuition</span><span class="mw-editsection"></span></h2>
<p>In the context of flow analysis, there is only an interest in considering how units are transferred between nodes in a holistic sense. Put another way, it is not necessary to distinguish multiple arcs between a pair of nodes:
</p>
<ul><li>Given any two nodes <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span>, if there are two arcs from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span> with capacities <span class="texhtml">5</span> and <span class="texhtml">3</span> respectively, this is equivalent to considering only a single arc between <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span> with capacity <span class="texhtml">8</span> — it is only useful to know that <span class="texhtml">8</span> units can be transferred from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span>, not how they can be transferred.</li>
<li>Again, given two nodes <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span>, if there is a flow of <span class="texhtml">5</span> units from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span>, and another flow of <span class="texhtml">3</span> units from <span class="texhtml mvar" style="font-style:italic;">v</span> to <span class="texhtml mvar" style="font-style:italic;">u</span>, this is equivalent to a net flow of <span class="texhtml">2</span> units from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span>, or a net flow of <span class="texhtml">−2</span> units from <span class="texhtml mvar" style="font-style:italic;">v</span> to <span class="texhtml mvar" style="font-style:italic;">u</span> (so sign indicates direction) — it is only useful to know that a net flow of <span class="texhtml">2</span> units will flow between <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span>, and the direction that they will flow, not how that net flow is achieved.</li></ul>
<p>For this reason, the <i>capacity function</i> <span class="texhtml"><i>c</i>: <i>V</i> × <i>V</i> → <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {R} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {R} }</annotation>
</semantics>
</math></span><img alt="\mathbb {R} " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" style="vertical-align: -0.338ex; width:1.678ex; height:2.176ex;"/></span><sub>∞</sub></span>, which does not allow for multiple arcs starting and ending at the same nodes, is sufficient for flow analysis. Similarly, it is enough to impose the <i>skew symmetry</i> constraint on flow functions to ensure that flow between two vertices is encoded by a single number (to indicate magnitude), and a sign (to indicate direction) — by knowing the flow between <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span> you implicitly, via skew symmetry, know the flow between <span class="texhtml mvar" style="font-style:italic;">v</span> and <span class="texhtml mvar" style="font-style:italic;">u</span>. These simplifications of the model aren't always immediately intuitive, but they are convenient when it comes time to analyze flows.
</p><p>The <i>capacity constraint</i> simply ensures that a flow on any one arc within the network cannot exceed the capacity of that arc.
</p>
<h2><span class="mw-headline" id="Concepts_useful_to_flow_problems">Concepts useful to flow problems</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Residuals">Residuals</span><span class="mw-editsection"></span></h3>
<p>The <b>residual capacity</b> of an arc with respect to a pseudo-flow <span class="texhtml mvar" style="font-style:italic;">f</span>, denoted <span class="texhtml"><i>c</i><sub><i>f</i></sub></span>, is the difference between the arc's capacity and its flow. That is, <span class="texhtml"><i>c</i><sub><i>f</i></sub> (<i>e</i>) = <i>c</i>(<i>e</i>) - <i>f</i>(<i>e</i>)</span>. From this we can construct a <b>residual network</b>, denoted <span class="texhtml"><i>G</i><sub><i>f</i></sub> (<i>V</i>, <i>E</i><sub><i>f</i></sub>)</span>, which models the amount of <i>available</i> capacity on the set of arcs in <span class="texhtml"><i>G</i> = (<i>V</i>, <i>E</i>)</span>. More formally, given a flow network <span class="texhtml mvar" style="font-style:italic;"><i>G</i></span>, the residual network <span class="texhtml"><i>G</i><sub><i>f</i></sub></span>  has the node set <span class="texhtml mvar" style="font-style:italic;">V</span>, arc set <span class="texhtml"><i>E</i><sub><i>f</i></sub> = {<i>e</i> ∈ <i>V</i> × <i>V</i> : <i>c<sub>f</sub></i> (<i>e</i>) &gt; 0}</span> and capacity function <span class="texhtml"><i>c</i><sub><i>f</i></sub></span>.
</p><p>This concept is used in Ford–Fulkerson algorithm which computes the maximum flow in a flow network.
</p><p>Note that there can be an unsaturated path (a path with available capacity) from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span> in the residual network, even though there is no such path from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span> in the original network. Since flows in opposite directions cancel out, <i>decreasing</i> the flow from <span class="texhtml mvar" style="font-style:italic;">v</span> to <span class="texhtml mvar" style="font-style:italic;">u</span> is the same as <i>increasing</i> the flow from <span class="texhtml mvar" style="font-style:italic;">u</span> to <span class="texhtml mvar" style="font-style:italic;">v</span>.
</p>
<h3><span class="mw-headline" id="Augmenting_paths">Augmenting paths</span><span class="mw-editsection"></span></h3>
<p>An <b>augmenting path</b> is a path <span class="texhtml">(<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>, ..., <i>u</i><sub><i>k</i></sub>)</span> in the residual network, where <span class="texhtml"><i>u</i><sub>1</sub> = <i>s</i></span>, <span class="texhtml"><i>u</i><sub><i>k</i></sub> = <i>t</i></span>, and <span class="texhtml">for all <i>u</i><sub><i>i</i></sub>, <i>u</i><sub><i>i</i> + 1</sub> (<i>c</i><sub><i>f</i></sub> (<i>u</i><sub><i>i</i></sub>, <i>u</i><sub><i>i</i> + 1</sub>) &gt; 0) (1 ≤ i &lt; k)</span>. A network is at maximum flow if and only if there is no augmenting path in the residual network <span class="texhtml"><i>G</i><sub><i>f</i></sub></span>.
</p><p><br/>
</p>
<h3><span id="Multiple_sources_and.2For_sinks"></span><span class="mw-headline" id="Multiple_sources_and/or_sinks">Multiple sources and/or sinks</span><span class="mw-editsection"></span></h3>
<p>Sometimes, when modeling a network with more than one source, a <b>supersource</b> is introduced to the graph.<sup class="reference" id="cite_ref-2">[2]</sup> This consists of a vertex connected to each of the sources with edges of infinite capacity, so as to act as a global source. A similar construct for sinks is called a <b>supersink</b>.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>

<p>To the left you see a flow network with source labeled <span class="texhtml mvar" style="font-style:italic;">s</span>, sink <span class="texhtml mvar" style="font-style:italic;">t</span>, and four additional nodes. The flow and capacity is denoted <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f/c}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>c</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f/c}</annotation>
</semantics>
</math></span><img alt="f/c" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fb831cd04ec8b60f900a75341088eb25ac2f255a" style="vertical-align: -0.838ex; width:3.448ex; height:2.843ex;"/></span>. Notice how the network upholds skew symmetry, capacity constraints and flow conservation. The total amount of flow from <span class="texhtml mvar" style="font-style:italic;">s</span> to <span class="texhtml mvar" style="font-style:italic;">t</span> is 5, which can be easily seen from the fact that the total outgoing flow from <span class="texhtml mvar" style="font-style:italic;">s</span> is 5, which is also the incoming flow to <span class="texhtml mvar" style="font-style:italic;">t</span>. We know that no flow appears or disappears in any of the other nodes.
</p>

<p>Below you see the residual network for the given flow. Notice how there is positive residual capacity on some edges where the original capacity is zero, for example for the edge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (d,c)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo>,</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (d,c)}</annotation>
</semantics>
</math></span><img alt="(d,c)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/67dbe3343879ab3dd75427ddd90bc98b36131912" style="vertical-align: -0.838ex; width:5.066ex; height:2.843ex;"/></span>. This flow is not a maximum flow. There is available capacity along the paths <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (s,a,c,t)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (s,a,c,t)}</annotation>
</semantics>
</math></span><img alt="(s,a,c,t)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/757b09210ecacb5d69a15b75712980894025c804" style="vertical-align: -0.838ex; width:9.078ex; height:2.843ex;"/></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (s,a,b,d,t)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>d</mi>
<mo>,</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (s,a,b,d,t)}</annotation>
</semantics>
</math></span><img alt="(s,a,b,d,t)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ded7bfb888df6e3d7e5eb6ce8163a7a575bdc705" style="vertical-align: -0.838ex; width:11.318ex; height:2.843ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (s,a,b,d,c,t)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>d</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (s,a,b,d,c,t)}</annotation>
</semantics>
</math></span><img alt="(s,a,b,d,c,t)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0ee0e5e49b941d74086ee160cf2f9b742cd13e9c" style="vertical-align: -0.838ex; width:13.359ex; height:2.843ex;"/></span>, which are then the augmenting paths. The residual capacity of the first path is
<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \min(c(s,a)-f(s,a),c(a,c)-f(a,c),c(c,t)-f(c,t))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo form="prefix" movablelimits="true">min</mo>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
<mo>−<!-- − --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>c</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>,</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
<mo>−<!-- − --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>,</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>c</mi>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mo>,</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
<mo>−<!-- − --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mo>,</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \min(c(s,a)-f(s,a),c(a,c)-f(a,c),c(c,t)-f(c,t))}</annotation>
</semantics>
</math></span><img alt="\min(c(s,a)-f(s,a),c(a,c)-f(a,c),c(c,t)-f(c,t))" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e0367dfec282fd04b8be37d1e96473f062754325" style="vertical-align: -0.838ex; width:52.996ex; height:2.843ex;"/></span> <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle =\min(5-3,3-2,2-1)=\min(2,1,1)=1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo>=</mo>
<mo form="prefix" movablelimits="true">min</mo>
<mo stretchy="false">(</mo>
<mn>5</mn>
<mo>−<!-- − --></mo>
<mn>3</mn>
<mo>,</mo>
<mn>3</mn>
<mo>−<!-- − --></mo>
<mn>2</mn>
<mo>,</mo>
<mn>2</mn>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mo form="prefix" movablelimits="true">min</mo>
<mo stretchy="false">(</mo>
<mn>2</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle =\min(5-3,3-2,2-1)=\min(2,1,1)=1}</annotation>
</semantics>
</math></span><img alt="=\min(5-3,3-2,2-1)=\min(2,1,1)=1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/20af8d9c9f7f19af55ec1c569c5952c03f90b903" style="vertical-align: -0.838ex; width:44.301ex; height:2.843ex;"/></span>.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="citation for the formula used (December 2015)">citation needed</span></i>]</sup> Notice that as long as there exists some path with a positive residual capacity, the flow will not be maximum. The residual capacity for some path is the minimum residual capacity of all edges in that path.
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Picture a series of water pipes, fitting into a network. Each pipe is of a certain diameter, so it can only maintain a flow of a certain amount of water. Anywhere that pipes meet, the total amount of water coming into that junction must be equal to the amount going out, otherwise we would quickly run out of water, or we would have a buildup of water. We have a water inlet, which is the source, and an outlet, the sink. A flow would then be one possible way for water to get from source to sink so that the total amount of water coming out of the outlet is consistent. Intuitively, the total flow of a network is the rate at which water comes out of the outlet.
</p><p>Flows can pertain to people or material over transportation networks, or to electricity over electrical distribution systems.  For any such physical network, the flow coming into any intermediate node needs to equal the flow going out of that node.  This conservation constraint is equivalent to Kirchhoff's current law.
</p><p>Flow networks also find applications in ecology: flow networks arise naturally when considering the flow of nutrients and energy between different organisms in a food web.  The mathematical problems associated with such networks are quite different from those that arise in networks of fluid or traffic flow.  The field of ecosystem network analysis, developed by Robert Ulanowicz and others, involves using concepts from information theory and thermodynamics to study the evolution of these networks over time.
</p>
<h2><span class="mw-headline" id="Classifying_flow_problems">Classifying flow problems</span><span class="mw-editsection"></span></h2>
<p>The simplest and most common problem using flow networks is to find what is called the maximum flow, which provides the largest possible total flow from the source to the sink in a given graph. There are many other problems which can be solved using max flow algorithms, if they are appropriately modeled as flow networks, such as bipartite matching, the assignment problem and the transportation problem. Maximum flow problems can be solved efficiently with the push–relabel algorithm. The max-flow min-cut theorem states that finding a maximal network flow is equivalent to finding a  cut of minimum capacity that separates the source and the sink, where a cut is the division of vertices such that the source is in one division and the sink is in another.
</p>
<table align="right" class="wikitable" style="height: 200px;">
<caption>Well-known algorithms for the Maximum Flow Problem
</caption>
<tbody><tr>
<th>Inventor(s)</th>
<th>Year</th>
<th>Time<br/>complexity<br/>(with <span class="texhtml"><i>n</i></span> nodes<br/>and <span class="texhtml"><i>m</i></span> arcs)
</th></tr>
<tr>
<td>Dinic's algorithm</td>
<td>1969</td>
<td><span class="texhtml"><i>O</i>(<i>mn</i><sup>2</sup>)</span>
</td></tr>
<tr>
<td>Edmonds–Karp algorithm</td>
<td>1972</td>
<td><span class="texhtml"><i>O</i>(<i>m</i><sup>2</sup><i>n</i>)</span>
</td></tr>
<tr>
<td>MPM (Malhotra, Pramodh-Kumar, and Maheshwari)<br/>algorithm<sup class="reference" id="cite_ref-4">[4]</sup>
</td>
<td>1978</td>
<td><span class="texhtml"><i>O</i>(<i>n</i><sup>3</sup>)</span>
</td></tr>
<tr>
<td>James B. Orlin<sup class="reference" id="cite_ref-5">[5]</sup></td>
<td>2013</td>
<td><span class="texhtml"><i>O</i>(<i>mn</i>)</span>
</td></tr></tbody></table>
<p>In a multi-commodity flow problem, you have multiple sources and sinks, and various "commodities" which are to flow from a given source to a given sink. This could be for example various goods that are produced at various factories, and are to be delivered to various given customers through the <i>same</i> transportation network.
</p><p>In a minimum cost flow problem, each edge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle u,v}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle u,v}</annotation>
</semantics>
</math></span><img alt="u,v" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7e66f4b32a0181923cc1337a5634f38241e5c697" style="vertical-align: -0.671ex; width:3.491ex; height:2.009ex;"/></span> has a given cost <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k(u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k(u,v)}</annotation>
</semantics>
</math></span><img alt="k(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/808ae4bfa206821f9086b1dcd7dc45a44ee90d8f" style="vertical-align: -0.838ex; width:6.512ex; height:2.843ex;"/></span>, and the cost of sending the flow <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(u,v)}</annotation>
</semantics>
</math></span><img alt="f(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f6a108a1020838e47fa6d73a3b9e00d38197ebb" style="vertical-align: -0.838ex; width:6.579ex; height:2.843ex;"/></span> across the edge is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(u,v)\cdot k(u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
<mo>⋅<!-- ⋅ --></mo>
<mi>k</mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(u,v)\cdot k(u,v)}</annotation>
</semantics>
</math></span><img alt="f(u,v)\cdot k(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f9664a51f0432adc90da6dc32e2a20e3c349ce3" style="vertical-align: -0.838ex; width:14.77ex; height:2.843ex;"/></span>. The objective is to send a given amount of flow from the source to the sink, at the lowest possible price.
</p><p>In a circulation problem, you have a lower bound <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \ell (u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ℓ<!-- ℓ --></mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \ell (u,v)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \ell (u,v)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c8bdff0f6342ee13c0d97f05f7b4509cd9d08fc1" style="vertical-align: -0.838ex; width:6.27ex; height:2.843ex;"/></span> on the edges, in addition to the upper bound <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c(u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>c</mi>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c(u,v)}</annotation>
</semantics>
</math></span><img alt="c(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3af127906713b7741d8b0562429672f686b449b0" style="vertical-align: -0.838ex; width:6.307ex; height:2.843ex;"/></span>. Each edge also has a cost. Often, flow conservation holds for <i>all</i> nodes in a circulation problem, and there is a connection from the sink back to the source. In this way, you can dictate the total flow with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \ell (t,s)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ℓ<!-- ℓ --></mi>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo>,</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \ell (t,s)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \ell (t,s)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/46df1bdb0fdc5848262a77325baebf121738ed7e" style="vertical-align: -0.838ex; width:5.743ex; height:2.843ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c(t,s)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>c</mi>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo>,</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c(t,s)}</annotation>
</semantics>
</math></span><img alt="c(t,s)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4d8aea67ab3b26f26e5eef46c57306177203773b" style="vertical-align: -0.838ex; width:5.78ex; height:2.843ex;"/></span>. The flow <i>circulates</i> through the network, hence the name of the problem.
</p><p>In a <b>network with gains</b> or <b>generalized network</b> each edge has a <b>gain</b>, a real number (not zero) such that, if the edge has gain <i>g</i>, and an amount <i>x</i> flows into the edge at its tail, then an amount <i>gx</i> flows out at the head.
</p><p>In a <b>source localization problem</b>, an algorithm tries to identify the most likely source node of information diffusion through a partially observed network. This can be done in linear time for trees and cubic time for arbitrary networks and has applications ranging from tracking mobile phone users to identifying the originating source of disease outbreaks.<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Braess's paradox</li>
<li>Centrality</li>
<li>Ford–Fulkerson algorithm</li>
<li>Dinic's algorithm</li>
<li>Flow (computer networking)</li>
<li>Flow graph (disambiguation)</li>
<li>Max-flow min-cut theorem</li>
<li>Oriented matroid</li>
<li>Shortest path problem</li>
<li>Nowhere-zero flow</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFGeorge_T._HeinemanGary_PolliceStanley_Selkow2008">George T. Heineman; Gary Pollice; Stanley Selkow (2008). "Chapter 8:Network Flow Algorithms". <i>Algorithms in a Nutshell</i>. Oreilly Media. pp. 226–250. ISBN <bdi>978-0-596-51624-6</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+8%3ANetwork+Flow+Algorithms&amp;rft.btitle=Algorithms+in+a+Nutshell&amp;rft.pages=226-250&amp;rft.pub=Oreilly+Media&amp;rft.date=2008&amp;rft.isbn=978-0-596-51624-6&amp;rft.au=George+T.+Heineman&amp;rft.au=Gary+Pollice&amp;rft.au=Stanley+Selkow&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFRavindra_K._Ahuja,_Thomas_L._Magnanti,_and_James_B._Orlin1993">Ravindra K. Ahuja, Thomas L. Magnanti, and James B. Orlin (1993). <i>Network Flows: Theory, Algorithms and Applications</i>. Prentice Hall. ISBN <bdi>0-13-617549-X</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Network+Flows%3A+Theory%2C+Algorithms+and+Applications&amp;rft.pub=Prentice+Hall&amp;rft.date=1993&amp;rft.isbn=0-13-617549-X&amp;rft.au=Ravindra+K.+Ahuja%2C+Thomas+L.+Magnanti%2C+and+James+B.+Orlin&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span><span class="cs1-maint citation-comment"><code class="cs1-code">{{cite book}}</code>:  CS1 maint: multiple names: authors list (link)</span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBollobás,_Béla1979">Bollobás, Béla (1979). <i>Graph Theory: An Introductory Course</i>. Heidelberg: Springer-Verlag. ISBN <bdi>3-540-90399-2</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Graph+Theory%3A+An+Introductory+Course&amp;rft.place=Heidelberg&amp;rft.pub=Springer-Verlag&amp;rft.date=1979&amp;rft.isbn=3-540-90399-2&amp;rft.au=Bollob%C3%A1s%2C+B%C3%A9la&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFChartrand,_Gary_&amp;_Oellermann,_Ortrud_R.1993">Chartrand, Gary &amp; Oellermann, Ortrud R. (1993). <i>Applied and Algorithmic Graph Theory</i>. New York: McGraw-Hill. ISBN <bdi>0-07-557101-3</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Applied+and+Algorithmic+Graph+Theory&amp;rft.place=New+York&amp;rft.pub=McGraw-Hill&amp;rft.date=1993&amp;rft.isbn=0-07-557101-3&amp;rft.au=Chartrand%2C+Gary+%26+Oellermann%2C+Ortrud+R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span><span class="cs1-maint citation-comment"><code class="cs1-code">{{cite book}}</code>:  CS1 maint: multiple names: authors list (link)</span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFEven,_Shimon1979">Even, Shimon (1979). <span class="cs1-lock-registration" title="Free registration required"><i>Graph Algorithms</i></span>. Rockville, Maryland: Computer Science Press. ISBN <bdi>0-914894-21-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Graph+Algorithms&amp;rft.place=Rockville%2C+Maryland&amp;rft.pub=Computer+Science+Press&amp;rft.date=1979&amp;rft.isbn=0-914894-21-8&amp;rft.au=Even%2C+Shimon&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fgraphalgorithms0000even&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFGibbons,_Alan1985">Gibbons, Alan (1985). <i>Algorithmic Graph Theory</i>. Cambridge: Cambridge University Press. ISBN <bdi>0-521-28881-9</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithmic+Graph+Theory&amp;rft.place=Cambridge&amp;rft.pub=Cambridge+University+Press&amp;rft.date=1985&amp;rft.isbn=0-521-28881-9&amp;rft.au=Gibbons%2C+Alan&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFThomas_H._Cormen,_Charles_E._Leiserson,_Ronald_L._Rivest,_and_Clifford_Stein2001">Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein (2001) [1990]. "26". <i>Introduction to Algorithms</i> (2nd ed.). MIT Press and McGraw-Hill. pp. 696–697. ISBN <bdi>0-262-03293-7</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=26&amp;rft.btitle=Introduction+to+Algorithms&amp;rft.pages=696-697&amp;rft.edition=2nd&amp;rft.pub=MIT+Press+and+McGraw-Hill&amp;rft.date=2001&amp;rft.isbn=0-262-03293-7&amp;rft.au=Thomas+H.+Cormen%2C+Charles+E.+Leiserson%2C+Ronald+L.+Rivest%2C+and+Clifford+Stein&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFlow+network"></span><span class="cs1-maint citation-comment"><code class="cs1-code">{{cite book}}</code>:  CS1 maint: multiple names: authors list (link)</span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Maximum Flow Problem</li>
<li>Real graph instances</li>
<li>Lemon C++ library with several maximum flow and minimum cost circulation algorithms</li>
<li>QuickGraph Archived 2018-01-21 at the Wayback Machine, graph data structures and algorithms for .Net</li></ul>
<!-- 
NewPP limit report
Parsed by mw2275
Cached time: 20221224002809
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.405 seconds
Real time usage: 0.570 seconds
Preprocessor visited node count: 4366/1000000
Post‐expand include size: 53001/2097152 bytes
Template argument size: 6712/2097152 bytes
Highest expansion depth: 19/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 33836/5000000 bytes
Lua time usage: 0.213/10.000 seconds
Lua memory usage: 6314186/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  423.991      1 -total
 33.15%  140.537      1 Template:Reflist
 23.76%  100.749      2 Template:DADS
 22.65%   96.047      6 Template:If_empty
 15.83%   67.112     56 Template:Math
 14.03%   59.490      1 Template:Short_description
 10.99%   46.603      1 Template:Commons
 10.57%   44.807      1 Template:Sister_project
 10.09%   42.795      1 Template:Side_box
  7.95%   33.703      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:645676-0!canonical and timestamp 20221224002808 and revision id 1124283674.
 -->
</div></body>
</html>