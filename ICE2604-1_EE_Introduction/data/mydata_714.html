<!DOCTYPE html>
<html>
<head>
<title>orthogonally_convex_rectilinear_polygon</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>A <b>rectilinear polygon</b> is a polygon all of whose sides meet at right angles.  Thus the interior angle at each vertex is either 90° or 270°.  Rectilinear polygons are a special case of isothetic polygons.
</p><p>In many cases another definition is preferable: a <b>rectilinear polygon</b> is a polygon with sides parallel to the axes of Cartesian coordinates. The distinction becomes crucial when spoken about sets of polygons: the latter definition would imply that sides of all polygons in the set are aligned with the same coordinate axes. Within the framework of the second definition it is natural to speak of <b>horizontal edges</b> and <b>vertical edges</b> of a rectilinear polygon.
</p><p>Rectilinear polygons are also known as <b>orthogonal polygons</b>. Other terms in use are <b>iso-oriented</b>,  <b>axis-aligned</b>, and <b>axis-oriented polygons</b>. These adjectives are less confusing when the polygons of this type are rectangles, and the term <b>axis-aligned rectangle</b> is preferred, although <b>orthogonal rectangle</b> and <b>rectilinear rectangle</b> are in use as well.
</p><p>The importance of the class of rectilinear polygons comes from the following.  
</p>
<ul><li>They are convenient for the representation of shapes in integrated circuit mask layouts due to their simplicity for design and manufacturing. Many manufactured objects result in orthogonal polygons.</li>
<li>Problems in computational geometry stated in terms of polygons often allow for more efficient algorithms when restricted to orthogonal polygons. An example is provided by the art gallery theorem for orthogonal polygons, which leads to more efficient guard coverage than is possible for arbitrary polygons.</li></ul>

<h2><span class="mw-headline" id="Elements">Elements</span><span class="mw-editsection"></span></h2>
<p>A rectilinear polygon has edges of two types: <i>horizontal</i> and <i>vertical</i>. 
</p>
<ul><li><i>Lemma</i>: The number of horizontal edges is equal to the number of vertical edges (because every horizontal edge is followed by a vertical edge and vice versa).
<ul><li>Corollary: Orthogonal polygons have an even number of edges.</li></ul></li></ul>

<p>A rectilinear polygon has corners of two types: corners in which the smaller angle (90°) is interior to the polygon are called <i>convex</i> and corners in which the larger angle (270°) is interior are called <i>concave</i>.<sup class="reference" id="cite_ref-bybc96_1-0">[1]</sup>
</p><p>A <i>knob</i> is an edge whose two endpoints are convex corners. An <i>antiknob</i> is an edge whose two endpoints are concave corners.<sup class="reference" id="cite_ref-bybc96_1-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Simple_rectilinear_polygon">Simple rectilinear polygon</span><span class="mw-editsection"></span></h2>
<p>A rectilinear polygon that is also simple is also called <b>hole-free</b> because it has no holes - only a single continuous boundary. It has several interesting properties:
</p>
<ol><li>The number of convex corners is four more than the number of concave corners. To see why, imagine that you traverse the boundary of the polygon clockwise (with your right hand inside the polygon and your left hand outside). At a convex corner, you turn 90° right; at any concave corner, you turn 90° left. Finally you must make an entire 360° turn and come back to the original point; hence the number of right turns must be 4 more than the number of left turns.
<ul><li>Corollary: every rectilinear polygon has at least 4 convex corners.</li></ul></li>
<li>The number of knobs (sides connecting two convex corners) is four more than the number of antiknobs (sides connecting two concave corners).To see why, let <i>X</i> be the number of convex corners and <i>Y</i> the number of concave corners. By the previous fact, <i>X=Y+4</i>. Let <i>XX</i> the number of convex corners followed by a convex corner, <i>XY</i> the number of convex corners followed by a concave corner, <i>YX</i> and <i>YY</i> defined analogously. Then obviously <i>X=XX+XY=XX+YX</i> and <i>Y=XY+YY=YX+YY</i>. Hence <i>XX=X-XY=X-(Y-YY)=YY+(X-Y)=YY+4</i>.<sup class="reference" id="cite_ref-2">[2]</sup>
<ul><li>Corollary: every rectilinear polygon has at least 4 knobs.</li></ul></li></ol>
<h2><span class="mw-headline" id="Squares_and_rectangles_in_a_rectilinear_polygon">Squares and rectangles in a rectilinear polygon</span><span class="mw-editsection"></span></h2>
<p>A rectilinear polygon can be covered by a finite number of squares or rectangles with edges parallel to the edges of the polygon (see Polygon covering). It is possible to distinguish several types of squares/rectangles contained in a certain rectilinear polygon <i>P</i>:<sup class="reference" id="cite_ref-bybc96_1-2">[1]</sup>
</p><p>A <b>maximal square</b> in a polygon <i>P</i> is a square in <i>P</i> which is not contained in any other square in <i>P</i>. Similarly, a maximal rectangle is a rectangle not contained in any other rectangle in <i>P</i>.
</p><p>A square <i>s</i> is maximal in <i>P</i> if each pair of adjacent edges of <i>s</i> intersects the boundary of <i>P</i>. The proof of both sides is by contradiction:
</p>
<ul><li>If a certain adjacent pair in <i>s</i> does not intersect the boundary of <i>P</i>, then this pair be pushed further towards the boundary, so <i>s</i> is not maximal.</li>
<li>If <i>s</i> is not maximal in <i>P</i>, then there is a larger square in <i>P</i> containing <i>s</i>; the interior of this larger square contains a pair of adjacent edges of <i>s</i>, hence this pair does not intersect the boundary of <i>P</i>.</li></ul>
<p>The first direction is also true for rectangles, i.e.: If a rectangle <i>s</i> is maximal, then each pair of adjacent edges of <i>s</i> intersects the boundary of <i>P</i>. The second direction is not necessarily true: a rectangle can intersect the boundary of <i>P</i> in even 3 adjacent sides and still not be maximal as it can be stretched in the 4th side.
</p><p>Corollary: every maximal square/rectangle in <i>P</i> has at least two points, on two opposite edges, that intersect the boundary of <i>P</i>.
</p><p>A <b>corner square</b> is a maximal square <i>s</i> in a polygon <i>P</i> such that at least one corner of <i>s</i> overlaps a convex corner of <i>P</i>. For every convex corner, there is exactly one maximal (corner) square covering it, but a single maximal square may cover more than one corner. For every corner, there may by many different maximal rectangles covering it.
</p>


<p>A <b>separator square</b> in a polygon <i>P</i> is a square <i>s</i> in <i>P</i> such that <i>P</i>−<i>s</i> is not connected.
</p>
<ul><li><i>Lemma</i>: in a simple rectilinear polygon, a maximal square that does not contain a knob is a separator.<sup class="reference" id="cite_ref-ao81_3-0">[3]</sup> A square containing a knob may or may not be a separator. The number of different separator squares may be infinite and even uncountable. For example, in a rectangle, every maximal square not touching one of the shorter sides is a separator.</li></ul>
<p>A <b>continuator square</b> is a square <i>s</i> in a polygon <i>P</i> such that the intersection between the boundary of <i>s</i> and the boundary of <i>P</i> is continuous. A maximal continuator is always a corner square. Moreover, a maximal continuator always contains a knob. Hence the number of continuators is always finite and bounded by the number of knobs.
</p><p>There are several different types of continuators, based on the number of knobs they contain and their internal structure (see figure). The <i>balcony</i> of a continuator is defined as its points that are not covered by any other maximal square (see figure).
</p><p>No square can be both a continuator and a separator. In general polygons, there may be squares that are neither continuators nor separators, but in simple polygons this cannot happen:<sup class="reference" id="cite_ref-bybc96_1-3">[1]</sup>
</p>
<ol><li>In a simple rectilinear polygon, every maximal square is either a separator or a continuator. This is also true for rectangles: every maximal rectangle is either a separator or a continuator.</li>
<li>In a simple rectilinear polygon which is not a square, there are at least two continuators.</li></ol>
<p>There is an interesting analogy between maximal squares in a simple polygon and nodes in a tree: a continuator is analogous to a leaf node and a separator is analogous to an internal node.
</p>
<h2><span class="mw-headline" id="Special_cases">Special cases</span><span class="mw-editsection"></span></h2>
<p>The simplest rectilinear polygon is an axis-aligned rectangle - a rectangle with 2 sides parallel to the x axis and 2 sides parallel to the y axis. See also: Minimum bounding rectangle.
</p><p>A golygon is a rectilinear polygon whose side lengths in sequence are consecutive integers.
</p><p>A rectilinear polygon which is not a rectangle is never convex, but it can be orthogonally convex. See <b>Orthogonally convex rectilinear polygon</b> .
</p><p>A <b>monotone rectilinear polygon</b> is a monotone polygon which is also rectilinear.
</p><p>A T-square is a fractal generated from a sequence of rectilinear polygons with interesting properties.
</p>
<h2><span class="mw-headline" id="Generalizations">Generalizations</span><span class="mw-editsection"></span></h2>
<ul><li>Orthogonal polyhedra - the natural generalization of orthogonal polygons to 3D.</li>
<li>Rectilinearity [1]</li></ul>
<h2><span class="mw-headline" id="Algorithmic_problems_involving_rectilinear_polygons">Algorithmic problems involving rectilinear polygons</span><span class="mw-editsection"></span></h2>
<p>Most of them may be stated for general polygons as well, but expectation of more efficient algorithms warrants a separate consideration
</p>
<ul><li>Orthogonal range searching</li>
<li>Orthogonal convex hull construction</li>
<li>Boolean operations on polygons for orthogonal polygons (e.g., intersection and union)</li>
<li>Motion planning/path planning/routing among rectilinear obstacles</li>
<li>Visibility problems (Illumination problems)
<ul><li>Rectilinear art gallery problems</li></ul></li>
<li>Maximal empty rectangle</li></ul>
<h2><span class="mw-headline" id="Rectangular_decomposition">Rectangular decomposition</span><span class="mw-editsection"></span></h2>
<p>Of particular interest to rectilinear polygons are problems of decomposing a given rectilinear polygon to simple units - usually rectangles or squares. There are several types of decomposition problems:
</p>
<ul><li>In <i>covering</i> problems, the goal is to find a smallest set of units (squares or rectangles) whose union is equal to the polygon. The units may overlap. See Polygon covering.</li>
<li>In <i>packing</i> problems, the goal is to find a largest set of non-overlapping units whose union is contained in the polygon. The union may be smaller than the polygon.</li>
<li>In <i>partitioning</i> problems, the goal is to find a smallest set of non-overlapping units whose union is exactly equal to the polygon. See Polygon partition.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><style data-mw-deduplicate="TemplateStyles:r1067248974">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style><cite class="citation book cs1" id="CITEREFFranco_P._Preparata_and_Michael_Ian_Shamos1985">Franco P. Preparata and Michael Ian Shamos (1985). <i>Computational Geometry - An Introduction</i>. Springer. ISBN <bdi>0-387-96131-3</bdi>. 1st edition: ; 2nd printing, corrected and expanded, 1988.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computational+Geometry+-+An+Introduction&amp;rft.pub=Springer&amp;rft.date=1985&amp;rft.isbn=0-387-96131-3&amp;rft.au=Franco+P.+Preparata+and+Michael+Ian+Shamos&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARectilinear+polygon"></span>, chapter 8: "The Geometry of Rectangles"</li></ul>

<!-- 
NewPP limit report
Parsed by mw2275
Cached time: 20221224000517
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.158 seconds
Real time usage: 0.224 seconds
Preprocessor visited node count: 386/1000000
Post‐expand include size: 7381/2097152 bytes
Template argument size: 437/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 11277/5000000 bytes
Lua time usage: 0.093/10.000 seconds
Lua memory usage: 3412277/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  177.155      1 -total
 41.29%   73.149      1 Template:Cite_book
 34.24%   60.657      1 Template:Short_description
 17.67%   31.306      2 Template:Pagetype
 12.47%   22.092      1 Template:About
  9.84%   17.435      2 Template:Main_other
  8.72%   15.454      1 Template:SDcat
  6.43%   11.397      2 Template:Cite_journal
  2.52%    4.466      1 Template:Cite_web
  1.35%    2.386      1 Template:Short_description/lowercasecheck
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:8779182-0!canonical and timestamp 20221224000517 and revision id 1076385183.
 -->
</div></body>
</html>