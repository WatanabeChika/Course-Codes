<!DOCTYPE html>
<html>
<head>
<title>introspective_sort</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Introsort</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Sorting algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data">O(<i>n</i> log <i>n</i>)</td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data">O(<i>n</i> log <i>n</i>)</td></tr></tbody></table>
<p><b>Introsort</b> or <b>introspective sort</b> is a hybrid sorting algorithm that provides both fast average performance and (asymptotically) optimal worst-case performance. It begins with quicksort, it switches to heapsort when the recursion depth exceeds a level based on (the logarithm of) the number of elements being sorted and it switches to insertion sort when the number of elements is below some threshold. This combines the good parts of the three algorithms, with practical performance comparable to quicksort on typical data sets and worst-case O(<i>n</i> log <i>n</i>) runtime due to the heap sort. Since the three algorithms it uses are comparison sorts, it is also a comparison sort.
</p><p>Introsort was invented by David Musser in Musser (1997), in which he also introduced introselect, a hybrid selection algorithm based on quickselect (a variant of quicksort), which falls back to median of medians and thus provides worst-case linear complexity, which is optimal. Both algorithms were introduced with the purpose of providing generic algorithms for the C++ Standard Library which had both fast average performance and optimal worst-case performance, thus allowing the performance requirements to be tightened.<sup class="reference" id="cite_ref-1">[1]</sup>  Introsort is in place and not stable.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>

<h2><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h2>
<p>If a heapsort implementation and partitioning functions of the type discussed in the quicksort article are available, the introsort can be described succinctly as
</p>
<pre><b>procedure</b> sort(A : array):
    maxdepth ← ⌊log<sub>2</sub>(length(A))⌋ × 2
    introsort(A, maxdepth)

<b>procedure</b> introsort(A, maxdepth):
    n ← length(A)
    <b>if</b> n &lt; 16:
        insertionsort(A)
    <b>else if</b> maxdepth = 0:
        heapsort(A)
    <b>else</b>:
        p ← partition(A)  <i>// assume this function does pivot selection, p is the final position of the pivot</i>
        introsort(A[1:p-1], maxdepth - 1)
        introsort(A[p+1:n], maxdepth - 1)
</pre>
<p>The factor 2 in the maximum depth is arbitrary; it can be tuned for practical performance. <span class="texhtml"><i>A</i>[<i>i</i>:<i>j</i>]</span> denotes the array slice of items <span class="texhtml mvar" style="font-style:italic;">i</span> to <span class="texhtml mvar" style="font-style:italic;">j</span> including both <span class="texhtml"><i>A</i>[<i>i</i>]</span> and <span class="texhtml"><i>A</i>[<i>j</i>]</span>. The indices are assumed to start with 1 (the first element of the <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">A</span> array is <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">A[1]</span>).
</p>
<h2><span class="mw-headline" id="Analysis">Analysis</span><span class="mw-editsection"></span></h2>
<p>In quicksort, one of the critical operations is choosing the pivot: the element around which the list is partitioned. The simplest pivot selection algorithm is to take the first or the last element of the list as the pivot, causing poor behavior for the case of sorted or nearly sorted input. Niklaus Wirth's variant uses the middle element to prevent these occurrences, degenerating to O(<i>n</i><sup>2</sup>) for contrived sequences. The median-of-3 pivot selection algorithm takes the median of the first, middle, and last elements of the list; however, even though this performs well on many real-world inputs, it is still possible to contrive a <i>median-of-3 killer</i> list that will cause dramatic slowdown of a quicksort based on this pivot selection technique.
</p><p>Musser reported that on a median-of-3 killer sequence of 100,000 elements, introsort's running time was 1/200 that of median-of-3 quicksort. Musser also considered the effect on caches of Sedgewick's delayed small sorting, where small ranges are sorted at the end in a single pass of insertion sort. He reported that it could double the number of cache misses, but that its performance with double-ended queues was significantly better and should be retained for template libraries, in part because the gain in other cases from doing the sorts immediately was not great.
</p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"></span></h2>
<p>Introsort or some variant is used in a number of standard library sort functions, including some C++ sort implementations.
</p><p>The June 2000 SGI C++ Standard Template Library stl_algo.h implementation of unstable sort uses the Musser introsort approach with the recursion depth to switch to heapsort passed as a parameter, median-of-3 pivot selection and the Knuth final insertion sort pass for partitions smaller than 16.
</p><p>The GNU Standard C++ library is similar: uses introsort with a maximum depth of 2×log<sub>2</sub> <i>n</i>, followed by an insertion sort on partitions smaller than 16.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>LLVM libc++ also uses introsort with a maximum depth of 2×log<sub>2</sub> <i>n</i>, however the size limit for insertion sort is different for different data types (30 if swaps are trivial, 6 otherwise). Also, arrays with sizes up to 5 are handled separately.<sup class="reference" id="cite_ref-4">[4]</sup> Kutenin (2022) provides an overview for some changes made by LLVM, with a focus on the 2022 fix for quadraticness.<sup class="reference" id="cite_ref-Kutenin-LLVM_5-0">[5]</sup>
</p><p>The Microsoft .NET Framework Class Library, starting from version 4.5 (2012), uses introsort instead of simple quicksort.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>Go uses introsort with small modification: for slices of 12 or less elements it uses Shellsort instead of insertion sort, and more advanced median of three medians of three pivot selection for quicksort.
</p><p>Java, starting from version 14 (2020), uses a hybrid sorting algorithm that uses merge sort for highly structured arrays (arrays that are composed of a small number of sorted subarrays) and introsort otherwise to sort arrays of ints, longs, floats and doubles.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="pdqsort">pdqsort</span><span class="mw-editsection"></span></h3>
<p>Pattern-defeating quicksort (pdqsort) is a variant of introsort incorporating the following improvements:<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<ul><li>Median-of-three pivoting,</li>
<li>"BlockQuicksort" partitioning technique to mitigates branch misprediction penalities,</li>
<li>Linear time performance for certain input patterns (adaptive sort),</li>
<li>Use element shuffling on bad cases before trying the slower heapsort.</li></ul>
<p>pdqsort is used by Rust, GAP,<sup class="reference" id="cite_ref-9">[9]</sup> and the C++ library Boost.<sup class="reference" id="cite_ref-10">[10]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h3><span class="mw-headline" id="General">General</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>

<!-- 
NewPP limit report
Parsed by mw2309
Cached time: 20221223231226
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.243 seconds
Real time usage: 0.335 seconds
Preprocessor visited node count: 1235/1000000
Post‐expand include size: 28732/2097152 bytes
Template argument size: 936/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 25661/5000000 bytes
Lua time usage: 0.140/10.000 seconds
Lua memory usage: 5304677/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  296.518      1 -total
 32.57%   96.576      1 Template:Reflist
 25.64%   76.030      4 Template:Cite_web
 18.26%   54.146      1 Template:Short_description
 15.16%   44.959      1 Template:Sorting
 13.89%   41.193      1 Template:Navbox
  9.48%   28.099      1 Template:Infobox_Algorithm
  9.01%   26.702      2 Template:Pagetype
  8.35%   24.763      1 Template:Harvtxt
  7.94%   23.547      1 Template:Infobox
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:363477-0!canonical and timestamp 20221223231225 and revision id 1124281462.
 -->
</div></body>
</html>