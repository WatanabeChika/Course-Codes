<!DOCTYPE html>
<html>
<head>
<title>double-ended_priority_queue</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>In computer science, a <b>double-ended priority queue (DEPQ)</b><sup class="reference" id="cite_ref-Sahni_1-0">[1]</sup> or <b>double-ended heap</b><sup class="reference" id="cite_ref-brass_2-0">[2]</sup> is a data structure similar to a priority queue or heap, but allows for efficient removal of both the maximum and minimum, according to some ordering on the <i>keys</i> (items) stored in the structure. Every element in a DEPQ has a priority or value. In a DEPQ, it is possible to remove the elements in both ascending as well as descending order.<sup class="reference" id="cite_ref-rubyforge_3-0">[3]</sup>
</p>

<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<p>A double-ended priority queue features the following operations:
</p>
<dl><dt>isEmpty()</dt>
<dd>Checks if DEPQ is empty and returns true if empty.</dd>
<dt>size()</dt>
<dd>Returns the total number of elements present in the DEPQ.</dd>
<dt>getMin()</dt>
<dd>Returns the element having least priority.</dd>
<dt>getMax()</dt>
<dd>Returns the element having highest priority.</dd>
<dt>put(<i>x</i>)</dt>
<dd>Inserts the element <i>x</i> in the DEPQ.</dd>
<dt>removeMin()</dt>
<dd>Removes an element with minimum priority and returns this element.</dd>
<dt>removeMax()</dt>
<dd>Removes an element with maximum priority and returns this element.</dd></dl>
<p>If an operation is to be performed on two elements having the same priority, then the element inserted first is chosen. Also, the priority of any element can be changed once it has been inserted in the DEPQ.<sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>Double-ended priority queues can be built from balanced binary search trees (where the minimum and maximum elements are the leftmost and rightmost leaves, respectively), or using specialized data structures like min-max heap and pairing heap.
</p><p>Generic methods of arriving at double-ended priority queues from normal priority queues are:<sup class="reference" id="cite_ref-5">[5]</sup>
</p>
<h3><span class="mw-headline" id="Dual_structure_method">Dual structure method</span><span class="mw-editsection"></span></h3>

<p>In this method two different priority queues for min and max are maintained. The same elements in both the PQs are shown with the help of correspondence pointers.<br/>
Here, the minimum and maximum elements are values contained in the root nodes of min heap and max heap respectively.
</p>
<ul><li><b>Removing the min element</b>: Perform removemin() on the min heap and remove(<i>node value</i>) on the max heap, where <i>node value</i> is the value in the corresponding node in the max heap.</li>
<li><b>Removing the max element</b>: Perform removemax() on the max heap and remove(<i>node value</i>) on the min heap, where <i>node value</i> is the value in the corresponding node in the min heap.</li></ul>

<h3><span class="mw-headline" id="Total_correspondence">Total correspondence</span><span class="mw-editsection"></span></h3>

<p>Half the elements are in the min PQ and the other half in the max PQ. Each element in the min PQ has a one-to-one correspondence with an element in max PQ. If the number of elements in the DEPQ is odd, one of the elements is retained in a buffer.<sup class="reference" id="cite_ref-Sahni_1-3">[1]</sup> Priority of every element in the min PQ will be less than or equal to the corresponding element in the max PQ.<br/>
</p>

<h3><span class="mw-headline" id="Leaf_correspondence">Leaf correspondence</span><span class="mw-editsection"></span></h3>

<p>In contrast to a total correspondence, in this method only the leaf elements of the min and max PQ form corresponding one-to-one pairs. It is not necessary for non-leaf elements to be in a one-to-one correspondence pair.<sup class="reference" id="cite_ref-Sahni_1-5">[1]</sup> 
If the number of elements in the DEPQ is odd, one of the elements is retained in a buffer.<sup class="reference" id="cite_ref-Sahni_1-6">[1]</sup><br/>
</p>

<h3><span class="mw-headline" id="Interval_heaps">Interval heaps</span><span class="mw-editsection"></span></h3>

<p>Apart from the above-mentioned correspondence methods, DEPQ's can be obtained efficiently using interval heaps.<sup class="reference" id="cite_ref-interval_heap_6-0">[6]</sup> An interval heap is like an embedded min-max heap in which each node contains two elements. It is a complete binary tree in which:<sup class="reference" id="cite_ref-interval_heap_6-1">[6]</sup>
</p>
<ul><li>The left element is less than or equal to the right element.</li>
<li>Both the elements define a closed interval.</li>
<li>Interval represented by any node except the root is a sub-interval of the parent node.</li>
<li>Elements on the left hand side define a min heap.</li>
<li>Elements on the right hand side define a max heap.</li></ul>
<p>Depending on the number of elements, two cases are possible<sup class="reference" id="cite_ref-interval_heap_6-2">[6]</sup> - 
</p>
<ol><li><b>Even number of elements:</b> In this case, each node contains two elements say <i>p</i> and <i>q</i>, with <i>p</i> ≤ <i>q</i>. Every node is then represented by the interval [<i>p</i>, <i>q</i>].</li>
<li><b>Odd number of elements:</b> In this case, each node except the last contains two elements represented by the interval [<i>p</i>, <i>q</i>] whereas the last node will contain a single element and is represented by the interval [<i>p</i>, <i>p</i>].</li></ol>
<h4><span class="mw-headline" id="Inserting_an_element">Inserting an element</span><span class="mw-editsection"></span></h4>
<p>Depending on the number of elements already present in the interval heap, following cases are possible:
</p>
<ul><li><b>Odd number of elements:</b> If the number of elements in the interval heap is odd, the new element is firstly inserted in the last node. Then, it is successively compared with the previous node elements and tested to satisfy the criteria essential for an interval heap as stated above. In case if the element does not satisfy any of the criteria, it is moved from the last node to the root until all the conditions are satisfied.<sup class="reference" id="cite_ref-interval_heap_6-3">[6]</sup></li>
<li><b>Even number of elements:</b> If the number of elements is even, then for the insertion of a new element an additional node is created. If the element falls to the left of the parent interval, it is considered to be in the min heap and if the element falls to the right of the parent interval, it is considered in the max heap. Further, it is compared successively and moved from the last node to the root until all the conditions for interval heap are satisfied. If the element lies within the interval of the parent node itself, the process is stopped then and there itself and moving of elements does not take place.<sup class="reference" id="cite_ref-interval_heap_6-4">[6]</sup></li></ul>
<p>The time required for inserting an element depends on the number of movements required to meet all the conditions and is O(log <i>n</i>).
</p>
<h4><span class="mw-headline" id="Deleting_an_element">Deleting an element</span><span class="mw-editsection"></span></h4>
<ul><li><b>Min element:</b> In an interval heap, the minimum element is the element on the left hand side of the root node. This element is removed and returned. To fill in the vacancy created on the left hand side of the root node, an element from the last node is removed and reinserted into the root node. This element is then compared successively with all the left hand elements of the descending nodes and the process stops when all the conditions for an interval heap are satisfied. In case if the left hand side element in the node becomes greater than the right side element at any stage, the two elements are swapped<sup class="reference" id="cite_ref-interval_heap_6-5">[6]</sup> and then further comparisons are done. Finally, the root node will again contain the minimum element on the left hand side.</li>
<li><b>Max element:</b> In an interval heap, the maximum element is the element on the right hand side of the root node. This element is removed and returned. To fill in the vacancy created on the right hand side of the root node, an element from the last node is removed and reinserted into the root node. Further comparisons are carried out on a similar basis as discussed above. Finally, the root node will again contain the max element on the right hand side.</li></ul>
<p>Thus, with interval heaps, both the minimum and maximum elements can be removed efficiently traversing from root to leaf. Thus, a DEPQ can be obtained<sup class="reference" id="cite_ref-interval_heap_6-6">[6]</sup> from an interval heap where the elements of the interval heap are the priorities of elements in the DEPQ.
</p>
<h2><span class="mw-headline" id="Time_Complexity">Time Complexity</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Interval_Heaps_2">Interval Heaps</span><span class="mw-editsection"></span></h3>
<p>When DEPQ's are implemented using Interval heaps consisting of <i>n</i> elements, the time complexities for the various functions are formulated in the table below<sup class="reference" id="cite_ref-Sahni_1-7">[1]</sup>
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Operation</th>
<th>Time Complexity
</th></tr>
<tr>
<td>init( )</td>
<td>O(n)
</td></tr>
<tr>
<td>isEmpty( )</td>
<td>O(1)
</td></tr>
<tr>
<td>getmin( )</td>
<td>O(1)
</td></tr>
<tr>
<td>getmax( )</td>
<td>O(1)
</td></tr>
<tr>
<td>size( )</td>
<td>O(1)
</td></tr>
<tr>
<td>insert(x)</td>
<td>O(log <i>n</i>)
</td></tr>
<tr>
<td>removeMin( )</td>
<td>O(log <i>n</i>)
</td></tr>
<tr>
<td>removeMax( )</td>
<td>O(log <i>n</i>)
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Pairing_heaps">Pairing heaps</span><span class="mw-editsection"></span></h3>
<p>When DEPQ's are implemented using heaps or pairing heaps consisting of <i>n</i> elements, the time complexities for the various functions are formulated in the table below.<sup class="reference" id="cite_ref-Sahni_1-8">[1]</sup> For pairing heaps, it is an amortized complexity.
</p>
<table class="wikitable sortable">
<tbody><tr>
<th>Operation</th>
<th>Time Complexity
</th></tr>
<tr>
<td>isEmpty( )</td>
<td>O(1)
</td></tr>
<tr>
<td>getmin( )</td>
<td>O(1)
</td></tr>
<tr>
<td>getmax( )</td>
<td>O(1)
</td></tr>
<tr>
<td>insert(x)</td>
<td>O(log <i>n</i>)
</td></tr>
<tr>
<td>removeMax( )</td>
<td>O(log <i>n</i>)
</td></tr>
<tr>
<td>removeMin( )</td>
<td>O(log <i>n</i>)
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="External_sorting">External sorting</span><span class="mw-editsection"></span></h3>
<p>One example application of the double-ended priority queue is external sorting. In an external sort, there are more elements than can be held in the computer's memory. The elements to be sorted are initially on a disk and the sorted sequence is to be left on the disk. The external quick sort is implemented using the DEPQ as follows:
</p>
<ol><li>Read in as many elements as will fit into an internal DEPQ. The elements in the DEPQ will eventually be the middle group (pivot) of elements.</li>
<li>Read in the remaining elements. If the next element is ≤ the smallest element in the DEPQ, output this next element as part of the left group. If the next element is ≥ the largest element in the DEPQ, output this next element as part of the right group. Otherwise, remove either the max or min element from the DEPQ (the choice may be made randomly or alternately); if the max element is removed, output it as part of the right group; otherwise, output the removed element as part of the left group; insert the newly input element into the DEPQ.</li>
<li>Output the elements in the DEPQ, in sorted order, as the middle group.</li>
<li>Sort the left and right groups recursively.</li></ol>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Queue (abstract data type)</li>
<li>Priority queue</li>
<li>Double-ended queue</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>

<!-- 
NewPP limit report
Parsed by mw1436
Cached time: 20221221023811
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.175 seconds
Real time usage: 0.245 seconds
Preprocessor visited node count: 581/1000000
Post‐expand include size: 17998/2097152 bytes
Template argument size: 778/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 15972/5000000 bytes
Lua time usage: 0.097/10.000 seconds
Lua memory usage: 3427741/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  199.559      1 -total
 61.61%  122.950      1 Template:Reflist
 30.39%   60.654      1 Template:Cite_book
 18.54%   36.992      1 Template:Data_structures
 17.84%   35.594      1 Template:Bare_URL_PDF
 17.71%   35.349      1 Template:Navbox
 15.68%   31.291      1 Template:Fix
 15.43%   30.795      1 Template:Distinguish
 10.25%   20.455      1 Template:Category_handler
  3.70%    7.381      2 Template:Cite_web
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:29244037-0!canonical and timestamp 20221221023811 and revision id 1077032743.
 -->
</div></body>
</html>