<!DOCTYPE html>
<html>
<head>
<title>Shannon-Fano_coding</title>
</head>
<body>
<div class="mw-parser-output">
<p>In the field of data compression, <b>Shannon–Fano coding</b>, named after Claude Shannon and Robert Fano, is a name given to two different but related techniques for constructing a prefix code based on a set of symbols and their probabilities (estimated or measured).
</p>
<ul><li><b>Shannon's method</b> chooses a prefix code where a source symbol <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span> is given the codeword length <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/721404aef701034ef9c4e2cd575e7ff290208439" style="vertical-align: -0.838ex; width:15.234ex; height:2.843ex;"/></span>. One common way of choosing the codewords uses the binary expansion of the cumulative probabilities.   This method was proposed in Shannon's "A Mathematical Theory of Communication" (1948), his article introducing the field of information theory.</li>
<li><b>Fano's method</b> divides the source symbols into two sets ("0" and "1") with probabilities as close to 1/2 as possible. Then those sets are themselves divided in two, and so on, until each set contains only one symbol. The codeword for that symbol is the string of "0"s and "1"s that records which half of the divides it fell on. This method was proposed in a later technical report by Fano (1949).</li></ul>
<p>Shannon–Fano codes are suboptimal in the sense that they do not always achieve the lowest possible expected codeword length, as Huffman coding does.<sup class="reference" id="cite_ref-Kaur_1-0">[1]</sup> However, Shannon–Fano codes have an expected codeword length within 1 bit of optimal. Fano's method usually produces encoding with shorter expected lengths than Shannon's method. However, Shannon's method is easier to analyse theoretically.
</p><p>Shannon–Fano coding should not be confused with Shannon–Fano–Elias coding (also known as Elias coding), the precursor to arithmetic coding.
</p>

<h2><span class="mw-headline" id="Naming">Naming</span><span class="mw-editsection"></span></h2>
<p>Regarding the confusion in the two different codes being referred to by the same name, Krajči et al<sup class="reference" id="cite_ref-Kraj_2-0">[2]</sup> write:
</p>
<blockquote>
<p>Around 1948, both Claude E. Shannon (1948) and Robert M. Fano (1949) independently proposed two different source coding algorithms for an efficient description of a discrete memoryless source. Unfortunately, in spite of being different, both schemes became known under the same name <i>Shannon–Fano coding</i>.
</p><p>There are several reasons for this mixup. For one thing, in the discussion of his coding scheme, Shannon mentions Fano’s scheme and calls it “substantially the same” (Shannon, 1948, p. 17). For another, both Shannon’s and Fano’s coding schemes are similar in the sense that they both are efficient, but <i>suboptimal</i> prefix-free coding schemes with a similar performance
</p>
</blockquote>
<p>Shannon's (1948) method, using predefined word lengths, is called <b>Shannon–Fano coding</b> by Cover and Thomas,<sup class="reference" id="cite_ref-3">[3]</sup> Goldie and Pinch,<sup class="reference" id="cite_ref-4">[4]</sup> Jones and Jones,<sup class="reference" id="cite_ref-5">[5]</sup> and Han and Kobayashi.<sup class="reference" id="cite_ref-6">[6]</sup> It is called <b>Shannon coding</b> by Yeung.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>Fano's (1949) method, using binary division of probabilities, is called <b>Shannon–Fano coding</b> by Salomon<sup class="reference" id="cite_ref-8">[8]</sup> and Gupta.<sup class="reference" id="cite_ref-9">[9]</sup> It is called <b>Fano coding</b> by Krajči et al.<sup class="reference" id="cite_ref-Kraj_2-1">[2]</sup>
</p>
<h2><span id="Shannon.27s_code:_predefined_word_lengths"></span><span class="mw-headline" id="Shannon's_code:_predefined_word_lengths">Shannon's code: predefined word lengths</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<h3><span id="Shannon.27s_algorithm"></span><span class="mw-headline" id="Shannon's_algorithm">Shannon's algorithm</span><span class="mw-editsection"></span></h3>
<p>Shannon's method starts by deciding on the lengths of all the codewords, then picks a prefix code with those word lengths.
</p><p>Given a source with probabilities <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle p_{1},p_{2},\dots ,p_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle p_{1},p_{2},\dots ,p_{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle p_{1},p_{2},\dots ,p_{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/69d4afc30479593f8b2dd046bf3cb3038181e32a" style="vertical-align: -0.671ex; margin-left: -0.089ex; width:13.137ex; height:2.009ex;"/></span> the desired codeword lengths are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/721404aef701034ef9c4e2cd575e7ff290208439" style="vertical-align: -0.838ex; width:15.234ex; height:2.843ex;"/></span>. Here, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lceil x\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mi>x</mi>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lceil x\rceil }</annotation>
</semantics>
</math></span><img alt="\lceil x\rceil " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5ac7f37c8288700904b4a22a2f7c94d45ba917de" style="vertical-align: -0.838ex; width:3.394ex; height:2.843ex;"/></span> is the ceiling function, meaning the smallest integer greater than or equal to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x}</annotation>
</semantics>
</math></span><img alt="x" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span>.
</p><p>Once the codeword lengths have been determined, we must choose the codewords themselves. One method is to pick codewords in order from most probable to least probable symbols, picking each codeword to be the lexicographically first word of the correct length that maintains the prefix-free property.
</p><p>A second method makes use of cumulative probabilities. First, the probabilities are written in decreasing order <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle p_{1}\geq p_{2}\geq \cdots \geq p_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>≥<!-- ≥ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>≥<!-- ≥ --></mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>≥<!-- ≥ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle p_{1}\geq p_{2}\geq \cdots \geq p_{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle p_{1}\geq p_{2}\geq \cdots \geq p_{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/619aef9748e4d8c82cfd778842a984deea4534bf" style="vertical-align: -0.671ex; margin-left: -0.089ex; width:18.943ex; height:2.343ex;"/></span>. Then, the cumulative probabilities are defined as
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c_{1}=0,\qquad c_{i}=\sum _{j=1}^{i-1}p_{j}{\text{ for }}i\geq 2,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mn>0</mn>
<mo>,</mo>
<mspace width="2em"></mspace>
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mrow class="MJX-TeXAtom-ORD">
<mtext> for </mtext>
</mrow>
<mi>i</mi>
<mo>≥<!-- ≥ --></mo>
<mn>2</mn>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c_{1}=0,\qquad c_{i}=\sum _{j=1}^{i-1}p_{j}{\text{ for }}i\geq 2,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle c_{1}=0,\qquad c_{i}=\sum _{j=1}^{i-1}p_{j}{\text{ for }}i\geq 2,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ede1a47eccf59ae90511138b0d1d73614d0af94a" style="vertical-align: -3.338ex; width:32.385ex; height:7.676ex;"/></span></dd></dl>
<p>so <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c_{1}=0,c_{2}=p_{1},c_{3}=p_{1}+p_{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mn>0</mn>
<mo>,</mo>
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>=</mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo>=</mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c_{1}=0,c_{2}=p_{1},c_{3}=p_{1}+p_{2}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle c_{1}=0,c_{2}=p_{1},c_{3}=p_{1}+p_{2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e3641758d65721b8784fb30867a43dad153ec264" style="vertical-align: -0.671ex; width:28.22ex; height:2.509ex;"/></span> and so on.
The codeword for symbol <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span> is chosen to be the first <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l_{i}}</annotation>
</semantics>
</math></span><img alt="l_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/48ba35055d00bcaa522bca9247c8857730998759" style="vertical-align: -0.671ex; width:1.493ex; height:2.509ex;"/></span> binary digits in the binary expansion of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c_{i}}</annotation>
</semantics>
</math></span><img alt="c_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/01acb7953ba52c2aa44264b5d0f8fd223aa178a2" style="vertical-align: -0.671ex; width:1.807ex; height:2.009ex;"/></span>.
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h3>
<p>This example shows the construction of a Shannon–Fano code for a small alphabet. There 5 different source symbols. Suppose 39 total symbols have been observed with the following frequencies, from which we can estimate the symbol probabilities.
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Count
</th>
<td>15
</td>
<td>7
</td>
<td>6
</td>
<td>6
</td>
<td>5
</td></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr></tbody></table></dd></dl>
<p>This source has entropy <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle H(X)=2.186}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>H</mi>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mn>2.186</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle H(X)=2.186}</annotation>
</semantics>
</math></span><img alt="{\displaystyle H(X)=2.186}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/078e8ca8bd882cdec894413b558b1de67de2d2eb" style="vertical-align: -0.838ex; width:14.248ex; height:2.843ex;"/></span> bits.
</p><p>For the Shannon–Fano code, we need to calculate the desired word lengths <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/721404aef701034ef9c4e2cd575e7ff290208439" style="vertical-align: -0.838ex; width:15.234ex; height:2.843ex;"/></span>.
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr>
<tr>
<th><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle -\log _{2}p_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle -\log _{2}p_{i}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle -\log _{2}p_{i}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7eaddc022cf29572c7c757a7d7c7f2047378adb4" style="vertical-align: -0.838ex; width:8.577ex; height:2.676ex;"/></span>
</th>
<td>1.379
</td>
<td>2.480
</td>
<td>2.700
</td>
<td>2.700
</td>
<td>2.963
</td></tr>
<tr>
<th>Word lengths <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9b3ec24cbf1b652103106f86a20426d53f155d8" style="vertical-align: -0.838ex; width:10.642ex; height:2.843ex;"/></span>
</th>
<td>2
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td></tr></tbody></table></dd></dl>
<p>We can pick codewords in order, choosing the lexicographically first word of the correct length that maintains the prefix-free property. Clearly A gets the codeword 00. To maintain the prefix-free property, B's codeword may not start 00, so the lexicographically first available word of length 3 is 010. Continuing like this, we get the following code:
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr>
<tr>
<th>Word lengths <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9b3ec24cbf1b652103106f86a20426d53f155d8" style="vertical-align: -0.838ex; width:10.642ex; height:2.843ex;"/></span>
</th>
<td>2
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td></tr>
<tr>
<th>Codewords
</th>
<td>00
</td>
<td>010
</td>
<td>011
</td>
<td>100
</td>
<td>101
</td></tr></tbody></table></dd></dl>
<p>Alternatively, we can use the cumulative probability method.
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr>
<tr>
<th>Cumulative probabilities
</th>
<td>0.000
</td>
<td>0.385
</td>
<td>0.564
</td>
<td>0.718
</td>
<td>0.872
</td></tr>
<tr>
<th>...in binary
</th>
<td>0.00000
</td>
<td>0.01100
</td>
<td>0.10010
</td>
<td>0.10110
</td>
<td>0.11011
</td></tr>
<tr>
<th>Word lengths <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \lceil -\log _{2}p_{i}\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \lceil -\log _{2}p_{i}\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9b3ec24cbf1b652103106f86a20426d53f155d8" style="vertical-align: -0.838ex; width:10.642ex; height:2.843ex;"/></span>
</th>
<td>2
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td>
<td>3
</td></tr>
<tr>
<th>Codewords
</th>
<td>00
</td>
<td>011
</td>
<td>100
</td>
<td>101
</td>
<td>110
</td></tr></tbody></table></dd></dl>
<p>Note that although the codewords under the two methods are different, the word lengths are the same. We have lengths of 2 bits for A, and 3 bits for B, C, D and E, giving an average length of
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {2\,{\text{bits}}\cdot (15)+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.62\,{\text{bits per symbol,}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mn>2</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<mn>15</mn>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mn>3</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<mn>7</mn>
<mo>+</mo>
<mn>6</mn>
<mo>+</mo>
<mn>6</mn>
<mo>+</mo>
<mn>5</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>39</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>symbols</mtext>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>≈<!-- ≈ --></mo>
<mn>2.62</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits per symbol,</mtext>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {2\,{\text{bits}}\cdot (15)+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.62\,{\text{bits per symbol,}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\frac {2\,{\text{bits}}\cdot (15)+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.62\,{\text{bits per symbol,}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b48583844aba1518607322f1105de3217937ced4" style="vertical-align: -2.338ex; width:60.375ex; height:6.176ex;"/></span></dd></dl>
<p>which is within one bit of the entropy.
</p>
<h3><span class="mw-headline" id="Expected_word_length">Expected word length</span><span class="mw-editsection"></span></h3>
<p>For Shannon's method, the word lengths satisfy
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil \leq -\log _{2}p_{i}+1.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
<mo>≤<!-- ≤ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>+</mo>
<mn>1.</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil \leq -\log _{2}p_{i}+1.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle l_{i}=\lceil -\log _{2}p_{i}\rceil \leq -\log _{2}p_{i}+1.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12c4da64d8ac656d1f6c7e6098853b76a0ee3a89" style="vertical-align: -0.838ex; width:31.559ex; height:2.843ex;"/></span></dd></dl>
<p>Hence the expected word length satisfies
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {E} L=\sum _{i=1}^{n}p_{i}l_{i}\leq \sum _{i=1}^{n}p_{i}(-\log _{2}p_{i}+1)=-\sum _{i=1}^{n}p_{i}\log _{2}p_{i}+\sum _{i=1}^{n}p_{i}=H(X)+1.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">E</mi>
</mrow>
<mi>L</mi>
<mo>=</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<msub>
<mi>l</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>≤<!-- ≤ --></mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mo>−<!-- − --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mo>−<!-- − --></mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>+</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mi>H</mi>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mn>1.</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {E} L=\sum _{i=1}^{n}p_{i}l_{i}\leq \sum _{i=1}^{n}p_{i}(-\log _{2}p_{i}+1)=-\sum _{i=1}^{n}p_{i}\log _{2}p_{i}+\sum _{i=1}^{n}p_{i}=H(X)+1.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \mathbb {E} L=\sum _{i=1}^{n}p_{i}l_{i}\leq \sum _{i=1}^{n}p_{i}(-\log _{2}p_{i}+1)=-\sum _{i=1}^{n}p_{i}\log _{2}p_{i}+\sum _{i=1}^{n}p_{i}=H(X)+1.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ff86cb810462c07fb095aecbd2d90068a397ab8" style="vertical-align: -3.005ex; width:76.562ex; height:6.843ex;"/></span></dd></dl>
<p>Here, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle H(X)=-\textstyle \sum _{i=1}^{n}p_{i}\log _{2}p_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>H</mi>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mo>−<!-- − --></mo>
<mstyle displaystyle="false" scriptlevel="0">
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle H(X)=-\textstyle \sum _{i=1}^{n}p_{i}\log _{2}p_{i}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle H(X)=-\textstyle \sum _{i=1}^{n}p_{i}\log _{2}p_{i}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/749961ac9916d371e0a9925000dea881272e3010" style="vertical-align: -1.005ex; width:25.626ex; height:3.176ex;"/></span> is the entropy, and Shannon's source coding theorem says that any code must have an average length of at least <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle H(X)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>H</mi>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle H(X)}</annotation>
</semantics>
</math></span><img alt="H(X)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bd232b6fb5ea803efc1154d2efb0c3fe00a4531b" style="vertical-align: -0.838ex; width:5.853ex; height:2.843ex;"/></span>. Hence we see that the Shannon–Fano code is always within one bit of the optimal expected word length.
</p>
<h2><span id="Fano.27s_code:_binary_splitting"></span><span class="mw-headline" id="Fano's_code:_binary_splitting">Fano's code: binary splitting</span><span class="mw-editsection"></span></h2>
<h3><span id="Outline_of_Fano.27s_code"></span><span class="mw-headline" id="Outline_of_Fano's_code">Outline of Fano's code</span><span class="mw-editsection"></span></h3>
<p>In Fano's method, the symbols are arranged in order from most probable to least probable, and then divided into two sets whose total probabilities are as close as possible to being equal.  All symbols then have the first digits of their codes assigned; symbols in the first set receive "0" and symbols in the second set receive "1".  As long as any sets with more than one member remain, the same process is repeated on those sets, to determine successive digits of their codes.  When a set has been reduced to one symbol this means the symbol's code is complete and will not form the prefix of any other symbol's code.
</p><p>The algorithm produces fairly efficient variable-length encodings; when the two smaller sets produced by a partitioning are in fact of equal probability, the one bit of information used to distinguish them is used most efficiently.  Unfortunately, Shannon–Fano coding does not always produce optimal prefix codes; the set of probabilities {0.35, 0.17, 0.17, 0.16, 0.15} is an example of one that will be assigned non-optimal codes by Shannon–Fano coding.
</p><p>Fano's version of Shannon–Fano coding is used in the <code>IMPLODE</code> compression method, which is part of the <code>ZIP</code> file format.<sup class="reference" id="cite_ref-appnote_10-0">[10]</sup>
</p>
<h3><span id="The_Shannon.E2.80.93Fano_tree"></span><span class="mw-headline" id="The_Shannon–Fano_tree">The Shannon–Fano tree</span><span class="mw-editsection"></span></h3>
<p>A Shannon–Fano tree is built according to a specification designed to define an effective code table. The actual algorithm is simple:
</p>
<ol><li>For a given list of symbols, develop a corresponding list of probabilities or frequency counts so that each symbol’s relative frequency of occurrence is known.</li>
<li>Sort the lists of symbols according to frequency, with the most frequently occurring symbols at the left and the least common at the right.</li>
<li>Divide the list into two parts, with the total frequency counts of the left part being as close to the total of the right as possible.</li>
<li>The left part of the list is assigned the binary digit 0, and the right part is assigned the digit 1. This means that the codes for the symbols in the first part will all start with 0, and the codes in the second part will all start with 1.</li>
<li>Recursively apply the steps 3 and 4 to each of the two halves, subdividing groups and adding bits to the codes until each symbol has become a corresponding code leaf on the tree.</li></ol>
<h3><span class="mw-headline" id="Example_2">Example</span><span class="mw-editsection"></span></h3>

<p>We continue with the previous example.
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Count
</th>
<td>15
</td>
<td>7
</td>
<td>6
</td>
<td>6
</td>
<td>5
</td></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr></tbody></table></dd></dl>
<p>All symbols are sorted by frequency, from left to right (shown in Figure a). Putting the dividing line between symbols B and C results in a total of 22 in the left group and a total of 17 in the right group. This minimizes the difference in totals between the two groups.
</p><p>With this division, A and B will each have a code that starts with a 0 bit, and the C, D, and E codes will all start with a 1, as shown in Figure b. Subsequently, the left half of the tree gets a new division between A and B, which puts A on a leaf with code 00 and B on a leaf with code 01.
</p><p>After four division procedures, a tree of codes results. In the final tree, the three symbols with the highest frequencies have all been assigned 2-bit codes, and two symbols with lower counts have 3-bit codes as shown table below:
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr>
<tr>
<th>First division
</th>
<td colspan="2">0
</td>
<td colspan="3">1
</td></tr>
<tr>
<th>Second division
</th>
<td rowspan="2" style="vertical-align:top">0
</td>
<td rowspan="2" style="vertical-align:top">1
</td>
<td rowspan="2" style="vertical-align:top">0
</td>
<td colspan="2">1
</td></tr>
<tr>
<th>Third division
</th>
<td>0
</td>
<td>1
</td></tr>
<tr>
<th>Codewords
</th>
<td>00
</td>
<td>01
</td>
<td>10
</td>
<td>110
</td>
<td>111
</td></tr></tbody></table></dd></dl>
<p>This results in lengths of 2 bits for A, B and C and per 3 bits for D and E, giving an average length of
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {2\,{\text{bits}}\cdot (15+7+6)+3\,{\text{bits}}\cdot (6+5)}{39\,{\text{symbols}}}}\approx 2.28\,{\text{bits per symbol.}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mn>2</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<mn>15</mn>
<mo>+</mo>
<mn>7</mn>
<mo>+</mo>
<mn>6</mn>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mn>3</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<mn>6</mn>
<mo>+</mo>
<mn>5</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>39</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>symbols</mtext>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>≈<!-- ≈ --></mo>
<mn>2.28</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits per symbol.</mtext>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {2\,{\text{bits}}\cdot (15+7+6)+3\,{\text{bits}}\cdot (6+5)}{39\,{\text{symbols}}}}\approx 2.28\,{\text{bits per symbol.}}}</annotation>
</semantics>
</math></span><img alt="{\frac  {2\,{\text{bits}}\cdot (15+7+6)+3\,{\text{bits}}\cdot (6+5)}{39\,{\text{symbols}}}}\approx 2.28\,{\text{bits per symbol.}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b06f778ec375a89fa477e7c112e56112885394c" style="vertical-align: -2.338ex; width:60.375ex; height:6.176ex;"/></span></dd></dl>
<p>We see that Fano's method, with an average length of 2.28, has outperformed Shannon's method, with an average length of 2.62.
</p>
<h3><span class="mw-headline" id="Expected_word_length_2">Expected word length</span><span class="mw-editsection"></span></h3>
<p>It is shown by Krajči et al<sup class="reference" id="cite_ref-Kraj_2-2">[2]</sup> that the expected length of Fano's method has expected length bounded above by <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mathbb {E} L\leq H(X)+1-p_{\text{min}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">E</mi>
</mrow>
<mi>L</mi>
<mo>≤<!-- ≤ --></mo>
<mi>H</mi>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mn>1</mn>
<mo>−<!-- − --></mo>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mtext>min</mtext>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mathbb {E} L\leq H(X)+1-p_{\text{min}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \mathbb {E} L\leq H(X)+1-p_{\text{min}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3a8e85850b76079035ae8c52f73fd134e6d51842" style="vertical-align: -0.838ex; width:23.07ex; height:2.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle p_{\text{min}}=\textstyle \min _{i}p_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mtext>min</mtext>
</mrow>
</msub>
<mo>=</mo>
<mstyle displaystyle="false" scriptlevel="0">
<munder>
<mo form="prefix" movablelimits="true">min</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</munder>
<msub>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle p_{\text{min}}=\textstyle \min _{i}p_{i}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle p_{\text{min}}=\textstyle \min _{i}p_{i}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a6973429a210a11695325638ea42ee42cabfdd0b" style="vertical-align: -0.671ex; margin-left: -0.089ex; width:14.361ex; height:2.509ex;"/></span> is the probability of the least common symbol.
</p>
<h2><span class="mw-headline" id="Comparison_with_other_coding_methods">Comparison with other coding methods</span><span class="mw-editsection"></span></h2>
<p>Neither Shannon–Fano algorithm is guaranteed to generate an optimal code. For this reason, Shannon–Fano codes are almost never used; Huffman coding is almost as computationally simple and produces prefix codes that always achieve the lowest possible expected code word length, under the constraints that each symbol is represented by a code formed of an integral number of bits.  This is a constraint that is often unneeded, since the codes will be packed end-to-end in long sequences.  If we consider groups of codes at a time, symbol-by-symbol Huffman coding is only optimal if the probabilities of the symbols are independent and are some power of a half, i.e., <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \textstyle 1/2^{k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mstyle displaystyle="false" scriptlevel="0">
<mn>1</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
</mstyle>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \textstyle 1/2^{k}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \textstyle 1/2^{k}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3d0edd70ac9dc5868800bd3ab4cfbec3390b586f" style="vertical-align: -0.838ex; width:4.576ex; height:3.176ex;"/></span>.  In most situations, arithmetic coding can produce greater overall compression than either Huffman or Shannon–Fano, since it can encode in fractional numbers of bits which more closely approximate the actual information content of the symbol.  However, arithmetic coding has not superseded Huffman the way that Huffman supersedes Shannon–Fano, both because arithmetic coding is more computationally expensive and because it is covered by multiple patents.<sup class="reference" id="cite_ref-LiDrew2014_11-0">[11]</sup>
</p>
<h3><span class="mw-headline" id="Huffman_coding">Huffman coding</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A few years later, David A. Huffman (1949)<sup class="reference" id="cite_ref-12">[12]</sup> gave a different algorithm that always produces an optimal tree for any given symbol probabilities. While Fano's Shannon–Fano tree is created by dividing from the root to the leaves, the Huffman algorithm works in the opposite direction, merging from the leaves to the root. 
</p>
<ol><li>Create a leaf node for each symbol and add it to a priority queue, using its frequency of occurrence as the priority.</li>
<li>While there is more than one node in the queue:
<ol><li>Remove the two nodes of lowest probability or frequency from the queue</li>
<li>Prepend 0 and 1 respectively to any code already assigned to these nodes</li>
<li>Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.</li>
<li>Add the new node to the queue.</li></ol></li>
<li>The remaining node is the root node and the tree is complete.</li></ol>
<h3><span class="mw-headline" id="Example_with_Huffman_coding">Example with Huffman coding</span><span class="mw-editsection"></span></h3>

<p>We use the same frequencies as for the Shannon–Fano example above, viz:
</p>
<dl><dd><table class="wikitable" style="text-align: center;">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Count
</th>
<td>15
</td>
<td>7
</td>
<td>6
</td>
<td>6
</td>
<td>5
</td></tr>
<tr>
<th>Probabilities
</th>
<td>0.385
</td>
<td>0.179
</td>
<td>0.154
</td>
<td>0.154
</td>
<td>0.128
</td></tr></tbody></table></dd></dl>
<p>In this case D &amp; E have the lowest frequencies and so are allocated 0 and 1 respectively and grouped together with a combined probability of 0.282.  The lowest pair now are B and C so they're allocated 0 and 1 and grouped together with a combined probability of 0.333.  This leaves BC and DE now with the lowest probabilities so 0 and 1 are prepended to their codes and they are combined.  This then leaves just A and BCDE, which have 0 and 1 prepended respectively and are then combined.  This leaves us with a single node and our algorithm is complete.
</p><p>The code lengths for the different characters this time are 1 bit for A and 3 bits for all other characters.
</p>
<dl><dd><table class="wikitable">
<tbody><tr>
<th>Symbol
</th>
<th>A
</th>
<th>B
</th>
<th>C
</th>
<th>D
</th>
<th>E
</th></tr>
<tr>
<th>Codewords
</th>
<td>0
</td>
<td>100
</td>
<td>101
</td>
<td>110
</td>
<td>111
</td></tr></tbody></table></dd></dl>
<p>This results in the lengths of 1 bit for A and per 3 bits for B, C, D and E, giving an average length of
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {1\,{\text{bit}}\cdot 15+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.23\,{\text{bits per symbol.}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mn>1</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bit</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mn>15</mn>
<mo>+</mo>
<mn>3</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits</mtext>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mo stretchy="false">(</mo>
<mn>7</mn>
<mo>+</mo>
<mn>6</mn>
<mo>+</mo>
<mn>6</mn>
<mo>+</mo>
<mn>5</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>39</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>symbols</mtext>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>≈<!-- ≈ --></mo>
<mn>2.23</mn>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>bits per symbol.</mtext>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {1\,{\text{bit}}\cdot 15+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.23\,{\text{bits per symbol.}}}</annotation>
</semantics>
</math></span><img alt="{\frac  {1\,{\text{bit}}\cdot 15+3\,{\text{bits}}\cdot (7+6+6+5)}{39\,{\text{symbols}}}}\approx 2.23\,{\text{bits per symbol.}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cf7c95d5e201cf4a002377f2eb0105a50ba9fc69" style="vertical-align: -2.338ex; width:57.649ex; height:6.176ex;"/></span></dd></dl>
<p>We see that the Huffman code has outperformed both types of Shannon–Fano code, which had expected lengths of 2.62 and 2.28.
</p>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1" id="CITEREFFano1949">Fano, R.M. (1949). "The transmission of information". <i>Technical Report No. 65</i>. Cambridge (Mass.), USA: Research Laboratory of Electronics at MIT.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Technical+Report+No.+65&amp;rft.atitle=The+transmission+of+information&amp;rft.date=1949&amp;rft.aulast=Fano&amp;rft.aufirst=R.M.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Ffano-tr65.7z&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AShannon%E2%80%93Fano+coding"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1" id="CITEREFShannon1948">Shannon, C.E. (July 1948). "A Mathematical Theory of Communication". <i>Bell System Technical Journal</i>. <b>27</b>: 379–423.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bell+System+Technical+Journal&amp;rft.atitle=A+Mathematical+Theory+of+Communication&amp;rft.volume=27&amp;rft.pages=379-423&amp;rft.date=1948-07&amp;rft.aulast=Shannon&amp;rft.aufirst=C.E.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fost-engineering-shannon1948&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AShannon%E2%80%93Fano+coding"></span></li></ul>
<!-- 
NewPP limit report
Parsed by mw1455
Cached time: 20221223231448
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.204 seconds
Real time usage: 0.294 seconds
Preprocessor visited node count: 778/1000000
Post‐expand include size: 12939/2097152 bytes
Template argument size: 454/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 22145/5000000 bytes
Lua time usage: 0.098/10.000 seconds
Lua memory usage: 4244866/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  191.372      1 -total
 50.10%   95.883      1 Template:Reflist
 41.40%   79.225      4 Template:Cite_journal
 30.48%   58.327      1 Template:Short_description
 16.17%   30.948      2 Template:Pagetype
 10.20%   19.525      2 Template:Main
  8.65%   16.545      3 Template:Main_other
  7.62%   14.576      1 Template:SDcat
  2.90%    5.542      1 Template:Cite_web
  2.82%    5.394      1 Template:Cite_book
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:62544-0!canonical and timestamp 20221223231448 and revision id 1115172689.
 -->
</div></body>
</html>