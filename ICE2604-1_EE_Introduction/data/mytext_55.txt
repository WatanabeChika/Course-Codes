cut_vertexIn graph theory, a biconnected component (sometimes known as a 2-connected component) is a maximal biconnected subgraph.  Any connected graph decomposes into a tree of biconnected components called the block-cut tree of the graph. The blocks are attached to each other at shared vertices called cut vertices or separating vertices or articulation points.  Specifically, a cut vertex is any vertex whose removal increases the number of connected components.[1]The classic sequential algorithm for computing biconnected components in a connected undirected graph is due to John Hopcroft and Robert Tarjan (1973).[2] It runs in linear time, and is based on depth-first search. This algorithm is also outlined as Problem 22-2 of Introduction to Algorithms (both 2nd and 3rd editions).The idea is to run a depth-first search while maintaining the following information:the depth of each vertex in the depth-first-search tree (once it gets visited), andfor each vertex , the lowest depth of neighbors of all descendants of  (including  itself) in the depth-first-search tree, called the .The depth is standard to maintain during a depth-first search.  The low point of  can be computed after visiting all descendants of  (i.e., just before  gets popped off the depth-first-search stack) as the minimum of the depth of , the depth of all neighbors of  (other than the parent of  in the depth-first-search tree) and the lowpoint of all children of  in the depth-first-search tree.The key fact is that a nonroot vertex  is a cut vertex (or articulation point) separating two biconnected components if and only if there is a child  of  such that . This property can be tested once the depth-first search returned from every child of  (i.e., just before  gets popped off the depth-first-search stack), and if true,  separates the graph into different biconnected components. This can be represented by computing one biconnected component out of every such  (a component which contains  will contain the subtree of , plus ), and then erasing the subtree of  from the tree.The root vertex must be handled separately: it is a cut vertex if and only if it has at least two children in the DFS tree.  Thus, it suffices to simply build one component out of each child subtree of the root (including the root).GetArticulationPoints(i, d)    visited[i] := true    depth[i] := d    low[i] := d    childCount := 0    isArticulation := false    for each ni in adj[i] do        if not visited[ni] then            parent[ni] := i            GetArticulationPoints(ni, d + 1)            childCount := childCount + 1            if low[ni] ≥ depth[i] then                isArticulation := true            low[i] := Min (low[i], low[ni])        else if ni ≠ parent[i] then            low[i] := Min (low[i], depth[ni])    if (parent[i] ≠ null and isArticulation) or (parent[i] = null and childCount &gt; 1) then        Output i as articulation pointNote that the terms child and parent denote the relations in the DFS tree, not the original graph.A simple alternative to the above algorithm uses chain decompositions, which are special ear decompositions depending on DFS-trees.[3] Chain decompositions can be computed in linear time by this traversing rule. Let  be a chain decomposition of . Then  is 2-vertex-connected if and only if  has minimum degree 2 and  is the only cycle in . This gives immediately a linear-time 2-connectivity test and can be extended to list all cut vertices of  in linear time using the following statement: A vertex  in a connected graph  (with minimum degree 2) is a cut vertex if and only if  is incident to a bridge or  is the first vertex of a cycle in . The list of cut vertices can be used to create the block-cut tree of  in linear time.In the online version of the problem, vertices and edges are added (but not removed) dynamically, and a data structure must maintain the biconnected components.  Jeffery Westbrook and Robert Tarjan (1992) [4] developed an efficient data structure for this problem based on disjoint-set data structures.  Specifically, it processes  vertex additions and  edge additions in  total time, where  is the inverse Ackermann function.  This time bound is proved to be optimal.Uzi Vishkin and Robert Tarjan (1985) [5] designed a parallel algorithm on CRCW PRAM that runs in  time with  processors.One can define a binary relation on the edges of an arbitrary undirected graph, according to which two edges  and  are related if and only if either  or the graph contains a simple cycle through both  and . Every edge is related to itself, and an edge  is related to another edge  if and only if  is related in the same way to . Less obviously, this is a transitive relation: if there exists a simple cycle containing edges  and , and another simple cycle containing edges  and , then one can combine these two cycles to find a simple cycle through  and . Therefore, this is an equivalence relation, and it can be used to partition the edges into equivalence classes, subsets of edges with the property that two edges are related to each other if and only if they belong to the same equivalence class. The subgraphs formed by the edges in each equivalence class are the biconnected components of the given graph. Thus, the biconnected components partition the edges of the graph; however, they may share vertices with each other.[6]The block graph of a given graph  is the intersection graph of its blocks. Thus, it has one vertex for each block of , and an edge between two vertices whenever the corresponding two blocks share a vertex.A graph  is the block graph of another graph  exactly when all the blocks of  are complete subgraphs. The graphs  with this property are known as the block graphs.[7]A cutpoint, cut vertex, or articulation point of a graph  is a vertex that is shared by two or more blocks. The structure of the blocks and cutpoints of a connected graph can be described by a tree called the block-cut tree or BC-tree. This tree has a vertex for each block and for each articulation point of the given graph. There is an edge in the block-cut tree for each pair of a block and an articulation point that belongs to that block.[8]Triconnected componentBridge (graph theory)Single-entry single-exit Counter part of biconnected components in directed graphsEugene C. Freuder (1985). "A Sufficient Condition for Backtrack-Bounded Search". Journal of the Association for Computing Machinery. 32 (4): 755–761. doi:10.1145/4221.4225.C++ implementation of Biconnected Components