<!DOCTYPE html>
<html>
<head>
<title>R*-tree</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">R*-tree</th></tr><tr><th class="infobox-label" scope="row">Invented</th><td class="infobox-data">1990</td></tr><tr><th class="infobox-label" scope="row">Invented by</th><td class="infobox-data">Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Space</th><td class="infobox-data infobox-data-a">
<span class="texhtml">O(<i>n</i>)</span></td><td class="infobox-data infobox-data-b">
<span class="texhtml">O(<i>n</i>)</span></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
<span class="texhtml">O(log <i>n</i>)</span></td><td class="infobox-data infobox-data-b">
</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
<span class="texhtml">O(log <i>n</i>)</span></td><td class="infobox-data infobox-data-b">
</td></tr></tbody></table></td></tr></tbody></table>
<p>In data processing <b>R*-trees</b> are a variant of R-trees used for indexing spatial information. R*-trees have slightly higher construction cost than standard R-trees, as the data may need to be reinserted; but the resulting tree will usually have a better query performance. Like the standard R-tree, it can store both point and spatial data.
It was proposed by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger in 1990.<sup class="reference" id="cite_ref-rstar_1-0">[1]</sup>
</p>

<h2><span id="Difference_between_R.2A-trees_and_R-trees"></span><span class="mw-headline" id="Difference_between_R*-trees_and_R-trees">Difference between R*-trees and R-trees</span><span class="mw-editsection"></span></h2>

<p>Minimization of both coverage and overlap is crucial to the performance of R-trees. Overlap means that, on data query or insertion, more than one branch of the tree needs to be expanded (due to the way data is being split in regions which may overlap). A minimized coverage improves pruning performance, allowing exclusion of whole pages from search more often, in particular for negative range queries.
The R*-tree attempts to reduce both, using a combination of a revised node split algorithm and the concept of forced reinsertion
at node overflow. This is based on the observation that R-tree structures are highly susceptible 
to the order in which their entries are inserted, so an insertion-built (rather than bulk-loaded) structure 
is likely to be sub-optimal. Deletion and reinsertion of entries allows them to "find" a place in the tree 
that may be more appropriate than their original location.
</p><p>When a node overflows, a portion of its entries are removed from the node and reinserted into the tree.
(In order to avoid an indefinite cascade of reinsertions caused by subsequent node overflow, the reinsertion 
routine may be called only once in each level of the tree when inserting any one new entry.) This has the 
effect of producing more well-clustered groups of entries in nodes, reducing node coverage. Furthermore, 
actual node splits are often postponed, causing average node occupancy to rise.
Re-insertion can be seen as a method of incremental tree optimization triggered on node overflow.
</p>
<h2><span class="mw-headline" id="Performance">Performance</span><span class="mw-editsection"></span></h2>
<ul><li>Improved split heuristic produces pages that are more rectangular and thus better for many applications.</li>
<li>Reinsertion method optimizes the existing tree, but increases complexity.</li>
<li>Efficiently supports point and spatial data at the same time.</li></ul>

<style data-mw-deduplicate="TemplateStyles:r1021810730">@media all and (max-width:720px){.mw-parser-output .mod-gallery{width:100%!important}}.mw-parser-output .mod-gallery{display:table}.mw-parser-output .mod-gallery-default{background:transparent;margin-top:0.3em}.mw-parser-output .mod-gallery-center{margin-left:auto;margin-right:auto}.mw-parser-output .mod-gallery-left{float:left}.mw-parser-output .mod-gallery-right{float:right}.mw-parser-output .mod-gallery-none{float:none}.mw-parser-output .mod-gallery-collapsible{width:100%}.mw-parser-output .mod-gallery .title,.mw-parser-output .mod-gallery .main,.mw-parser-output .mod-gallery .footer{display:table-row}.mw-parser-output .mod-gallery .title>div{display:table-cell;padding:0.2em 0 0.6em 1.6em;text-align:center;font-weight:bold}.mw-parser-output .mod-gallery .main>div{display:table-cell}.mw-parser-output .mod-gallery .gallery{line-height:1.35em}.mw-parser-output .mod-gallery .footer>div{display:table-cell;padding:0.2em 0 0.6em 1.6em;text-align:right;font-size:80%;line-height:1em}.mw-parser-output .mod-gallery .title>div *,.mw-parser-output .mod-gallery .footer>div *{overflow:visible}.mw-parser-output .mod-gallery .gallerybox img{background:none!important}.mw-parser-output .mod-gallery .bordered-images .thumb img{border:solid #eaecf0 1px}.mw-parser-output .mod-gallery .whitebg .thumb{background:#fff!important}</style>
<h2><span class="mw-headline" id="Algorithm_and_complexity">Algorithm and complexity</span><span class="mw-editsection"></span></h2>
<ul><li>The R*-tree uses the same algorithm as the regular R-tree for query and delete operations.</li>
<li>When inserting, the R*-tree uses a combined strategy. For leaf nodes, overlap is minimized, while for inner nodes, enlargement and area are minimized.</li>
<li>When splitting, the R*-tree uses a topological split that chooses a split axis based on perimeter, then minimizes overlap.</li>
<li>In addition to an improved split strategy, the R*-tree also tries to avoid splits by reinserting objects and subtrees into the tree, inspired by the concept of balancing a B-tree.</li></ul>
<p>Worst case query and delete complexity are thus identical to the R-Tree. The insertion strategy to the R*-tree is with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(M\log M)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(M\log M)}</annotation>
</semantics>
</math></span><img alt="{\mathcal  {O}}(M\log M)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5d5e6a48d9520ac74d058cde16744f683d476287" style="vertical-align: -0.838ex; width:12.29ex; height:2.843ex;"/></span> more complex than the linear split strategy (<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(M)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(M)}</annotation>
</semantics>
</math></span><img alt="{\mathcal  {O}}(M)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/84fff48af4c0694fcb3f73a58422215818e43dfd" style="vertical-align: -0.838ex; width:6.101ex; height:2.843ex;"/></span>) of the R-tree, but less complex than the quadratic split strategy (<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(M^{2})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>M</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(M^{2})}</annotation>
</semantics>
</math></span><img alt="{\mathcal  {O}}(M^{2})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/56d4e54472d20728432dfd8cb45a89a7d2d508b4" style="vertical-align: -0.838ex; width:7.212ex; height:3.176ex;"/></span>) for a page size of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle M}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>M</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle M}</annotation>
</semantics>
</math></span><img alt="M" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" style="vertical-align: -0.338ex; width:2.442ex; height:2.176ex;"/></span> objects and has little impact on the total complexity. The total insert complexity is still comparable to the R-tree: reinsertions affect at most one branch of the tree and thus <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(\log n)}</annotation>
</semantics>
</math></span><img alt="{\mathcal {O}}(\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74a9dfea91c47d1c6563e89bbcd891771b91acfa" style="vertical-align: -0.838ex; width:8.413ex; height:2.843ex;"/></span> reinsertions, comparable to performing a split on a regular R-tree. So on overall, the complexity of the R*-tree is the same as that of a regular R-tree.
</p><p>An implementation of the full algorithm must address many corner cases and tie situations not discussed here.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li><img alt="" class="noviewer" data-file-height="1376" data-file-width="1024" decoding="async" height="16" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/12px-Commons-logo.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/18px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/24px-Commons-logo.svg.png 2x" width="12"/> Media related to R*-tree at Wikimedia Commons</li></ul>


<!-- 
NewPP limit report
Parsed by mw2272
Cached time: 20221220214531
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.293 seconds
Real time usage: 0.455 seconds
Preprocessor visited node count: 1140/1000000
Post‐expand include size: 41802/2097152 bytes
Template argument size: 1304/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 25766/5000000 bytes
Lua time usage: 0.173/10.000 seconds
Lua memory usage: 4577448/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  353.653      1 -total
 29.07%  102.817      1 Template:Reflist
 22.27%   78.744      2 Template:Cite_book
 15.74%   55.661      1 Template:Short_description
 14.29%   50.542      1 Template:Infobox_data_structure
 14.09%   49.816      2 Template:Navbox
 13.66%   48.316      1 Template:CS_trees
 13.31%   47.084      1 Template:Commons_cat_inline
 13.09%   46.288      1 Template:Infobox
 12.46%   44.050      1 Template:Sister-inline
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1369832-0!canonical and timestamp 20221220214530 and revision id 1087756859.
 -->
</div></body>
</html>