<!DOCTYPE html>
<html>
<head>
<title>bogosort</title>
</head>
<body>
<div class="mw-parser-output">
<p class="mw-empty-elt">
</p>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Bogosort</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Sorting</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data">Unbounded (randomized version), <span class="texhtml"><i>O</i>((<i>n</i>+1)!)</span> (deterministic version)</td></tr><tr><th class="infobox-label" scope="row">Best-case performance</th><td class="infobox-data"><span class="texhtml"><i>O</i>(<i>n</i>)</span><sup class="reference" id="cite_ref-Fun07_1-0">[1]</sup></td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data"><span class="texhtml"><i>O</i>((<i>n</i>+1)!)</span><sup class="reference" id="cite_ref-Fun07_1-1">[1]</sup></td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><span class="texhtml"><i>O</i>(<i>1</i>)</span></td></tr></tbody></table>
<p>In computer science, <b>bogosort</b><sup class="reference" id="cite_ref-Fun07_1-2">[1]</sup><sup class="reference" id="cite_ref-KSFS_2-0">[2]</sup> (also known as <b>permutation sort</b>, <b>stupid sort</b>,<sup class="reference" id="cite_ref-3">[3]</sup> slowsort or bozosort) is a sorting algorithm based on the generate and test paradigm. The function successively generates permutations of its input until it finds one that is sorted. It is not considered useful for sorting, but may be used for educational purposes, to contrast it with more efficient algorithms.
</p><p>Two versions of this algorithm exist: a deterministic version that enumerates all permutations until it hits a sorted one,<sup class="reference" id="cite_ref-KSFS_2-1">[2]</sup><sup class="reference" id="cite_ref-Naish86_4-0">[4]</sup> and a randomized version that randomly permutes its input. An analogy for the working of the latter version is to sort a deck of cards by throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. Its name is a portmanteau of the words <i>bogus</i> and <i>sort</i>.<sup class="reference" id="cite_ref-5">[5]</sup>
</p>

<h2><span class="mw-headline" id="Description_of_the_algorithm">Description of the algorithm</span><span class="mw-editsection"></span></h2>
<p>The following is a description of the randomized algorithm in pseudocode:
</p>
<pre><b>while not</b> sorted(deck):
    shuffle(deck)
</pre>
<p>Here is the above pseudocode rewritten in Python 3:
</p>

<p>This code assumes that <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">data</code> is a simple, mutable, array-like data structure—like Python's built-in <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">list</code>—whose elements can be compared without issue.
</p>
<h2><span class="mw-headline" id="Running_time_and_termination">Running time and termination</span><span class="mw-editsection"></span></h2>

<p>If all elements to be sorted are distinct, the expected number of comparisons performed in the average case by randomized bogosort is asymptotically equivalent to <span class="texhtml">(<i>e</i> − 1)<i>n</i>!</span>, and the expected number of swaps in the average case equals <span class="texhtml">(<i>n</i> − 1)<i>n</i>!</span>.<sup class="reference" id="cite_ref-Fun07_1-3">[1]</sup> The expected number of swaps grows faster than the expected number of comparisons, because if the elements are not in order, this will usually be discovered after only a few comparisons, no matter how many elements there are; but the work of shuffling the collection is proportional to its size. In the worst case, the number of comparisons and swaps are both unbounded, for the same reason that a tossed coin might turn up heads any number of times in a row.
</p><p>The best case occurs if the list as given is already sorted; in this case the expected number of comparisons is <span class="texhtml"><i>n</i> − 1</span>, and no swaps at all are carried out.<sup class="reference" id="cite_ref-Fun07_1-4">[1]</sup>
</p><p>For any collection of fixed size, the expected running time of the algorithm is finite for much the same reason that the infinite monkey theorem holds: there is some probability of getting the right permutation, so given an unbounded number of tries it will almost surely eventually be chosen.
</p>
<h2><span class="mw-headline" id="Related_algorithms">Related algorithms</span><span class="mw-editsection"></span></h2>
<dl><dt><style data-mw-deduplicate="TemplateStyles:r1023754711">.mw-parser-output .vanchor>:target~.vanchor-text{background-color:#b1d2ff}</style><span class="vanchor"><span id="Gorosort"></span><span class="vanchor-text">Gorosort</span></span></dt>
<dd>is a sorting algorithm introduced in the 2011 Google Code Jam.<sup class="reference" id="cite_ref-6">[6]</sup> As long as the list is not in order, a subset of all elements is randomly permuted. If this subset is optimally chosen each time this is performed, the expected value of the total number of times this operation needs to be done is equal to the number of misplaced elements.</dd>
<dt><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="Bogobogosort"></span><span class="vanchor-text">Bogobogosort</span></span></dt>
<dd>is an algorithm that was designed not to succeed before the heat death of the universe on any sizable list. It works by recursively calling itself with smaller and smaller copies of the beginning of the list to see if they are sorted.  The base case is a single element, which is always sorted.  For other cases, it compares the last element to the maximum element from the previous elements in the list.  If the last element is greater or equal, it checks if the order of the copy matches the previous version, and if so returns.  Otherwise, it reshuffles the current copy of the list and restarts its recursive check.<sup class="reference" id="cite_ref-7">[7]</sup></dd>
<dt><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="Bozosort"></span><span class="vanchor-text">Bozosort</span></span></dt>
<dd>is another sorting algorithm based on random numbers. If the list is not in order, it picks two items at random and swaps them, then checks to see if the list is sorted. The running time analysis of a bozosort is more difficult, but some estimates are found in H. Gruber's analysis of "perversely awful" randomized sorting algorithms.<sup class="reference" id="cite_ref-Fun07_1-5">[1]</sup> <span class="texhtml"><i>O</i>(<i>n</i>!)</span> is found to be the expected average case.</dd>
<dt><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="Worstsort"></span><span class="vanchor-text">Worstsort</span></span></dt>
<dd>is a pessimal<sup class="reference" id="cite_ref-pessimal_8-0">[a]</sup> sorting algorithm that is guaranteed to complete in finite time; however, its efficiency can be arbitrarily bad, depending on its configuration. The <span class="texhtml">worstsort</span> algorithm is based on a bad sorting algorithm, <span class="texhtml">badsort</span>. The badsort algorithm accepts two parameters: <span class="texhtml mvar" style="font-style:italic;">L</span>, which is the list to be sorted, and <span class="texhtml mvar" style="font-style:italic;">k</span>, which is a recursion depth. At recursion level <span class="texhtml"><i>k</i> = 0</span>, <span class="texhtml">badsort</span> merely uses a common sorting algorithm, such as bubblesort, to sort its inputs and return the sorted list. That is to say, <span class="texhtml">badsort(<i>L</i>, 0) = bubblesort(<i>L</i>)</span>. Therefore, badsort's time complexity is <span class="texhtml"><i>O</i>(<i>n</i><sup>2</sup>)</span> if <span class="texhtml"><i>k</i> = 0</span>. However, for any <span class="texhtml"><i>k</i> &gt; 0</span>, <span class="texhtml">badsort(<i>L</i>, <i>k</i>)</span> first generates <span class="texhtml mvar" style="font-style:italic;">P</span>, the list of all permutations of <span class="texhtml mvar" style="font-style:italic;">L</span>. Then, <span class="texhtml">badsort</span> calculates <span class="texhtml">badsort(<i>P</i>, <i>k</i> − 1)</span>, and returns the first element of the sorted <span class="texhtml mvar" style="font-style:italic;">P</span>. To make <span class="texhtml">worstsort</span> truly pessimal, <span class="texhtml mvar" style="font-style:italic;">k</span> may be assigned to the value of a computable increasing function such as <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f\colon \mathbb {N} \to \mathbb {N} }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo>:<!-- : --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
<mo stretchy="false">→<!-- → --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">N</mi>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f\colon \mathbb {N} \to \mathbb {N} }</annotation>
</semantics>
</math></span><img alt="{\displaystyle f\colon \mathbb {N} \to \mathbb {N} }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c4647669d51d83784f3e74f1e7a7e079cf267584" style="vertical-align: -0.671ex; width:9.283ex; height:2.509ex;"/></span> (e.g. <span class="texhtml"><i>f</i>(<i>n</i>) = <i>A</i>(<i>n</i>, <i>n</i>)</span>, where <span class="texhtml mvar" style="font-style:italic;">A</span> is Ackermann's function).  Ergo, to sort a list arbitrarily badly, you would execute <span class="texhtml">worstsort(<i>L</i>, <i>f</i>) = badsort(<i>L</i>, <i>f</i>(length(<i>L</i>)))</span>, where <span class="texhtml">length(<i>L</i>)</span> is the number of elements in <span class="texhtml mvar" style="font-style:italic;">L</span>. The resulting algorithm has complexity <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \Omega \left(\left(n!^{(f(n))}\right)^{2}\right)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mi mathvariant="normal">Ω<!-- Ω --></mi>
<mrow>
<mo>(</mo>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<mi>n</mi>
<msup>
<mo>!</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</mrow>
<mo>)</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>)</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \Omega \left(\left(n!^{(f(n))}\right)^{2}\right)}</annotation>
</semantics>
</math></span><img alt="{\textstyle \Omega \left(\left(n!^{(f(n))}\right)^{2}\right)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c383f42362507fbfd26a753f8cffa3724ec16b1e" style="vertical-align: -1.838ex; width:14.748ex; height:4.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n!^{(m)}=(\dotso ((n!)!)!\dotso )!}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<msup>
<mo>!</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mo>…<!-- … --></mo>
<mo stretchy="false">(</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>!</mo>
<mo>…<!-- … --></mo>
<mo stretchy="false">)</mo>
<mo>!</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n!^{(m)}=(\dotso ((n!)!)!\dotso )!}</annotation>
</semantics>
</math></span><img alt="{\displaystyle n!^{(m)}=(\dotso ((n!)!)!\dotso )!}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4435a0951134ded165b34d6aa922089df38851c5" style="vertical-align: -0.838ex; width:23.725ex; height:3.343ex;"/></span> = factorial of <span class="texhtml mvar" style="font-style:italic;">n</span> iterated <span class="texhtml mvar" style="font-style:italic;">m</span> times. This algorithm can be made as inefficient as one wishes by picking a fast enough growing function <span class="texhtml mvar" style="font-style:italic;">f</span>.<sup class="reference" id="cite_ref-9">[8]</sup></dd>
<dt>Slowsort</dt>
<dd>is a different humorous sorting algorithm that employs a misguided divide-and-conquer strategy to achieve massive complexity.</dd>
<dt><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="Quantum_Bogosort"></span><span class="vanchor-text">Quantum Bogosort</span></span></dt>
<dd>is a hypothetical sorting algorithm based on bogosort, created as an in-joke among computer scientists. The algorithm generates a random permutation of its input using a quantum source of entropy, checks if the list is sorted, and, if it is not, destroys the universe. Assuming that the many-worlds interpretation holds, the use of this algorithm will result in at least one surviving universe where the input was successfully sorted in <span class="texhtml"><i>O</i>(<i>n</i>)</span> time.<sup class="reference" id="cite_ref-10">[9]</sup></dd>
<dt><link href="mw-data:TemplateStyles:r1023754711" rel="mw-deduplicated-inline-style"/><span class="vanchor"><span id="Miracle_sort"></span><span class="vanchor-text">Miracle sort</span></span></dt>
<dd>is a sorting algorithm that checks if the array is sorted until a miracle occurs. It continually checks the array until it is sorted, never changing the order of the array.<sup class="reference" id="cite_ref-11">[10]</sup> Because the order is never altered, the algorithm has a hypothetical time complexity of <span class="texhtml"><i>O</i>(<i>∞</i>)</span>, but it can still sort through events such as miracles or single-event upsets. Particular care must be taken in the implementation of this algorithm as optimizing compilers may simply transform it into a while(true) loop.</dd></dl>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Las Vegas algorithm</li>
<li>Stooge sort</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>BogoSort on WikiWikiWeb</li>
<li>Inefficient sort algorithms</li>
<li>Bogosort: an implementation that runs on Unix-like systems, similar to the standard sort program.</li>
<li>Bogosort and jmmcg::bogosort<sup class="noprint Inline-Template"><span style="white-space: nowrap;">[<i><span title=" Dead link tagged July 2020">permanent dead link</span></i>]</span></sup>: Simple, yet perverse, C++ implementations of the bogosort algorithm.</li>
<li>Bogosort NPM package: bogosort implementation for Node.js ecosystem.</li>
<li>Max Sherman Bogo-sort is Sort of Slow, June 2013</li></ul>

<!-- 
NewPP limit report
Parsed by mw2408
Cached time: 20221224014420
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.305 seconds
Real time usage: 0.431 seconds
Preprocessor visited node count: 2931/1000000
Post‐expand include size: 45215/2097152 bytes
Template argument size: 4613/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 5/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 33757/5000000 bytes
Lua time usage: 0.159/10.000 seconds
Lua memory usage: 4480039/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  345.138      1 -total
 30.90%  106.636      2 Template:Reflist
 20.44%   70.556      3 Template:Citation
 16.37%   56.501      1 Template:Short_description
 13.17%   45.459      1 Template:Infobox_Algorithm
 11.67%   40.293      1 Template:Infobox
 11.41%   39.370      1 Template:Sorting
 10.90%   37.625      1 Template:Navbox
  9.06%   31.259      2 Template:Pagetype
  7.70%   26.589     25 Template:Math
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:99870-0!canonical and timestamp 20221224014419 and revision id 1123033813.
 -->
</div></body>
</html>