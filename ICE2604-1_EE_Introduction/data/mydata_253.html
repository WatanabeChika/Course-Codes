<!DOCTYPE html>
<html>
<head>
<title>cutting_stock_problem</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In operations research, the <b>cutting-stock problem</b> is the problem of cutting standard-sized pieces of stock material, such as paper rolls or sheet metal, into pieces of specified sizes while minimizing material wasted. It is an optimization problem in mathematics that arises from applications in industry. In terms of computational complexity, the problem is an NP-hard problem reducible to the knapsack problem. The problem can be formulated as an integer linear programming problem.
</p>

<h2><span class="mw-headline" id="Illustration_of_one-dimensional_cutting-stock_problem">Illustration of one-dimensional cutting-stock problem</span><span class="mw-editsection"></span></h2>
<p>A paper machine can produce an unlimited number of master (jumbo) rolls, each 5600 mm wide. The following 13 items must be cut, in the table below.
</p><p>The important thing about this kind of problem is that many different product units can be made from the same master roll, and the number of possible combinations is itself very large, in general, and not trivial to enumerate.
</p><p>The problem therefore is to find an optimum set of patterns of making product rolls from the master roll, such that the demand is satisfied and waste is minimized.
</p>
<dl><dd><dl><dd><table class="wikitable">
<tbody><tr>
<th width="80pt">Width
</th>
<th width="80pt">#Items
</th></tr>
<tr>
<td align="center">1380</td>
<td align="center">22
</td></tr>
<tr>
<td align="center">1520</td>
<td align="center">25
</td></tr>
<tr>
<td align="center">1560</td>
<td align="center">12
</td></tr>
<tr>
<td align="center">1710</td>
<td align="center">14
</td></tr>
<tr>
<td align="center">1820</td>
<td align="center">18
</td></tr>
<tr>
<td align="center">1880</td>
<td align="center">18
</td></tr>
<tr>
<td align="center">1930</td>
<td align="center">20
</td></tr>
<tr>
<td align="center">2000</td>
<td align="center">10
</td></tr>
<tr>
<td align="center">2050</td>
<td align="center">12
</td></tr>
<tr>
<td align="center">2100</td>
<td align="center">14
</td></tr>
<tr>
<td align="center">2140</td>
<td align="center">16
</td></tr>
<tr>
<td align="center">2150</td>
<td align="center">18
</td></tr>
<tr>
<td align="center">2200</td>
<td align="center">20
</td></tr></tbody></table></dd></dl></dd></dl>
<h3><span class="mw-headline" id="Bounds_and_checks">Bounds and checks</span><span class="mw-editsection"></span></h3>
<p>A simple lower bound is obtained by dividing the total amount of product by the size of each master roll. The total product required is 1380 x 22 + 1520 x 25 + ... + 2200 x 20 = 407160 mm. Each master roll is 5600  mm, requiring a minimum of 72.7 rolls, which means 73 rolls or more are required.
</p>
<h3><span class="mw-headline" id="Solution">Solution</span><span class="mw-editsection"></span></h3>

<p>There are 308 possible patterns for this small instance. The optimal answer requires 73 master rolls and has 0.401% waste; it can be shown computationally that in this case the minimum number of patterns with this level of waste is 10. It can also be computed that 19 different such solutions exist, each with 10 patterns and a waste of 0.401%, of which one such solution is shown below and in the picture:
</p>
<dl><dd><table class="wikitable">
<tbody><tr>
<th>Repetition
</th>
<th align="center">Contents
</th></tr>
<tr>
<td align="center">2</td>
<td>1820 + 1820 + 1820
</td></tr>
<tr>
<td align="center">3</td>
<td>1380 + 2150 + 1930
</td></tr>
<tr>
<td align="center">12</td>
<td>1380 + 2150 + 2050
</td></tr>
<tr>
<td align="center">7</td>
<td>1380 + 2100 + 2100
</td></tr>
<tr>
<td align="center">12</td>
<td>2200 + 1820 + 1560
</td></tr>
<tr>
<td align="center">8</td>
<td>2200 + 1520 + 1880
</td></tr>
<tr>
<td align="center">1</td>
<td>1520 + 1930 + 2150
</td></tr>
<tr>
<td align="center">16</td>
<td>1520 + 1930 + 2140
</td></tr>
<tr>
<td align="center">10</td>
<td>1710 + 2000 + 1880
</td></tr>
<tr>
<td align="center" style="border-bottom:3px solid grey">2</td>
<td>1710 + 1710 + 2150
</td></tr>
<tr>
<td align="center"><b>73</b>
</td></tr></tbody></table></dd></dl>
<h2><span class="mw-headline" id="Classification">Classification</span><span class="mw-editsection"></span></h2>
<p>Cutting-stock problems can be classified in several ways.<sup class="reference" id="cite_ref-Wäscher2007_1-0">[1]</sup> One way is the dimensionality of the cutting: the above example illustrates a one-dimensional (1D) problem; other industrial applications of 1D occur when cutting pipes, cables, and steel bars. Two-dimensional (2D) problems are encountered in furniture, clothing and glass production. When either the master item or the required parts are irregular-shaped (a situation often encountered in the leather, textile, metals industries) this is referred to as the <i>nesting</i> problem.
</p><p>Not many three-dimensional (3D) applications involving cutting are known; however the closely related 3D packing problem has many industrial applications, such as packing objects into shipping containers (see e.g. containerization: the related sphere packing problem has been studied since the 17th century (Kepler conjecture)).
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Industrial applications of cutting-stock problems for high production volumes arise especially when basic material is produced in large rolls that are further cut into smaller units (see roll slitting). This is done e.g. in paper and plastic film industries but also in production of flat metals like steel or brass. There are many variants and additional constraints arising from special production constraints due to machinery and process limits, customer requirements and quality issues; some examples are:
</p>
<ul><li>Two-stage, where the rolls produced in the first stage are then processed a second time. For instance, all office stationery (e.g. A4 size in Europe, Letter size in US) is produced in such a process. The complication arises because the machinery in the second stage is narrower than the primary.  Efficient utilisation of both stages of production is important (from an energy or material use perspective) and what is efficient for the primary stage may be inefficient for the secondary, leading to trade-offs. Metallised film (used in packaging of snacks), and plastic extrusion on paper (used in liquid packaging, e.g. juice cartons) are further examples of such a process.</li>
<li>Winder constraints where the slitting process has physical or logical constraints: a very common constraint is that only a certain number of slitting knives are available, so that feasible patterns should not contain more than a maximum number of rolls. Because winder machinery is not standardised, very many other constraints are encountered.</li>
<li>An example of a customer requirement is when a particular order cannot be satisfied from either of the two edge positions: this is because the edges of the sheet tend to have greater variations in thickness and some applications can be very sensitive to these.</li>
<li>An example of a quality issue is when the master roll contains defects that have to be cut around. Expensive materials with demanding quality characteristics such as photographic paper or Tyvek have to be carefully optimised so that the wasted area is minimised.</li>
<li>Multi-machine problems arise when orders can be produced on more than one machine and these machines have different widths. Generally availability of more than one master roll width improves the waste considerably; in practice however additional order splitting constraints may have to be taken into account.</li>
<li>There is also a semi-continuous problem, where the produced rolls do not have to be of the same diameter, but can vary within a range. This typically occurs with sheet orders. This is sometimes known as a <i>1½ dimensional</i> problem. This variant also occurs in the production of corrugated fiberboard, where it is called, somewhat confusingly, the <i>corrugator scheduling problem</i>.</li>
<li>Because some paper machines are relatively narrow compared to the demanded items, some companies have invested in a <i>skiving</i> (also known as a <i>web-welding</i>) secondary process, whereby two reels (produced by slitting the initial jumbo reels) are joined side-by-side (with a little overlap) to make up a wider roll. Producing narrower reels in the primary process leads to lower overall waste.<sup class="reference" id="cite_ref-Johnson1997_2-0">[2]</sup></li>
<li>In the metals industry one key difference is that typically the master rolls are produced earlier and are generally different from each other (both in terms of width and length). Therefore, there are similarities with the multi-machine problem mentioned above. The presence of length variations creates a 2-D problem, because waste can occur both width-wise and length-wise.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (February 2016)">citation needed</span></i>]</sup></li>
<li>The guillotine problem is another 2-D problem of cutting sheets into rectangles of specified sizes, however only cuts that continue all the way across each sheet are allowed. Industrial applications of this problem can be found in the glass industry.</li></ul>


<ul><li>The cutting stock problem of determining, for the one-dimensional case, the best master size that will meet given demand is known as the <i>assortment</i> problem.<sup class="reference" id="cite_ref-3">[3]</sup></li></ul>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>The cutting stock problem was first formulated by Kantorovich in 1939.<sup class="reference" id="cite_ref-4">[4]</sup> In 1951 before computers became widely available, L. V. Kantorovich and V. A. Zalgaller suggested<sup class="reference" id="cite_ref-5">[5]</sup> solving the problem of the economical use of material at the cutting stage with the help of linear programming. The proposed technique was later called the <i>column generation method</i>.
</p>
<h2><span class="mw-headline" id="Mathematical_formulation_and_solution_approaches">Mathematical formulation and solution approaches</span><span class="mw-editsection"></span></h2>
<p>The standard formulation for the cutting-stock problem (but not the only one) starts with a list of <i>m</i> orders, each requiring <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle q_{j}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle q_{j}}</annotation>
</semantics>
</math></span><img alt="q_{j}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e0d567ac2d170501680d2efa4c1d71d6a8569ef1" style="vertical-align: -1.005ex; width:1.947ex; height:2.343ex;"/></span> pieces, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle j=1,\ldots ,m}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>j</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mi>m</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle j=1,\ldots ,m}</annotation>
</semantics>
</math></span><img alt="{\displaystyle j=1,\ldots ,m}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/745ead100813850e9d68e2a6cb6be14124998279" style="vertical-align: -0.671ex; margin-left: -0.027ex; width:12.464ex; height:2.509ex;"/></span>. We then construct a list of all possible combinations of cuts (often called "patterns" or "configurations"). Let <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>C</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C}</annotation>
</semantics>
</math></span><img alt="C" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" style="vertical-align: -0.338ex; width:1.766ex; height:2.176ex;"/></span> be the number of those patterns. We associate with each pattern a positive integer variable <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}}</annotation>
</semantics>
</math></span><img alt="x_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e87000dd6142b81d041896a30fe58f0c3acb2158" style="vertical-align: -0.671ex; width:2.129ex; height:2.009ex;"/></span>, representing how many times pattern <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span> is to be used, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i=1,\ldots ,C}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mi>C</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i=1,\ldots ,C}</annotation>
</semantics>
</math></span><img alt="{\displaystyle i=1,\ldots ,C}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/079123b105ccb8cb22437ca56c88d11295d745db" style="vertical-align: -0.671ex; width:12.008ex; height:2.509ex;"/></span>.  The linear integer program is then:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \min \sum _{i=1}^{C}c_{i}x_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo form="prefix" movablelimits="true">min</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>C</mi>
</mrow>
</munderover>
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \min \sum _{i=1}^{C}c_{i}x_{i}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \min \sum _{i=1}^{C}c_{i}x_{i}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/65a10643875f7d42aa18dc8f40f02a14807362f9" style="vertical-align: -3.005ex; width:11.94ex; height:7.343ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\text{s.t.}}\sum _{i=1}^{C}a_{ij}x_{i}\geq q_{j},\quad \quad \forall j=1,\dots ,m}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mtext>s.t.</mtext>
</mrow>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>C</mi>
</mrow>
</munderover>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>≥<!-- ≥ --></mo>
<msub>
<mi>q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>,</mo>
<mspace width="1em"></mspace>
<mspace width="1em"></mspace>
<mi mathvariant="normal">∀<!-- ∀ --></mi>
<mi>j</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mi>m</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\text{s.t.}}\sum _{i=1}^{C}a_{ij}x_{i}\geq q_{j},\quad \quad \forall j=1,\dots ,m}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\text{s.t.}}\sum _{i=1}^{C}a_{ij}x_{i}\geq q_{j},\quad \quad \forall j=1,\dots ,m}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/986e1052668515efaeef351177ce80849fa27d29" style="vertical-align: -3.005ex; width:36.535ex; height:7.343ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}\geq 0}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>≥<!-- ≥ --></mo>
<mn>0</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}\geq 0}</annotation>
</semantics>
</math></span><img alt="x_{i}\geq 0" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/90a99710f61d5dea19e49ae5b31164d2b56b07e3" style="vertical-align: -0.671ex; width:6.39ex; height:2.509ex;"/></span>, integer</dd></dl>
<p>where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle a_{ij}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle a_{ij}}</annotation>
</semantics>
</math></span><img alt="a_{ij}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ebea6cd2813c330c798921a2894b358f7b643917" style="vertical-align: -1.005ex; width:2.707ex; height:2.343ex;"/></span> is the number of times order <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle j}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>j</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle j}</annotation>
</semantics>
</math></span><img alt="j" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0" style="vertical-align: -0.671ex; margin-left: -0.027ex; width:0.985ex; height:2.509ex;"/></span> appears in pattern <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c_{i}}</annotation>
</semantics>
</math></span><img alt="c_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/01acb7953ba52c2aa44264b5d0f8fd223aa178a2" style="vertical-align: -0.671ex; width:1.807ex; height:2.009ex;"/></span> is the cost (often the waste) of pattern <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle i}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>i</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle i}</annotation>
</semantics>
</math></span><img alt="i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" style="vertical-align: -0.338ex; width:0.802ex; height:2.176ex;"/></span>. The precise nature of the quantity constraints can lead to subtly different mathematical characteristics. The above formulation's quantity constraints are <b>minimum</b> constraints (at least the given amount of each order must be produced, but possibly more). 
</p><p>When <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle c_{i}=1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>=</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle c_{i}=1}</annotation>
</semantics>
</math></span><img alt="c_{i}=1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72a49c420af01ae19ff3c93374f416a53e376d24" style="vertical-align: -0.671ex; width:6.067ex; height:2.509ex;"/></span>, the objective minimises the number of utilised master items and, if the constraint for the quantity to be produced is replaced by equality, it is called the <b>bin packing problem</b>. 
</p><p>The most general formulation has two-sided constraints (and in this case a minimum-waste solution may consume more than the minimum number of master items):
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle q_{j}\leq \sum _{i=1}^{n}a_{ij}x_{i}\leq Q_{j},\quad \quad \forall j=1,\dots ,m}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>≤<!-- ≤ --></mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>≤<!-- ≤ --></mo>
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>,</mo>
<mspace width="1em"></mspace>
<mspace width="1em"></mspace>
<mi mathvariant="normal">∀<!-- ∀ --></mi>
<mi>j</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mi>m</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle q_{j}\leq \sum _{i=1}^{n}a_{ij}x_{i}\leq Q_{j},\quad \quad \forall j=1,\dots ,m}</annotation>
</semantics>
</math></span><img alt="q_{j}\leq \sum _{i=1}^{n}a_{ij}x_{i}\leq Q_{j},\quad \quad \forall j=1,\dots ,m" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ba5c6c0c598747dd666d333b9e64a5f6c28d2c1" style="vertical-align: -3.005ex; width:38.879ex; height:6.843ex;"/></span></dd></dl>
<p>This formulation applies not just to one-dimensional problems. Many variations are possible, including one where the objective is not to minimise the waste, but to maximise the total value of the produced items, allowing each order to have a different value.
</p><p>In general, the number of possible patterns grows exponentially as a function of <i>m</i>, the number of orders. As the number of orders increases, it may therefore become impractical to enumerate the possible cutting patterns.
</p><p>An alternative approach uses delayed column-generation. This method solves the cutting-stock problem by starting with just a few patterns. It generates additional patterns when they are needed. For the one-dimensional case, the new patterns are introduced by solving an auxiliary optimization problem called the knapsack problem, using dual variable information from the linear program. The knapsack problem has well-known methods to solve it, such as branch and bound and dynamic programming. The Delayed Column Generation method can be much more efficient than the original approach, particularly as the size of the problem grows. The column generation approach as applied to the cutting stock problem was pioneered by Gilmore and Gomory in a series of papers published in the 1960s.<sup class="reference" id="cite_ref-Gilmore61_6-0">[6]</sup><sup class="reference" id="cite_ref-Gilmore63_7-0">[7]</sup> Gilmore and Gomory showed that this approach is guaranteed to converge to the (fractional) optimal solution, without needing to enumerate all the possible patterns in advance.
</p><p>A limitation of the original Gilmore and Gomory method is that it does not handle integrality, so the solution may contain fractions, e.g. a particular pattern should be produced 3.67 times. Rounding to the nearest integer often does not work, in the sense that it may lead to a sub-optimal solution and/or under- or over-production of some of the orders (and possible infeasibility in the presence of two-sided demand constraints). This limitation is overcome in modern algorithms, which can solve to optimality (in the sense of finding solutions with minimum waste) very large instances of the problem (generally larger than encountered in practice<sup class="reference" id="cite_ref-Goulimis1990_8-0">[8]</sup><sup class="reference" id="cite_ref-Carvalho1998_9-0">[9]</sup>).
</p><p>The cutting-stock problem is often highly degenerate, in that multiple solutions with the same amount of waste are possible. This degeneracy arises because it is possible to move items around, creating new patterns, without affecting the amount of waste. This gives rise to a whole collection of related problems which are concerned with some other criterion, such as the following:
</p>
<ul><li>The minimum pattern count problem: to find a minimum-pattern-count solution amongst the minimum-waste solutions. This is a very hard problem, even when the waste is known.<sup class="reference" id="cite_ref-Umetani2003_10-0">[10]</sup><sup class="reference" id="cite_ref-Diegel1996_11-0">[11]</sup><sup class="reference" id="cite_ref-McDiarmid1999_12-0">[12]</sup> There is a conjecture that any equality-constrained one-dimensional instance with <i>n</i> sizes has at least one minimum waste solution with no more than <i>n</i> + 1 patterns. This conjecture was first refuted in April 2020 with an example with 9 sizes that requires 11 patterns.<sup class="reference" id="cite_ref-Goulimis2020_13-0">[13]</sup></li>
<li>The minimum stack problem: this is concerned with the sequencing of the patterns so as not to have too many partially completed orders at any time. This was an open problem until 2007, when an efficient algorithm based on dynamic programming was published.<sup class="reference" id="cite_ref-Banda2007_14-0">[14]</sup></li>
<li>The minimum number of knife changes problem (for the one-dimensional problem): this is concerned with sequencing and permuting the patterns so as to minimise the number of times the slitting knives have to be moved. This is a special case of the generalised travelling salesman problem.</li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>High-multiplicity bin packing</li>
<li>Configuration linear program</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFChvátal,_V.1983">Chvátal, V. (1983). <span class="cs1-lock-registration" title="Free registration required"><i>Linear Programming</i></span>. W.H. Freeman. ISBN <bdi>978-0-7167-1587-0</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Linear+Programming&amp;rft.pub=W.H.+Freeman&amp;rft.date=1983&amp;rft.isbn=978-0-7167-1587-0&amp;rft.au=Chv%C3%A1tal%2C+V.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Flinearprogrammin00chv&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACutting+stock+problem"></span></li>
<li>Hatem Ben Amor, J.M. Valério de Carvalho, <i>Cutting Stock Problems</i> in Column Generation, edited by Guy Desaulniers, Jacques Desrosiers, and Marius M. Solomon, Springer, 2005, XVI, <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-387-25485-4</li>
<li>M. Delorme, M. Iori, S. Martello, <i>Bin packing and cutting stock problems: Mathematical models and exact algorithms</i>, European Journal of Operational Research 2016, 255, 1–20, <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>doi:10.1016/j.ejor.2016.04.030</li></ul>
<!-- 
NewPP limit report
Parsed by mw1472
Cached time: 20221217172012
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.197 seconds
Real time usage: 0.317 seconds
Preprocessor visited node count: 904/1000000
Post‐expand include size: 17797/2097152 bytes
Template argument size: 891/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 20713/5000000 bytes
Lua time usage: 0.096/10.000 seconds
Lua memory usage: 3969527/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  224.940      1 -total
 38.70%   87.056      1 Template:Reflist
 33.76%   75.938      1 Template:More_citations_needed
 30.54%   68.701      1 Template:Cite_journal
 28.39%   63.853      1 Template:Ambox
 10.29%   23.150      1 Template:Citation_needed
  9.29%   20.888      1 Template:ISBN
  7.56%   17.003      1 Template:Fix
  6.94%   15.604      1 Template:Find_sources_mainspace
  5.90%   13.265      2 Template:Catalog_lookup_link
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:826868-0!canonical and timestamp 20221217172011 and revision id 1083819910.
 -->
</div></body>
</html>