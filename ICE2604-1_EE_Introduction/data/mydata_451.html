<!DOCTYPE html>
<html>
<head>
<title>Merkle_tree</title>
</head>
<body>
<div class="mw-parser-output"><img alt="Listen to this article" data-file-height="96" data-file-width="128" decoding="async" height="15" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/47/Sound-icon.svg/20px-Sound-icon.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/47/Sound-icon.svg/30px-Sound-icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/47/Sound-icon.svg/40px-Sound-icon.svg.png 2x" width="20"/></div><div class="mw-parser-output">

<p>In cryptography and computer science, a <b>hash tree</b> or <b>Merkle tree</b> is a tree in which every "leaf" (node) is labelled with the cryptographic hash of a data block, and every node that is not a leaf (called a <i>branch</i>, <i>inner node</i>, or <i>inode</i>) is labelled with the cryptographic hash of the labels of its child nodes. A hash tree allows efficient and secure verification of the contents of a large data structure. A hash tree is a generalization of a hash list and a hash chain.
</p><p>Demonstrating that a leaf node is a part of a given binary hash tree requires computing a number of hashes proportional to the logarithm of the number of leaf nodes in the tree.<sup class="reference" id="cite_ref-1">[1]</sup> Conversely, in a hash list, the number is proportional to the number of leaf nodes itself. A Merkle tree is therefore an efficient example of a cryptographic commitment scheme, in which the root of the tree is seen as a commitment and leaf nodes may be revealed and proven to be part of the original commitment<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="It is not clear that the scheme mentioned in this page is hiding (though, it is known to be computationally binding) (January 2022)">citation needed</span></i>]</sup>.
</p><p>The concept of a hash tree is named after Ralph Merkle, who patented it in 1979.<sup class="reference" id="cite_ref-2">[2]</sup><sup class="reference" id="cite_ref-3">[3]</sup>
</p>

<h2><span class="mw-headline" id="Uses">Uses</span><span class="mw-editsection"></span></h2>
<p>Hash trees can be used to verify any kind of data stored, handled and transferred in and between computers. They can help ensure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and even to check that the other peers do not lie and send fake blocks.
</p><p>Hash trees are used in hash-based cryptography.  Hash trees are also used in the InterPlanetary File System (IPFS), Btrfs and ZFS file systems<sup class="reference" id="cite_ref-4">[4]</sup> (to counter data degradation<sup class="reference" id="cite_ref-5">[5]</sup>); Dat protocol; Apache Wave protocol;<sup class="reference" id="cite_ref-6">[6]</sup> Git and Mercurial distributed revision control systems; the Tahoe-LAFS backup system; Zeronet; the Bitcoin and Ethereum peer-to-peer networks;<sup class="reference" id="cite_ref-7">[7]</sup> the Certificate Transparency framework; the Nix package manager and descendants like GNU Guix;<sup class="reference" id="cite_ref-8">[8]</sup> and a number of NoSQL systems such as Apache Cassandra, Riak, and Dynamo.<sup class="reference" id="cite_ref-9">[9]</sup>
Suggestions have been made to use hash trees in trusted computing systems.<sup class="reference" id="cite_ref-10">[10]</sup>
</p><p>The initial Bitcoin implementation of Merkle trees by Satoshi Nakamoto applies the compression step of the hash function to an excessive degree, which is mitigated by using Fast Merkle Trees.<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"></span></h2>
<p>A hash tree is a tree of hashes in which the leaves (i.e., leaf nodes, sometimes also called "leafs") are hashes of data blocks in, for instance, a file or set of files. Nodes farther up in the tree are the hashes of their respective children. For example, in the above picture <i>hash 0</i> is the result of hashing the concatenation of <i>hash 0-0</i> and <i>hash 0-1</i>. That is, <i>hash 0</i> = <i>hash</i>( <i>hash 0-0</i> + <i>hash 0-1</i> ) where "+" denotes concatenation.
</p><p>Most hash tree implementations are binary (two child nodes under each node) but they can just as well use many more child nodes under each node.
</p><p>Usually, a cryptographic hash function such as SHA-2 is used for the hashing. If the hash tree only needs to protect against unintentional damage, unsecured checksums such as CRCs can be used.
</p><p>In the top of a hash tree there is a <i>top hash</i> (or <i>root hash</i> or <i>master hash</i>). Before downloading a file on a P2P network, in most cases the top hash is acquired from a trusted source, for instance a friend or a web site that is known to have good recommendations of files to download. When the top hash is available, the hash tree can be received from any non-trusted source, like any peer in the P2P network. Then, the received hash tree is checked against the trusted top hash, and if the hash tree is damaged or fake, another hash tree from another source will be tried until the program finds one that matches the top hash.<sup class="reference" id="cite_ref-:0_12-0">[12]</sup>
</p><p>The main difference from a hash list is that one branch of the hash tree can be downloaded at a time and the integrity of each branch can be checked immediately, even though the whole tree is not available yet. For example, in the picture, the integrity of <i>data block L2</i> can be verified immediately if the tree already contains <i>hash 0-0</i> and <i>hash 1</i> by hashing the data block and iteratively combining the result with <i>hash 0-0</i> and then <i>hash 1</i> and finally comparing the result with the <i>top hash</i>. Similarly, the integrity of <i>data block L3</i> can be verified if the tree already has <i>hash 1-1</i> and <i>hash 0</i>.  This can be an advantage since it is efficient to split files up in very small data blocks so that only small blocks have to be re-downloaded if they get damaged. If the hashed file is big, such a hash list or hash chain becomes fairly big. But if it is a tree, one small branch can be downloaded quickly, the integrity of the branch can be checked, and then the downloading of data blocks can start.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (October 2016)">citation needed</span></i>]</sup>
</p>
<h3><span class="mw-headline" id="Second_preimage_attack">Second preimage attack</span><span class="mw-editsection"></span></h3>
<p>The Merkle hash root does not indicate the tree depth, enabling a second-preimage attack in which an attacker creates a document other than the original that has the same Merkle hash root.  For the example above, an attacker can create a new document containing two data blocks, where the first is <i>hash 0-0</i> + <i>hash 0-1</i>, and the second is <i>hash 1-0</i> + <i>hash 1-1</i>.<sup class="reference" id="cite_ref-13">[13]</sup><sup class="reference" id="cite_ref-14">[14]</sup>
</p><p>One simple fix is defined in Certificate Transparency: when computing leaf node hashes, a 0x00 byte is prepended to the hash data, while 0x01 is prepended when computing internal node hashes.<sup class="reference" id="cite_ref-:0_12-1">[12]</sup>  Limiting the hash tree size is a prerequisite of some formal security proofs, and helps in making some proofs tighter. Some implementations limit the tree depth using hash tree depth prefixes before hashes, so any extracted hash chain is defined to be valid only if the prefix decreases at each step and is still positive when the leaf is reached.
</p>
<h3><span class="mw-headline" id="Tiger_tree_hash">Tiger tree hash</span><span class="mw-editsection"></span></h3>
<p>The Tiger tree hash is a widely used form of hash tree. It uses a binary hash tree (two child nodes under each node), usually has a data block size of 1024 bytes and uses the Tiger hash.<sup class="reference" id="cite_ref-15">[15]</sup>
</p><p>Tiger tree hashes are used in Gnutella,<sup class="reference" id="cite_ref-16">[16]</sup> Gnutella2, and Direct Connect P2P file sharing protocols<sup class="reference" id="cite_ref-17">[17]</sup> and in file sharing applications such as Phex,<sup class="reference" id="cite_ref-18">[18]</sup> BearShare, LimeWire, Shareaza, DC++<sup class="reference" id="cite_ref-19">[19]</sup> and gtk-gnutella.<sup class="reference" id="cite_ref-20">[20]</sup>
</p>
<h4><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h4>
<p>Base32: <code>R5T6Y8UYRYO5SUXGER5NMUOEZ5O6E4BHPP2MRFQ</code>
</p><p>URN: <code>urn:tree:tiger:R5T6Y8UYRYO5SUXGER5NMUOEZ5O6E4BHPP2MRFQ</code>
</p><p>magnet: <code>magnet:?xt=urn:tree:tiger:R5T6Y8UYRYO5SUXGER5NMUOEZ5O6E4BHPP2MRFQ</code>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1128808480">.mw-parser-output .portalbox{padding:0;display:table;box-sizing:border-box;max-width:175px}.mw-parser-output .portalborder{border:solid #aaa 1px;padding:0.1em;background:#f9f9f9}.mw-parser-output .portalbox-entry{display:table-row;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox-image{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox-link{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}@media(min-width:720px){.mw-parser-output .portalleft{clear:left;float:left;margin:0.5em 1em 0.5em 0}.mw-parser-output .portalright{clear:right;float:right;margin:0.5em 0 0.5em 1em}}</style>
<ul><li>Binary tree</li>
<li>Blockchain</li>
<li>Distributed hash table</li>
<li>Hash table</li>
<li>Hash trie</li>
<li>Linked timestamping</li>
<li>Radix tree</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><span>Merkle tree patent 4,309,569</span> –  explains both the hash tree structure and the use of it to handle many one-time signatures</li>
<li>Tree Hash EXchange format (THEX) –  a detailed description of Tiger trees</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1040133893">.mw-parser-output .spoken-wikipedia{border:1px solid #a2a9b1;background-color:#f8f9fa;margin:0.5em 0;padding:0.2em;line-height:1.5em;font-size:90%}.mw-parser-output .spoken-wikipedia-header{text-align:center}.mw-parser-output .spoken-wikipedia-listen-to{font-weight:bold}.mw-parser-output .spoken-wikipedia-files{text-align:center;margin-top:10px;margin-bottom:0.4em}.mw-parser-output .spoken-wikipedia-icon{float:left;margin-left:5px;margin-top:10px}.mw-parser-output .spoken-wikipedia-disclaimer{margin-left:60px;margin-top:10px;font-size:95%;line-height:1.4em}.mw-parser-output .spoken-wikipedia-footer{margin-top:10px;text-align:center}@media(min-width:720px){.mw-parser-output .spoken-wikipedia{width:20em;float:right;clear:right;margin-left:1em}}</style>
<ul><li>A C implementation of a dynamically re-sizeable binary SHA-256 hash tree (Merkle tree)</li>
<li>Merkle tree implementation in Java</li>
<li>Tiger Tree Hash (TTH) source code in C#, by Gil Schmidt</li>
<li>Tiger Tree Hash (TTH) implementations in C and Java</li>
<li>RHash, an open source command-line tool, which can calculate TTH and magnet links with TTH</li></ul>


<!-- 
NewPP limit report
Parsed by mw2378
Cached time: 20221222030725
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.338 seconds
Real time usage: 0.456 seconds
Preprocessor visited node count: 2271/1000000
Post‐expand include size: 70531/2097152 bytes
Template argument size: 3073/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 4/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 63630/5000000 bytes
Lua time usage: 0.197/10.000 seconds
Lua memory usage: 7171679/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  384.568      1 -total
 46.20%  177.656      1 Template:Reflist
 24.51%   94.274     11 Template:Cite_web
 17.27%   66.399      3 Template:Navbox
 13.52%   51.997      1 Template:Short_description
 12.43%   47.818      1 Template:Cryptography_navbox
  9.83%   37.800      2 Template:Citation_needed
  8.69%   33.411      1 Template:Spoken_Wikipedia
  8.18%   31.464      2 Template:Fix
  6.96%   26.748      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2497388-0!canonical and timestamp 20221222030725 and revision id 1123544588.
 -->
</div></body>
</html>