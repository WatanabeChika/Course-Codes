<!DOCTYPE html>
<html>
<head>
<title>cutting_plane</title>
</head>
<body>
<div class="mw-parser-output">

<p>In mathematical optimization, the <b>cutting-plane method</b> is any of a variety of optimization methods that iteratively refine a feasible set or objective function by means of linear inequalities, termed <i>cuts</i>.  Such procedures are commonly used to find integer solutions to mixed integer linear programming (MILP) problems, as well as to solve general, not necessarily differentiable convex optimization problems.  The use of cutting planes to solve MILP was introduced by Ralph E. Gomory.
</p><p>Cutting plane methods for MILP work by solving a non-integer linear program, the linear relaxation of the given integer program. The theory of Linear Programming dictates that under mild assumptions (if the linear program has an optimal solution, and if the feasible region does not contain a line), one can always find an extreme point or a corner point that is optimal. The obtained optimum is tested for being an integer solution. If it is not, there is guaranteed to exist a linear inequality that <i>separates</i> the optimum from the convex hull of the true feasible set. Finding such an inequality is the <i>separation problem</i>, and such an inequality is a <i>cut</i>.  A cut can be added to the relaxed linear program. Then, the current non-integer solution is no longer feasible to the relaxation. This process is repeated until an optimal integer solution is found.
</p><p>Cutting-plane methods for general convex continuous optimization and variants are known under various names: Kelley's method, Kelley–Cheney–Goldstein method, and bundle methods.  They are popularly used for non-differentiable convex minimization, where a convex objective function and its subgradient can be evaluated efficiently but usual gradient methods for differentiable optimization can not be used.  This situation is most typical for the concave maximization of Lagrangian dual functions.  Another common situation is the application of the Dantzig–Wolfe decomposition to a structured optimization problem in which formulations with an exponential number of variables are obtained.  Generating these variables on demand by means of delayed column generation is identical to performing a cutting plane on the respective dual problem.
</p>

<h2><span id="Gomory.27s_cut"></span><span class="mw-headline" id="Gomory's_cut">Gomory's cut</span><span class="mw-editsection"></span></h2>
<p>Cutting planes were proposed by Ralph Gomory in the 1950s as a method for solving integer programming and mixed-integer programming problems. However, most experts, including Gomory himself, considered them to be impractical due to numerical instability, as well as ineffective because many rounds of cuts were needed to make progress towards the solution.  Things turned around when in the mid-1990s Gérard Cornuéjols and co-workers showed them to be very effective in combination with branch-and-bound (called branch-and-cut) and ways to overcome numerical instabilities.  Nowadays, all commercial MILP solvers use Gomory cuts in one way or another. Gomory cuts are very efficiently generated from a simplex tableau, whereas many other types of cuts are either expensive or even NP-hard to separate.  Among other general cuts for MILP, most notably lift-and-project dominates Gomory cuts.<sup class="reference" id="cite_ref-1">[1]</sup><sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>Let an integer programming problem be formulated (in canonical form) as:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\begin{aligned}{\text{Maximize  }}&amp;c^{T}x\\{\text{Subject to  }}&amp;Ax\leq b,\\&amp;x\geq 0,\,x_{i}{\text{ all integers}}.\end{aligned}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true" rowspacing="3pt">
<mtr>
<mtd>
<mrow class="MJX-TeXAtom-ORD">
<mtext>Maximize </mtext>
</mrow>
</mtd>
<mtd>
<msup>
<mi>c</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>T</mi>
</mrow>
</msup>
<mi>x</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mrow class="MJX-TeXAtom-ORD">
<mtext>Subject to </mtext>
</mrow>
</mtd>
<mtd>
<mi>A</mi>
<mi>x</mi>
<mo>≤<!-- ≤ --></mo>
<mi>b</mi>
<mo>,</mo>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd>
<mi>x</mi>
<mo>≥<!-- ≥ --></mo>
<mn>0</mn>
<mo>,</mo>
<mspace width="thinmathspace"></mspace>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mrow class="MJX-TeXAtom-ORD">
<mtext> all integers</mtext>
</mrow>
<mo>.</mo>
</mtd>
</mtr>
</mtable>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\begin{aligned}{\text{Maximize  }}&amp;c^{T}x\\{\text{Subject to  }}&amp;Ax\leq b,\\&amp;x\geq 0,\,x_{i}{\text{ all integers}}.\end{aligned}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\begin{aligned}{\text{Maximize  }}&amp;c^{T}x\\{\text{Subject to  }}&amp;Ax\leq b,\\&amp;x\geq 0,\,x_{i}{\text{ all integers}}.\end{aligned}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c242be5d3adcf16dee3883063b5da9ba9d341f27" style="vertical-align: -3.722ex; margin-bottom: -0.282ex; width:32.843ex; height:9.176ex;"/></span></dd></dl>
<p>The method proceeds by first dropping the requirement that the x<sub>i</sub> be integers and solving the associated linear programming problem to obtain a basic feasible solution. Geometrically, this solution will be a vertex of the convex polytope consisting of all feasible points. If this vertex is not an integer point then the method finds a hyperplane with the vertex on one side and all feasible integer points on the other. This is then added as an additional linear constraint to exclude the vertex found, creating a modified linear program. The new program is then solved and the process is repeated until an integer solution is found.
</p><p>Using the simplex method to solve a linear program produces a set of equations of the form
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}+\sum {\bar {a}}_{i,j}x_{j}={\bar {b}}_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>+</mo>
<mo>∑<!-- ∑ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}+\sum {\bar {a}}_{i,j}x_{j}={\bar {b}}_{i}}</annotation>
</semantics>
</math></span><img alt="x_i+\sum \bar a_{i,j}x_j=\bar b_i" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffe4e1f572904929b35c19ffd39e1fd9e4f3bbf4" style="vertical-align: -1.338ex; width:19.176ex; height:3.843ex;"/></span></dd></dl>
<p>where <i>x<sub>i</sub></i> is a basic<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="First: this is rather technical detail of the simplex algorithm, which cannot be presumed known to readers of this article. Second: this appears to presume an equality Ax=b formulation of the linear program rather than the inequality Ax≤b form used above, and that transformation will introduce extra variables. Do we know those have to be integer-valued? Third: do we even need to distinguish basic and nonbasic variables?? (May 2022)">clarification needed</span></i>]</sup> variable and the <i>x<sub>j</sub>'</i>s are the nonbasic variables. Rewrite this equation so that the integer parts are on the left side and the fractional parts are on the right side:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}+\sum \lfloor {\bar {a}}_{i,j}\rfloor x_{j}-\lfloor {\bar {b}}_{i}\rfloor ={\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>+</mo>
<mo>∑<!-- ∑ --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>=</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>−<!-- − --></mo>
<mo>∑<!-- ∑ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo stretchy="false">)</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}+\sum \lfloor {\bar {a}}_{i,j}\rfloor x_{j}-\lfloor {\bar {b}}_{i}\rfloor ={\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}.}</annotation>
</semantics>
</math></span><img alt="x_i+\sum \lfloor \bar a_{i,j} \rfloor x_j - \lfloor \bar b_i \rfloor  = \bar b_i - \lfloor \bar b_i \rfloor - \sum ( \bar a_{i,j} -\lfloor \bar a_{i,j} \rfloor) x_j." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/675910c919eca629091105f2c3cd6c253a30eb7a" style="vertical-align: -1.338ex; width:56.713ex; height:3.843ex;"/></span></dd></dl>
<p>For any integer point in the feasible region, the right side of this equation is less than 1 and the left side is an integer, therefore the common value must be less than or equal to 0. So the inequality
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}\leq 0}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>−<!-- − --></mo>
<mo>∑<!-- ∑ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo stretchy="false">)</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>≤<!-- ≤ --></mo>
<mn>0</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}\leq 0}</annotation>
</semantics>
</math></span><img alt="\bar b_i - \lfloor \bar b_i \rfloor - \sum ( \bar a_{i,j} -\lfloor \bar a_{i,j} \rfloor) x_j \le 0" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ee9a37ba2751bdbe2a6133e5675504031da2115a" style="vertical-align: -1.338ex; width:34.568ex; height:3.843ex;"/></span></dd></dl>
<p>must hold for any integer point in the feasible region. Furthermore, nonbasic variables are equal to 0s in any basic solution and if <i>x<sub>i</sub></i> is not an integer for the basic solution <i>x</i>,
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}={\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor &gt;0.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>−<!-- − --></mo>
<mo>∑<!-- ∑ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo stretchy="false">)</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>−<!-- − --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>&gt;</mo>
<mn>0.</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor -\sum ({\bar {a}}_{i,j}-\lfloor {\bar {a}}_{i,j}\rfloor )x_{j}={\bar {b}}_{i}-\lfloor {\bar {b}}_{i}\rfloor &gt;0.}</annotation>
</semantics>
</math></span><img alt="\bar b_i - \lfloor \bar b_i \rfloor - \sum ( \bar a_{i,j} -\lfloor \bar a_{i,j} \rfloor) x_j = \bar b_i - \lfloor \bar b_i \rfloor &gt; 0." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8957efe5f6f2d2e4ae526619bf9996b4a79bdc90" style="vertical-align: -1.338ex; width:47.143ex; height:3.843ex;"/></span></dd></dl>
<p>So the inequality above excludes the basic feasible solution and thus is a cut with the desired properties. Introducing a new slack variable x<sub>k</sub> for this inequality, a new constraint is added to the linear program, namely
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{k}+\sum (\lfloor {\bar {a}}_{i,j}\rfloor -{\bar {a}}_{i,j})x_{j}=\lfloor {\bar {b}}_{i}\rfloor -{\bar {b}}_{i},\,x_{k}\geq 0,\,x_{k}{\mbox{ an integer}}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msub>
<mo>+</mo>
<mo>∑<!-- ∑ --></mo>
<mo stretchy="false">(</mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>a</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</msub>
<mo>=</mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>−<!-- − --></mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>b</mi>
<mo stretchy="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mo>,</mo>
<mspace width="thinmathspace"></mspace>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msub>
<mo>≥<!-- ≥ --></mo>
<mn>0</mn>
<mo>,</mo>
<mspace width="thinmathspace"></mspace>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msub>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mtext> an integer</mtext>
</mstyle>
</mrow>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{k}+\sum (\lfloor {\bar {a}}_{i,j}\rfloor -{\bar {a}}_{i,j})x_{j}=\lfloor {\bar {b}}_{i}\rfloor -{\bar {b}}_{i},\,x_{k}\geq 0,\,x_{k}{\mbox{ an integer}}.}</annotation>
</semantics>
</math></span><img alt="x_k + \sum (\lfloor \bar a_{i,j} \rfloor - \bar a_{i,j}) x_j = \lfloor \bar b_i \rfloor - \bar b_i,\, x_k \ge 0,\, x_k \mbox{ an integer}." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/66496df299d4e9afc2c12820a5b07a83267280a6" style="vertical-align: -1.338ex; width:59.01ex; height:3.843ex;"/></span></dd></dl>
<h2><span class="mw-headline" id="Convex_optimization">Convex optimization</span><span class="mw-editsection"></span></h2>
<p>Cutting plane methods are also applicable in nonlinear programming. The underlying principle is to approximate the feasible region of a nonlinear (convex) program by a finite set of closed half spaces and to solve a sequence of approximating linear programs.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Benders' decomposition</li>
<li>Branch and cut</li>
<li>Branch and bound</li>
<li>Column generation</li>
<li>Dantzig–Wolfe decomposition</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1" id="CITEREFMarchandMartinWeismantelWolsey2002">Marchand, Hugues; Martin, Alexander; Weismantel, Robert; Wolsey, Laurence (2002). "Cutting planes in integer and mixed integer programming". <i>Discrete Applied Mathematics</i>. <b>123</b> (1–3): 387–446. doi:<span class="cs1-lock-free" title="Freely accessible">10.1016/s0166-218x(01)00348-1</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Discrete+Applied+Mathematics&amp;rft.atitle=Cutting+planes+in+integer+and+mixed+integer+programming&amp;rft.volume=123&amp;rft.issue=1%E2%80%933&amp;rft.pages=387-446&amp;rft.date=2002&amp;rft_id=info%3Adoi%2F10.1016%2Fs0166-218x%2801%2900348-1&amp;rft.aulast=Marchand&amp;rft.aufirst=Hugues&amp;rft.au=Martin%2C+Alexander&amp;rft.au=Weismantel%2C+Robert&amp;rft.au=Wolsey%2C+Laurence&amp;rft_id=%2F%2Fdoi.org%2F10.1016%252Fs0166-218x%252801%252900348-1&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACutting-plane+method"></span></li>
<li>Avriel, Mordecai (2003). <i>Nonlinear Programming: Analysis and Methods.</i> Dover Publications. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-486-43227-0</li>
<li>Cornuéjols, Gérard (2008).  Valid Inequalities for Mixed Integer Linear Programs.  <i>Mathematical Programming Ser. B</i>, (2008) 112:3–44.  [1]</li>
<li>Cornuéjols, Gérard (2007).  Revival of the Gomory Cuts in the 1990s.  <i>Annals of Operations Research</i>, Vol. 149 (2007), pp. 63–66.  [2]</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>"Integer Programming" Section 9.8 <i>Applied Mathematical Programming</i> Chapter 9 Integer Programming (full text). Bradley, Hax, and Magnanti (Addison-Wesley, 1977)</li></ul>

<!-- 
NewPP limit report
Parsed by mw2272
Cached time: 20221224090646
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.296 seconds
Real time usage: 0.444 seconds
Preprocessor visited node count: 1235/1000000
Post‐expand include size: 71228/2097152 bytes
Template argument size: 3019/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 16479/5000000 bytes
Lua time usage: 0.169/10.000 seconds
Lua memory usage: 4580148/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  328.992      1 -total
 31.39%  103.278      1 Template:Reflist
 26.10%   85.852      3 Template:Cite_journal
 21.67%   71.295      1 Template:Optimization_algorithms
 20.73%   68.205      1 Template:Navbox_with_collapsible_groups
 18.02%   59.280      1 Template:Short_description
 10.99%   36.154      1 Template:Why
  9.81%   32.268      2 Template:Pagetype
  9.27%   30.509      1 Template:Fix
  9.08%   29.872      1 Template:Clarify
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1597680-0!canonical and timestamp 20221224090645 and revision id 1092503865.
 -->
</div></body>
</html>