<!DOCTYPE html>
<html>
<head>
<title>first-in,_first-out</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>

<p>In computing and in systems theory, <b>FIFO</b> is an acronym for <b>first in, first out</b> (the first in is the first out), a method for organizing the manipulation of a data structure (often, specifically a data buffer) where the oldest (first) entry, or "head" of the queue, is processed first.
</p><p>Such processing is analogous to servicing people in a queue area on a first-come, first-served (FCFS) basis, i.e. in the same sequence in which they arrive at the queue's tail.
</p><p>FCFS is also the jargon term for the FIFO operating system scheduling algorithm, which gives every process central processing unit (CPU) time in the order in which it is demanded.<sup class="reference" id="cite_ref-TanenbaumBos2015_1-0">[1]</sup> FIFO's opposite is LIFO, last-in-first-out, where the youngest entry or "top of the stack" is processed first.<sup class="reference" id="cite_ref-Kruse_2-0">[2]</sup> A priority queue is neither FIFO or LIFO but may adopt similar behaviour temporarily or by default. Queueing theory encompasses these methods for processing data structures, as well as interactions between strict-FIFO queues.
</p>

<h2><span class="mw-headline" id="Computer_science">Computer science</span><span class="mw-editsection"></span></h2>

<p>Depending on the application, a FIFO could be implemented as a hardware shift register, or using different memory structures, typically a circular buffer or a kind of list. For information on the abstract data structure, see Queue (data structure). Most software implementations of a FIFO queue are not thread safe and require a locking mechanism to verify the data structure chain is being manipulated by only one thread at a time.
</p><p>The following code shows a linked list FIFO C++ language implementation. In practice, a number of list implementations exist, including popular Unix systems C sys/queue.h macros or the C++ standard library std::list template, avoiding the need for implementing the data structure from scratch.
</p>

<p>In computing environments that support the pipes-and-filters model for interprocess communication, a FIFO is another name for a named pipe.
</p><p>Disk controllers can use the FIFO as a disk scheduling algorithm to determine the order in which to service disk I/O requests, where it is also known by the same FCFS initialism as for CPU scheduling mentioned before.<sup class="reference" id="cite_ref-TanenbaumBos2015_1-1">[1]</sup>
</p><p>Communication network bridges, switches and routers used in computer networks use FIFOs to hold data packets in route to their next destination. Typically at least one FIFO structure is used per network connection. Some devices feature multiple FIFOs for simultaneously and independently queuing different types of information.<sup class="reference" id="cite_ref-KuroseRoss2006_3-0">[3]</sup>
</p>
<h2><span class="mw-headline" id="Electronics">Electronics</span><span class="mw-editsection"></span></h2>

<p>FIFOs are commonly used in electronic circuits for buffering and flow control between hardware and software. In its hardware form, a FIFO primarily consists of a set of read and write pointers, storage and control logic. Storage may be static random access memory (SRAM), flip-flops, latches or any other suitable form of storage. For FIFOs of non-trivial size, a dual-port SRAM is usually used, where one port is dedicated to writing and the other to reading.
</p><p>The first known FIFO implemented in electronics was by Peter Alfke in 1969 at Fairchild Semiconductor.<sup class="reference" id="cite_ref-Alfke_4-0">[4]</sup> Alfke was later a director at Xilinx.
</p>
<h3><span class="mw-headline" id="Synchronicity">Synchronicity</span><span class="mw-editsection"></span></h3>
<p>A synchronous FIFO is a FIFO where the same clock is used for both reading and writing. An asynchronous FIFO uses different clocks for reading and writing and they can introduce metastability issues. A common implementation of an asynchronous FIFO uses a Gray code (or any unit distance code) for the read and write pointers to ensure reliable flag generation. One further note concerning flag generation is that one must necessarily use pointer arithmetic to generate flags for asynchronous FIFO implementations. Conversely, one may use either a leaky bucket approach or pointer arithmetic to generate flags in synchronous FIFO implementations.
</p><p>A hardware FIFO is used for synchronization purposes. It is often implemented as a circular queue, and thus has two pointers:
</p>
<ul><li>Read pointer / read address register</li>
<li>Write pointer / write address register</li></ul>
<h3><span class="mw-headline" id="Status_flags">Status flags</span><span class="mw-editsection"></span></h3>
<p>Examples of FIFO status flags include: full, empty, almost full, and almost empty. A FIFO is empty when the read address register reaches the write address register. A FIFO is full when the write address register reaches the read address register. Read and write addresses are initially both at the first memory location and the FIFO queue is <i>empty</i>.
</p><p>In both cases, the read and write addresses end up being equal. To distinguish between the two situations, a simple and robust solution is to add one extra bit for each read and write address which is inverted each time the address wraps. With this set up, the disambiguation conditions are:
</p>
<ul><li>When the read address register equals the write address register, the FIFO is empty.</li>
<li>When the read and write address registers differ only in the extra most significant bit and the rest are equal, the FIFO is full.</li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>FIFO and LIFO accounting</li>
<li>FINO</li>
<li>Queueing theory</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Cummings et al.,  Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons, SNUG San Jose 2002</li></ul>


<!-- 
NewPP limit report
Parsed by mw2309
Cached time: 20221224011327
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.261 seconds
Real time usage: 0.354 seconds
Preprocessor visited node count: 649/1000000
Post‐expand include size: 34804/2097152 bytes
Template argument size: 958/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 26705/5000000 bytes
Lua time usage: 0.169/10.000 seconds
Lua memory usage: 5155080/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  300.552      1 -total
 28.77%   86.468      1 Template:Reflist
 22.06%   66.296      3 Template:Cite_book
 21.16%   63.602      1 Template:Authority_control
 19.35%   58.171      1 Template:Short_description
 19.11%   57.430      1 Template:More_citations_needed
 17.40%   52.284      1 Template:Ambox
 10.82%   32.512      2 Template:Pagetype
 10.42%   31.315      1 Template:Queueing_theory
  9.71%   29.189      1 Template:Navbox
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:11347-0!canonical and timestamp 20221224011327 and revision id 1104188471.
 -->
</div></body>
</html>