branch_and_boundGraph and treesearch algorithmsα–β pruningBacktrackingBeam searchBest-first searchBranch &amp; boundBreadth-First Search (BFS)British MuseumDepth-First Search (DFS)Hill climbingIterative Deepening DFS (IDDFS)Lexicographic BFSShortest pathA*B*Bellman–FordBidirectional searchD*Dijkstra'sFloyd–WarshallFringe searchIterative Deepening (IDA*)Johnson'sJump point searchKruskal'sLifelong Planning A* (LPA*)PathfindingSMA*ListsGraph algorithmsSearch algorithmsList of graph algorithmsRelated topicsDynamic programmingGraph coloringGraph traversalMinimum spanning treeSearch gamesThreaded binary treeTree traversalBranch and bound (BB, B&amp;B, or BnB) is an algorithm  design paradigm for discrete and combinatorial optimization problems, as well as mathematical optimization. A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions by means of state space search: the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution, and is discarded if it cannot produce a better solution than the best one found so far by the algorithm.The algorithm depends on efficient estimation of the lower and upper bounds of regions/branches of the search space. If no bounds are available, the algorithm degenerates to an exhaustive search.The method was first proposed by Ailsa Land and Alison Doig whilst carrying out research at the London School of Economics sponsored by British Petroleum in 1960 for discrete programming,[1][2] and has become the most commonly used tool for solving NP-hard optimization problems.[3] The name "branch and bound" first occurred in the work of Little et al. on the traveling salesman problem.[4][5] Branch and bound methods do not go deep like Depth-first search; the first direction is lateral movement in the tree similar to Breadth-first search (BFS).The goal of a branch-and-bound algorithm is to find a value  that maximizes or minimizes the value of a real-valued function , called an objective function, among some set  of admissible, or candidate solutions. The set  is called the search space, or feasible region. The rest of this section assumes that minimization of  is desired; this assumption comes without loss of generality, since one can find the maximum value of  by finding the minimum of . A B&amp;B algorithm operates according to two principles:It recursively splits the search space into smaller spaces, then minimizing  on these smaller spaces; the splitting is called branching.Branching alone would amount to brute-force enumeration of candidate solutions and testing them all. To improve on the performance of brute-force search, a B&amp;B algorithm keeps track of bounds on the minimum that it is trying to find, and uses these bounds to "prune" the search space, eliminating candidate solutions that it can prove will not contain an optimal solution.Turning these principles into a concrete algorithm for a specific optimization problem requires some kind of data structure that represents sets of candidate solutions. Such a representation is called an instance of the problem. Denote the set of candidate solutions of an instance  by . The instance representation has to come with three operations: produces two or more instances that each represent a subset of . (Typically, the subsets are disjoint to prevent the algorithm from visiting the same candidate solution twice, but this is not required. However, an optimal solution among  must be contained in at least one of the subsets.[6]) computes a lower bound on the value of any candidate solution in the space represented by , that is,  for all  in . determines whether  represents a single candidate solution. (Optionally, if it does not, the operation may choose to return some feasible solution from among .[6]) If  returns a solution then  provides an upper bound for the optimal objective value over the whole space of feasible solutions.Using these operations, a B&amp;B algorithm performs a top-down recursive search through the tree of instances formed by the branch operation. Upon visiting an instance , it checks whether  is equal or greater than the current upper bound; if so,  may be safely discarded from the search and the recursion stops. This pruning step is usually implemented by maintaining a global variable that records the minimum upper bound seen among all instances examined so far.The following is the skeleton of a generic branch and bound algorithm for minimizing an arbitrary objective function .[3] To obtain an actual algorithm from this, one requires a bounding function , that computes lower bounds of  on nodes of the search tree, as well as a problem-specific branching rule. As such, the generic algorithm presented here is a higher-order function.Using a heuristic, find a solution  to the optimization problem. Store its value, . (If no heuristic is available, set  to infinity.)  will denote the best solution found so far, and will be used as an upper bound on candidate solutions.Initialize a queue to hold a partial solution with none of the variables of the problem assigned.Loop until the queue is empty:Take a node  off the queue.If  represents a single candidate solution  and , then  is the best solution so far. Record it and set .Else, branch on  to produce new nodes . For each of these:If , do nothing; since the lower bound on this node is greater than the upper bound of the problem, it will never lead to the optimal solution, and can be discarded.Else, store  on the queue.Several different queue data structures can be used. This FIFO queue-based implementation yields a breadth-first search. A stack (LIFO queue) will yield a depth-first algorithm. A best-first branch and bound algorithm can be obtained by using a priority queue that sorts nodes on their lower bound.[3] Examples of best-first search algorithms with this premise are Dijkstra's algorithm and its descendant A* search. The depth-first variant is recommended when no good heuristic is available for producing an initial solution, because it quickly produces full solutions, and therefore upper bounds.[7]PseudocodeA C++-like pseudocode implementation of the above is:In the above pseudocode, the functions heuristic_solve and populate_candidates called as subroutines must be provided as applicable to the problem. The functions  (objective_function) and  (lower_bound_function) are treated as function objects as written, and could correspond to lambda expressions, function pointers and other types of callable objects in the C++ programming language.When  is a vector of , branch and bound algorithms can be combined with interval analysis[8] and contractor techniques in order to provide guaranteed enclosures of the global minimum.[9][10]This approach is used for a number of NP-hard problems:Integer programmingNonlinear programmingTravelling salesman problem (TSP)[4][11]Quadratic assignment problem (QAP)Maximum satisfiability problem (MAX-SAT)Nearest neighbor search[12] (by Keinosuke Fukunaga)Flow shop schedulingCutting stock problemComputational phylogeneticsSet inversionParameter estimation0/1 knapsack problemSet cover problemFeature selection in machine learning[13][14]Structured prediction in computer vision[15]Arc routing problem, including Chinese Postman problemTalent Scheduling, scenes shooting arrangement problemBranch-and-bound may also be a base of various heuristics. For example, one may wish to stop branching when the gap between the upper and lower bounds becomes smaller than a certain threshold. This is used when the solution is "good enough for practical purposes" and can greatly reduce the computations required. This type of solution is particularly applicable when the cost function used is noisy or is the result of statistical estimates and so is not known precisely but rather only known to lie within a range of values with a specific probability.[]Nau et al. present a generalization of branch and bound that also subsumes the A*, B* and alpha-beta search algorithms.[16]Branch and bound can be used to solve this problemMaximize  with these constraints and  are integers. The first step is to relax the integer constraint. We have two extreme points for the first equation that form a line:  and . We can form the second line with the vector points  and . The third point is . This is a convex hull region so the solution lies on one of the vertices of the region. We can find the intersection using row reduction, which is , or  with a value of 276.667. We test the other endpoints by sweeping the line over the region and find this is the maximum over the reals.  We choose the variable with the maximum fractional part, in this case  becomes the parameter for the branch and bound method. We branch to  and obtain 276 @ . We have reached an integer solution so we move to the other branch . We obtain 275.75 @. We have a decimal so we branch  to  and we find 274.571 @. We try the other branch  and there are no feasible solutions. Therefore, the maximum is 276 with  and .   BacktrackingBranch-and-cut, a hybrid between branch-and-bound and the cutting plane methods that is used extensively for solving integer linear programs.Alpha-beta pruningLiPS – Free easy-to-use GUI program intended for solving linear, integer and goal programming problems.Cbc – (Coin-or branch and cut) is an open-source mixed integer programming solver written in C++.