<!DOCTYPE html>
<html>
<head>
<title>comparison_sort</title>
</head>
<body>
<div class="mw-parser-output">

<p>A <b>comparison sort</b> is a type of sorting algorithm that only reads the list elements through a single abstract comparison operation (often a "less than or equal to" operator or a three-way comparison) that determines which of two elements should occur first in the final sorted list. The only requirement is that the operator forms a total preorder over the data, with:
</p>
<ol><li>if <i>a</i> ≤ <i>b</i> and <i>b</i> ≤ <i>c</i> then <i>a</i> ≤ <i>c</i> (transitivity)</li>
<li>for all <i>a</i> and <i>b</i>, <i>a</i> ≤ <i>b</i> or <i>b</i> ≤ <i>a</i> (connexity).</li></ol>
<p>It is possible that both <i>a</i> ≤ <i>b</i> and <i>b</i> ≤ <i>a</i>; in this case either may come first in the sorted list. In a stable sort, the input order determines the sorted order in this case.
</p><p>A metaphor for thinking about comparison sorts is that someone has a set of unlabelled weights and a balance scale. Their goal is to line up the weights in order by their weight without any information except that obtained by placing two weights on the scale and seeing which one is heavier (or if they weigh the same).
</p>

<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>

<p>Some of the most well-known comparison sorts include:
</p>
<ul><li>Quicksort</li>
<li>Heapsort</li>
<li>Shellsort</li>
<li>Merge sort</li>
<li>Introsort</li>
<li>Insertion sort</li>
<li>Selection sort</li>
<li>Bubble sort</li>
<li>Odd–even sort</li>
<li>Cocktail shaker sort</li>
<li>Cycle sort</li>
<li>Merge-insertion sort</li>
<li>Smoothsort</li>
<li>Timsort</li>
<li>Block sort</li></ul>
<h2><span class="mw-headline" id="Performance_limits_and_advantages_of_different_sorting_techniques">Performance limits and advantages of different sorting techniques</span><span class="mw-editsection"></span></h2>
<p>There are fundamental limits on the performance of comparison sorts. A comparison sort must have an average-case lower bound of Ω(<i>n</i> log <i>n</i>) comparison operations,<sup class="reference" id="cite_ref-1">[1]</sup> which is known as linearithmic time. This is a consequence of the limited information available through comparisons alone — or, to put it differently, of the vague algebraic structure of totally ordered sets. In this sense, mergesort, heapsort, and introsort are asymptotically optimal in terms of the number of comparisons they must perform, although this metric neglects other operations. Non-comparison sorts (such as the examples discussed below) can achieve O(<i>n</i>) performance by using operations other than comparisons, allowing them to sidestep this lower bound (assuming elements are constant-sized).
</p><p>Comparison sorts may run faster on some lists; many adaptive sorts such as insertion sort run in O(<i>n</i>) time on an already-sorted or nearly-sorted list. The Ω(<i>n</i> log <i>n</i>) lower bound applies only to the case in which the input list can be in any possible order.
</p><p>Real-world measures of sorting speed may need to take into account the ability of some algorithms to optimally use relatively fast cached computer memory, or the application may benefit from sorting methods where sorted data begins to appear to the user quickly (and then user's speed of reading will be the limiting factor) as opposed to sorting methods where no output is available until the whole list is sorted.
</p><p>Despite these limitations, comparison sorts offer the notable practical advantage that control over the comparison function allows sorting of many different datatypes and fine control over how the list is sorted. For example, reversing the result of the comparison function allows the list to be sorted in reverse; and one can sort a list of tuples in lexicographic order by just creating a comparison function that compares each part in sequence:
</p>
<pre><b>function</b> tupleCompare((lefta, leftb, leftc), (righta, rightb, rightc))
    <b>if</b> lefta ≠ righta
        <b>return</b> compare(lefta, righta)
    <b>else if</b> leftb ≠ rightb
        <b>return</b> compare(leftb, rightb)
    <b>else</b>
        <b>return</b> compare(leftc, rightc)
</pre>
<p>Comparison sorts generally adapt more easily to complex orders such as the order of floating-point numbers. Additionally, once a comparison function is written, any comparison sort can be used without modification; non-comparison sorts typically require specialized versions for each datatype.
</p><p>This flexibility, together with the efficiency of the above comparison sorting algorithms on modern computers, has led to widespread preference for comparison sorts in most practical work.
</p>
<h2><span class="mw-headline" id="Alternatives">Alternatives</span><span class="mw-editsection"></span></h2>
<p>Some sorting problems admit a strictly faster solution than the <span class="texhtml">Ω(<i>n</i> log <i>n</i>)</span> bound for comparison sorting by using non-comparison sorts; an example is integer sorting, where all keys are integers. When the keys form a small (compared to <span class="texhtml mvar" style="font-style:italic;">n</span>) range, counting sort is an example algorithm that runs in linear time. Other integer sorting algorithms, such as radix sort, are not asymptotically faster than comparison sorting, but can be faster in practice.
</p><p>The problem of sorting pairs of numbers by their sum is not subject to the <span class="texhtml">Ω(<i>n</i>² log <i>n</i>)</span> bound either (the square resulting from the pairing up); the best known algorithm still takes <span class="texhtml">O(<i>n</i>² log <i>n</i>)</span> time, but only <span class="texhtml">O(<i>n</i>²)</span> comparisons.
</p>
<h2><span class="mw-headline" id="Number_of_comparisons_required_to_sort_a_list">Number of comparisons required to sort a list</span><span class="mw-editsection"></span></h2>

<p>The number of comparisons that a comparison sort algorithm requires increases in proportion to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n\log(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n\log(n)}</annotation>
</semantics>
</math></span><img alt="n\log(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aca080dee55ba2825a2d955bd6ca43c0e7ed04db" style="vertical-align: -0.838ex; width:7.958ex; height:2.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> is the number of elements to sort.  This bound is asymptotically tight.
</p><p>Given a list of distinct numbers (we can assume this because this is a worst-case analysis), there are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> factorial permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutation. If the algorithm always completes after at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n)}</annotation>
</semantics>
</math></span><img alt="f(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c1c49fad1eccc4e9af1e4f23f32efdc3ac4da973" style="vertical-align: -0.838ex; width:4.483ex; height:2.843ex;"/></span> steps, it cannot distinguish more than <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{f(n)}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{f(n)}}</annotation>
</semantics>
</math></span><img alt="2^{{f(n)}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bf7592370246b59696719487219d60f955d3ad79" style="vertical-align: -0.338ex; width:4.564ex; height:2.843ex;"/></span> cases because the keys are distinct and each comparison has only two possible outcomes. Therefore,
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{f(n)}\geq n!}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>≥<!-- ≥ --></mo>
<mi>n</mi>
<mo>!</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{f(n)}\geq n!}</annotation>
</semantics>
</math></span><img alt="2^{f(n)}\geq n!" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5923fb5c3b850b59520d56a43cd69e28bc6f2b15" style="vertical-align: -0.505ex; width:9.704ex; height:3.009ex;"/></span>, or equivalently <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(n)\geq \log _{2}(n!).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo>≥<!-- ≥ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(n)\geq \log _{2}(n!).}</annotation>
</semantics>
</math></span><img alt="f(n)\geq\log_2(n!)." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3c5431de96b0a6fd51c957d1c1ffaf254523c6e7" style="vertical-align: -0.838ex; width:16.105ex; height:2.843ex;"/></span></dd></dl>
<p>By looking at the first <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n/2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n/2}</annotation>
</semantics>
</math></span><img alt="n/2" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/95c3931a3fa03cc98cfacd2c49a7ca35b96eaa9b" style="vertical-align: -0.838ex; width:3.72ex; height:2.843ex;"/></span> factors of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n!=n(n-1)\cdots 1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>!</mo>
<mo>=</mo>
<mi>n</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>⋯<!-- ⋯ --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n!=n(n-1)\cdots 1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle n!=n(n-1)\cdots 1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7b51d8826920b8401b03a1905366caab64adb969" style="vertical-align: -0.838ex; width:18.401ex; height:2.843ex;"/></span>, we obtain
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log _{2}(n!)\geq \log _{2}\left(\left({\frac {n}{2}}\right)^{\frac {n}{2}}\right)={\frac {n}{2}}{\frac {\log n}{\log 2}}-{\frac {n}{2}}=\Theta (n\log n).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>≥<!-- ≥ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mrow>
<mo>(</mo>
<msup>
<mrow>
<mo>(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
</mrow>
<mo>)</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
</mrow>
</msup>
<mo>)</mo>
</mrow>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
</mrow>
<mrow>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mn>2</mn>
</mrow>
</mfrac>
</mrow>
<mo>−<!-- − --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">Θ<!-- Θ --></mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log _{2}(n!)\geq \log _{2}\left(\left({\frac {n}{2}}\right)^{\frac {n}{2}}\right)={\frac {n}{2}}{\frac {\log n}{\log 2}}-{\frac {n}{2}}=\Theta (n\log n).}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log _{2}(n!)\geq \log _{2}\left(\left({\frac {n}{2}}\right)^{\frac {n}{2}}\right)={\frac {n}{2}}{\frac {\log n}{\log 2}}-{\frac {n}{2}}=\Theta (n\log n).}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/68fdd75b41ffd1b9cb2850371a968a3f92bd519e" style="vertical-align: -2.505ex; width:55.186ex; height:6.343ex;"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log _{2}(n!)=\Omega (n\log n).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi mathvariant="normal">Ω<!-- Ω --></mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log _{2}(n!)=\Omega (n\log n).}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log _{2}(n!)=\Omega (n\log n).}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d3a93e489098ccc966ad184f573f5fcfc7f5500f" style="vertical-align: -0.838ex; width:21.645ex; height:2.843ex;"/></span></dd></dl>
<p>This provides the lower-bound part of the claim. A more precise bound can be given via Stirling's approximation. An upper bound of the same form, with the same leading term as the bound obtained from Stirling's approximation, follows from the existence of the algorithms that attain this bound in the worst case, like merge sort.
</p><p>The above argument provides an <i>absolute</i>, rather than only asymptotic lower bound on the number of comparisons, namely <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \left\lceil \log _{2}(n!)\right\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow>
<mo>⌈</mo>
<mrow>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
</mrow>
<mo>⌉</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \left\lceil \log _{2}(n!)\right\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \left\lceil \log _{2}(n!)\right\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cd0f9fbe42cbca42479014d5306ccf8c83d1538f" style="vertical-align: -0.838ex; width:9.942ex; height:2.843ex;"/></span> comparisons. This lower bound is fairly good (it can be approached within a linear tolerance by a simple merge sort), but it is known to be inexact. For example, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \left\lceil \log _{2}(13!)\right\rceil =33}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow>
<mo>⌈</mo>
<mrow>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mn>13</mn>
<mo>!</mo>
<mo stretchy="false">)</mo>
</mrow>
<mo>⌉</mo>
</mrow>
<mo>=</mo>
<mn>33</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \left\lceil \log _{2}(13!)\right\rceil =33}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \left\lceil \log _{2}(13!)\right\rceil =33}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ba69ee2b08a72d4febd8e43b75a5e8f6f8f7e66" style="vertical-align: -0.838ex; width:16.295ex; height:2.843ex;"/></span>, but the minimal number of comparisons to sort 13 elements has been proved to be 34.
</p><p>Determining the <i>exact</i> number of comparisons needed to sort a given number of entries is a computationally hard problem even for small <i>n</i>, and no simple formula for the solution is known. For some of the few concrete values that have been computed, see <span class="nowrap external">OEIS: A036604</span>.
</p>
<h3><span class="mw-headline" id="Lower_bound_for_the_average_number_of_comparisons">Lower bound for the average number of comparisons</span><span class="mw-editsection"></span></h3>
<p>A similar bound applies to the average number of comparisons. Assuming that
</p>
<ul><li>all keys are distinct, i.e. every comparison will give either <i>a</i>&gt;<i>b</i> or <i>a</i>&lt;<i>b</i>, and</li>
<li>the input is a random permutation, chosen uniformly from the set of all possible permutations of <i>n</i> elements,</li></ul>
<p>it is impossible to determine which order the input is in with fewer than <span class="texhtml">log<sub>2</sub>(<i>n</i>!)</span> comparisons on average.
</p><p>This can be most easily seen using concepts from information theory. The Shannon entropy of such a random permutation is <span class="texhtml">log<sub>2</sub>(<i>n</i>!)</span> bits. Since a comparison can give only two results, the maximum amount of information it provides is 1 bit. Therefore, after <i>k</i> comparisons the remaining entropy of the permutation, given the results of those comparisons, is at least <span class="texhtml">log<sub>2</sub>(<i>n</i>!) − <i>k</i></span> bits on average. To perform the sort, complete information is needed, so the remaining entropy must be 0. It follows that <i>k</i> must be at least <span class="texhtml">log<sub>2</sub>(<i>n</i>!)</span> on average. 
</p><p>The lower bound derived via information theory is phrased as 'information-theoretic lower bound'. Information-theoretic lower bound is correct but is not necessarily the strongest lower bound. And in some cases, the information-theoretic lower bound of a problem may even be far from the true lower bound. For example, the information-theoretic lower bound of selection is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \left\lceil \log _{2}(n)\right\rceil }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow>
<mo>⌈</mo>
<mrow>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⌉</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \left\lceil \log _{2}(n)\right\rceil }</annotation>
</semantics>
</math></span><img alt="{\displaystyle \left\lceil \log _{2}(n)\right\rceil }" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12082efb8a0367653757c4ce8f6675ebd9bf297e" style="vertical-align: -0.838ex; width:9.295ex; height:2.843ex;"/></span> whereas <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n-1}</annotation>
</semantics>
</math></span><img alt="n-1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fbd0b0f32b28f51962943ee9ede4fb34198a2521" style="vertical-align: -0.505ex; width:5.398ex; height:2.343ex;"/></span> comparisons are needed by an adversarial argument. The interplay between information-theoretic lower bound and the true lower bound are much like a real-valued function lower-bounding an integer function. However, this is not exactly correct when the average case is considered.
</p><p>To unearth what happens while analyzing the average case, the key is that what does 'average' refer to? Averaging over what? With some knowledge of information theory, the information-theoretic lower bound averages over the set of all permutations as a whole. But any computer algorithms (under what are believed currently) must treat each permutation as an individual instance of the problem. Hence, the average lower bound we're searching for is averaged over all individual cases.
</p><p>To search for the lower bound relating to the non-achievability of computers, we adopt the Decision tree model. Let's rephrase a bit of what our objective is. In the Decision tree model, the lower bound to be shown is the lower bound of the average length of root-to-leaf paths of an <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n!}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>!</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n!}</annotation>
</semantics>
</math></span><img alt="n!" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bae971720be3cc9b8d82f4cdac89cb89877514a6" style="vertical-align: -0.338ex; width:2.042ex; height:2.176ex;"/></span>-leaf binary tree (in which each leaf corresponds to a permutation). It would be convinced to say that a balanced full binary tree achieves the minimum of the average length. With some careful calculations, for a balanced full binary tree with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n!}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>!</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n!}</annotation>
</semantics>
</math></span><img alt="n!" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bae971720be3cc9b8d82f4cdac89cb89877514a6" style="vertical-align: -0.338ex; width:2.042ex; height:2.176ex;"/></span> leaves, the average length of root-to-leaf paths is given by 
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {(2n!-2^{\lfloor \log _{2}n!\rfloor +1})\cdot \lceil \log _{2}n!\rceil +(2^{\lfloor \log _{2}n!\rfloor +1}-n!)\cdot \lfloor \log _{2}n!\rfloor }{n!}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mn>2</mn>
<mi>n</mi>
<mo>!</mo>
<mo>−<!-- − --></mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo>!</mo>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
<mo>⋅<!-- ⋅ --></mo>
<mo fence="false" stretchy="false">⌈<!-- ⌈ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo>!</mo>
<mo fence="false" stretchy="false">⌉<!-- ⌉ --></mo>
<mo>+</mo>
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo>!</mo>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mi>n</mi>
<mo>!</mo>
<mo stretchy="false">)</mo>
<mo>⋅<!-- ⋅ --></mo>
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<msub>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo>!</mo>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>!</mo>
</mrow>
</mfrac>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {(2n!-2^{\lfloor \log _{2}n!\rfloor +1})\cdot \lceil \log _{2}n!\rceil +(2^{\lfloor \log _{2}n!\rfloor +1}-n!)\cdot \lfloor \log _{2}n!\rfloor }{n!}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\frac {(2n!-2^{\lfloor \log _{2}n!\rfloor +1})\cdot \lceil \log _{2}n!\rceil +(2^{\lfloor \log _{2}n!\rfloor +1}-n!)\cdot \lfloor \log _{2}n!\rfloor }{n!}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/88f254ee0c0f9200176e998c122b1caba15acc88" style="vertical-align: -2.005ex; width:58.056ex; height:6.176ex;"/></span></dd></dl>
<p>For example, for <span class="texhtml"><i>n</i> = 3</span>, the information-theoretic lower bound for the average case is approximately 2.58, while the average lower bound derived via Decision tree model is 8/3, approximately 2.67.
</p><p>In the case that multiple items may have the same key, there is no obvious statistical interpretation for the term "average case", so an argument like the above cannot be applied without making specific assumptions about the distribution of keys.
</p>
<h3><span id="n_log_n_maximum_number_of_comparisons_for_array-size_in_format_2.5Ek"></span><span class="mw-headline" id="n_log_n_maximum_number_of_comparisons_for_array-size_in_format_2^k">n log n maximum number of comparisons for array-size in format 2^k</span><span class="mw-editsection"></span></h3>
<p>Can easy compute for real algorithm sorted-list-merging (array are sorted n-blocks with size 1, merge to 1-1 to 2, merge 2-2 to 4...).
</p>
<pre>(1) = = = = = = = =

(2) =   =   =   =     // max 1 compares (size1+size2-1), 4x repeats to concat 8 arrays with size 1 and 1
   === === === ===

(3)   =       =       // max 7 compares, 2x repeats to concat 4 arrays with size 2 and 2
     ===     ===  
    =====   ===== 
   ======= =======

(4)                   // max 15 compares, 1x repeats to concat 2 arrays with size 4 and 4

Formula extraction:
n = 256 = 2^8 (array size in format 2^k, for simplify)
On = (n-1) + 2(n/2-1) + 4(n/4-1) + 8(n/8-1) + 16(n/16-1) + 32(n/32-1) + 64(n/64-1) + 128(n/128-1)
On = (n-1) + (n-2) + (n-4) + (n-8) + (n-16) + (n-32) + (n-64) + (n-128)
On = n+n+n+n+n+n+n+n - (1+2+4+8+16+32+64+128)   | 1+2+4... = formula for geometric sequence Sn = a1 * (q^i - 1) / (n - 1), n is number of items, a1 is first item
On = 8*n - 1 * (2^8 - 1) / (2 - 1)
On = 8*n - (2^8 - 1)   | 2^8 = n
On = 8*n - (n - 1)
On = (8-1)*n + 1   | 8 = ln(n)/ln(2) = ln(256)/ln(2)
On = (ln(n)/ln(2) - 1) * n + 1

Example:
n = 2^4 = 16, On ~= 3*n
n = 2^8 = 256, On ~= 7*n
n = 2^10 = 1.024, On ~= 9*n
n = 2^20 = 1.048.576, On ~= 19*n
</pre>
<h3><span class="mw-headline" id="Sorting_a_pre-sorted_list">Sorting a pre-sorted list</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>If a list is already close to sorted, according to some measure of sortedness, the number of comparisons required to sort it can be smaller. An adaptive sort takes advantage of this "presortedness" and runs more quickly on nearly-sorted inputs, often while still maintaining an <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n\log n)}</annotation>
</semantics>
</math></span><img alt="O(n\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1" style="vertical-align: -0.838ex; width:10.118ex; height:2.843ex;"/></span> worst case time bound. An example is adaptive heap sort, a sorting algorithm based on Cartesian trees. It takes time <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n\log k)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>k</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n\log k)}</annotation>
</semantics>
</math></span><img alt="O(n\log k)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/99e71cfbbb1dbd170050e63d7b342b07b4b014e2" style="vertical-align: -0.838ex; width:9.934ex; height:2.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k}</annotation>
</semantics>
</math></span><img alt="k" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" style="vertical-align: -0.338ex; width:1.211ex; height:2.176ex;"/></span> is the average, over all values <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x}</annotation>
</semantics>
</math></span><img alt="x" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span> in the sequence, of the number of times the sequence jumps from below <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x}</annotation>
</semantics>
</math></span><img alt="x" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span> to above <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>x</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x}</annotation>
</semantics>
</math></span><img alt="x" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span> or vice versa.<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>

<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li>Donald Knuth. <i>The Art of Computer Programming</i>, Volume 3: <i>Sorting and Searching</i>, Second Edition. Addison-Wesley, 1997. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-89685-0. Section 5.3.1: Minimum-Comparison Sorting, pp. 180–197.</li></ul>

<!-- 
NewPP limit report
Parsed by mw2371
Cached time: 20221224050403
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.237 seconds
Real time usage: 0.374 seconds
Preprocessor visited node count: 1529/1000000
Post‐expand include size: 28463/2097152 bytes
Template argument size: 1610/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 25638/5000000 bytes
Lua time usage: 0.116/10.000 seconds
Lua memory usage: 3877807/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  242.390      1 -total
 27.21%   65.957      1 Template:Introduction_to_Algorithms
 26.33%   63.818      1 Template:Cite_book
 22.18%   53.769      1 Template:Short_description
 16.02%   38.830      1 Template:Sorting
 15.13%   36.664      1 Template:Navbox
 10.70%   25.925      2 Template:Pagetype
  7.95%   19.279     12 Template:Main_other
  7.31%   17.721      1 Template:Main
  6.76%   16.392      1 Template:SDcat
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:3189304-0!canonical and timestamp 20221224050403 and revision id 1125862898.
 -->
</div></body>
</html>