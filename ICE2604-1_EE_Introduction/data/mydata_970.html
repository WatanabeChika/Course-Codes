<!DOCTYPE html>
<html>
<head>
<title>strand_sort</title>
</head>
<body>
<div class="mw-parser-output">
<p><b>Strand sort</b> is a recursive sorting algorithm that sorts items of a list into increasing order. It has O(n<sup>2</sup>) worst time complexity which occurs when the input list is reverse sorted.<sup class="reference" id="cite_ref-:0_1-0">[1]</sup> It has a best case time complexity of O(n) which occurs when the input is a list that is already sorted.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="The previously given citation does not mention performance (May 2022)">citation needed</span></i>]</sup>
</p><p>The algorithm first moves the first element of a list into a sub-list.<sup class="reference" id="cite_ref-:0_1-1">[1]</sup> It then compares the last element in the sub-list to each subsequent element in the original list.<sup class="reference" id="cite_ref-:0_1-2">[1]</sup> Once there is an element in the original list that is greater than the last element in the sub-list, the element is removed from the original list and added to the sub-list.<sup class="reference" id="cite_ref-:0_1-3">[1]</sup> This process continues until the last element in the sub-list is compared to the remaining elements in the original list.<sup class="reference" id="cite_ref-:0_1-4">[1]</sup> The sub-list is then merged into a new list.<sup class="reference" id="cite_ref-:0_1-5">[1]</sup> Repeat this process and merge all sub-lists until all elements are sorted.<sup class="reference" id="cite_ref-:0_1-6">[1]</sup> This algorithm is called strand sort because there are strands of sorted elements within the unsorted elements that are removed one at a time.<sup class="reference" id="cite_ref-:0_1-7">[1]</sup> This algorithm is also used in J Sort for fewer than 40 elements.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>
<p>This example is based on the description of the algorithm provided in the book, <i>IT Enabled Practices and Emerging Management Paradigms</i>.<sup class="reference" id="cite_ref-:0_1-8">[1]</sup>
</p><p><b>Step 1:</b> Start with a list of numbers: {5, 1, 4, 2, 0, 9, 6, 3, 8, 7 }
</p><p><b>Step 2:</b> Next move the first element of the list into a new sub-list:  sub-list contains {5}
</p><p><b>Step 3:</b> Then iterate through the original list and compare each number to 5 until there is a number greater than 5.
</p>
<ul><li>1 &lt; 5 so 1 is not added to the sub-list.</li>
<li>4 &lt; 5 so 4 is not added to the sub-list.</li>
<li>2 &lt; 5 so 2 is not added to the sub-list.</li>
<li>0 &lt; 5 so 0  is not added to the sub-list.</li>
<li>9 &gt; 5 so 9 is added to the sub-list and removed from the original list.</li></ul>
<p><b>Step 4:</b> Now compare 9 with the remaining elements in the original list until there is a number greater than 9.  
</p>
<ul><li>6 &lt; 9 so 6 is not added to the sub-list.</li>
<li>3 &lt; 9 so 3 is not added to the sub-list.</li>
<li>8 &lt; 9 so 8 is not added to the sub-list.</li>
<li>7 &lt; 9 so 7 is not added to the sub-list.</li></ul>
<p><b>Step 5:</b> Now there are no more elements to compare 9 to so merge the sub-list into a new list, called solution-list.
</p><p>After step 5, the original list contains {1, 4, 2, 0, 6, 3, 8, 7}
</p><p>The sub-list is empty, and the solution list contains {5, 9}
</p><p><b>Step 6:</b> Move the first element of the original list into sub-list: sub-list contains {1}
</p><p><b>Step 7:</b> Iterate through the original list and compare each number to 1 until there is a number greater than 1.
</p>
<ul><li>4 &gt; 1 so 4 is added to the sub-list and 4 is removed from the original list.</li></ul>
<p><b>Step 8:</b> Now compare 4 with the remaining elements in the original list until there is a number greater than 4.
</p>
<ul><li>2 &lt; 4 so 2 is not added to the sub-list.</li>
<li>0 &lt; 4 so 0 is not added to the sub-list.</li>
<li>6 &gt; 4 so 6 is added to the sub-list and is removed from the original list.</li></ul>
<p><b>Step 9:</b> Now compare 6 with the remaining elements in the original list until there is a number greater than 6.  
</p>
<ul><li>3 &lt; 6 so 3 is not added to the sub-list.</li>
<li>8 &gt; 6 so 8 is added to the sub-list and is removed from the original list.</li></ul>
<p><b>Step 10:</b> Now compare 8 with the remaining elements in the original list until there is a number greater than 8.
</p>
<ul><li>7 &lt; 8 so 7 is not added to the sub-list.</li></ul>
<p><b>Step 11:</b> Since there are no more elements in the original list to compare {8} to, the sub-list is merged with the solution list. Now the original list contains {2, 0, 3, 7}, the sub-list is empty and the solution-list contains: {1, 4, 5, 6, 8, 9}.
</p><p><b>Step 12:</b>  Move the first element of the original list into sub-list. Sub-list contains {2}
</p><p><b>Step 13:</b> Iterate through the original list and compare each number to 2 until there is a number greater than 2.
</p>
<ul><li>0 &lt; 2 so 0 is not added to the sub-list.</li>
<li>3 &gt; 2 so 3 is added to the sub-list and is removed from the original list.</li></ul>
<p><b>Step 14:</b> Now compare 3 with the remaining elements in the original list until there is a number greater than 3.
</p>
<ul><li>7 &gt; 3 so 7 is added to the sub-list and is removed from the original list.</li></ul>
<p><b>Step 15:</b> Since there are no more elements in the original list to compare {7} to, the sub-list is merged with the solution list. The original list now contains {0}, the sub-list is empty, and solution list contains: {1, 2, 3, 4, 5, 6, 7, 8, 9}.
</p><p><b>Step 16:</b>  Move the first element of the original list into sub-list. Sub-list contains {0}.
</p><p><b>Step 17:</b>  Since the original list is now empty, the sub-list is merged with the solution list. The solution list now contains: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. There are now no more elements in the original list, and all of the elements in the solution list have successfully been sorted into increasing numerical order.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2><p>
Since Strand Sort requires many insertions and deletions, it is best to use a linked list when implementing the algorithm.<sup class="reference" id="cite_ref-:1_3-0">[3]</sup> Linked lists require constant time for both insertions and removals of elements using iterators. The time to traverse through the linked list is directly related to the input size of the list.<sup class="reference" id="cite_ref-4">[4]</sup> The following implementation is done in Java 8 and is based on the description of the algorithm from the book, <i>IT Enabled Practices and Emerging Management Paradigms</i>.<sup class="reference" id="cite_ref-:0_1-9">[1]</sup></p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2413
Cached time: 20221214155148
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.154 seconds
Real time usage: 0.482 seconds
Preprocessor visited node count: 448/1000000
Post‐expand include size: 8617/2097152 bytes
Template argument size: 698/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 31280/5000000 bytes
Lua time usage: 0.069/10.000 seconds
Lua memory usage: 3199767/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  364.566      1 -total
 26.99%   98.381      1 Template:Reflist
 18.50%   67.445      2 Template:Cite_book
 13.05%   47.566      1 Template:Citation_needed
  8.66%   31.575      1 Template:Fix
  5.94%   21.645      2 Template:Category_handler
  2.22%    8.079      2 Template:Cite_web
  1.47%    5.352      1 Template:Delink
  0.56%    2.050      1 Template:Fix/category
  0.40%    1.466      2 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:58982979-0!canonical and timestamp 20221214155148 and revision id 1086366912.
 -->
</div></body>
</html>