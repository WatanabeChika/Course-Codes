<!DOCTYPE html>
<html>
<head>
<title>clique_problem</title>
</head>
<body>
<div class="mw-parser-output"><img alt="This is a good article. Click here for more information." data-file-height="185" data-file-width="180" decoding="async" height="20" src="//upload.wikimedia.org/wikipedia/en/thumb/9/94/Symbol_support_vote.svg/19px-Symbol_support_vote.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/9/94/Symbol_support_vote.svg/29px-Symbol_support_vote.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/94/Symbol_support_vote.svg/39px-Symbol_support_vote.svg.png 2x" width="19"/></div><div class="mw-parser-output">
<p class="mw-empty-elt">
</p>

<p>In computer science, the <b>clique problem</b> is the computational problem of finding cliques (subsets of vertices, all adjacent to each other, also called complete subgraphs) in a graph. It has several different formulations depending on which cliques, and what information about the cliques, should be found. Common formulations of the clique problem include finding a maximum clique (a clique with the largest possible number of vertices), finding a maximum weight clique in a weighted graph, listing all maximal cliques (cliques that cannot be enlarged), and solving the decision problem of testing whether a graph contains a clique larger than a given size.
</p><p>The clique problem arises in the following real-world setting. Consider a social network, where the graph's vertices represent people, and the graph's edges represent mutual acquaintance. Then a clique represents a subset of people who all know each other, and algorithms for finding cliques can be used to discover these groups of mutual friends. Along with its applications in social networks, the clique problem also has many applications in bioinformatics, and computational chemistry.
</p><p>Most versions of the clique problem are hard. The clique decision problem is NP-complete (one of Karp's 21 NP-complete problems). The problem of finding the maximum clique is both fixed-parameter intractable and hard to approximate. And, listing all maximal cliques may require exponential time as there exist graphs with exponentially many maximal cliques. Therefore, much of the theory about the clique problem is devoted to identifying special types of graph that admit more efficient algorithms, or to establishing the computational difficulty of the general problem in various models of computation.
</p><p>To find a maximum clique, one can systematically inspect all subsets, but this sort of brute-force search is too time-consuming to be practical for networks comprising more than a few dozen vertices.
Although no polynomial time algorithm is known for this problem, more efficient algorithms than the brute-force search are known. For instance, the Bron–Kerbosch algorithm can be used to list all maximal cliques in worst-case optimal time, and it is also possible to list them in polynomial time per clique.
</p>

<h2><span class="mw-headline" id="History_and_applications">History and applications</span><span class="mw-editsection"></span></h2>
<p>The study of complete subgraphs in mathematics predates the "clique" terminology. For instance, complete subgraphs make an early appearance in the mathematical literature in the graph-theoretic reformulation of Ramsey theory by Erdős &amp; Szekeres (1935). But the term "clique" and the problem of algorithmically listing cliques both come from the social sciences, where complete subgraphs are used to model social cliques, groups of people who all know each other. Luce &amp; Perry (1949) used graphs to model social networks, and adapted the social science terminology to graph theory. They were the first to call complete subgraphs "cliques". The first algorithm for solving the clique problem is that of Harary &amp; Ross (1957),<sup class="reference" id="cite_ref-bbpp_1-0">[1]</sup> who were motivated by the sociological application. Social science researchers have also defined various other types of cliques and maximal cliques in social network, "cohesive subgroups" of people or actors in the network all of whom share one of several different kinds of connectivity relation. Many of these generalized notions of cliques can also be found by constructing an undirected graph whose edges represent related pairs of actors from the social network, and then applying an algorithm for the clique problem to this graph.<sup class="reference" id="cite_ref-FOOTNOTEWassermanFaust1994_2-0">[2]</sup>
</p><p>Since the work of Harary and Ross, many others have devised algorithms for various versions of the clique problem.<sup class="reference" id="cite_ref-bbpp_1-1">[1]</sup> In the 1970s, researchers began studying these algorithms from the point of view of worst-case analysis. See, for instance, Tarjan &amp; Trojanowski (1977), an early work on the worst-case complexity of the maximum clique problem. Also in the 1970s, beginning with the work of Cook (1971) and Karp (1972), researchers began using the theory of NP-completeness and related intractability results to provide a mathematical explanation for the perceived difficulty of the clique problem. In the 1990s, a breakthrough series of papers beginning with Feige et al. (1991) and reported in <i>The New York Times</i>,<sup class="reference" id="cite_ref-FOOTNOTEKolata1990_3-0">[3]</sup> showed that (assuming P ≠ NP) it is not even possible to approximate the problem accurately and efficiently.
</p><p>Clique-finding algorithms have been used in chemistry, to find chemicals that match a target structure<sup class="reference" id="cite_ref-FOOTNOTERhodesWillettCalvetDunbar2003_4-0">[4]</sup> and to model molecular docking and the binding sites of chemical reactions.<sup class="reference" id="cite_ref-FOOTNOTEKuhlCrippenFriesen1983_5-0">[5]</sup> They can also be used to find similar structures within different molecules.<sup class="reference" id="cite_ref-6">[6]</sup> In these applications, one forms a graph in which each vertex represents a matched pair of atoms, one from each of two molecules. Two vertices are connected by an edge if the matches that they represent are compatible with each other. Being compatible may mean, for instance, that the distances between the atoms within the two molecules are approximately equal, to within some given tolerance. A clique in this graph represents a set of matched pairs of atoms in which all the matches are compatible with each other.<sup class="reference" id="cite_ref-7">[7]</sup> A special case of this method is the use of the modular product of graphs to reduce the problem of finding the maximum common induced subgraph of two graphs to the problem of finding a maximum clique in their product.<sup class="reference" id="cite_ref-FOOTNOTEBarrowBurstall1976_8-0">[8]</sup>
</p><p>In automatic test pattern generation, finding cliques can help to bound the size of a test set.<sup class="reference" id="cite_ref-FOOTNOTEHamzaogluPatel1998_9-0">[9]</sup> In bioinformatics, clique-finding algorithms have been used to infer evolutionary trees,<sup class="reference" id="cite_ref-FOOTNOTEDaySankoff1986_10-0">[10]</sup> predict protein structures,<sup class="reference" id="cite_ref-FOOTNOTESamudralaMoult1998_11-0">[11]</sup> and find closely interacting clusters of proteins.<sup class="reference" id="cite_ref-FOOTNOTESpirinMirny2003_12-0">[12]</sup> Listing the cliques in a dependency graph is an important step in the analysis of certain random processes.<sup class="reference" id="cite_ref-FOOTNOTEFrankStrauss1986_13-0">[13]</sup> In mathematics, Keller's conjecture on face-to-face tiling of hypercubes was disproved by Lagarias &amp; Shor (1992), who used a clique-finding algorithm on an associated graph to find a counterexample.<sup class="reference" id="cite_ref-14">[14]</sup>
</p>
<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>An undirected graph is formed by a finite set of vertices and a set of unordered pairs of vertices, which are called edges. By convention, in algorithm analysis, the number of vertices in the graph is denoted by <span class="texhtml mvar" style="font-style:italic;">n</span> and the number of edges is denoted by <span class="texhtml mvar" style="font-style:italic;">m</span>. A clique in a graph <span class="texhtml mvar" style="font-style:italic;">G</span> is a complete subgraph of <span class="texhtml mvar" style="font-style:italic;">G</span>. That is, it is a subset <span class="texhtml mvar" style="font-style:italic;">K</span> of the vertices such that every two vertices in <span class="texhtml mvar" style="font-style:italic;">K</span> are the two endpoints of an edge in <span class="texhtml mvar" style="font-style:italic;">G</span>. A maximal clique is a clique to which no more vertices can be added. For each vertex <span class="texhtml mvar" style="font-style:italic;">v</span> that is not part of a maximal clique, there must be another vertex <span class="texhtml mvar" style="font-style:italic;">w</span> that is in the clique and non-adjacent to <span class="texhtml mvar" style="font-style:italic;">v</span>, preventing <span class="texhtml mvar" style="font-style:italic;">v</span> from being added to the clique. A maximum clique is a clique that includes the largest possible number of vertices. The clique number <span class="texhtml"><i>ω</i>(<i>G</i>)</span> is the number of vertices in a maximum clique of <span class="texhtml mvar" style="font-style:italic;">G</span>.<sup class="reference" id="cite_ref-bbpp_1-2">[1]</sup>
</p><p>Several closely related clique-finding problems have been studied.<sup class="reference" id="cite_ref-v02p09_15-0">[15]</sup>
</p>
<ul><li>In the maximum clique problem, the input is an undirected graph, and the output is a maximum clique in the graph. If there are multiple maximum cliques, one of them may be chosen arbitrarily.<sup class="reference" id="cite_ref-v02p09_15-1">[15]</sup></li>
<li>In the weighted maximum clique problem, the input is an undirected graph with weights on its vertices (or, less frequently, edges) and the output is a clique with maximum total weight. The maximum clique problem is the special case in which all weights are equal.<sup class="reference" id="cite_ref-FOOTNOTEPelillo2009_16-0">[16]</sup> As well as the problem of optimizing the sum of weights, other more complicated bicriterion optimization problems have also been studied.<sup class="reference" id="cite_ref-FOOTNOTESethuramanButenko2015_17-0">[17]</sup></li>
<li>In the maximal clique listing problem, the input is an undirected graph, and the output is a list of all its maximal cliques. The maximum clique problem may be solved using as a subroutine an algorithm for the maximal clique listing problem, because the maximum clique must be included among all the maximal cliques.<sup class="reference" id="cite_ref-FOOTNOTEValiente2002_18-0">[18]</sup></li>
<li>In the <span class="texhtml mvar" style="font-style:italic;">k</span>-clique problem, the input is an undirected graph and a number <span class="texhtml mvar" style="font-style:italic;">k</span>. The output is a clique with <span class="texhtml mvar" style="font-style:italic;">k</span> vertices, if one exists, or a special value indicating that there is no <span class="texhtml mvar" style="font-style:italic;">k</span>-clique otherwise. In some variations of this problem, the output should list all cliques of size <span class="texhtml mvar" style="font-style:italic;">k</span>.<sup class="reference" id="cite_ref-CN85_19-0">[19]</sup></li>
<li>In the clique decision problem, the input is an undirected graph and a number <span class="texhtml mvar" style="font-style:italic;">k</span>, and the output is a Boolean value: true if the graph contains a <span class="texhtml mvar" style="font-style:italic;">k</span>-clique, and false otherwise.<sup class="reference" id="cite_ref-FOOTNOTECormenLeisersonRivestStein2001_20-0">[20]</sup></li></ul>
<p>The first four of these problems are all important in practical applications. The clique decision problem is not of practical importance; it is formulated in this way in order to apply the theory of NP-completeness to clique-finding problems.<sup class="reference" id="cite_ref-FOOTNOTECormenLeisersonRivestStein2001_20-1">[20]</sup>
</p><p>The clique problem and the independent set problem are complementary: a clique in <span class="texhtml mvar" style="font-style:italic;">G</span> is an independent set in the complement graph of <span class="texhtml mvar" style="font-style:italic;">G</span> and vice versa.<sup class="reference" id="cite_ref-21">[21]</sup> Therefore, many computational results may be applied equally well to either problem, and some research papers do not clearly distinguish between the two problems. However, the two problems have different properties when applied to restricted families of graphs. For instance, the clique problem may be solved in polynomial time for planar graphs<sup class="reference" id="cite_ref-planar_22-0">[22]</sup> while the independent set problem remains NP-hard on planar graphs.<sup class="reference" id="cite_ref-FOOTNOTEGareyJohnsonStockmeyer1976_23-0">[23]</sup>
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Finding_a_single_maximal_clique">Finding a single maximal clique</span><span class="mw-editsection"></span></h3>
<p>A maximal clique, sometimes called inclusion-maximal, is a clique that is not included in a larger clique.  Therefore, every clique is contained in a maximal clique.<sup class="reference" id="cite_ref-24">[24]</sup> Maximal cliques can be very small.  A graph may contain a non-maximal clique with many vertices and a separate clique of size 2 which is maximal.  While a maximum (i.e., largest) clique is necessarily maximal, the converse does not hold.  There are some types of graphs in which every maximal clique is maximum; these are the complements of the well-covered graphs, in which every maximal independent set is maximum.<sup class="reference" id="cite_ref-FOOTNOTEPlummer1993_25-0">[25]</sup> However, other graphs have maximal cliques that are not maximum.
</p><p>A single maximal clique can be found by a straightforward greedy algorithm. Starting with an arbitrary clique (for instance, any single vertex or even the empty set), grow the current clique one vertex at a time by looping through the graph's remaining vertices. For each vertex <span class="texhtml mvar" style="font-style:italic;">v</span> that this loop examines, add <span class="texhtml mvar" style="font-style:italic;">v</span> to the clique if it is adjacent to every vertex that is already in the clique, and discard <span class="texhtml mvar" style="font-style:italic;">v</span> otherwise. This algorithm runs in linear time.<sup class="reference" id="cite_ref-26">[26]</sup>  Because of the ease of finding maximal cliques, and their potential small size,  more attention has been given to the much harder algorithmic problem of finding a maximum or otherwise large clique. However, some research in parallel algorithms has studied the problem of finding a maximal clique. In particular, the problem of finding the lexicographically first maximal clique (the one found by the algorithm above) has been shown to be complete for the class of polynomial-time functions. This result implies that the problem is unlikely to be solvable within the parallel complexity class NC.<sup class="reference" id="cite_ref-FOOTNOTECook1985_27-0">[27]</sup>
</p>
<h3><span class="mw-headline" id="Cliques_of_fixed_size">Cliques of fixed size</span><span class="mw-editsection"></span></h3>
<p>One can test whether a graph <span class="texhtml mvar" style="font-style:italic;">G</span> contains a <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex clique, and find any such clique that it contains, using a brute force algorithm. This algorithm examines each subgraph with <span class="texhtml mvar" style="font-style:italic;">k</span> vertices and checks to see whether it forms a clique. It takes time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>n</i><sup><i>k</i></sup> <i>k</i><sup>2</sup>)</span>, as expressed using big O notation.
This is because there are <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>n</i><sup><i>k</i></sup>)</span> subgraphs to check, each of which has <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>k</i><sup>2</sup>)</span> edges whose presence in <span class="texhtml mvar" style="font-style:italic;">G</span> needs to be checked. Thus, the problem may be solved in polynomial time whenever <span class="texhtml mvar" style="font-style:italic;">k</span> is a fixed constant. However, when <span class="texhtml mvar" style="font-style:italic;">k</span> does not have a fixed value, but instead may vary as part of the input to the problem, the time is exponential.<sup class="reference" id="cite_ref-28">[28]</sup>
</p><p>The simplest nontrivial case of the clique-finding problem is finding a triangle in a graph, or equivalently determining whether the graph is triangle-free.
In a graph <span class="texhtml mvar" style="font-style:italic;">G</span> with <span class="texhtml mvar" style="font-style:italic;">m</span> edges, there may be at most <span class="texhtml">Θ(<i>m</i><sup>3/2</sup>)</span> triangles (using big theta notation to indicate that this bound is tight). The worst case for this formula occurs when <span class="texhtml mvar" style="font-style:italic;">G</span> is itself a clique. Therefore, algorithms for listing all triangles must take at least <span class="texhtml">Ω(<i>m</i><sup>3/2</sup>)</span> time in the worst case (using big omega notation), and algorithms are known that match this time bound.<sup class="reference" id="cite_ref-29">[29]</sup> For instance, Chiba &amp; Nishizeki (1985) describe an algorithm that sorts the vertices in order from highest degree to lowest and then iterates through each vertex <span class="texhtml mvar" style="font-style:italic;">v</span> in the sorted list, looking for triangles that include <span class="texhtml mvar" style="font-style:italic;">v</span> and do not include any previous vertex in the list. To do so the algorithm marks all neighbors of <span class="texhtml mvar" style="font-style:italic;">v</span>, searches through all edges incident to a neighbor of <span class="texhtml mvar" style="font-style:italic;">v</span> outputting a triangle for every edge that has two marked endpoints, and then removes the marks and deletes <span class="texhtml mvar" style="font-style:italic;">v</span> from the graph. As the authors show, the time for this algorithm is proportional to the arboricity of the graph (denoted <span class="texhtml"><i>a</i>(<i>G</i>)</span>) multiplied by the number of edges, which is <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i> <i>a</i>(<i>G</i>))</span>. Since the arboricity is at most <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i><sup>1/2</sup>)</span>, this algorithm runs in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i><sup>3/2</sup>)</span>. More generally, all <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex cliques can be listed by a similar algorithm that takes time proportional to the number of edges multiplied by the arboricity to the power <span class="texhtml">(<i>k</i> − 2)</span>. For graphs of constant arboricity, such as planar graphs (or in general graphs from any non-trivial minor-closed graph family), this algorithm takes <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i>)</span> time, which is optimal since it is linear in the size of the input.<sup class="reference" id="cite_ref-CN85_19-1">[19]</sup>
</p><p>If one desires only a single triangle, or an assurance that the graph is triangle-free, faster algorithms are possible. As Itai &amp; Rodeh (1978) observe, the graph contains a triangle if and only if its adjacency matrix and the square of the adjacency matrix contain nonzero entries in the same cell. Therefore, fast matrix multiplication techniques can be applied to find triangles in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>n</i><sup>2.376</sup>)</span>. Alon, Yuster &amp; Zwick (1994) used fast matrix multiplication to improve the <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i><sup>3/2</sup>)</span> algorithm for finding triangles to <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>m</i><sup>1.41</sup>)</span>. These algorithms based on fast matrix multiplication have also been extended to problems of finding <span class="texhtml mvar" style="font-style:italic;">k</span>-cliques for larger values of <span class="texhtml mvar" style="font-style:italic;">k</span>.<sup class="reference" id="cite_ref-30">[30]</sup>
</p>
<h3><span class="mw-headline" id="Listing_all_maximal_cliques">Listing all maximal cliques</span><span class="mw-editsection"></span></h3>
<p>By a result of Moon &amp; Moser (1965), every <span class="texhtml mvar" style="font-style:italic;">n</span>-vertex graph has at most <span class="texhtml">3<sup><i>n</i>/3</sup></span> maximal cliques. They can be listed by the Bron–Kerbosch algorithm, a recursive backtracking procedure of Bron &amp; Kerbosch (1973). The main recursive subroutine of this procedure has three arguments: a partially constructed (non-maximal) clique, a set of candidate vertices that could be added to the clique, and another set of vertices that should not be added (because doing so would lead to a clique that has already been found). The algorithm tries adding the candidate vertices one by one to the partial clique, making a recursive call for each one. After trying each of these vertices, it moves it to the set of vertices that should not be added again. Variants of this algorithm can be shown to have worst-case running time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(3<sup><i>n</i>/3</sup>)</span>, matching the number of cliques that might need to be listed.<sup class="reference" id="cite_ref-FOOTNOTETomitaTanakaTakahashi2006_31-0">[31]</sup> Therefore, this provides a worst-case-optimal solution to the problem of listing all maximal cliques. Further, the Bron–Kerbosch algorithm has been widely reported as being faster in practice than its alternatives.<sup class="reference" id="cite_ref-32">[32]</sup>
</p><p>However, when the number of cliques is significantly smaller than its worst case, other algorithms might be preferable. As Tsukiyama et al. (1977) showed, it is also possible to list all maximal cliques in a graph in an amount of time that is polynomial per generated clique. An algorithm such as theirs in which the running time depends on the output size is known as an output-sensitive algorithm. Their algorithm is based on the following two observations, relating the maximal cliques of the given graph <span class="texhtml mvar" style="font-style:italic;">G</span> to the maximal cliques of a graph <span class="texhtml"><i>G</i> \ <i>v</i></span> formed by removing an arbitrary vertex <span class="texhtml mvar" style="font-style:italic;">v</span> from <span class="texhtml mvar" style="font-style:italic;">G</span>:
</p>
<ul><li>For every maximal clique <span class="texhtml mvar" style="font-style:italic;">K</span> of <span class="texhtml"><i>G</i> \ <i>v</i></span>, either <span class="texhtml mvar" style="font-style:italic;">K</span> continues to form a maximal clique in <span class="texhtml mvar" style="font-style:italic;">G</span>, or <span class="texhtml"><i>K</i> ⋃ {<i>v</i>} </span> forms a maximal clique in <span class="texhtml mvar" style="font-style:italic;">G</span>. Therefore, <span class="texhtml mvar" style="font-style:italic;">G</span> has at least as many maximal cliques as <span class="texhtml"><i>G</i> \ <i>v</i></span> does.</li>
<li>Each maximal clique in <span class="texhtml mvar" style="font-style:italic;">G</span> that does not contain <span class="texhtml mvar" style="font-style:italic;">v</span> is a maximal clique in <span class="texhtml"><i>G</i> \ <i>v</i></span>, and each maximal clique in <span class="texhtml mvar" style="font-style:italic;">G</span> that does contain <span class="texhtml mvar" style="font-style:italic;">v</span> can be formed from a maximal clique <span class="texhtml mvar" style="font-style:italic;">K</span> in <span class="texhtml"><i>G</i> \ <i>v</i></span> by adding <span class="texhtml mvar" style="font-style:italic;">v</span> and removing the non-neighbors of <span class="texhtml mvar" style="font-style:italic;">v</span> from <span class="texhtml mvar" style="font-style:italic;">K</span>.</li></ul>
<p>Using these observations they can generate all maximal cliques in <span class="texhtml mvar" style="font-style:italic;">G</span> by a recursive algorithm that chooses a vertex <span class="texhtml mvar" style="font-style:italic;">v</span> arbitrarily and then, for each maximal clique <span class="texhtml mvar" style="font-style:italic;">K</span> in <span class="texhtml"><i>G</i> \ <i>v</i></span>, outputs both <span class="texhtml mvar" style="font-style:italic;">K</span> and the clique formed by adding <span class="texhtml mvar" style="font-style:italic;">v</span> to <span class="texhtml mvar" style="font-style:italic;">K</span> and removing the non-neighbors of <span class="texhtml mvar" style="font-style:italic;">v</span>. However, some cliques of <span class="texhtml mvar" style="font-style:italic;">G</span> may be generated in this way from more than one parent clique of <span class="texhtml"><i>G</i> \ <i>v</i></span>, so they eliminate duplicates by outputting a clique in <span class="texhtml mvar" style="font-style:italic;">G</span> only when its parent in <span class="texhtml"><i>G</i> \ <i>v</i></span> is lexicographically maximum among all possible parent cliques. On the basis of this principle, they show that all maximal cliques in <span class="texhtml mvar" style="font-style:italic;">G</span> may be generated in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>mn</i>)</span> per clique, where <span class="texhtml mvar" style="font-style:italic;">m</span> is the number of edges in <span class="texhtml mvar" style="font-style:italic;">G</span> and <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of vertices. Chiba &amp; Nishizeki (1985) improve this to <span class="texhtml">O(<i>ma</i>)</span> per clique, where <span class="texhtml mvar" style="font-style:italic;">a</span> is the arboricity of the given graph. Makino &amp; Uno (2004) provide an alternative output-sensitive algorithm based on fast matrix multiplication. Johnson &amp; Yannakakis (1988) show that it is even possible to list all maximal cliques in lexicographic order with polynomial delay per clique. However, the choice of ordering is important for the efficiency of this algorithm: for the reverse of this order,
there is no polynomial-delay algorithm unless P = NP.
</p><p>On the basis of this result, it is possible to list all maximal cliques in polynomial time, for families of graphs in which the number of cliques is polynomially bounded. These families include chordal graphs, complete graphs, triangle-free graphs, interval graphs, graphs of bounded boxicity, and planar graphs.<sup class="reference" id="cite_ref-FOOTNOTERosgenStewart2007_33-0">[33]</sup> In particular, the planar graphs have <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>n</i>)</span> cliques, of at most constant size, that can be listed in linear time. The same is true for any family of graphs that is both sparse (having a number of edges at most a constant times the number of vertices) and closed under the operation of taking subgraphs.<sup class="reference" id="cite_ref-CN85_19-2">[19]</sup><sup class="reference" id="cite_ref-ELS10_34-0">[34]</sup>
</p>
<h3><span class="mw-headline" id="Finding_maximum_cliques_in_arbitrary_graphs">Finding maximum cliques in arbitrary graphs</span><span class="mw-editsection"></span></h3>
<p>It is possible to find the maximum clique, or the clique number, of an arbitrary <i>n</i>-vertex graph in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(3<sup><i>n</i>/3</sup>) = <span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1.4422<sup><i>n</i></sup>)</span> by using one of the algorithms described above to list all maximal cliques in the graph and returning the largest one. However, for this variant of the clique problem better worst-case time bounds are possible. The algorithm of Tarjan &amp; Trojanowski (1977) solves this problem in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(2<sup><i>n</i>/3</sup>) = <span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1.2599<sup><i>n</i></sup>)</span>. It is a recursive backtracking scheme similar to that of the Bron–Kerbosch algorithm, but is able to eliminate some recursive calls when it can be shown that the cliques found within the call will be suboptimal. Jian (1986) improved the time to <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(2<sup>0.304<i>n</i></sup>) = <span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1.2346<sup><i>n</i></sup>)</span>, and Robson (1986) improved it to <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(2<sup>0.276<i>n</i></sup>) = <span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1.2108<sup><i>n</i></sup>)</span> time, at the expense of greater space usage. Robson's algorithm combines a similar backtracking scheme (with a more complicated case analysis) and a dynamic programming technique in which the optimal solution is precomputed for all small connected subgraphs of the complement graph. These partial solutions are used to shortcut the backtracking recursion. The fastest algorithm known today is a refined version of this method by Robson (2001) which runs in time <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(2<sup>0.249<i>n</i></sup>) = <span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1.1888<sup><i>n</i></sup>)</span>.<sup class="reference" id="cite_ref-FOOTNOTERobson2001_35-0">[35]</sup>
</p><p>There has also been extensive research on heuristic algorithms for solving maximum clique problems without worst-case runtime guarantees, based on methods including branch and bound,<sup class="reference" id="cite_ref-36">[36]</sup> local search,<sup class="reference" id="cite_ref-37">[37]</sup> greedy algorithms,<sup class="reference" id="cite_ref-38">[38]</sup> and constraint programming.<sup class="reference" id="cite_ref-FOOTNOTERégin2003_39-0">[39]</sup> Non-standard computing methodologies that have been suggested for finding cliques include DNA computing<sup class="reference" id="cite_ref-40">[40]</sup> and adiabatic quantum computation.<sup class="reference" id="cite_ref-FOOTNOTEChildsFarhiGoldstoneGutmann2002_41-0">[41]</sup> The maximum clique problem was the subject of an implementation challenge sponsored by DIMACS in 1992–1993,<sup class="reference" id="cite_ref-FOOTNOTEJohnsonTrick1996_42-0">[42]</sup> and a collection of graphs used as benchmarks for the challenge, which is publicly available.<sup class="reference" id="cite_ref-43">[43]</sup>
</p>
<h3><span class="mw-headline" id="Special_classes_of_graphs">Special classes of graphs</span><span class="mw-editsection"></span></h3>

<p>Planar graphs, and other families of sparse graphs, have been discussed above: they have linearly many maximal cliques, of bounded size, that can be listed in linear time.<sup class="reference" id="cite_ref-CN85_19-3">[19]</sup> In particular, for planar graphs, any clique can have at most four vertices, by Kuratowski's theorem.<sup class="reference" id="cite_ref-planar_22-1">[22]</sup>
</p><p>Perfect graphs are defined by the properties that their clique number equals their chromatic number, and that this equality holds also in each of their induced subgraphs. For perfect graphs, it is possible to find a maximum clique in polynomial time, using an algorithm based on semidefinite programming.<sup class="reference" id="cite_ref-FOOTNOTEGrötschelLovászSchrijver1988_44-0">[44]</sup>
However, this method is complex and non-combinatorial, and specialized clique-finding algorithms have been developed for many subclasses of perfect graphs.<sup class="reference" id="cite_ref-FOOTNOTEGolumbic1980_45-0">[45]</sup> In the complement graphs of bipartite graphs, Kőnig's theorem allows the maximum clique problem to be solved using techniques for matching. In another class of perfect graphs, the permutation graphs, a maximum clique is a longest decreasing subsequence of the permutation defining the graph and can be found using known algorithms for the longest decreasing subsequence problem. Conversely, every instance of the longest decreasing subsequence problem can be described equivalently as a problem of finding a maximum clique in a permutation graph.<sup class="reference" id="cite_ref-46">[46]</sup> Even, Pnueli &amp; Lempel (1972) provide an alternative quadratic-time algorithm for maximum cliques in comparability graphs, a broader class of perfect graphs that includes the permutation graphs as a special case.<sup class="reference" id="cite_ref-FOOTNOTEEvenPnueliLempel1972_47-0">[47]</sup> In chordal graphs, the maximal cliques can be found by listing the vertices in an elimination ordering, and checking the clique neighborhoods of each vertex in this ordering.<sup class="reference" id="cite_ref-48">[48]</sup>
</p><p>In some cases, these algorithms can be extended to other, non-perfect, classes of graphs as well. For instance, in a circle graph, the neighborhood of each vertex is a permutation graph, so a maximum clique in a circle graph can be found by applying the permutation graph algorithm to each neighborhood.<sup class="reference" id="cite_ref-49">[49]</sup> Similarly, in a unit disk graph (with a known geometric representation), there is a polynomial time algorithm for maximum cliques based on applying the algorithm for complements of bipartite graphs to shared neighborhoods of pairs of vertices.<sup class="reference" id="cite_ref-FOOTNOTEClarkColbournJohnson1990_50-0">[50]</sup>
</p><p>The algorithmic problem of finding a maximum clique in a random graph drawn from the Erdős–Rényi model (in which each edge appears with probability <span class="texhtml">1/2</span>, independently from the other edges) was suggested by Karp (1976). Because the maximum clique in a random graph has logarithmic size with high probability, it
can be found by a brute force search in expected time <span class="texhtml">2<sup><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(log<sup>2</sup><i>n</i>)</sup></span>. This is a quasi-polynomial time bound.<sup class="reference" id="cite_ref-FOOTNOTESong2015_51-0">[51]</sup> Although the clique number of such graphs is usually very close to <span class="texhtml">2 log<sub>2</sub><i>n</i></span>, simple greedy algorithms as well as more sophisticated randomized approximation techniques only find cliques with size <span class="texhtml">log<sub>2</sub><i>n</i></span>, half as big. The number of maximal cliques in such graphs is with high probability exponential in <span class="texhtml">log<sup>2</sup><i>n</i></span>, which prevents methods that list all maximal cliques from running in polynomial time.<sup class="reference" id="cite_ref-FOOTNOTEJerrum1992_52-0">[52]</sup> Because of the difficulty of this problem, several authors have investigated the planted clique problem, the clique problem on random graphs that have been augmented by adding large cliques.<sup class="reference" id="cite_ref-53">[53]</sup> While spectral methods<sup class="reference" id="cite_ref-FOOTNOTEAlonKrivelevichSudakov1998_54-0">[54]</sup> and semidefinite programming<sup class="reference" id="cite_ref-FOOTNOTEFeigeKrauthgamer2000_55-0">[55]</sup> can detect hidden cliques of size <span class="texhtml">Ω(<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>n</i></span></span>)</span>, no polynomial-time algorithms are currently known to detect those of size <span class="texhtml"><i>o</i>(<span class="nowrap">√<span style="border-top:1px solid; padding:0 0.1em;"><i>n</i></span></span>)</span> (expressed using little-o notation).<sup class="reference" id="cite_ref-FOOTNOTEMekaPotechinWigderson2015_56-0">[56]</sup>
</p>
<h3><span class="mw-headline" id="Approximation_algorithms">Approximation algorithms</span><span class="mw-editsection"></span></h3>
<p>Several authors have considered approximation algorithms that attempt to find a clique or independent set that, although not maximum, has size as close to the maximum as can be found in polynomial time. Although much of this work has focused on independent sets in sparse graphs, a case that does not make sense for the complementary clique problem, there has also been work on approximation algorithms that do not use such sparsity assumptions.<sup class="reference" id="cite_ref-57">[57]</sup>
</p><p>Feige (2004) describes a polynomial time algorithm that finds a clique of size <span class="texhtml">Ω((log <i>n</i>/log log <i>n</i>)<sup>2</sup>)</span> in any graph that has clique number <span class="texhtml">Ω(<i>n</i>/log<sup><i>k</i></sup><i>n</i>)</span> for any constant <span class="texhtml mvar" style="font-style:italic;">k</span>. By using this algorithm when the clique number of a given input graph is between <span class="texhtml"><i>n</i>/log <i>n</i></span> and <span class="texhtml"><i>n</i>/log<sup>3</sup><i>n</i></span>, switching to a different algorithm of Boppana &amp; Halldórsson (1992) for graphs with higher clique numbers, and choosing a two-vertex clique if both algorithms fail to find anything, Feige provides an approximation algorithm that finds a clique with a number of vertices within a factor of <span class="texhtml">O(<i>n</i>(log log <i>n</i>)<sup>2</sup>/log<sup>3</sup><i>n</i>)</span> of the maximum. Although the approximation ratio of this algorithm is weak, it is the best known to date.<sup class="reference" id="cite_ref-58">[58]</sup> The results on hardness of approximation described below suggest that there can be no approximation algorithm with an approximation ratio significantly less than linear.
</p>
<h2><span class="mw-headline" id="Lower_bounds">Lower bounds</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="NP-completeness">NP-completeness</span><span class="mw-editsection"></span></h3>

<p>The clique decision problem is NP-complete. It was one of Richard Karp's original 21 problems shown NP-complete in his 1972 paper "Reducibility Among Combinatorial Problems".<sup class="reference" id="cite_ref-FOOTNOTEKarp1972_60-0">[60]</sup>  This problem was also mentioned in Stephen Cook's paper introducing the theory of NP-complete problems.<sup class="reference" id="cite_ref-FOOTNOTECook1971_61-0">[61]</sup> Because of the hardness of the decision problem, the problem of finding a maximum clique is also NP-hard. If one could solve it, one could also solve the decision problem, by comparing the size of the maximum clique to the size parameter given as input in the decision problem.
</p><p>Karp's NP-completeness proof is a many-one reduction from the Boolean satisfiability problem. It describes how to translate Boolean formulas in conjunctive normal form (CNF) into equivalent instances of the maximum clique problem.<sup class="reference" id="cite_ref-62">[62]</sup> Satisfiability, in turn, was proved NP-complete in the Cook–Levin theorem. From a given CNF formula, Karp forms a graph that has a vertex for every pair <span class="texhtml">(<i>v</i>,<i>c</i>)</span>, where <span class="texhtml mvar" style="font-style:italic;">v</span> is a variable or its negation and <span class="texhtml mvar" style="font-style:italic;">c</span> is a clause in the formula that contains <span class="texhtml mvar" style="font-style:italic;">v</span>. Two of these vertices are connected by an edge if they represent compatible variable assignments for different clauses. That is, there is an edge from <span class="texhtml">(<i>v</i>,<i>c</i>)</span> to <span class="texhtml">(<i>u</i>,<i>d</i>)</span> whenever <span class="texhtml"><i>c</i> ≠ <i>d</i></span> and <span class="texhtml mvar" style="font-style:italic;">u</span> and <span class="texhtml mvar" style="font-style:italic;">v</span> are not each other's negations. If <span class="texhtml mvar" style="font-style:italic;">k</span> denotes the number of clauses in the CNF formula, then the <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex cliques in this graph represent consistent ways of assigning truth values to some of its variables in order to satisfy the formula. Therefore, the formula is satisfiable if and only if a <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex clique exists.<sup class="reference" id="cite_ref-FOOTNOTEKarp1972_60-1">[60]</sup>
</p><p>Some NP-complete problems (such as the travelling salesman problem in planar graphs) may be solved in time that is exponential in a sublinear function of the input size parameter <span class="texhtml mvar" style="font-style:italic;">n</span>, significantly faster than a brute-force search.<sup class="reference" id="cite_ref-63">[63]</sup> However, it is unlikely that such a subexponential time bound is possible for the clique problem in arbitrary graphs, as it would imply similarly subexponential bounds for many other standard NP-complete problems.<sup class="reference" id="cite_ref-FOOTNOTEImpagliazzoPaturiZane2001_64-0">[64]</sup>
</p>
<h3><span class="mw-headline" id="Circuit_complexity">Circuit complexity</span><span class="mw-editsection"></span></h3>

<p>The computational difficulty of the clique problem has led it to be used to prove several lower bounds in circuit complexity. The existence of a clique of a given size is a monotone graph property, meaning that, if a clique exists in a given graph, it will exist in any supergraph. Because this property is monotone, there must exist a monotone circuit, using only and gates and or gates, to solve the clique decision problem for a given fixed clique size. However, the size of these circuits can be proven to be a super-polynomial function of the number of vertices and the clique size, exponential in the cube root of the number of vertices.<sup class="reference" id="cite_ref-65">[65]</sup> Even if a small number of NOT gates are allowed, the complexity remains superpolynomial.<sup class="reference" id="cite_ref-66">[66]</sup> Additionally, the depth of a monotone circuit for the clique problem using gates of bounded fan-in must be at least a polynomial in the clique size.<sup class="reference" id="cite_ref-67">[67]</sup>
</p>
<h3><span class="mw-headline" id="Decision_tree_complexity">Decision tree complexity</span><span class="mw-editsection"></span></h3>

<p>The (deterministic) decision tree complexity of determining a graph property is the number of questions of the form "Is there an edge between vertex <span class="texhtml mvar" style="font-style:italic;">u</span> and vertex <span class="texhtml mvar" style="font-style:italic;">v</span>?" that have to be answered in the worst case to determine whether a graph has a particular property. That is, it is the minimum height of a boolean decision tree for the problem. There are <span class="texhtml"><i>n</i>(<i>n</i> − 1)/2</span> possible questions to be asked. Therefore, any graph property can be determined with at most <span class="texhtml"><i>n</i>(<i>n</i> − 1)/2</span> questions. It is also possible to define random and quantum decision tree complexity of a property, the expected number of questions (for a worst case input) that a randomized or quantum algorithm needs to have answered in order to correctly determine whether the given graph has the property.<sup class="reference" id="cite_ref-68">[68]</sup>
</p><p>Because the property of containing a clique is monotone, it is covered by the Aanderaa–Karp–Rosenberg conjecture, which states that the deterministic decision tree complexity of determining any non-trivial monotone graph property is exactly <span class="texhtml"><i>n</i>(<i>n</i> − 1)/2</span>. For arbitrary monotone graph properties, this conjecture remains unproven. However, for deterministic decision trees, and for any <span class="texhtml mvar" style="font-style:italic;">k</span> in the range <span class="texhtml">2 ≤ <i>k</i> ≤ <i>n</i></span>,  the property of containing a <span class="texhtml mvar" style="font-style:italic;">k</span>-clique was shown to have decision tree complexity exactly <span class="texhtml"><i>n</i>(<i>n</i> − 1)/2</span> by Bollobás (1976). Deterministic decision trees also require exponential size to detect cliques, or large polynomial size to detect cliques of bounded size.<sup class="reference" id="cite_ref-69">[69]</sup>
</p><p>The Aanderaa–Karp–Rosenberg conjecture also states that the randomized decision tree complexity of non-trivial monotone functions is <span class="texhtml">Θ(<i>n</i><sup>2</sup>)</span>. The conjecture again remains unproven, but has been resolved for the property of containing a <span class="texhtml mvar" style="font-style:italic;">k</span> clique for <span class="texhtml">2 ≤ <i>k</i> ≤ <i>n</i></span>. This property is known to have randomized decision tree complexity <span class="texhtml">Θ(<i>n</i><sup>2</sup>)</span>.<sup class="reference" id="cite_ref-70">[70]</sup> For quantum decision trees, the best known lower bound is <span class="texhtml">Ω(<i>n</i>)</span>, but no matching algorithm is known for the case of <span class="texhtml"><i>k</i> ≥ 3</span>.<sup class="reference" id="cite_ref-71">[71]</sup>
</p>
<h3><span class="mw-headline" id="Fixed-parameter_intractability">Fixed-parameter intractability</span><span class="mw-editsection"></span></h3>
<p>Parameterized complexity is the complexity-theoretic study of problems that are naturally equipped with a small integer parameter <span class="texhtml mvar" style="font-style:italic;">k</span> and for which the problem becomes more difficult as <span class="texhtml mvar" style="font-style:italic;">k</span> increases, such as finding <span class="texhtml mvar" style="font-style:italic;">k</span>-cliques in graphs. A problem is said to be fixed-parameter tractable if there is an algorithm for solving it on inputs of size <span class="texhtml mvar" style="font-style:italic;">n</span>, and a function <span class="texhtml mvar" style="font-style:italic;">f</span>, such that the algorithm runs in time <span class="texhtml"><i>f</i>(<i>k</i>) <i>n</i><sup><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(1)</sup></span>. That is, it is fixed-parameter tractable if it can be solved in polynomial time for any fixed value of <span class="texhtml mvar" style="font-style:italic;">k</span> and moreover if the exponent of the polynomial does not depend on <span class="texhtml mvar" style="font-style:italic;">k</span>.<sup class="reference" id="cite_ref-72">[72]</sup>
</p><p>For finding <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex cliques, the brute force search algorithm has running time <span class="texhtml">O(<i>n</i><sup><i>k</i></sup><i>k</i><sup>2</sup>)</span>. Because the exponent of <span class="texhtml mvar" style="font-style:italic;">n</span> depends on <span class="texhtml mvar" style="font-style:italic;">k</span>, this algorithm is not fixed-parameter tractable.
Although it can be improved by fast matrix multiplication the running time still has an exponent that is linear in <span class="texhtml mvar" style="font-style:italic;">k</span> Thus, although the running time of known algorithms for the clique problem is polynomial for any fixed <span class="texhtml mvar" style="font-style:italic;">k</span>, these algorithms do not suffice for fixed-parameter tractability. Downey &amp; Fellows (1995) defined a hierarchy of parametrized problems, the W hierarchy, that they conjectured did not have fixed-parameter tractable algorithms. They proved that independent set (or, equivalently, clique) is hard for the first level of this hierarchy, W[1]. Thus, according to their conjecture, clique has no fixed-parameter tractable algorithm. Moreover, this result provides the basis for proofs of W[1]-hardness of many other problems, and thus serves as an analogue of the Cook–Levin theorem for parameterized complexity.<sup class="reference" id="cite_ref-FOOTNOTEDowneyFellows1995_73-0">[73]</sup>
</p><p>Chen et al. (2006) showed that finding <span class="texhtml mvar" style="font-style:italic;">k</span>-vertex cliques cannot be done in time <span class="texhtml"><i>n</i><sup><i>o</i>(<i>k</i>)</sup></span> unless the exponential time hypothesis fails. Again, this provides evidence that no fixed-parameter tractable algorithm is possible.<sup class="reference" id="cite_ref-FOOTNOTEChenHuangKanjXia2006_74-0">[74]</sup>
</p><p>Although the problems of listing maximal cliques or finding maximum cliques are unlikely to be fixed-parameter tractable with the parameter <span class="texhtml mvar" style="font-style:italic;">k</span>, they may be fixed-parameter tractable for other parameters of instance complexity. For instance, both problems are known to be fixed-parameter tractable when parametrized by the degeneracy of the input graph.<sup class="reference" id="cite_ref-ELS10_34-1">[34]</sup>
</p>
<h3><span class="mw-headline" id="Hardness_of_approximation">Hardness of approximation</span><span class="mw-editsection"></span></h3>

<p>Weak results hinting that the clique problem might be hard to approximate have been known for a long time. Garey &amp; Johnson (1978) observed that, because the clique number takes on small integer values and is NP-hard to compute, it cannot have a fully polynomial-time approximation scheme. If too accurate an approximation were available, rounding its value to an integer would give the exact clique number. However, little more was known until the early 1990s, when several authors began to make connections between the approximation of maximum cliques and probabilistically checkable proofs. They used these connections to prove hardness of approximation results for the maximum clique problem.<sup class="reference" id="cite_ref-75">[75]</sup>
After many improvements to these results it is now known that, for every real number <span class="texhtml"><i>ε</i> &gt; 0</span>, there can be no polynomial time algorithm that approximates the maximum clique to within a factor better than <span class="texhtml"><span style="font-style:italic; padding-right:0.15em;"><i>O</i></span>(<i>n</i><sup>1 − <i>ε</i></sup>)</span>, unless P = NP.<sup class="reference" id="cite_ref-76">[76]</sup>
</p><p>The rough idea of these inapproximability results is to form a graph that represents a probabilistically checkable proof system for an NP-complete problem such as the Boolean satisfiability problem. In a probabilistically checkable proof system, a proof is represented as a sequence of bits. An instance of the satisfiability problem should have a valid proof if and only if it is satisfiable. The proof is checked by an algorithm that, after a polynomial-time computation on the input to the satisfiability problem, chooses to examine a small number of randomly chosen positions of the proof string. Depending on what values are found at that sample of bits, the checker will either accept or reject the proof, without looking at the rest of the bits. False negatives are not allowed: a valid proof must always be accepted. However, an invalid proof may sometimes mistakenly be accepted. For every invalid proof, the probability that the checker will accept it must be low.<sup class="reference" id="cite_ref-inapprox-redux_77-0">[77]</sup>
</p><p>To transform a probabilistically checkable proof system of this type into a clique problem, one forms a graph with a vertex for each possible accepting run of the proof checker. That is, a vertex is defined by one of the possible random choices of sets of positions to examine, and by bit values for those positions that would cause the checker to accept the proof. It can be represented by a partial word with a 0 or 1 at each examined position and a wildcard character at each remaining position. Two vertices are adjacent, in this graph, if the corresponding two accepting runs see the same bit values at every position they both examine. Each (valid or invalid) proof string corresponds to a clique, the set of accepting runs that see that proof string, and all maximal cliques arise in this way. One of these cliques is large if and only if it corresponds to a proof string that many proof checkers accept. If the original satisfiability instance is satisfiable, it will have a valid proof string, one that is accepted by all runs of the checker, and this string will correspond to a large clique in the graph. However, if the original instance is not satisfiable, then all proof strings are invalid, each proof string has only a small number of checker runs that mistakenly accept it, and all cliques are small. Therefore, if one could distinguish in polynomial time between graphs that have large cliques and graphs in which all cliques are small, or if one could accurately approximate the clique problem, then applying this approximation to the graphs generated from satisfiability instances would allow satisfiable instances to be distinguished from unsatisfiable instances. However, this is not possible unless P = NP.<sup class="reference" id="cite_ref-inapprox-redux_77-1">[77]</sup>
</p>

<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Surveys_and_textbooks">Surveys and textbooks</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h3><span class="mw-headline" id="Popular_press">Popular press</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1054258005" rel="mw-deduplicated-inline-style"/>
<h3><span class="mw-headline" id="Research_articles">Research articles</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1054258005" rel="mw-deduplicated-inline-style"/>
<!-- 
NewPP limit report
Parsed by mw2409
Cached time: 20221224020748
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 1.212 seconds
Real time usage: 1.313 seconds
Preprocessor visited node count: 14847/1000000
Post‐expand include size: 263198/2097152 bytes
Template argument size: 12620/2097152 bytes
Highest expansion depth: 10/100
Expensive parser function count: 1/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 232675/5000000 bytes
Lua time usage: 0.779/10.000 seconds
Lua memory usage: 8898029/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1103.346      1 -total
 50.68%  559.134    107 Template:Citation
 16.86%  185.979     98 Template:Harvtxt
 10.34%  114.066      1 Template:Reflist
  7.88%   86.908     39 Template:Sfnp
  6.65%   73.330     73 Template:Math
  4.32%   47.655      1 Template:Short_description
  4.25%   46.934    116 Template:Main_other
  2.43%   26.828      2 Template:Pagetype
  1.96%   21.604      1 Template:Good_article
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:249254-0!canonical and timestamp 20221224020746 and revision id 1093311196.
 -->
</div></body>
</html>