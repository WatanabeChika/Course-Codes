<!DOCTYPE html>
<html>
<head>
<title>planarization</title>
</head>
<body>
<div class="mw-parser-output">
<p>In the mathematical field of graph theory, <b>planarization</b> is a method of extending graph drawing methods from planar graphs to graphs that are not planar, by embedding the non-planar graphs within a larger planar graph.<sup class="reference" id="cite_ref-gdh_1-0">[1]</sup><sup class="reference" id="cite_ref-gda_2-0">[2]</sup>
</p><p>Planarization may be performed by using any method to find a drawing (with crossings) for the given graph, and then replacing each crossing point by a new artificial vertex, causing each crossed edge to be subdivided into a path. The original graph will be represented as an immersion minor of its planarization.
</p><p>In <b>incremental planarization</b>, the planarization process is split into two stages. First, a large planar subgraph is found within the given graph. Then, the remaining edges that are not already part of this subgraph are added back one at a time, and routed through an embedding of the planar subgraph. When one of these edges crosses an already-embedded edge, the two edges that cross are replaced by two-edge paths, with a new artificial vertex that represents the crossing point placed at the middle of both paths.<sup class="reference" id="cite_ref-gdh_1-1">[1]</sup><sup class="reference" id="cite_ref-gda_2-1">[2]</sup> In some case a third local optimization stage is added to the planarization process, in which edges with many crossings are removed and re-added in an attempt to improve the planarization.<sup class="reference" id="cite_ref-gdh_1-2">[1]</sup>
</p>
<h2><span class="mw-headline" id="Finding_the_largest_planar_subgraph">Finding the largest planar subgraph</span><span class="mw-editsection"></span></h2>
<p>Using incremental planarization for graph drawing is most effective when the first step of the process finds as large a planar graph as possible. Unfortunately, finding the planar subgraph with the maximum possible number of edges (the <i>maximum planar subgraph</i> problem<sup class="reference" id="cite_ref-chimani_3-0">[3]</sup>) is NP-hard, and MaxSNP-hard, implying that there probably does not exist a polynomial time algorithm that solves the problem exactly or that approximates it arbitrarily well.<sup class="reference" id="cite_ref-cffk_4-0">[4]</sup>
</p><p>In an <i>n</i>-vertex connected graph, the largest planar subgraph has at most 3<i>n</i> − 6 edges, and any spanning tree forms a planar subgraph with <i>n</i> − 1 edges. Thus, it is easy to approximate the maximum planar subgraph within an approximation ratio of one-third, simply by finding a spanning tree. A better approximation ratio, 9/4, is known, based on a method for finding a large partial 2-tree as a subgraph of the given graph.<sup class="reference" id="cite_ref-gdh_1-3">[1]</sup><sup class="reference" id="cite_ref-cffk_4-1">[4]</sup> Alternatively, if it is expected that the planar subgraph will include almost all of the edges of the given graph, leaving only a small number <i>k</i> of non-planar edges for the incremental planarization process, then one can solve the problem exactly by using a fixed-parameter tractable algorithm whose running time is linear in the graph size but non-polynomial in the parameter <i>k</i>.<sup class="reference" id="cite_ref-5">[5]</sup> The problem may also be solved exactly by a branch and cut algorithm, with no guarantees on running time, but with good performance in practice.<sup class="reference" id="cite_ref-gdh_1-4">[1]</sup><sup class="reference" id="cite_ref-6">[6]</sup> This parameter <i>k</i> is known as the <b>skewness</b> of the graph.<sup class="reference" id="cite_ref-chimani_3-1">[3]</sup><sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>There has also been some study of a related problem, finding the largest planar induced subgraph of a given graph. Again, this is NP-hard, but fixed-parameter tractable when all but a few vertices belong to the induced subgraph.<sup class="reference" id="cite_ref-8">[8]</sup> Edwards &amp; Farr (2002) proved a tight bound of 3<i>n</i>/(Δ + 1) on the size of the largest planar induced subgraph, as a function of <i>n</i>, the number of vertices in the given graph, and Δ, its maximum degree; their proof leads to a polynomial time algorithm for finding an induced subgraph of this size.<sup class="reference" id="cite_ref-9">[9]</sup>
</p>
<h2><span class="mw-headline" id="Adding_edges_to_a_planarization">Adding edges to a planarization</span><span class="mw-editsection"></span></h2>
<p>Once a large planar subgraph has been found, the incremental planarization process continues by considering the remaining edges one by one. As it does so, it maintains a planarization of the subgraph formed by the edges that have already been considered. It adds each new edge to a planar embedding of this subgraph, forming a drawing with crossings, and then replaces each crossing point with a new artificial vertex subdividing the two edges that cross.<sup class="reference" id="cite_ref-gdh_1-5">[1]</sup><sup class="reference" id="cite_ref-gda_2-2">[2]</sup> In some versions of this procedure, the order for adding edges is arbitrary, but it is also possible to choose the ordering to be a random permutation, running the same algorithm several times and returning the best planarization that it finds.<sup class="reference" id="cite_ref-gdh_1-6">[1]</sup>
</p><p>In the simplest form of this process, the planar embedding of the planarized subgraph is not allowed to change while new edges are added. In order to add each new edge in a way that minimizes the number of crossings it forms, one can use a shortest path algorithm in the dual graph of the current embedding, in order to find the shortest sequence of faces of the embedding and edges to be crossed that connects the endpoints of the new edge to each other. This process takes polynomial time per edge.<sup class="reference" id="cite_ref-gda_2-3">[2]</sup>
</p><p>Fixing the embedding of the planarized subgraph is not necessarily optimal in terms of the number of crossings that result. In fact, there exist graphs that are formed by adding one edge to a planar subgraph, where the optimal drawing has only two crossings but where fixing the planar embedding of the subgraph forces a linear number of crossings to be created.<sup class="reference" id="cite_ref-gdh_1-7">[1]</sup> As a compromise between finding the optimal planarization of a planar subgraph plus one edge, and keeping a fixed embedding, it is possible to search over all embeddings of the planarized subgraph and find the one that minimizes the number of crossings formed by the new edge.<sup class="reference" id="cite_ref-gdh_1-8">[1]</sup><sup class="reference" id="cite_ref-10">[10]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2373
Cached time: 20221224003258
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.181 seconds
Real time usage: 0.239 seconds
Preprocessor visited node count: 889/1000000
Post‐expand include size: 22516/2097152 bytes
Template argument size: 578/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 34486/5000000 bytes
Lua time usage: 0.111/10.000 seconds
Lua memory usage: 5634667/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  220.500      1 -total
 60.18%  132.702      1 Template:Reflist
 43.41%   95.711      9 Template:Citation
 23.53%   51.892      1 Template:Short_description
 12.55%   27.669      1 Template:Harvtxt
 11.96%   26.368      2 Template:Pagetype
  7.23%   15.940      3 Template:Main_other
  6.48%   14.288      1 Template:Mathworld
  6.48%   14.287      1 Template:SDcat
  0.91%    2.016      1 Template:Short_description/lowercasecheck
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:43170363-0!canonical and timestamp 20221224003258 and revision id 1102259894.
 -->
</div></body>
</html>