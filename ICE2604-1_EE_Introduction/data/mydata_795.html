<!DOCTYPE html>
<html>
<head>
<title>probabilistically_checkable_proof</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_footnotes plainlinks metadata ambox ambox-style ambox-More_footnotes" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computational complexity theory, a <b>probabilistically checkable proof</b> (<b>PCP</b>) is a type of proof that can be checked by a randomized algorithm using a bounded amount of randomness and reading a bounded number of bits of the proof. The algorithm is then required to accept correct proofs and reject incorrect proofs with very high probability. A standard proof (or certificate), as used in the verifier-based definition of the complexity class NP, also satisfies these requirements, since the checking procedure deterministically reads the whole proof, always accepts correct proofs and rejects incorrect proofs. However, what makes them interesting is the existence of probabilistically checkable proofs that can be checked by reading only a few bits of the proof using randomness in an essential way.
</p><p>Probabilistically checkable proofs give rise to many complexity classes depending on the number of queries required and the amount of randomness used. The class <b>PCP</b>[<i>r</i>(<i>n</i>),<i>q</i>(<i>n</i>)] refers to the set of decision problems that have probabilistically checkable proofs that can be verified in polynomial time using at most <i>r</i>(<i>n</i>) random bits and by reading at most <i>q</i>(<i>n</i>) bits of the proof.<sup class="reference" id="cite_ref-ab07_1-0">[1]</sup> Unless specified otherwise, correct proofs should always be accepted, and incorrect proofs should be rejected with probability greater than 1/2. The PCP theorem, a major result in computational complexity theory, states that <b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b>.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>Given a decision problem <i>L</i> (or a language L with its alphabet set Σ), a <b>probabilistically checkable proof system</b> for <i>L</i> with  completeness <i>c</i>(<i>n</i>) and soundness <i>s</i>(<i>n</i>), where 0 ≤ <i>s</i>(<i>n</i>) ≤ <i>c</i>(<i>n</i>) ≤ 1, consists of a prover and a verifier. Given a claimed solution x with length n, which might be false, the prover produces a proof <i>π</i> which states <i>x</i> solves L (<i>x</i> ∈ <i>L</i>, the proof is a string  ∈ Σ<sup>*</sup>). And the verifier is a randomized oracle Turing Machine <i>V</i> (the <i>verifier</i>) that checks the proof <i>π</i> for the statement that <i>x</i> solves <i>L</i>(or <i>x</i> ∈ <i>L</i>) and decides whether to accept the statement. The system has the following properties:
</p>
<ul><li><b>Completeness</b>: For any <i>x</i> ∈ <i>L</i>, given the proof <i>π</i> produced by the prover of the system, the verifier accepts the statement with probability at least <i>c</i>(<i>n</i>),</li>
<li><b>Soundness</b>: For any <i>x</i> ∉ <i>L</i>, then for any proof <i>π</i>, the verifier mistakenly accepts the statement with probability at most <i>s</i>(<i>n</i>).</li></ul>
<p>For the computational complexity of the verifier, we have the <i>randomness complexity</i> <i>r</i>(<i>n</i>) to measure the maximum number of random bits that <i>V</i> uses over all <i>x</i> of length <i>n</i> and the <i>query complexity</i> <i>q</i>(<i>n</i>) of the verifier is the maximum number of queries that <i>V</i> makes to π over all <i>x</i> of length <i>n</i>.
</p><p>In the above definition, the length of proof is not mentioned since usually it includes the alphabet set and all the witnesses. For the prover, we do not care how it arrives at the solution to the problem; we care only about the proof it gives of the solution's membership in the language.
</p><p>The verifier is said to be <i>non-adaptive</i> if it makes all its queries before it receives any of the answers to previous queries.
</p><p>The complexity class <b>PCP</b><sub><i>c</i>(<i>n</i>), <i>s</i>(<i>n</i>)</sub>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] is the class of all decision problems having probabilistically checkable proof systems over binary alphabet of completeness <i>c</i>(<i>n</i>) and soundness <i>s</i>(<i>n</i>), where the verifier is nonadaptive, runs in polynomial time, and it has randomness complexity <i>r</i>(<i>n</i>) and query complexity <i>q</i>(<i>n</i>).
</p><p>The shorthand notation <b>PCP</b>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] is sometimes used for <b>PCP</b><sub>1, ½</sub>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)].  The complexity class <b>PCP</b> is defined as <b>PCP</b><sub>1, ½</sub>[O(log <i>n</i>), O(1)].
</p>
<h2><span class="mw-headline" id="History_and_significance">History and significance</span><span class="mw-editsection"></span></h2>
<p>The theory of probabilistically checkable proofs studies the power of probabilistically checkable proof systems under various restrictions of the parameters (completeness, soundness, randomness complexity, query complexity, and alphabet size).  It has applications to computational complexity (in particular hardness of approximation) and cryptography.
</p><p>The definition of a probabilistically checkable proof was explicitly introduced by Arora and Safra in 1992,<sup class="reference" id="cite_ref-as92_2-0">[2]</sup> although their properties were studied earlier.  In 1990 Babai, Fortnow, and Lund proved that <b>PCP</b>[poly(<i>n</i>), poly(<i>n</i>)] = <b>NEXP</b>, providing the first nontrivial equivalence between standard proofs (<b>NEXP</b>) and probabilistically checkable proofs.<sup class="reference" id="cite_ref-bfl90_3-0">[3]</sup>  The PCP theorem proved in 1992 states that <b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b>.<sup class="reference" id="cite_ref-as92_2-1">[2]</sup><sup class="reference" id="cite_ref-almss_4-0">[4]</sup>
</p><p>The theory of hardness of approximation requires a detailed understanding of the role of completeness, soundness, alphabet size, and query complexity in probabilistically checkable proofs.
</p>
<h2><span class="mw-headline" id="Properties">Properties</span><span class="mw-editsection"></span></h2>
<p>From computational complexity point of view, for extreme settings of the parameters, the definition of probabilistically checkable proofs is easily seen to be equivalent to standard complexity classes.  For example, we have the following for different setting of <b>PCP</b>[r(n), q(n)]:
</p>
<ul><li><b>PCP</b>[0, 0] = <b>P</b> (<b>P</b> is defined to have no randomness and no access to a proof.)</li>
<li><b>PCP</b>[O(log(<i>n</i>)), 0] = <b>P</b> (A logarithmic number of random bits doesn't help a polynomial time Turing machine, since it could try all possibly random strings of logarithmic length in polynomial time.)</li>
<li><b>PCP</b>[0,O(log(<i>n</i>))] = <b>P</b> (Without randomness, the proof can be thought of as a fixed logarithmic sized string. A polynomial time machine could try all possible logarithmic sized proofs in polynomial time.)</li>
<li><b>PCP</b>[poly(<i>n</i>), 0] = <b>coRP</b> (By definition of <b>coRP</b>.)</li>
<li><b>PCP</b>[0, poly(<i>n</i>)] = <b>NP</b> (By the verifier-based definition of NP.)</li></ul>
<p>The PCP theorem and MIP = NEXP can be characterized as follows:
</p>
<ul><li><b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b> (the PCP theorem)</li>
<li><b>PCP</b>[poly(<i>n</i>),O(1)] = <b>PCP</b>[poly(<i>n</i>),poly(<i>n</i>)] = <b>NEXP</b> (MIP = NEXP).</li></ul>
<p>It is also known that <b>PCP</b>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] ⊆ NTIME(poly(n,2<sup>O(<i>r</i>(<i>n</i>))</sup><i>q</i>(<i>n</i>))).  
In particular, <b>PCP</b>[log <i>n</i>, poly(<i>n</i>)] = <b>NP</b>. 
On the other hand, if <b>NP</b> ⊆ <b>PCP</b>[o(log <i>n</i>),o(log <i>n</i>)] then P = NP.<sup class="reference" id="cite_ref-as92_2-2">[2]</sup>
</p>
<h2><span class="mw-headline" id="Linear_PCP">Linear PCP</span><span class="mw-editsection"></span></h2>
<p>A Linear PCP is a PCP in which the proof is a vector of elements of a finite field <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \pi \in \mathbb {F} ^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>π<!-- π --></mi>
<mo>∈<!-- ∈ --></mo>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">F</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \pi \in \mathbb {F} ^{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \pi \in \mathbb {F} ^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/860017463a2271dd0487dc61969924c246cea777" style="vertical-align: -0.338ex; width:6.811ex; height:2.343ex;"/></span>, and such that the PCP oracle is only allowed to do linear operations on the proof. Namely, the response from the oracle to a verifier query <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle q\in \mathbb {F} ^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>q</mi>
<mo>∈<!-- ∈ --></mo>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">F</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle q\in \mathbb {F} ^{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle q\in \mathbb {F} ^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a32dba33b263ce768c1b615355c208934699582b" style="vertical-align: -0.671ex; width:6.549ex; height:2.676ex;"/></span> is a linear function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(q,\pi )}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mi>π<!-- π --></mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(q,\pi )}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(q,\pi )}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b2d56033e5d4b6bf1e8021ae3557dea3737437c8" style="vertical-align: -0.838ex; width:6.523ex; height:2.843ex;"/></span>. Linear PCPs have important applications in proof systems that can be compiled into SNARKs.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Interactive proof systems</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Holographic proof at the Encyclopedia of Mathematics</li>
<li>PCP course notes by Subhash Khot at the New York University, 2008.</li>
<li>PCP course notes and A history of the PCP theorem by Ryan O'Donnell and Venkatesan Guruswami from the University of Washington, 2005.</li>
<li><i>Complexity Zoo</i>: PCP</li></ul>

<!-- 
NewPP limit report
Parsed by mw1477
Cached time: 20221220212549
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.295 seconds
Real time usage: 0.373 seconds
Preprocessor visited node count: 1905/1000000
Post‐expand include size: 26067/2097152 bytes
Template argument size: 413/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 19396/5000000 bytes
Lua time usage: 0.164/10.000 seconds
Lua memory usage: 3824266/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  297.533      1 -total
 40.75%  121.238      1 Template:Reflist
 33.31%   99.117      4 Template:Citation
 23.16%   68.894      1 Template:More_footnotes
 19.73%   58.703      1 Template:ComplexityClasses
 18.76%   55.823      1 Template:Navbox
 16.42%   48.861      1 Template:Ambox
 15.43%   45.908      5 Template:R
 12.73%   37.866      6 Template:R/ref
  5.57%   16.576      6 Template:R/superscript
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:504509-0!canonical and timestamp 20221220212549 and revision id 1077794443.
 -->
</div></body>
</html>