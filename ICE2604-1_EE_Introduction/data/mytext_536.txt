Kraft's_inequalityIn coding theory, the Kraft–McMillan inequality gives a necessary and sufficient condition for the existence of a prefix code[1] (in Leon G. Kraft's version) or a uniquely decodable code (in Brockway McMillan's version) for a given set of codeword lengths. Its applications to prefix codes and trees often find use in computer science and information theory.Kraft's inequality was published in Kraft (1949). However, Kraft's paper discusses only prefix codes, and attributes the analysis leading to the inequality to Raymond Redheffer. The result was independently discovered in McMillan (1956). McMillan proves the result for the general case of uniquely decodable codes, and attributes the version for prefix codes to a spoken observation in 1955 by Joseph Leo Doob.Kraft's inequality limits the lengths of codewords in a prefix code: if one takes an exponential of the length of each valid codeword, the resulting set of values must look like a probability mass function, that is, it must have total measure less than or equal to one. Kraft's inequality can be thought of in terms of a constrained budget to be spent on codewords, with shorter codewords being more expensive. Among the useful properties following from the inequality are the following statements:If Kraft's inequality holds with strict inequality, the code has some redundancy.If Kraft's inequality holds with equality, the code in question is a complete code.[2]If Kraft's inequality does not hold, the code is not uniquely decodable.For every uniquely decodable code, there exists a prefix code with the same length distribution.Let each source symbol from the alphabetbe encoded into a uniquely decodable code over an alphabet of size  with codeword lengthsThenConversely, for a given set of natural numbers  satisfying the above inequality, there exists a uniquely decodable code over an alphabet of size  with those codeword lengths.Any binary tree can be viewed as defining a prefix code for the leaves of the tree. Kraft's inequality states thatHere the sum is taken over the leaves of the tree, i.e. the nodes without any children. The depth is the distance to the root node. In the tree to the right, this sum isFirst, let us show that the Kraft inequality holds whenever the code for  is a prefix code.Suppose that . Let  be the full -ary tree of depth  (thus, every node of  at level  has  children, while the nodes at level  are leaves). Every word of length  over an -ary alphabet corresponds to a node in this tree at depth . The th word in the prefix code corresponds to a node ; let  be the set of all leaf nodes (i.e. of nodes at depth ) in the subtree of  rooted at . That subtree being of height , we haveSince the code is a prefix code, those subtrees cannot share any leaves, which means thatThus, given that the total number of nodes at depth  is , we havefrom which the result follows.Conversely, given any ordered sequence of  natural numbers,satisfying the Kraft inequality, one can construct a prefix code with codeword lengths equal to each  by choosing a word of length  arbitrarily, then ruling out all words of greater length that have it as a prefix. There again, we shall interpret this in terms of leaf nodes of an -ary tree of depth .  First choose any node from the full tree at depth ; it corresponds to the first word of our new code. Since we are building a prefix code, all the descendants of this node (i.e., all words that have this first word as a prefix) become unsuitable for inclusion in the code. We consider the descendants at depth  (i.e., the leaf nodes among the descendants); there are   such descendant nodes that are removed from consideration. The next iteration picks a (surviving) node at depth  and removes  further leaf nodes, and so on.  After  iterations, we have removed a total ofnodes. The question is whether we need to remove more leaf nodes than we actually have available —  in all — in the process of building the code. Since the Kraft inequality holds, we have indeedand thus a prefix code can be built. Note that as the choice of nodes at each step is largely arbitrary, many different suitable prefix codes can be built, in general.Now we will prove that the Kraft inequality holds whenever  is a uniquely decodable code. (The converse needs not be proven, since we have already proven it for prefix codes, which is a stronger claim.)Denote . The idea of the proof is to get an upper bound on  for  and show that it can only hold for all  if . Rewrite  asConsider all m-powers , in the form of words , where  are indices between 1 and . Note that, since S was assumed to uniquely decodable, implies . This means that each summand corresponds to exactly one word in . This allows us to rewrite the equation towhere  is the number of codewords in  of length  and  is the length of the longest codeword in . For an -letter alphabet there are only  possible words of length , so . Using this, we upper bound :Taking the -th root, we getThis bound holds for any . The right side is 1 asymptotically, so  must hold (otherwise the inequality would be broken for a large enough ).Given a sequence of  natural numbers,satisfying the Kraft inequality, we can construct a prefix code as follows.  Define the ith codeword, Ci, to be the first  digits after the radix point (e.g. decimal point) in the base r representation ofNote that by Kraft's inequality, this sum is never more than 1.  Hence the codewords capture the entire value of the sum.  Therefore, for j &gt; i, the first  digits of Cj form a larger number than Ci, so the code is prefix free.Kraft, Leon G. (1949), A device for quantizing, grouping, and coding amplitude modulated pulses, Cambridge, MA: MS Thesis, Electrical Engineering Department, Massachusetts Institute of Technology, hdl:1721.1/12390.McMillan, Brockway (1956), "Two inequalities implied by unique decipherability", IEEE Trans. Inf. Theory, 2 (4): 115–116, doi:10.1109/TIT.1956.1056818.Chaitin's constantCanonical Huffman code