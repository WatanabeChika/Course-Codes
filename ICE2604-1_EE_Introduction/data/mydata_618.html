<!DOCTYPE html>
<html>
<head>
<title>min-heap_property</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In computer science, a <b>heap</b> is a specialized tree-based data structure which is essentially an almost complete<sup class="reference" id="cite_ref-1">[1]</sup> tree that satisfies the <b>heap property</b>: in a <i>max heap</i>, for any given node C, if P is a parent node of C, then the <i>key</i> (the <i>value</i>) of P is greater than or equal to the key of C. In a <i>min heap</i>, the key of P is less than or equal to the key of C.<sup class="reference" id="cite_ref-2">[2]</sup> The node at the "top" of the heap (with no parents) is called the <i>root</i> node.
</p><p>The heap is one maximally efficient implementation of an abstract data type called a priority queue, and in fact, priority queues are often referred to as "heaps", regardless of how they may be implemented. In a heap, the highest (or lowest) priority element is always stored at the root. However, a heap is not a sorted structure; it can be regarded as being partially ordered. A heap is a useful data structure when it is necessary to repeatedly remove the object with the highest (or lowest) priority, or when insertions need to be interspersed with removals of the root node.
</p><p>A common implementation of a heap is the binary heap, in which the tree is a binary tree (see figure). The heap data structure, specifically the binary heap, was introduced by J. W. J. Williams in 1964, as a data structure for the heapsort sorting algorithm.<sup class="reference" id="cite_ref-3">[3]</sup> Heaps are also crucial in several efficient graph algorithms such as Dijkstra's algorithm. When a heap is a complete binary tree, it has a smallest possible height—a heap with <i>N</i> nodes and <i>a</i> branches for each node always has log<sub><i>a</i></sub> <i>N</i> height.
</p><p>Note that, as shown in the graphic, there is no implied ordering between siblings or cousins and no implied sequence for an in-order traversal (as there would be in, e.g., a binary search tree). The heap relation mentioned above applies only between nodes and their parents, grandparents, etc. The maximum number of children each node can have depends on the type of heap.
</p>

<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<p>The common operations involving heaps are:
</p>
<dl><dt>Basic</dt></dl>
<ul><li><i>find-max</i> (or <i>find-min</i>): find a maximum item of a max-heap, or a minimum item of a min-heap, respectively (a.k.a. <i>peek</i>)</li>
<li><i>insert</i>: adding a new key to the heap (a.k.a., <i>push</i><sup class="reference" id="cite_ref-4">[4]</sup>)</li>
<li><i>extract-max</i> (or <i>extract-min</i>): returns the node of maximum value from a max heap [or minimum value from a min heap] after removing it from the heap (a.k.a., <i>pop</i><sup class="reference" id="cite_ref-5">[5]</sup>)</li>
<li><i>delete-max</i> (or <i>delete-min</i>): removing the root node of a max heap (or min heap), respectively</li>
<li><i>replace</i>: pop root and push a new key. More efficient than pop followed by push, since only need to balance once, not twice, and appropriate for fixed-size heaps.<sup class="reference" id="cite_ref-6">[6]</sup></li></ul>
<dl><dt>Creation</dt></dl>
<ul><li><i>create-heap</i>: create an empty heap</li>
<li><i>heapify</i>: create a heap out of given array of elements</li>
<li><i>merge</i> (<i>union</i>): joining two heaps to form a valid new heap containing all the elements of both, preserving the original heaps.</li>
<li><i>meld</i>: joining two heaps to form a valid new heap containing all the elements of both, destroying the original heaps.</li></ul>
<dl><dt>Inspection</dt></dl>
<ul><li><i>size</i>: return the number of items in the heap.</li>
<li><i>is-empty</i>: return true if the heap is empty, false otherwise.</li></ul>
<dl><dt>Internal</dt></dl>
<ul><li><i>increase-key</i> or <i>decrease-key</i>: updating a key within a max- or min-heap, respectively</li>
<li><i>delete</i>: delete an arbitrary node (followed by moving last node and sifting to maintain heap)</li>
<li><i>sift-up</i>: move a node up in the tree, as long as needed; used to restore heap condition after insertion. Called "sift" because node moves up the tree until it reaches the correct level, as in a sieve.</li>
<li><i>sift-down</i>: move a node down in the tree, similar to sift-up; used to restore heap condition after deletion or replacement.</li></ul>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>Heaps are usually implemented with an array, as follows:
</p>
<ul><li>Each element in the array represents a node of the heap, and</li>
<li>The parent / child relationship is defined implicitly by the elements' indices in the array.</li></ul>

<p>For a binary heap, in the array, the first index contains the root element. The next two indices of the array contain the root's children. The next four indices contain the four children of the root's two child nodes, and so on. Therefore, given a node at index <span class="texhtml mvar" style="font-style:italic;">i</span>, its children are at indices <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i+1}</annotation>
</semantics>
</math></span><img alt="2i+1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" style="vertical-align: -0.505ex; width:5.968ex; height:2.343ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2i+2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>i</mi>
<mo>+</mo>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2i+2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2i+2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a756deaef520ee23fe2b1232c90957f55ec9d92b" style="vertical-align: -0.505ex; width:5.968ex; height:2.343ex;"/></span>, and its parent is at index <span class="texhtml">⌊(<i>i</i>−1)/2⌋</span>. This simple indexing scheme makes it efficient to move "up" or "down" the tree.
</p><p>Balancing a heap is done by sift-up or sift-down operations (swapping elements which are out of order). As we can build a heap from an array without requiring extra memory (for the nodes, for example), heapsort can be used to sort an array in-place.
</p><p>After an element is inserted into or deleted from a heap, the heap property may be violated, and the heap must be re-balanced by swapping elements within the array.
</p><p>Although different type of heaps implement the operations differently, the most common way is as follows:
</p>
<ul><li><b>Insertion:</b> Add the new element at the end of the heap, in the first available free space. If this will violate the heap property, sift up the new element (<i>swim</i> operation) until the heap property has been reestablished.</li>
<li><b>Extraction:</b> Remove the root and insert the last element of the heap in the root. If this will violate the heap property, sift down the new root (<i>sink</i> operation) to reestablish the heap property.</li>
<li><b>Replacement:</b> Remove the root and put the <i>new</i> element in the root and sift down. When compared to extraction followed by insertion, this avoids a sift up step.</li></ul>
<p>Construction of a binary (or <i>d</i>-ary) heap out of a given array of elements may be performed in linear time using the classic Floyd algorithm, with the worst-case number of comparisons equal to 2<i>N</i> − 2<i>s</i><sub>2</sub>(<i>N</i>) − <i>e</i><sub>2</sub>(<i>N</i>) (for a binary heap), where <i>s</i><sub>2</sub>(<i>N</i>) is the sum of all digits of the binary representation of <i>N</i> and <i>e</i><sub>2</sub>(<i>N</i>) is the exponent of 2 in the prime factorization of <i>N</i>.<sup class="reference" id="cite_ref-7">[7]</sup> This is faster than a sequence of consecutive insertions into an originally empty heap, which is log-linear.<sup class="reference" id="cite_ref-8">[a]</sup>
</p>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Comparison_of_theoretic_bounds_for_variants">Comparison of theoretic bounds for variants</span><span class="mw-editsection"></span></h2>
<p>Here are time complexities<sup class="reference" id="cite_ref-CLRS_9-0">[8]</sup> of various heap data structures. Function names assume a max-heap.  For the meaning of "<i>O</i>(<i>f</i>)" and "<i>Θ</i>(<i>f</i>)" see Big O notation.
</p>
<table class="wikitable">
<tbody><tr>
<th>Operation
</th>
<th>find-max
</th>
<th>delete-max
</th>
<th>insert
</th>
<th>increase-key
</th>
<th>meld
</th></tr>
<tr>
<th>Binary<sup class="reference" id="cite_ref-CLRS_9-1">[8]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ffdddd"><i>Θ</i>(<i>n</i>)
</td></tr>
<tr>
<th>Leftist
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td></tr>
<tr>
<th>Binomial<sup class="reference" id="cite_ref-CLRS_9-2">[8]</sup><sup class="reference" id="cite_ref-10">[9]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)<sup class="reference" id="cite_ref-amortized_11-0">[b]</sup>
</td>
<td style="background:#ffffdd"><i>Θ</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-meld_12-0">[c]</sup>
</td></tr>
<tr>
<th>Fibonacci<sup class="reference" id="cite_ref-CLRS_9-3">[8]</sup><sup class="reference" id="cite_ref-Fredman_And_Tarjan_13-0">[10]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-1">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)<sup class="reference" id="cite_ref-amortized_11-2">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td></tr>
<tr>
<th>Pairing<sup class="reference" id="cite_ref-Iacono_14-0">[11]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-3">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>o</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-4">[b]</sup><sup class="reference" id="cite_ref-pairingdecreasekey_17-0">[d]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td></tr>
<tr>
<th>Brodal<sup class="reference" id="cite_ref-18">[14]</sup><sup class="reference" id="cite_ref-brodal_20-0">[e]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td></tr>
<tr>
<th>Rank-pairing<sup class="reference" id="cite_ref-21">[16]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-5">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)<sup class="reference" id="cite_ref-amortized_11-6">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td></tr>
<tr>
<th>Strict Fibonacci<sup class="reference" id="cite_ref-22">[17]</sup>
</th>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td></tr>
<tr>
<th>2–3 heap<sup class="reference" id="cite_ref-23">[18]</sup>
</th>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-7">[b]</sup>
</td>
<td style="background:#ffffdd"><i>O</i>(log <i>n</i>)<sup class="reference" id="cite_ref-amortized_11-8">[b]</sup>
</td>
<td style="background:#ddffdd"><i>Θ</i>(1)
</td>
<td style="background:#ffffdd"><i>?</i>
</td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>The heap data structure has many applications.
</p>
<ul><li>Heapsort: One of the best sorting methods being in-place and with no quadratic worst-case scenarios.</li>
<li>Selection algorithms: A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.<sup class="reference" id="cite_ref-24">[19]</sup></li>
<li>Graph algorithms: By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are Prim's minimal-spanning-tree algorithm and Dijkstra's shortest-path algorithm.</li>
<li>Priority Queue: A priority queue is an abstract concept like "a list" or "a map"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods.</li>
<li>K-way merge: A heap data structure is useful to merge many already-sorted input streams into a single sorted output stream. Examples of the need for merging include external sorting and streaming results from distributed data such as a log structured merge tree. The inner loop is obtaining the min element, replacing with the next element for the corresponding input stream, then doing a sift-down heap operation. (Alternatively the replace function.) (Using extract-max and insert functions of a priority queue are much less efficient.)</li>
<li>Order statistics: The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array.</li></ul>
<h2><span class="mw-headline" id="Programming_language_implementations">Programming language implementations</span><span class="mw-editsection"></span></h2>
<ul><li>The C++ Standard Library provides the <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">make_heap</span>, <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">push_heap</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">pop_heap</span> algorithms for heaps (usually implemented as binary heaps), which operate on arbitrary random access iterators. It treats the iterators as a reference to an array, and uses the array-to-heap conversion. It also provides the container adaptor <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">priority_queue</span>, which wraps these facilities in a container-like class. However, there is no standard support for the replace, sift-up/sift-down, or decrease/increase-key operations.</li>
<li>The Boost C++ libraries include a heaps library. Unlike the STL, it supports decrease and increase operations, and supports additional types of heap: specifically, it supports <i>d</i>-ary, binomial, Fibonacci, pairing and skew heaps.</li>
<li>There is a generic heap implementation for C and C++ with D-ary heap and B-heap support. It provides an STL-like API.</li>
<li>The standard library of the D programming language includes <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">std.container.BinaryHeap</span>, which is implemented in terms of D's ranges. Instances can be constructed from any random-access range. <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">BinaryHeap</span> exposes an input range interface that allows iteration with D's built-in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">foreach</span> statements and integration with the range-based API of the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">std.algorithm</span> package.</li>
<li>For Haskell there is the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">Data.Heap</span> module.</li>
<li>The Java platform (since version 1.5) provides a binary heap implementation with the class <code>java.util.PriorityQueue</code> in the Java Collections Framework. This class implements by default a min-heap; to implement a max-heap, programmer should write a custom comparator. There is no support for the replace, sift-up/sift-down, or decrease/increase-key operations.</li>
<li>Python has a <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">heapq</span> module that implements a priority queue using a binary heap. The library exposes a heapreplace function to support k-way merging.</li>
<li>PHP has both max-heap (<link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">SplMaxHeap</span>) and min-heap (<link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">SplMinHeap</span>) as of version 5.3 in the Standard PHP Library.</li>
<li>Perl has implementations of binary, binomial, and Fibonacci heaps in the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">Heap</span> distribution available on CPAN.</li>
<li>The Go language contains a <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">heap</span> package with heap algorithms that operate on an arbitrary type that satisfies a given interface. That package does not support the replace, sift-up/sift-down, or decrease/increase-key operations.</li>
<li>Apple's Core Foundation library contains a <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">CFBinaryHeap</span> structure.</li>
<li>Pharo has an implementation of a heap in the Collections-Sequenceable package along with a set of test cases. A heap is used in the implementation of the timer event loop.</li>
<li>The Rust programming language has a binary max-heap implementation, <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">BinaryHeap</span>, in the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">collections</span> module of its standard library.</li>
<li>.NET has PriorityQueue class which uses quarternary (d-ary) min-heap implementation. It is available from .NET 6.</li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Sorting algorithm</li>
<li>Search data structure</li>
<li>Stack (abstract data type)</li>
<li>Queue (abstract data type)</li>
<li>Tree (data structure)</li>
<li>Treap, a form of binary search tree based on heap-ordered trees</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<link href="mw-data:TemplateStyles:r1097025294" rel="mw-deduplicated-inline-style"/>
<ul><li>Heap at Wolfram MathWorld</li>
<li>Explanation of how the basic heap algorithms work</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBentley2000">Bentley, Jon Louis (2000). <i>Programming Pearls</i> (2nd ed.). Addison Wesley. pp. 147–162. ISBN <bdi>0201657880</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Programming+Pearls&amp;rft.pages=147-162&amp;rft.edition=2nd&amp;rft.pub=Addison+Wesley&amp;rft.date=2000&amp;rft.isbn=0201657880&amp;rft.aulast=Bentley&amp;rft.aufirst=Jon+Louis&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AHeap+%28data+structure%29"></span></li></ul>


<!-- 
NewPP limit report
Parsed by mw2325
Cached time: 20221223230703
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.348 seconds
Real time usage: 0.711 seconds
Preprocessor visited node count: 2682/1000000
Post‐expand include size: 74302/2097152 bytes
Template argument size: 3749/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 69081/5000000 bytes
Lua time usage: 0.176/10.000 seconds
Lua memory usage: 5565611/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  361.782      1 -total
 41.76%  151.082      2 Template:Reflist
 20.50%   74.161      4 Template:Cite_book
 12.79%   46.269      1 Template:Short_description
 11.96%   43.266      2 Template:Navbox
 11.83%   42.814      1 Template:CS-Trees
 11.47%   41.482      2 Template:Sister_project
 11.10%   40.148      1 Template:Commons_category
 11.01%   39.817      2 Template:Side_box
  8.02%   29.024      1 Template:Heap_Running_Times
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:13996-0!canonical and timestamp 20221223230702 and revision id 1123923298.
 -->
</div></body>
</html>