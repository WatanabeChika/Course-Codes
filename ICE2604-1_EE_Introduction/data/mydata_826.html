<!DOCTYPE html>
<html>
<head>
<title>random_number_generator</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>

<p><b>Random number generation</b> is a process by which, often by means of a <b>random number generator</b> (<b>RNG</b>), a sequence of numbers or symbols that cannot be reasonably predicted better than by random chance is generated. This means that the particular outcome sequence will contain some patterns detectable in hindsight but unpredictable to foresight. True random number generators can be <i>hardware random-number generators</i> (HRNGS) that generate random numbers, wherein each generation is a function of the current value of a physical environment's attribute that is constantly changing in a manner that is practically impossible to model. This would be in contrast to so-called "random number generations" done by <i>pseudorandom number generators</i> (PRNGs) that generate numbers that only look random but are in fact pre-determined—these generations can be reproduced simply by knowing the state of the PRNG.
</p><p>Various applications of randomness have led to the development of several different methods for generating random data. Some of these have existed since ancient times, among whose ranks are well-known "classic" examples, including the rolling of dice, coin flipping, the shuffling of playing cards, the use of yarrow stalks (for divination) in the I Ching, as well as countless other techniques. Because of the mechanical nature of these techniques, generating large quantities of sufficiently random numbers (important in statistics) required much work and time. Thus, results would sometimes be collected and distributed as random number tables.
</p><p>Several computational methods for pseudorandom number generation exist. All fall short of the goal of true randomness, although they may meet, with varying success, some of the statistical tests for randomness intended to measure how unpredictable their results are (that is, to what degree their patterns are discernible). This generally makes them unusable for applications such as cryptography. However, carefully designed <i>cryptographically secure pseudorandom number generators</i> (CSPRNGS) also exist, with special features specifically designed for use in cryptography.
</p>

<h2><span class="mw-headline" id="Practical_applications_and_uses">Practical applications and uses</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Random number generators have applications in gambling, statistical sampling, computer simulation, cryptography, completely randomized design, and other areas where producing an unpredictable result is desirable.  Generally, in applications having unpredictability as the paramount feature, such as in security applications, hardware generators are generally preferred over pseudorandom algorithms, where feasible.
</p><p>Pseudorandom number generators are very useful in developing  Monte Carlo-method simulations, as debugging is facilitated by the ability to run the same sequence of random numbers again by starting from the same <i>random seed</i>. They are also used in cryptography – so long as the <i>seed</i> is secret. Sender and  receiver can generate the same set of numbers automatically to use as keys.
</p><p>The generation of pseudorandom numbers is an important and common task in computer programming. While cryptography and certain numerical algorithms require a very high degree of <i>apparent</i> randomness, many other operations only need a modest amount of unpredictability. Some simple examples might be presenting a user with a "random quote of the day", or determining which way a computer-controlled adversary might move in a computer game. Weaker forms of <i>randomness</i> are used in hash algorithms and in creating amortized searching and sorting algorithms.
</p><p>Some applications which appear at first sight to be suitable for randomization are in fact not quite so simple. For instance, a system that "randomly" selects music tracks for a background music system must only <i>appear</i> random, and may even have ways to control the selection of music: a true random system would have no restriction on the same item appearing two or three times in succession.
</p>
<h2><span id=".22True.22_vs._pseudo-random_numbers"></span><span class="mw-headline" id='"True"_vs._pseudo-random_numbers'>"True" vs. pseudo-random numbers</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>There are two principal methods used to generate random numbers. The first method measures some physical phenomenon that is expected to be random and then compensates for possible biases in the measurement process. Example sources include measuring atmospheric noise, thermal noise, and other external electromagnetic and quantum phenomena. For example, cosmic background radiation or radioactive decay as measured over short timescales represent sources of natural entropy.
</p><p>The speed at which entropy can be obtained from natural sources is dependent on the underlying physical phenomena being measured. Thus, sources of naturally occurring "true" entropy are said to be blocking –  they are rate-limited until enough entropy is harvested to meet the demand. On some Unix-like systems, including most Linux distributions, the pseudo device file <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">/dev/random</span> will block until sufficient entropy is harvested from the environment.<sup class="reference" id="cite_ref-1">[1]</sup> Due to this blocking behavior, large bulk reads from <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">/dev/random</span>, such as filling a hard disk drive with random bits, can often be slow on systems that use this type of entropy source.
</p><p>The second method uses computational algorithms that can produce long sequences of apparently random results, which are in fact completely determined by a shorter initial value, known as a seed value or key. As a result, the entire seemingly random sequence can be reproduced if the seed value is known. This type of random number generator is often called a pseudorandom number generator. This type of generator typically does not rely on sources of naturally occurring entropy, though it may be periodically seeded by natural sources. This generator type is non-blocking, so they are not rate-limited by an external event, making large bulk reads a possibility.
</p><p>Some systems take a hybrid approach, providing randomness harvested from natural sources when available, and falling back to periodically re-seeded software-based cryptographically secure pseudorandom number generators (CSPRNGs). The fallback occurs when the desired read rate of randomness exceeds the ability of the natural harvesting approach to keep up with the demand. This approach avoids the rate-limited blocking behavior of random number generators based on slower and purely environmental methods.
</p><p>While a pseudorandom number generator based solely on deterministic logic can never be regarded as a "true" random number source in the purest sense of the word, in practice they are generally sufficient even for demanding security-critical applications. Carefully designed and implemented pseudorandom number generators can be certified for security-critical cryptographic purposes, as is the case with the yarrow algorithm and fortuna. The former is the basis of the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">/dev/random</span> source of entropy on FreeBSD, AIX, OS X, NetBSD, and others. OpenBSD uses a pseudorandom number algorithm known as arc4random.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>
<h2><span class="mw-headline" id="Generation_methods">Generation methods</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Physical_methods">Physical methods</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The earliest methods for generating random numbers, such as dice, coin flipping and roulette wheels, are still used today, mainly in games and gambling as they tend to be too slow for most applications in statistics and cryptography.
</p><p>A physical random number generator can be based on an essentially random atomic or subatomic physical phenomenon whose unpredictability can be traced to the laws of quantum mechanics. Sources of entropy include radioactive decay, thermal noise, shot noise, avalanche noise in Zener diodes, clock drift, the timing of actual movements of a hard disk read-write head, and radio noise.  However, physical phenomena and tools used to measure them generally feature asymmetries and systematic biases that make their outcomes not uniformly random.  A randomness extractor, such as a cryptographic hash function, can be used to approach a uniform distribution of bits from a non-uniformly random source, though at a lower bit rate.
</p><p>The appearance of wideband photonic entropy sources, such as optical chaos and amplified spontaneous emission noise, greatly aid the development of the physical random number generator. Among them, optical chaos<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup> has a high potential to physically produce high-speed random numbers due to its high bandwidth and large amplitude. A prototype of a high speed, real-time physical random bit generator based on a chaotic laser was built in 2013.<sup class="reference" id="cite_ref-5">[5]</sup>
</p><p>Various imaginative ways of collecting this entropic information have been devised. One technique is to run a hash function against a frame of a video stream from an unpredictable source. Lavarand used this technique with images of a number of lava lamps. HotBits measures radioactive decay with Geiger–Muller tubes,<sup class="reference" id="cite_ref-6">[6]</sup> while Random.org uses variations in the amplitude of atmospheric noise recorded with a normal radio.
</p>

<p>Another common entropy source is the behavior of human users of the system. While people are not considered good randomness generators upon request, they generate random behavior quite well in the context of playing mixed strategy games.<sup class="reference" id="cite_ref-7">[7]</sup> Some security-related computer software requires the user to make a lengthy series of mouse movements or keyboard inputs to create sufficient entropy needed to generate random keys or to initialize pseudorandom number generators.<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<h3><span class="mw-headline" id="Computational_methods">Computational methods</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Most computer generated random numbers use PRNGs which are algorithms that can automatically create long runs of numbers with good random properties but eventually the sequence repeats (or the memory usage grows without bound). These random numbers are fine in many situations but are not as random as numbers generated from electromagnetic atmospheric noise used as a source of entropy.<sup class="reference" id="cite_ref-9">[9]</sup> The series of values generated by such algorithms is generally determined by a fixed number called a <i>seed</i>. One of the most common PRNG is the linear congruential generator, which uses the recurrence
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle X_{n+1}=(aX_{n}+b)\,{\textrm {mod}}\,m}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>X</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mi>a</mi>
<msub>
<mi>X</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo>+</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
<mspace width="thinmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mtext>mod</mtext>
</mrow>
</mrow>
<mspace width="thinmathspace"></mspace>
<mi>m</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle X_{n+1}=(aX_{n}+b)\,{\textrm {mod}}\,m}</annotation>
</semantics>
</math></span><img alt="X_{n+1} = (a X_n + b)\, \textrm{mod}\, m" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4595ec3472446db9f4a7e19f5902191034a91744" style="vertical-align: -0.838ex; width:25.567ex; height:2.843ex;"/></span></dd></dl>
<p>to generate numbers, where <span class="texhtml mvar" style="font-style:italic;">a</span>, <span class="texhtml mvar" style="font-style:italic;">b</span> and <span class="texhtml mvar" style="font-style:italic;">m</span> are large integers, and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle X_{n+1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>X</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle X_{n+1}}</annotation>
</semantics>
</math></span><img alt="X_{{n+1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4a5e2ebcd9ef3ffc3f45a5745884e0a46de672cf" style="vertical-align: -0.671ex; width:5.243ex; height:2.509ex;"/></span> is the next in <span class="texhtml mvar" style="font-style:italic;">X</span> as a series of pseudorandom numbers. The maximum number of numbers the formula can produce is the modulus, <span class="texhtml mvar" style="font-style:italic;">m</span>. The recurrence relation can be extended to matrices to have much longer periods and better statistical properties
.<sup class="reference" id="cite_ref-10">[10]</sup>
To avoid certain non-random properties of a single linear congruential generator, several such random number generators with slightly different values of the multiplier coefficient, <span class="texhtml mvar" style="font-style:italic;">a</span>, can be used in parallel, with a "master" random number generator that selects from among the several different generators.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (December 2009)">citation needed</span></i>]</sup>
</p><p>A simple pen-and-paper method for generating random numbers is the so-called middle-square method suggested by John von Neumann. While simple to implement, its output is of poor quality. It has a very short period and severe weaknesses, such as the output sequence almost always converging to zero.  A recent innovation is to combine the middle square with a Weyl sequence. This method produces high quality output through a long period.<sup class="reference" id="cite_ref-11">[11]</sup>
</p><p>Most computer programming languages include functions or library routines that provide random number generators. They are often designed to provide a random byte or word, or a floating point number uniformly distributed between 0 and 1.
</p><p>The quality i.e. randomness of such library functions varies widely from completely predictable output, to cryptographically secure. The default random number generator in many languages, including Python, Ruby, R, IDL and PHP is based on the Mersenne Twister algorithm and is <i>not</i> sufficient for cryptography purposes, as is explicitly stated in the language documentation. Such library functions often have poor statistical properties and some will repeat patterns after only tens of thousands of trials.  They are often initialized using a computer's real time clock as the seed, since such a clock is 64 bit and measures in nanoseconds, far beyond the person's precision. These functions may provide enough randomness for certain tasks (for example video games) but are unsuitable where high-quality randomness is required, such as in cryptography applications, statistics or numerical analysis.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="Why unsuitable for numerical analysis? (May 2014)">citation needed</span></i>]</sup>
</p><p>Much higher quality random number sources are available on most operating systems;  for example /dev/random on various BSD flavors, Linux, Mac OS X, IRIX, and Solaris, or CryptGenRandom for Microsoft Windows. Most programming languages, including those mentioned above, provide a means to access these higher quality sources.
</p>
<h3><span class="mw-headline" id="By_humans">By humans</span><span class="mw-editsection"></span></h3>
<p>Random number generation may also be performed by humans, in the form of collecting various inputs from end users and using them as a randomization source. However, most studies find that human subjects have some degree of non-randomness when attempting to produce a random sequence of e.g. digits or letters.  They may alternate too much between choices when compared to a good random generator;<sup class="reference" id="cite_ref-12">[12]</sup> thus, this approach is not widely used.
</p>
<h2><span class="mw-headline" id="Post-processing_and_statistical_checks">Post-processing and statistical checks</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Even given a source of plausible random numbers (perhaps from a quantum mechanically based hardware generator), obtaining numbers which are completely unbiased takes care. In addition, behavior of these generators often changes with temperature, power supply voltage, the age of the device, or other outside interference. And a software bug in a pseudorandom number routine, or a hardware bug in the hardware it runs on, may be similarly difficult to detect.
</p><p>Generated random numbers are sometimes subjected to statistical tests before use to ensure that the underlying source is still working, and then post-processed to improve their statistical properties. An example would be the TRNG9803<sup class="reference" id="cite_ref-13">[13]</sup> hardware random number generator, which uses an entropy measurement as a hardware test, and then post-processes the random sequence with a shift register stream cipher. It is generally hard to use statistical tests to validate the generated random numbers. Wang and Nicol<sup class="reference" id="cite_ref-14">[14]</sup> proposed a distance-based statistical testing technique that is used to identify the weaknesses of several random generators. Li and Wang<sup class="reference" id="cite_ref-15">[15]</sup> proposed a method of testing random numbers based on laser chaotic entropy sources using Brownian motion properties.
</p>
<h2><span class="mw-headline" id="Other_considerations">Other considerations</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Reshaping_the_distribution">Reshaping the distribution</span><span class="mw-editsection"></span></h3>
<h4><span class="mw-headline" id="Uniform_distributions">Uniform distributions</span><span class="mw-editsection"></span></h4>
<p>Most random number generators natively work with integers or individual bits, so an extra step is required to arrive at the "canonical" uniform distribution between 0 and 1. The implementation is not as trivial as dividing the integer by its maximum possible value. Specifically:<sup class="reference" id="cite_ref-16">[16]</sup><sup class="reference" id="cite_ref-17">[17]</sup>
</p>
<ol><li>The integer used in the transformation must provide enough bits for the intended precision.</li>
<li>The nature of floating-point math itself means there exists more precision the closer the number is to zero. This extra precision is usually not used due to the sheer number of bits required.</li>
<li>Rounding error in division may bias the result. At worst, a supposedly excluded bound may be drawn countrary to expectations based on real-number math.</li></ol>
<p>The mainstream algorithm, used by OpenJDK, Rust, and NumPy, is described in a proposal for C++'s STL. It does not use the extra precision and suffers from bias only in the last bit due to round-to-even.<sup class="reference" id="cite_ref-18">[18]</sup> Other numeric concerns are warranted when shifting this "canonical" uniform distribution to a different range.<sup class="reference" id="cite_ref-19">[19]</sup> A proposed method for the Swift programming language claims to use the full precision everywhere.<sup class="reference" id="cite_ref-20">[20]</sup>
</p><p>Uniformly distributed integers are commonly used in algorithms such as the Fisher–Yates shuffle. Again, a naive implementation may induce a modulo bias into the result, so more involved algorithms must be used. A method that nearly never performs division was described in 2018 by Daniel Lemire,<sup class="reference" id="cite_ref-21">[21]</sup> with the current state-of-the-art being the arithmetic encoding-inspired 2021 "optimal algorithm" by Stephen Canon of Apple Inc.<sup class="reference" id="cite_ref-22">[22]</sup>
</p><p>Most 0 to 1 RNGs include 0 but exclude 1, while others include or exclude both.
</p>
<h4><span class="mw-headline" id="Other_distributions">Other distributions</span><span class="mw-editsection"></span></h4>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Given a source of uniform random numbers, there are a couple of methods to create a new random source that corresponds to a probability density function. One method, called the inversion method, involves integrating up to an area greater than or equal to the random number (which should be generated between 0 and 1 for proper distributions). A second method, called the acceptance-rejection method, involves choosing an x and y value and testing whether the function of x is greater than the y value.  If it is, the x value is accepted.  Otherwise, the x value is rejected and the algorithm tries again.<sup class="reference" id="cite_ref-23">[23]</sup><sup class="reference" id="cite_ref-24">[24]</sup>
</p><p>As an example for rejection sampling, to generate a pair of statistically independent standard normally distributed random numbers (<i>x</i>, <i>y</i>), one may first generate the polar coordinates (<i>r</i>, <i>θ</i>), where <i>r</i><sup>2</sup>~χ<sub>2</sub><sup>2</sup> and <i>θ</i>~UNIFORM(0,2π) (see Box–Muller transform).
</p>
<h3><span class="mw-headline" id="Whitening">Whitening</span><span class="mw-editsection"></span></h3>
<p>The outputs of multiple independent RNGs can be combined (for example, using a bit-wise XOR operation) to provide a combined RNG at least as good as the best RNG used. This is referred to as software whitening.
</p><p>Computational and hardware random number generators are sometimes combined to reflect the benefits of both kinds. Computational random number generators can typically generate pseudorandom numbers much faster than physical generators, while physical generators can generate "true randomness."
</p>
<h2><span class="mw-headline" id="Low-discrepancy_sequences_as_an_alternative">Low-discrepancy sequences as an alternative</span><span class="mw-editsection"></span></h2>
<p>Some computations making use of a random number generator can be summarized as the computation of a total or average value, such as the computation of integrals by the Monte Carlo method. For such problems, it may be possible to find a more accurate solution by the use of so-called low-discrepancy sequences, also called quasirandom numbers. Such sequences have a definite pattern that fills in gaps evenly, qualitatively speaking; a truly random sequence may, and usually does, leave larger gaps.
</p>
<h2><span class="mw-headline" id="Activities_and_demonstrations">Activities and demonstrations</span><span class="mw-editsection"></span></h2>
<p>The following sites make available random number samples:
</p>
<ul><li>The SOCR resource pages contain a number of hands-on interactive activities and demonstrations of random number generation using Java applets.</li>
<li>The Quantum Optics Group at the ANU generates random numbers sourced from quantum vacuum. Sample of random numbers are available at their quantum random number generator research page.</li>
<li>Random.org makes available random numbers that are sourced from the randomness of atmospheric noise.</li>
<li>The Quantum Random Bit Generator Service at the Ruđer Bošković Institute harvests randomness from the quantum process of photonic emission in semiconductors. They supply a variety of ways of fetching the data, including libraries for several programming languages.</li>
<li>The Group at the Taiyuan University of Technology generates random numbers sourced from a chaotic laser. Samples of random number are available at their Physical Random Number Generator Service.</li></ul>
<h2><span class="mw-headline" id="Backdoors">Backdoors</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Since much cryptography depends on a cryptographically secure random number generator for key and cryptographic nonce generation, if a random number generator can be made predictable, it can be used as backdoor by an attacker to break the encryption.
</p><p>The NSA is reported to have inserted a backdoor into the NIST certified cryptographically secure pseudorandom number generator Dual EC DRBG. If for example an SSL connection is created using this random number generator, then according to Matthew Green it would allow NSA to determine the state of the random number generator, and thereby eventually be able to read all data sent over the SSL connection.<sup class="reference" id="cite_ref-25">[25]</sup> Even though it was apparent that Dual_EC_DRBG was a very poor and possibly backdoored pseudorandom number generator long before the NSA backdoor was confirmed in 2013, it had seen significant usage in practice until 2013, for example by the prominent security company RSA Security.<sup class="reference" id="cite_ref-green_26-0">[26]</sup> There have subsequently been accusations that RSA Security knowingly inserted a NSA backdoor into its products, possibly as part of the Bullrun program. RSA has denied knowingly inserting a backdoor into its products.<sup class="reference" id="cite_ref-27">[27]</sup>
</p><p>It has also been theorized that hardware RNGs could be secretly modified to have less entropy than stated, which would make encryption using the hardware RNG susceptible to attack. One such method which has been published works by modifying the dopant mask of the chip, which would be undetectable to optical reverse-engineering.<sup class="reference" id="cite_ref-28">[28]</sup> For example, for random number generation in Linux, it is seen as unacceptable to use Intel's RDRAND hardware RNG without mixing in the RDRAND output with other sources of entropy to counteract any backdoors in the hardware RNG, especially after the revelation of the NSA Bullrun program.<sup class="reference" id="cite_ref-29">[29]</sup><sup class="reference" id="cite_ref-30">[30]</sup>
</p><p>In 2010, a U.S. lottery draw was rigged by the information security director of the Multi-State Lottery Association (MUSL), who surreptitiously installed backdoor malware on the MUSL's secure RNG computer during routine maintenance.<sup class="reference" id="cite_ref-dailybeast-hotlotto_31-0">[31]</sup> During the hacks the man won a total amount of $16,500,000 by predicting the numbers correctly a few times in year.
</p><p>Address space layout randomization (ASLR), a mitigation against rowhammer and related attacks on the physical hardware of memory chips has been found to be inadequate as of early 2017 by VUSec. The random number algorithm, if based on a shift register implemented in hardware, is predictable at sufficiently large values of p and can be reverse engineered with enough processing power (Brute Force Hack).
This also indirectly means that malware using this method can run on both GPUs and CPUs if coded to do so, even using GPU to break ASLR on the CPU itself.<sup class="reference" id="cite_ref-32">[32]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1 cs1-prop-long-vol" id="CITEREFDonald_Knuth1997">Donald Knuth (1997). "Chapter 3 – Random Numbers". <i>The Art of Computer Programming</i>. Vol. 2: Seminumerical algorithms (3 ed.).</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+3+%E2%80%93+Random+Numbers&amp;rft.btitle=The+Art+of+Computer+Programming&amp;rft.edition=3&amp;rft.date=1997&amp;rft.au=Donald+Knuth&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation conference cs1" id="CITEREFL'Ecuyer2017">L'Ecuyer, Pierre (2017). "History of Uniform Random Number Generation" <span class="cs1-format">(PDF)</span>. <i>Proceedings of the 2017 Winter Simulation Conference</i>. IEEE Press. pp. 202–230.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.atitle=History+of+Uniform+Random+Number+Generation&amp;rft.btitle=Proceedings+of+the+2017+Winter+Simulation+Conference&amp;rft.pages=202-230&amp;rft.pub=IEEE+Press&amp;rft.date=2017&amp;rft.aulast=L%27Ecuyer&amp;rft.aufirst=Pierre&amp;rft_id=https%3A%2F%2Fwww.informs-sim.org%2Fwsc17papers%2Fincludes%2Ffiles%2F016.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation encyclopaedia cs1" id="CITEREFL'Ecuyer2012">L'Ecuyer, Pierre (2012). "Random Number Generation" <span class="cs1-format">(PDF)</span>.  In J. E. Gentle; W. Haerdle; Y. Mori (eds.). <i>Handbook of Computational Statistics: Concepts and Methods</i>. <i>Handbook of Computational Statistics</i> (second ed.). Springer-Verlag. pp. 35–71. doi:10.1007/978-3-642-21551-3_3. hdl:<span class="cs1-lock-free" title="Freely accessible">10419/22195</span>. ISBN <bdi>978-3-642-21550-6</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Handbook+of+Computational+Statistics%3A+Concepts+and+Methods&amp;rft.btitle=Handbook+of+Computational+Statistics&amp;rft.pages=35-71&amp;rft.edition=second&amp;rft.pub=Springer-Verlag&amp;rft.date=2012&amp;rft_id=info%3Ahdl%2F10419%2F22195&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-642-21551-3_3&amp;rft.isbn=978-3-642-21550-6&amp;rft.aulast=L%27Ecuyer&amp;rft.aufirst=Pierre&amp;rft_id=https%3A%2F%2Fwww.econstor.eu%2Fbitstream%2F10419%2F22195%2F1%2F21_pl.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFKroeseTaimre,_T.Botev,_Z.I.2011">Kroese, D. P.; Taimre, T.; Botev, Z.I. (2011). "Chapter 1 – Uniform Random Number Generation". <i>Handbook of Monte Carlo Methods</i>. New York: John Wiley &amp; Sons. p. 772. ISBN <bdi>978-0-470-17793-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+1+%E2%80%93+Uniform+Random+Number+Generation&amp;rft.btitle=Handbook+of+Monte+Carlo+Methods&amp;rft.place=New+York&amp;rft.pages=772&amp;rft.pub=John+Wiley+%26+Sons&amp;rft.date=2011&amp;rft.isbn=978-0-470-17793-8&amp;rft.aulast=Kroese&amp;rft.aufirst=D.+P.&amp;rft.au=Taimre%2C+T.&amp;rft.au=Botev%2C+Z.I.&amp;rft_id=http%3A%2F%2Fwww.montecarlohandbook.org&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFPressTeukolskyVetterlingFlannery2007">Press, WH; Teukolsky, SA; Vetterling, WT; Flannery, BP (2007). "Chapter 7. Random Numbers". <i>Numerical Recipes: The Art of Scientific Computing</i> (3rd ed.). New York: Cambridge University Press. ISBN <bdi>978-0-521-88068-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+7.+Random+Numbers&amp;rft.btitle=Numerical+Recipes%3A+The+Art+of+Scientific+Computing&amp;rft.place=New+York&amp;rft.edition=3rd&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2007&amp;rft.isbn=978-0-521-88068-8&amp;rft.aulast=Press&amp;rft.aufirst=WH&amp;rft.au=Teukolsky%2C+SA&amp;rft.au=Vetterling%2C+WT&amp;rft.au=Flannery%2C+BP&amp;rft_id=http%3A%2F%2Fapps.nrbook.com%2Fempanel%2Findex.html%23pg%3D340&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span></li>
<li>NIST SP800-90A, B, C series on random number generation</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1">M. Tomassini, M. Sipper, and M. Perrenoud (October 2000). "On the generation of high-quality random numbers by two-dimensional cellular automata". <i>IEEE Transactions on Computers</i>. <b>49</b> (10): 1146–1151. doi:10.1109/12.888056.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IEEE+Transactions+on+Computers&amp;rft.atitle=On+the+generation+of+high-quality+random+numbers+by+two-dimensional+cellular+automata&amp;rft.volume=49&amp;rft.issue=10&amp;rft.pages=1146-1151&amp;rft.date=2000-10&amp;rft_id=info%3Adoi%2F10.1109%2F12.888056&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARandom+number+generation"></span><span class="cs1-maint citation-comment"><code class="cs1-code">{{cite journal}}</code>:  CS1 maint: uses authors parameter (link)</span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>RANDOM.ORG True Random Number Service</li>
<li>Quantum random number generator at ANU</li>
<li>Random and Pseudorandom on <i>In Our Time</i> at the BBC</li>
<li>jRand a Java-based framework for the generation of simulation sequences, including pseudorandom sequences of numbers</li>
<li>Random number generators in NAG Fortran Library</li>
<li>Randomness Beacon at NIST, broadcasting full-entropy bit-strings in blocks of 512 bits every 60 seconds. Designed to provide unpredictability, autonomy, and consistency.</li>
<li>A system call for random numbers: getrandom(), a LWN.net article describing a dedicated Linux system call</li>
<li>Statistical Properties of Pseudo Random Sequences and Experiments with PHP and Debian OpenSSL</li>
<li>Random Sequence Generator based on Avalanche Noise</li></ul>

<!-- 
NewPP limit report
Parsed by mw2307
Cached time: 20221223231743
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.456 seconds
Real time usage: 0.617 seconds
Preprocessor visited node count: 2999/1000000
Post‐expand include size: 91695/2097152 bytes
Template argument size: 3779/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 20/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 110735/5000000 bytes
Lua time usage: 0.273/10.000 seconds
Lua memory usage: 8015203/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  494.553      1 -total
 43.52%  215.253      1 Template:Reflist
 18.99%   93.891      7 Template:Cite_journal
 11.83%   58.492     19 Template:Cite_web
 11.03%   54.568      1 Template:More_citations_needed
 10.39%   51.403      1 Template:Short_description
 10.24%   50.631      1 Template:Authority_control
 10.13%   50.080      1 Template:Ambox
  5.59%   27.637      2 Template:Pagetype
  4.85%   23.973      6 Template:Main
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2736939-0!canonical and timestamp 20221223231742 and revision id 1122901850.
 -->
</div></body>
</html>