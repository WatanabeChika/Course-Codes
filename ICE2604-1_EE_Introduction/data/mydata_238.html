<!DOCTYPE html>
<html>
<head>
<title>fractional_knapsack_problem</title>
</head>
<body>
<div class="mw-parser-output"><p>In theoretical computer science, the <b>continuous knapsack problem</b> (also known as the <b>fractional knapsack problem</b>) is an algorithmic problem in combinatorial optimization in which the goal is to fill a container (the "knapsack") with fractional amounts of different materials chosen to maximize the value of the selected materials.<sup class="reference" id="cite_ref-gt_1-0">[1]</sup><sup class="reference" id="cite_ref-co_2-0">[2]</sup> It resembles the classic knapsack problem, in which the items to be placed in the container are indivisible; however, the continuous knapsack problem may be solved in polynomial time whereas the classic knapsack problem is NP-hard.<sup class="reference" id="cite_ref-gt_1-1">[1]</sup>  It is a classic example of how a seemingly small change in the formulation of a problem can have a large impact on its computational complexity.
</p>
<h2><span class="mw-headline" id="Problem_definition">Problem definition</span><span class="mw-editsection"></span></h2>
<p>An instance of either the continuous or classic knapsack problems may be specified by the numerical capacity <span class="texhtml mvar" style="font-style:italic;">W</span> of the knapsack, together with a collection of materials, each of which has two numbers associated with it: the weight <span class="texhtml"><i>w<sub>i</sub></i></span> of material that is available to be selected and the total value <span class="texhtml"><i>v<sub>i</sub></i></span> of that material. The goal is to choose an amount <span class="texhtml"><i>x<sub>i</sub></i> ≤ <i>w<sub>i</sub></i></span> of each material, subject to the capacity constraint
</p>
and maximizing the total benefit

In the classic knapsack problem, each of the amounts <span class="texhtml"><i>x<sub>i</sub></i></span> must be either zero or <span class="texhtml"><i>w<sub>i</sub></i></span>; the continuous knapsack problem differs by allowing <span class="texhtml"><i>x<sub>i</sub></i></span> to range continuously from zero to <span class="texhtml"><i>w<sub>i</sub></i></span>.<sup class="reference" id="cite_ref-gt_1-2">[1]</sup>
<p>Some formulations of this problem rescale the variables <span class="texhtml"><i>x<sub>i</sub></i></span> to be in the range from 0 to 1. In this case the capacity constraint becomes
</p>
and the goal is to maximize the total benefit

<h2><span class="mw-headline" id="Solution_technique">Solution technique</span><span class="mw-editsection"></span></h2>
<p>The continuous knapsack problem may be solved by a greedy algorithm, first published in 1957 by George Dantzig,<sup class="reference" id="cite_ref-co_2-1">[2]</sup><sup class="reference" id="cite_ref-3">[3]</sup> that considers the materials in sorted order by their values per unit weight. For each material, the amount <i>x<sub>i</sub></i> is chosen to be as large as possible:
</p>
<ul><li>If the sum of the choices made so far equals the capacity <i>W</i>, then the algorithm sets <i>x<sub>i</sub></i> = 0.</li>
<li>If the difference <i>d</i> between the sum of the choices made so far and <i>W</i> is smaller than <i>w<sub>i</sub></i>, then the algorithm sets <i>x<sub>i</sub></i> = <i>d</i>.</li>
<li>In the remaining case, the algorithm chooses <i>x<sub>i</sub></i> = <i>w<sub>i</sub></i>.</li></ul>
<p>Because of the need to sort the materials, this algorithm takes time <i>O</i>(<i>n</i> log <i>n</i>) on inputs with <i>n</i> materials.<sup class="reference" id="cite_ref-gt_1-3">[1]</sup><sup class="reference" id="cite_ref-co_2-2">[2]</sup> However, by adapting an algorithm for finding weighted medians, it is possible to solve the problem in time <i>O</i>(<i>n</i>).<sup class="reference" id="cite_ref-co_2-3">[2]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw1436
Cached time: 20221214151646
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.106 seconds
Real time usage: 0.152 seconds
Preprocessor visited node count: 652/1000000
Post‐expand include size: 7335/2097152 bytes
Template argument size: 738/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 11130/5000000 bytes
Lua time usage: 0.056/10.000 seconds
Lua memory usage: 2761034/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  107.529      1 -total
 78.32%   84.218      1 Template:Reflist
 62.86%   67.588      3 Template:Citation
 17.92%   19.268      8 Template:Math
  2.21%    2.375      9 Template:Main_other
  1.04%    1.116      1 Template:Mvar
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:8017444-0!canonical and timestamp 20221214151646 and revision id 1063637597.
 -->
</div></body>
</html>