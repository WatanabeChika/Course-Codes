external_sortExternal sorting is a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory, usually a disk drive. Thus, external sorting algorithms are external memory algorithms and thus applicable in the external memory model of computation.External sorting algorithms generally fall into two types, distribution sorting, which resembles quicksort, and external merge sort, which resembles merge sort. The latter typically uses a hybrid sort-merge strategy.  In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file.  In the merge phase, the sorted subfiles are combined into a single larger file.External sorting algorithms can be analyzed in the external memory model. In this model, a cache or internal memory of size  and an unbounded external memory are divided into blocks of size , and the running time of an algorithm is determined by the number of memory transfers between internal and external memory. Like their cache-oblivious counterparts, asymptotically optimal external sorting algorithms achieve a running time (in Big O notation) of .One example of external sorting is the external merge sort algorithm, which is a K-way merge algorithm. It sorts chunks that each fit in RAM, then merges the sorted chunks together.[1][2]The algorithm first sorts  items at a time and puts the sorted lists back into external memory. It then recursively does a -way merge on those sorted lists. To do this merge,  elements from each sorted list are loaded into internal memory, and the minimum is repeatedly outputted.For example, for sorting 900 megabytes of data using only 100 megabytes of RAM:Read 100 MB of the data in main memory and sort by some conventional method, like quicksort.Write the sorted data to disk.Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer.  (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)Perform a 9-way merge and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally—because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed.Historically, instead of a sort, sometimes a replacement-selection algorithm[3] was used to perform the initial distribution, to produce on average half as many output chunks of double the length.The previous example is a two-pass sort: first sort, then merge. The sort ends with a single k-way merge, rather than a series of two-way merge passes as in a typical in-memory merge sort. This is because each merge pass reads and writes every value from and to disk, so reducing the number of passes more than compensates for the additional cost of a k-way merge.The limitation to single-pass merging is that as the number of chunks increases, memory will be divided into more buffers, so each buffer is smaller. Eventually, the reads become so small that more time is spent on disk seeks than data transfer.  A typical magnetic hard disk drive might have a 10 ms access time and 100 MB/s data transfer rate, so each seek takes as much time as transferring 1 MB of data.Thus, for sorting, say, 50 GB in 100 MB of RAM, using a single 500-way merge pass isn't efficient: we can only read 100 MB / 501 ≈ 200 KB from each chunk at once, so 5/6 of the disk's time is spent seeking.  Using two merge passes solves the problem.  Then the sorting process might look like this:Run the initial chunk-sorting pass as before to create 500×100 MB sorted chunks.Run a first merge pass combining 25×100 MB chunks at a time, resulting in 20×2.5 GB sorted chunks.Run a second merge pass to merge the 20×2.5 GB sorted chunks into a single 50 GB sorted resultAlthough this requires an additional pass over the data, each read is now 4 MB long, so only 1/5 of the disk's time is spent seeking.  The improvement in data transfer efficiency during the merge passes (16.6% to 80% is almost a 5× improvement) more than makes up for the doubled number of merge passes.Variations include using an intermediate medium like solid-state disk for some stages, even if there isn't enough of it to hold the full dataset. Repeating the example above with 20 GB of temporary storage on SSD, the first pass could merge 200×100 MB sorted chunks read from that temporary space to write 20GB sorted chunks to HDD. The 200-way merge with 500kb buffers is reasonably efficient due to the much greater random-read throughput of SSDs, the first pass can benefit from an SSD's higher read/write bandwidth, and the second pass has fewer larger chunks to merge and therefore fewer HDD seeks. SSDs can also be used as read buffers in a merge phase, allowing fewer larger reads from HDD storage. Given the relatively low cost of SSD space, it can be an economical tool for sorting large inputs with very limited memory.Like in-memory sorts, efficient external sorts require O(n log n) time: linear increases in data size require logarithmic increases in the number of passes, and each pass takes a linear number of reads and writes. Using the large memory sizes provided by modern computers the logarithmic factor grows very slowly. Under reasonable assumptions at least 500 GB of data stored on a hard drive can be sorted using 1 GB of main memory before a third pass becomes advantageous, and many times that much data can be sorted before a fourth pass becomes useful.[4] Media with high random-read performance like solid-state drives (SSDs) also increase the amount that can be sorted before additional passes improve performance.Main memory size is important. Doubling memory dedicated to sorting halves the number of chunks and the number of reads per chunk, reducing the number of seeks required by about three-quarters. The ratio of RAM to disk storage on servers often makes it convenient to do huge sorts on a cluster of machines[5] rather than on one machine with multiple passes.External distribution sort is analogous to quicksort. The algorithm finds approximately  pivots and uses them to divide the  elements into approximately equally sized subarrays, each of whose elements are all smaller than the next, and then recurse until the sizes of the subarrays are less than the block size. When the subarrays are less than the block size, sorting can be done quickly because all reads and writes are done in the cache, and in the external memory model requires  operations.However, finding exactly  pivots would not be fast enough to make the external distribution sort asymptotically optimal. Instead, we find slightly fewer pivots. To find these pivots, the algorithm splits the  input elements into  chunks, and takes every  elements, and recursively uses the median of medians algorithm to find  pivots.[6]There is a duality, or fundamental similarity, between merge- and distribution-based algorithms.[7]The Sort Benchmark, created by computer scientist Jim Gray, compares external sorting algorithms implemented using finely tuned hardware and software.  Winning implementations use several techniques:Using parallelismMultiple disk drives can be used in parallel in order to improve sequential read and write speed.  This can be a very cost-efficient improvement: a Sort Benchmark winner in the cost-centric Penny Sort category uses six hard drives in an otherwise midrange machine.[8]Sorting software can use multiple threads, to speed up the process on modern multicore computers.Software can use asynchronous I/O so that one run of data can be sorted or merged while other runs are being read from or written to disk.Multiple machines connected by fast network links can each sort part of a huge dataset in parallel.[9]Increasing hardware speedUsing more RAM for sorting can reduce the number of disk seeks and avoid the need for more passes.Fast external memory like solid-state drives can speed sorts, either if the data is small enough to fit entirely on SSDs or, more rarely, to accelerate sorting SSD-sized chunks in a three-pass sort.Many other factors can affect hardware's maximum sorting speed: CPU speed and number of cores, RAM access latency, input/output bandwidth, disk read/write speed, disk seek time, and others. "Balancing" the hardware to minimize bottlenecks is an important part of designing an efficient sorting system.Cost-efficiency as well as absolute speed can be critical, especially in cluster environments where lower node costs allow purchasing more nodes.Increasing software speedSome Sort Benchmark entrants use a variation on radix sort for the first phase of sorting: they separate data into one of many "bins" based on the beginning of its value.  Sort Benchmark data is random and especially well-suited to this optimization.Compacting the input, intermediate files, and output can reduce time spent on I/O, but is not allowed in the Sort Benchmark.Because the Sort Benchmark sorts long (100-byte) records using short (10-byte) keys, sorting software sometimes rearranges the keys separately from the values to reduce memory I/O volume.Mainframe sort mergeExternal memory algorithmFunnelsortCache-oblivious distribution sortSTXXL, an algorithm toolkit including external mergesortAn external mergesort exampleA K-Way Merge ImplementationExternal-Memory Sorting in JavaA sample pennysort implementation using Judy ArraysSort Benchmark