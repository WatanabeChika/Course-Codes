<!DOCTYPE html>
<html>
<head>
<title>bounded_stack</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p class="mw-empty-elt">
</p>


<p>In computer science, a <b>stack</b> is an abstract data type that serves as a collection of elements, with two main operations:
</p>
<ul><li><b>Push</b>, which adds an element to the collection, and</li>
<li><b>Pop</b>, which removes the most recently added element that was not yet removed.</li></ul>
<p>Additionally, a peek operation can, without modifying the stack, return the value of the last element added. Calling this structure a <i>stack</i> is by analogy to a set of physical items stacked one atop another, such as a stack of plates. 
</p><p>The order in which an element added to or removed from a stack is described as <b>last in, first out</b>, referred to by the acronym <b>LIFO</b>.<sup class="reference" id="cite_ref-NB1_1-0">[nb 1]</sup> As with a stack of physical objects, this structure makes it easy to take an item off the top of the stack, but accessing a datum deeper in the stack may require taking off multiple other items first.<sup class="reference" id="cite_ref-clrs_2-0">[1]</sup>
</p><p>Considered as a linear data structure, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the <i>top</i> of the stack.  This data structure makes it possible to implement a stack as a singly linked list and as a pointer to the top element. A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept another element, the stack is in a state of stack overflow.
</p><p>A stack is needed to implement depth-first search.
</p>

<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Stacks entered the computer science literature in 1946, when Alan M. Turing used the terms "bury" and "unbury" as a means of calling and returning from subroutines.<sup class="reference" id="cite_ref-Turing_1945_3-0">[2]</sup><sup class="reference" id="cite_ref-Carpenter_1977_4-0">[3]</sup> Subroutines had already been implemented in Konrad Zuse's Z4 in 1945.
</p><p>Klaus Samelson and Friedrich L. Bauer of Technical University Munich proposed the idea of a stack in 1955<sup class="reference" id="cite_ref-Samelson_1955_5-0">[4]</sup><sup class="reference" id="cite_ref-Wilke_2015_6-0">[5]</sup> and filed a patent in 1957.<sup class="reference" id="cite_ref-Bauer_1957_7-0">[6]</sup><sup class="reference" id="cite_ref-Bauer_1982_8-0">[7]</sup><sup class="reference" id="cite_ref-Samelson_1959_9-0">[8]</sup><sup class="reference" id="cite_ref-Samelson_1960_10-0">[9]</sup> In March 1988, by which time Samelson was deceased, Bauer received the IEEE Computer Pioneer Award for the invention of the stack principle.<sup class="reference" id="cite_ref-IEEE_1989_11-0">[10]</sup><sup class="reference" id="cite_ref-Wilke_2015_6-1">[5]</sup> Similar concepts were developed, independently, by Charles Leonard Hamblin in the first half of 1954<sup class="reference" id="cite_ref-Hamblin_1957_12-0">[11]</sup> and by Wilhelm Kämmerer<span class="noprint" style="font-size:85%; font-style: normal;"> [de]</span> in 1958.<sup class="reference" id="cite_ref-Kämmerer_1958_13-0">[12]</sup><sup class="reference" id="cite_ref-Kämmerer_1960_14-0">[13]</sup>
</p><p>Stacks are often described using the analogy of a spring-loaded stack of plates in a cafeteria.<sup class="reference" id="cite_ref-Ball_1978_15-0">[14]</sup><sup class="reference" id="cite_ref-clrs_2-1">[1]</sup><sup class="reference" id="cite_ref-Godse_2010_16-0">[15]</sup> Clean plates are placed on top of the stack, pushing down any already there. When a plate is removed from the stack, the one below it pops up to become the new top plate.
</p>
<h2><span class="mw-headline" id="Non-essential_operations">Non-essential operations</span><span class="mw-editsection"></span></h2>
<p>In many implementations, a stack has more operations than the essential "push" and "pop" operations. An example of a non-essential operation is "top of stack", or "peek", which observes the top element without removing it from the stack.<sup class="reference" id="cite_ref-Horowitz_1984_17-0">[16]</sup> This could be done with a "pop" followed by a "push" to return the same data to the stack, so it is not considered an essential operation. If the stack is empty, an underflow condition will occur upon execution of either the "stack top" or "pop" operations. Additionally, many implementations provide a check if the stack is empty and one that returns its size.
</p>
<h2><span class="mw-headline" id="Software_stacks">Software stacks</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h3>
<p>A stack can be easily implemented either through an array or a linked list, as stacks are just special cases of lists.<sup class="reference" id="cite_ref-Pandey_2020_18-0">[17]</sup> What identifies the data structure as a stack, in either case, is not the implementation but the interface: the user is only allowed to pop or push items onto the array or linked list, with few other helper operations. The following will demonstrate both implementations, using pseudocode.
</p>
<h4><span class="mw-headline" id="Array">Array</span><span class="mw-editsection"></span></h4>
<p>An array can be used to implement a (bounded) stack, as follows. The first element, usually at the zero offset, is the bottom, resulting in <code>array[0]</code> being the first element pushed onto the stack and the last element popped off. The program must keep track of the size (length) of the stack, using a variable <i>top</i> that records the number of items pushed so far, therefore pointing to the place in the array where the next element is to be inserted (assuming a zero-based index convention). Thus, the stack itself can be effectively implemented as a three-element structure:
</p>
<pre><b>structure</b> stack:
    maxsize : integer
    top : integer
    items : array of item
</pre>
<pre><b>procedure</b> initialize(stk : stack, size : integer):
    stk.items ← new array of <i>size</i> items, initially empty
    stk.maxsize ← size
    stk.top ← 0
</pre>
<p>The <i>push</i> operation adds an element and increments the <i>top</i> index, after checking for overflow:
</p>
<pre><b>procedure</b> push(stk : stack, x : item):
    <b>if</b> stk.top = stk.maxsize:
        report overflow error
    <b>else</b>:
        stk.items[stk.top] ← x
        stk.top ← stk.top + 1
</pre>
<p>Similarly, <i>pop</i> decrements the <i>top</i> index after checking for underflow, and returns the item that was previously the top one:
</p>
<pre><b>procedure</b> pop(stk : stack):
    <b>if</b> stk.top = 0:
        report underflow error
    <b>else</b>:
        stk.top ← stk.top − 1
        r ← stk.items[stk.top]
        <b>return</b> r
</pre>
<p>Using a dynamic array, it is possible to implement a stack that can grow or shrink as much as needed. The size of the stack is simply the size of the dynamic array, which is a very efficient implementation of a stack since adding items to or removing items from the end of a dynamic array requires amortized O(1) time.
</p>
<h4><span class="mw-headline" id="Linked_list">Linked list</span><span class="mw-editsection"></span></h4>
<p>Another option for implementing stacks is to use a singly linked list. A stack is then a pointer to the "head" of the list, with perhaps a counter to keep track of the size of the list:
</p>
<pre><b>structure</b> frame:
    data : item
    next : frame or nil
</pre>
<pre><b>structure</b> stack:
    head : frame or nil
    size : integer
</pre>
<pre><b>procedure</b> initialize(stk : stack):
    stk.head ← nil
    stk.size ← 0
</pre>
<p>Pushing and popping items happens at the head of the list; overflow is not possible in this implementation (unless memory is exhausted):
</p>
<pre><b>procedure</b> push(stk : stack, x : item):
    newhead ← new frame
    newhead.data ← x
    newhead.next ← stk.head
    stk.head ← newhead
    stk.size ← stk.size + 1
</pre>
<pre><b>procedure</b> pop(stk : stack):
    <b>if</b> stk.head = nil:
        report underflow error
    r ← stk.head.data
    stk.head ← stk.head.next
    stk.size ← stk.size - 1
    <b>return</b> r
</pre>
<h3><span class="mw-headline" id="Stacks_and_programming_languages">Stacks and programming languages</span><span class="mw-editsection"></span></h3>
<p>Some languages, such as Perl, LISP, JavaScript and Python, make the stack operations push and pop available on their standard list/array types. Some languages, notably those in the Forth family (including PostScript), are designed around language-defined stacks that are directly visible to and manipulated by the programmer.
</p><p>The following is an example of manipulating a stack in Common Lisp ("<style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">&gt;</span>" is the Lisp interpreter's prompt; lines not starting with "<link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">&gt;</span>" are the interpreter's responses to expressions):
</p>

<p>Several of the C++ Standard Library container types have <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">push_back</span> and <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">pop_back</span> operations with LIFO semantics; additionally, the <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">stack</span> template class adapts existing containers to provide a restricted API with only push/pop operations.  PHP has an SplStack class. Java's library contains a <code>Stack</code> class that is a specialization of <code>Vector</code>.  Following is an example program in Java language, using that class.
</p>

<h2><span class="mw-headline" id="Hardware_stack">Hardware stack</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A common use of stacks at the architecture level is as a means of allocating and accessing memory.
</p>
<h3><span class="mw-headline" id="Basic_architecture_of_a_stack">Basic architecture of a stack</span><span class="mw-editsection"></span></h3>
<p>A typical stack is an area of computer memory with a fixed origin and a variable size.  Initially the size of the stack is zero.  A <i>stack pointer,</i> usually in the form of a hardware register, points to the most recently referenced location on the stack; when the stack has a size of zero, the stack pointer points to the origin of the stack.
</p><p>The two operations applicable to all stacks are:
</p>
<ul><li>a <i>push</i> operation, in which a data item is placed at the location pointed to by the stack pointer, and the address in the stack pointer is adjusted by the size of the data item;</li>
<li>a <i>pop</i> or <i>pull</i> operation: a data item at the current location pointed to by the stack pointer is removed, and the stack pointer is adjusted by the size of the data item.</li></ul>
<p>There are many variations on the basic principle of stack operations.  Every stack has a fixed location, in memory, at which it begins. As data items are added to the stack, the stack pointer is displaced to indicate the current extent of the stack, which expands away from the origin.
</p><p>Stack pointers may point to the origin of a stack or to a limited range of addresses either above or below the origin (depending on the direction in which the stack grows); however, the stack pointer cannot cross the origin of the stack.  In other words, if the origin of the stack is at address 1000 and the stack grows downwards (towards addresses 999, 998, and so on), the stack pointer must never be incremented beyond 1000 (to 1001, 1002, etc.).  If a pop operation on the stack causes the stack pointer to move past the origin of the stack, a <i>stack underflow</i> occurs.  If a push operation causes the stack pointer to increment or decrement beyond the maximum extent of the stack, a <i>stack overflow</i> occurs.
</p><p>Some environments that rely heavily on stacks may provide additional operations, for example:
</p>
<ul><li><i>Duplicate</i>: the top item is popped, and then pushed again (twice), so that an additional copy of the former top item is now on top, with the original below it.</li>
<li><i>Peek</i>: the topmost item is inspected (or returned), but the stack pointer and stack size does not change (meaning the item remains on the stack). This is also called <b>top</b> operation in many articles.</li>
<li><i>Swap</i> or <i>exchange</i>: the two topmost items on the stack exchange places.</li>
<li><i>Rotate (or Roll)</i>: the <span class="texhtml mvar" style="font-style:italic;">n</span> topmost items are moved on the stack in a rotating fashion. For example, if <span class="texhtml"><i>n</i> = 3</span>, items 1, 2, and 3 on the stack are moved to positions 2, 3, and 1 on the stack, respectively.  Many variants of this operation are possible, with the most common being called <i>left rotate</i> and <i>right rotate.</i></li></ul>
<p>Stacks are often visualized growing from the bottom up (like real-world stacks). They may also be visualized growing from left to right, so that "topmost" becomes "rightmost", or even growing from top to bottom. The important feature is that the bottom of the stack is in a fixed position. The illustration in this section is an example of a top-to-bottom growth visualization: the top (28) is the stack "bottom", since the stack "top" (9) is where items are pushed or popped from.
</p><p>A <i>right rotate</i> will move the first element to the third position, the second to the first and the third to the second. Here are two equivalent visualizations of this process:
</p>
<pre>apple                         banana
banana    ===right rotate==&gt;  cucumber
cucumber                      apple
</pre>
<pre>cucumber                      apple
banana    ===left rotate==&gt;   cucumber
apple                         banana
</pre>
<p>A stack is usually represented in computers by a block of memory cells, with the "bottom" at a fixed location, and the stack pointer holding the address of the current "top" cell in the stack.  The top and bottom terminology are used irrespective of whether the stack actually grows towards lower memory addresses or towards higher memory addresses.
</p><p>Pushing an item on to the stack adjusts the stack pointer by the size of the item (either decrementing or incrementing, depending on the direction in which the stack grows in memory), pointing it to the next cell, and copies the new top item to the stack area. Depending again on the exact implementation, at the end of a push operation, the stack pointer may point to the next unused location in the stack, or it may point to the topmost item in the stack.  If the stack points to the current topmost item, the stack pointer will be updated before a new item is pushed onto the stack; if it points to the next available location in the stack, it will be updated <i>after</i> the new item is pushed onto the stack.
</p><p>Popping the stack is simply the inverse of pushing.  The topmost item in the stack is removed and the stack pointer is updated, in the opposite order of that used in the push operation.
</p>
<h4><span class="mw-headline" id="Stack_in_main_memory">Stack in main memory</span><span class="mw-editsection"></span></h4>
<p>Many CISC-type CPU designs, including the x86, Z80 and 6502, have a dedicated register for use as the call stack stack pointer with dedicated call, return, push, and pop instructions that implicitly update the dedicated register, thus increasing code density. Some CISC processors, like the PDP-11 and the 68000, also have special addressing modes for implementation of stacks, typically with a semi-dedicated stack pointer as well (such as A7 in the 68000). In contrast, most RISC CPU designs do not have dedicated stack instructions and therefore most, if not all, registers may be used as stack pointers as needed.
</p>
<h4><span class="mw-headline" id="Stack_in_registers_or_dedicated_memory">Stack in registers or dedicated memory</span><span class="mw-editsection"></span></h4>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Some machines use a stack for arithmetic and logical operations; operands are pushed onto the stack, and arithmetic and logical operations act on the top one or more items on the stack, popping them off the stack and pushing the result onto the stack.  Machines that function in this fashion are called stack machines.
</p><p>A number of mainframes and minicomputers were stack machines, the most famous being the Burroughs large systems.  Other examples include the CISC HP 3000 machines and the CISC machines from Tandem Computers.
</p><p>The  x87 floating point architecture is an example of a set of registers organised as a stack where direct access to individual registers (relative to the current top) is also possible.
</p><p>Having the top-of-stack as an implicit argument allows for a small machine code footprint with a good usage of bus bandwidth and code caches, but it also prevents some types of optimizations possible on processors permitting random access to the register file for all (two or three) operands. A stack structure also makes superscalar implementations with register renaming (for speculative execution) somewhat more complex to implement, although it is still feasible, as exemplified by modern x87 implementations.
</p><p>Sun SPARC, AMD Am29000, and Intel i960 are all examples of architectures using register windows within a register-stack as another strategy to avoid the use of slow main memory for function arguments and return values.
</p><p>There are also a number of small microprocessors that implements a stack directly in hardware and some microcontrollers have a fixed-depth stack that is not directly accessible. Examples are the PIC microcontrollers, the Computer Cowboys MuP21, the Harris RTX line, and the Novix NC4016. Many stack-based microprocessors were used to implement the programming language Forth at the microcode level.
</p>
<h2><span class="mw-headline" id="Applications_of_stacks">Applications of stacks</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Expression_evaluation_and_syntax_parsing">Expression evaluation and syntax parsing</span><span class="mw-editsection"></span></h3>
<p>Calculators employing reverse Polish notation use a stack structure to hold values. Expressions can be represented in prefix, postfix or infix notations and conversion from one form to another may be accomplished using a stack. Many compilers use a stack for parsing the syntax of expressions, program blocks etc. before translating into low-level code. Most programming languages are context-free languages, allowing them to be parsed with stack-based machines.
</p>
<h3><span class="mw-headline" id="Backtracking">Backtracking</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Another important application of stacks is backtracking. Consider a simple example of finding the correct path in a maze. There are a series of points, from the starting point to the destination. We start from one point. To reach the final destination, there are several paths. Suppose we choose a random path. After following a certain path, we realise that the path we have chosen is wrong. So we need to find a way by which we can return to the beginning of that path. This can be done with the use of stacks. With the help of stacks, we remember the point where we have reached. This is done by pushing that point into the  stack. In case we end up on the wrong path, we can pop the last point from the stack and thus return to the last point and continue our quest to find the right path. This is called backtracking.
</p><p>The prototypical example of a backtracking algorithm is depth-first search, which finds all vertices of a graph that can be reached from a specified starting vertex. Other applications of backtracking involve searching through spaces that represent potential solutions to an optimization problem. Branch and bound is a technique for performing such backtracking searches without exhaustively searching all of the potential solutions in such a space.
</p>
<h3><span class="mw-headline" id="Compile-time_memory_management">Compile-time memory management</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>

<p>A number of programming languages are stack-oriented, meaning they define most basic operations (adding two numbers, printing a character) as taking their arguments from the stack, and placing any return values back on the stack. For example, PostScript has a return stack and an operand stack, and also has a graphics state stack and a dictionary stack. Many virtual machines are also stack-oriented, including the p-code machine and the Java Virtual Machine.
</p><p>Almost all calling conventions‍—‌the ways in which subroutines receive their parameters and return results‍—‌use a special stack (the "call stack") to hold information about procedure/function calling and nesting in order to switch to the context of the called function and restore to the caller function when the calling finishes. The functions follow a runtime protocol between caller and callee to save arguments and return value on the stack. Stacks are an important way of supporting nested or recursive function calls. This type of stack is used implicitly by the compiler to support CALL and RETURN statements (or their equivalents) and is not manipulated directly by the programmer.
</p><p>Some programming languages use the stack to store data that is local to a procedure. Space for local data items is allocated from the stack when the procedure is entered, and is deallocated when the procedure exits. The C programming language is typically implemented in this way. Using the same stack for both data and procedure calls has important security implications (see below) of which a programmer must be aware in order to avoid introducing serious security bugs into a program.
</p>
<h3><span class="mw-headline" id="Efficient_algorithms">Efficient algorithms</span><span class="mw-editsection"></span></h3>
<p>Several algorithms use a stack (separate from the usual function call stack of most programming languages) as the principal data structure with which they organize their information. These include:
</p>
<ul><li>Graham scan, an algorithm for the convex hull of a two-dimensional system of points. A convex hull of a subset of the input is maintained in a stack, which is used to find and remove concavities in the boundary when a new point is added to the hull.<sup class="reference" id="cite_ref-Graham_1972_19-0">[18]</sup></li>
<li>Part of the SMAWK algorithm for finding the row minima of a monotone matrix uses stacks in a similar way to Graham scan.<sup class="reference" id="cite_ref-Aggarwal_1987_20-0">[19]</sup></li>
<li>All nearest smaller values, the problem of finding, for each number in an array, the closest preceding number that is smaller than it. One algorithm for this problem uses a stack to maintain a collection of candidates for the nearest smaller value. For each position in the array, the stack is popped until a smaller value is found on its top, and then the value in the new position is pushed onto the stack.<sup class="reference" id="cite_ref-Omer_1993_21-0">[20]</sup></li>
<li>The nearest-neighbor chain algorithm, a method for agglomerative hierarchical clustering based on maintaining a stack of clusters, each of which is the nearest neighbor of its predecessor on the stack. When this method finds a pair of clusters that are mutual nearest neighbors, they are popped and merged.<sup class="reference" id="cite_ref-Martagh_1983_22-0">[21]</sup></li></ul>
<h2><span class="mw-headline" id="Security">Security</span><span class="mw-editsection"></span></h2>
<p>Some computing environments use stacks in ways that may make them vulnerable to security breaches and attacks.  Programmers working in such environments must take special care to avoid the pitfalls of these implementations.
</p><p>For example, some programming languages use a common stack to store both data local to a called procedure and the linking information that allows the procedure to return to its caller.  This means that the program moves data into and out of the same stack that contains critical return addresses for the procedure calls.  If data is moved to the wrong location on the stack, or an oversized data item is moved to a stack location that is not large enough to contain it, return information for procedure calls may be corrupted, causing the program to fail.
</p><p>Malicious parties may attempt a stack smashing attack that takes advantage of this type of implementation by providing oversized data input to a program that does not check the length of input.  Such a program may copy the data in its entirety to a location on the stack, and in so doing it may change the return addresses for procedures that have called it.  An attacker can experiment to find a specific type of data that can be provided to such a program such that the return address of the current procedure is reset to point to an area within the stack itself (and within the data provided by the attacker), which in turn contains instructions that carry out unauthorized operations.
</p><p>This type of attack is a variation on the buffer overflow attack and is an extremely frequent source of security breaches in software, mainly because some of the most popular compilers use a shared stack for both data and procedure calls, and do not verify the length of data items.  Frequently, programmers do not write code to verify the size of data items, either, and when an oversized or undersized data item is copied to the stack, a security breach may occur.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1128808480">.mw-parser-output .portalbox{padding:0;display:table;box-sizing:border-box;max-width:175px}.mw-parser-output .portalborder{border:solid #aaa 1px;padding:0.1em;background:#f9f9f9}.mw-parser-output .portalbox-entry{display:table-row;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox-image{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox-link{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}@media(min-width:720px){.mw-parser-output .portalleft{clear:left;float:left;margin:0.5em 1em 0.5em 0}.mw-parser-output .portalright{clear:right;float:right;margin:0.5em 0 0.5em 1em}}</style>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<ul><li><img alt="Public Domain" class="noviewer" data-file-height="196" data-file-width="196" decoding="async" height="12" src="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/12px-PD-icon.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/18px-PD-icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/6/62/PD-icon.svg/24px-PD-icon.svg.png 2x" width="12"/> This article incorporates public domain material from <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs1" id="CITEREFPaul_E._Black">Paul E. Black. "Bounded stack". <i>Dictionary of Algorithms and Data Structures</i>. NIST.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Dictionary+of+Algorithms+and+Data+Structures&amp;rft.atitle=Bounded+stack&amp;rft.au=Paul+E.+Black&amp;rft_id=https%3A%2F%2Fxlinux.nist.gov%2Fdads%2FHTML%2Fboundedstack.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AStack+%28abstract+data+type%29"></span></li></ul>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li>Donald Knuth. <i>The Art of Computer Programming</i>, Volume 1: <i>Fundamental Algorithms</i>, Third Edition. Addison-Wesley, 1997. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-89683-4. Section 2.2.1: Stacks, Queues, and Deques, pp. 238–243.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1 cs1-prop-location-test cs1-prop-foreign-lang-source" id="CITEREFLangmaack2015">Langmaack, Hans (2015) [2014-11-14].  Written at Kiel, Germany. <i>Friedrich L. Bauers und Klaus Samelsons Arbeiten in den 1950er-Jahren zur Einführung der Begriffe Kellerprinzip und Kellerautomat</i> [<i>Friedrich L. Bauer's and Klaus Samelson's works in the 1950s on the introduction of the terms cellar principle and cellar automaton</i>] <span class="cs1-format">(PDF)</span> (in German). Jena, Germany: Institut für Informatik, Christian-Albrechts-Universität zu Kiel. pp. 19–29. Archived <span class="cs1-format">(PDF)</span> from the original on 2022-11-14<span class="reference-accessdate">. Retrieved <span class="nowrap">2022-11-14</span></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Friedrich+L.+Bauers+und+Klaus+Samelsons+Arbeiten+in+den+1950er-Jahren+zur+Einf%C3%BChrung+der+Begriffe+Kellerprinzip+und+Kellerautomat&amp;rft.place=Jena%2C+Germany&amp;rft.pages=19-29&amp;rft.pub=Institut+f%C3%BCr+Informatik%2C+Christian-Albrechts-Universit%C3%A4t+zu+Kiel&amp;rft.date=2015&amp;rft.aulast=Langmaack&amp;rft.aufirst=Hans&amp;rft_id=https%3A%2F%2Fdl.gi.de%2Fbitstream%2Fhandle%2F20.500.12116%2F33413%2F19.pdf%3Fsequence%3D1%26isAllowed%3Dy&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AStack+%28abstract+data+type%29"></span> (11 pages) (NB. Published in Fothe &amp; Wilke.)</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1 cs1-prop-foreign-lang-source" id="CITEREFGoos2017">Goos, Gerhard (2017-08-07). <i>Geschichte der deutschsprachigen Informatik - Programmiersprachen und Übersetzerbau</i> [<i>History of informatics in German-speaking countries - Programming languages and compiler design</i>] <span class="cs1-format">(PDF)</span> (in German). Karlsruhe, Germany: Fakultät für Informatik, Karlsruhe Institute of Technology (KIT). Archived <span class="cs1-format">(PDF)</span> from the original on 2022-05-19<span class="reference-accessdate">. Retrieved <span class="nowrap">2022-11-14</span></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Geschichte+der+deutschsprachigen+Informatik+-+Programmiersprachen+und+%C3%9Cbersetzerbau&amp;rft.place=Karlsruhe%2C+Germany&amp;rft.pub=Fakult%C3%A4t+f%C3%BCr+Informatik%2C+Karlsruhe+Institute+of+Technology+%28KIT%29&amp;rft.date=2017-08-07&amp;rft.aulast=Goos&amp;rft.aufirst=Gerhard&amp;rft_id=http%3A%2F%2Fwww.kps2017.uni-jena.de%2Fproceedings%2Fkps2017_submission_1.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AStack+%28abstract+data+type%29"></span> (11 pages)</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<link href="mw-data:TemplateStyles:r1097025294" rel="mw-deduplicated-inline-style"/>
<ul><li>Stack Machines - the new wave</li>
<li>Bounding stack depth</li>
<li>Stack Size Analysis for Interrupt-driven Programs</li></ul>


<!-- 
NewPP limit report
Parsed by mw2325
Cached time: 20221223235231
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.539 seconds
Real time usage: 0.788 seconds
Preprocessor visited node count: 3508/1000000
Post‐expand include size: 87962/2097152 bytes
Template argument size: 3185/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 15/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 93870/5000000 bytes
Lua time usage: 0.323/10.000 seconds
Lua memory usage: 28342720/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  699.080      1 -total
 48.96%  342.301      2 Template:Reflist
 16.55%  115.674     14 Template:Cite_book
 13.53%   94.616      2 Template:Lang
  9.13%   63.831      1 Template:Introduction_to_Algorithms
  6.99%   48.871      1 Template:Short_description
  6.81%   47.612      2 Template:Sister_project
  6.58%   46.019      1 Template:Commons_category
  6.56%   45.859      2 Template:Side_box
  6.23%   43.524      1 Template:Data_structures
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:273993-0!canonical and timestamp 20221223235231 and revision id 1126628432.
 -->
</div></body>
</html>