nondeterministic_finite_state_machineIn automata theory, a finite-state machine is called a deterministic finite automaton (DFA), ifeach of its transitions is uniquely determined by its source state and input symbol, andreading an input symbol is required for each state transition.A nondeterministic finite automaton (NFA), or nondeterministic finite-state machine, does not need to obey these restrictions. In particular, every DFA is also an NFA. Sometimes the term NFA is used in a narrower sense, referring to an NFA that is not a DFA, but not in this article.Using the subset construction algorithm, each NFA can be translated to an equivalent DFA; i.e., a DFA recognizing the same formal language.[1]Like DFAs, NFAs only recognize regular languages.NFAs were introduced in 1959 by Michael O. Rabin and Dana Scott,[2]  who also showed their equivalence to DFAs. NFAs are used in the implementation of regular expressions: Thompson's construction is an algorithm for compiling a regular expression to an NFA that can efficiently perform pattern matching on strings. Conversely, Kleene's algorithm can be used to convert an NFA into a regular expression (whose size is generally exponential in the input automaton).NFAs have been generalized in multiple ways, e.g., nondeterministic finite automata with ε-moves, finite-state transducers, pushdown automata, alternating automata, ω-automata, and probabilistic automata.Besides the DFAs, other known special cases of NFAsare unambiguous finite automata (UFA)and self-verifying finite automata (SVFA).There are two ways to describe the behavior of an NFA, and both of them are equivalent. The first way makes use of the nondeterminism in the name of an NFA. For each input symbol, the NFA transitions to a new state until all input symbols have been consumed. In each step, the automaton nondeterministically "chooses" one of the applicable transitions. If there exists at least one "lucky run", i.e. some sequence of choices leading to an accepting state after completely consuming the input, it is accepted. Otherwise, i.e. if no choice sequence at all can consume all the input[3] and lead to an accepting state, the input is rejected.[4][5]In the second way, the NFA consumes a string of input symbols, one by one. In each step, whenever two or more transitions are applicable, it "clones" itself into appropriately many copies, each one following a different transition. If no transition is applicable, the current copy is in a dead end, and it "dies". If, after consuming the complete input, any of the copies is in an accept state, the input is accepted, else, it is rejected.[4][6][7]For a more elementary introduction of the formal definition see automata theory.An NFA is represented formally by a 5-tuple,, consisting ofa finite set of states .a finite set of input symbols .a transition function  : .an initial (or start) state .a set of states  distinguished as accepting (or final) states .Here,  denotes the power set of .Given an NFA , its recognized language is denoted by , and is defined as the set of all strings over the alphabet  that are accepted by .Loosely corresponding to the above informal explanations, there are several equivalent formal definitions of a string  being accepted by : is accepted if a sequence of states, , exists in  such that:, for .In words, the first condition says that the machine starts in the start state . The second condition says that given each character of string , the machine will transition from state to state according to the transition function . The last condition says that the machine accepts  if the last input of  causes the machine to halt in one of the accepting states. In order for  to be accepted by , it is not required that every state sequence ends in an accepting state, it is sufficient if one does. Otherwise, i.e. if it is impossible at all to get from  to a state from  by following , it is said that the automaton rejects the string. The set of strings  accepts is the language recognized by  and this language is denoted by .[5][6]Alternatively,  is accepted if , where  is defined recursively by: where  is the empty string, and for all .In words,  is the set of all states reachable from state  by consuming the string . The string  is accepted if some accepting state in  can be reached from the start state  by consuming .[4][7]The above automaton definition uses a single initial state, which is not necessary. Sometimes, NFAs are defined with a set of initial states. There is an easy construction that translates an NFA with multiple initial states to an NFA with a single initial state, which provides a convenient notation.The following automaton , with a binary alphabet, determines if the input ends with a 1.Let  wherethe transition function  can be defined by this state transition table (cf. upper left picture):01Since the set  contains more than one state,  is nondeterministic.The language of  can be described by the regular language given by the regular expression (0|1)*1.All possible state sequences for the input string "1011" are shown in the lower picture.The string is accepted by  since one state sequence satisfies the above definition; it doesn't matter that other sequences fail to do so.The picture can be interpreted in a couple of ways:In terms of the above "lucky-run" explanation, each path in the picture denotes a sequence of choices of .In terms of the "cloning" explanation, each vertical column shows all clones of  at a given point in time, multiple arrows emanating from a node indicate cloning, a node without emanating arrows indicating the "death" of a clone.The feasibility to read the same picture in two ways also indicates the equivalence of both above explanations.Considering the first of the above formal definitions, "1011" is accepted since when reading it  may traverse the state sequence , which satisfies conditions 1 to 3.Concerning the second formal definition, bottom-up computation shows that , hence , hence , hence , and hence ; since that set is not disjoint from , the string "1011" is accepted.In contrast, the string "10" is rejected by  (all possible state sequences for that input are shown in the upper right picture), since there is no way to reach the only accepting state, , by reading the final 0 symbol. While  can be reached after consuming the initial "1", this does not mean that the input "10" is accepted; rather, it means that an input string "1" would be accepted.A deterministic finite automaton (DFA) can be seen as a special kind of NFA, in which for each state and symbol, the transition function has exactly one state. Thus, it is clear that every formal language that can be recognized by a DFA can be recognized by an NFA.Conversely, for each NFA, there is a DFA such that it recognizes the same formal language. The DFA can be constructed using the powerset construction.This result shows that NFAs, despite their additional flexibility, are unable to recognize  languages that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has n states, the resulting DFA may have up to  states, which sometimes makes the construction impractical for large NFAs.Nondeterministic finite automaton with ε-moves (NFA-ε) is a further generalization to NFA. In this kind of automaton, the transition function is additionally defined on the empty string ε. A transition without consuming an input symbol is called an ε-transition and is represented in state diagrams by an arrow labeled "ε". ε-transitions provide a convenient way of modeling systems whose current states are not precisely known: i.e., if we are modeling a system and it is not clear whether the current state (after processing some input string) should be q or q', then we can add an ε-transition between these two states, thus putting the automaton in both states simultaneously.An NFA-ε is represented formally by a 5-tuple, , consisting ofa finite set of states a finite set of input symbols called the alphabet a transition function an initial (or start) state a set of states  distinguished as accepting (or final) states .Here,  denotes the power set of  and ε denotes empty string.For a state , let  denote the set of states that are reachable from  by following ε-transitions in the transition function , i.e., if there is a sequence of states  such that, for each , and. is known as the epsilon closure, (also ε-closure) of .The ε-closure of a set  of states of an NFA is defined as the set of states reachable from any state in  following ε-transitions. Formally, for , define .Similar to NFA without ε-moves, the transition function  of an NFA-ε can be extended to strings.Informally,  denotes the set of all states the automaton may have reached when starting in state  and reading the string The function  can be defined recursively as follows., for each state  and where  denotes the epsilon closure;Informally: Reading the empty string may drive the automaton from state  to any state of the epsilon closure of  for each state  each string  and each symbol Informally: Reading the string  may drive the automaton from state  to any state  in the recursively computed set ; after that, reading the symbol  may drive it from  to any state in the epsilon closure of The automaton is said to accept a string  if that is, if reading  may drive the automaton from its start state  to some accepting state in [4]Let  be a NFA-ε, with a binary alphabet, that determines if the input contains an even number of 0s or an even number of 1s. Note that 0 occurrences is an even number of occurrences as well.In formal notation, let  wherethe transition relation  can be defined by this state transition table:01εS0{}{}{S1, S3}S1{S2}{S1}{}S2{S1}{S2}{}S3{S3}{S4}{}S4{S4}{S3}{} can be viewed as the union of two DFAs: one with states  and the other with states . The language of  can be described by the regular language given by this regular expression .We define  using ε-moves but  can be defined without using ε-moves.To show NFA-ε is equivalent to NFA, first note that NFA is a special case of NFA-ε, so it remains to show for every NFA-ε, there exists an equivalent NFA.Given an NFA with epsilon moves define an NFA  whereand for each state  and each symbol  using the extended transition function  defined above.One has to distinguish the transition functions of  and  viz.  and  and their extensions to strings,  and  respectively.By construction,  has no ε-transitions.One can prove that  for each string , by induction on the length of Based on this, one can show that  if, and only if,  for each string If  this follows from the definition of Otherwise, let  with  and From  and  we have  we still have to show the "" direction.If  contains a state in  then  contains the same state, which lies in .If  contains  and  then   also contains a state in  viz. If  contains  and  then [] must be in [4]Since NFA is equivalent to DFA, NFA-ε is also equivalent to DFA.The set of languages recognized by NFAs is closed under the following operations. These closure operations are used in Thompson's construction algorithm, which constructs an NFA from any regular expression. They can also be used to prove that NFAs recognize exactly the regular languages.Union (cf. picture); that is, if the language L1 is accepted by some NFA A1 and L2 by some A2, then an NFA Au can be constructed that accepts the language L1∪L2.Intersection; similarly, from A1 and A2 an NFA Ai can be constructed that accepts L1∩L2.ConcatenationNegation; similarly, from A1 an NFA An can be constructed that accepts Σ*\L1.Kleene closureSince NFAs are equivalent to nondeterministic finite automaton with ε-moves (NFA-ε), the above closures are proved using closure properties of NFA-ε.The machine starts in the specified initial state and reads in a string of symbols from its alphabet. The automaton uses the state transition function Δ to determine the next state using the current state, and the symbol just read or the empty string. However, "the next state of an NFA depends not only on the current input event, but also on an arbitrary number of subsequent input events. Until these subsequent events occur it is not possible to determine which state the machine is in".[8] If, when the automaton has finished reading, it is in an accepting state, the NFA is said to accept the string, otherwise it is said to reject the string.The set of all strings accepted by an NFA is the language the NFA accepts. This language is a regular language.For every NFA a deterministic finite automaton (DFA) can be found that accepts the same language. Therefore, it is possible to convert an existing NFA into a DFA for the purpose of implementing a (perhaps) simpler machine. This can be performed using the powerset construction, which may lead to an exponential rise in the number of necessary states. For a formal proof of the powerset construction, please see the Powerset construction article.There are many ways to implement a NFA:Convert to the equivalent DFA. In some cases this may cause exponential blowup in the number of states.[9]Keep a set data structure of all states which the NFA might currently be in. On the consumption of an input symbol, unite the results of the transition function applied to all current states to get the set of next states; if ε-moves are allowed, include all states reachable by such a move (ε-closure). Each step requires at most s2 computations, where s is the number of states of the NFA. On the consumption of the last input symbol, if one of the current states is a final state, the machine accepts the string. A string of length n can be processed in time O(ns2),[7] and space O(s).Create multiple copies. For each n way decision, the NFA creates up to  copies of the machine. Each will enter a separate state. If, upon consuming the last input symbol, at least one copy of the NFA is in the accepting state, the NFA will accept.  (This, too, requires linear storage with respect to the number of NFA states, as there can be one machine for every NFA state.)Explicitly propagate tokens through the transition structure of the NFA and match whenever a token reaches the final state. This is sometimes useful when the NFA should encode additional context about the events that triggered the transition. (For an implementation that uses this technique to keep track of object references have a look at Tracematches.[10])It is PSPACE-complete to test, given an NFA, whether it is universal, i.e., if there is a string that it does not accept.[11] The same is true of the inclusion problem, i.e., given two NFAs, is the language of one a subset of the language of the other.NFAs and DFAs are equivalent in that if a language is recognized by an NFA, it is also recognized by a DFA and vice versa.  The establishment of such equivalence is important and useful.  It is useful because constructing an NFA to recognize a given language is sometimes much easier than constructing a DFA for that language.  It is important because NFAs can be used to reduce the complexity of the mathematical work required to establish many important properties in the theory of computation.  For example, it is much easier to prove closure properties of regular languages using NFAs than DFAs.Deterministic finite automatonTwo-way nondeterministic finite automatonPushdown automatonNondeterministic Turing machineM. O. Rabin and D. Scott, "Finite Automata and their Decision Problems", IBM Journal of Research and Development, 3:2 (1959) pp. 115–125.Michael Sipser, Introduction to the Theory of Computation. PWS, Boston. 1997. ISBN 0-534-94728-X. (see section 1.2: Nondeterminism, pp. 47–63.)John E. Hopcroft and Jeffrey D. Ullman, Introduction to Automata Theory, Languages, and Computation, Addison-Wesley Publishing, Reading Massachusetts, 1979. ISBN 0-201-02988-X. (See chapter 2.)