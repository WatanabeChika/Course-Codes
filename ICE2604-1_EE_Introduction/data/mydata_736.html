<!DOCTYPE html>
<html>
<head>
<title>passive_data_structure</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>In computer science and object-oriented programming, a <b>passive data structure</b> (<b>PDS</b>, also termed a <b>plain old data structure</b>, or <b>plain old data</b>, <b>POD</b>) is a term for a record, to contrast with objects. It is a data structure that is represented only as passive collections of field values (instance variables), without using object-oriented features.<sup class="reference" id="cite_ref-psd_1-0">[1]</sup>
</p>

<h2><span class="mw-headline" id="Rationale">Rationale</span><span class="mw-editsection"></span></h2>
<p>Passive data structures are appropriate when there is a part of a system where it should be clearly indicated that the detailed logic for data manipulation and integrity are elsewhere. PDSs are often found at the boundaries of a system, where information is being moved to and from other systems or persistent storage and the problem domain logic that is found in other parts of the system is irrelevant. For example, PDS would be convenient for representing the field values of objects that are being constructed from external data, in a part of the system where the semantic checks and interpretations needed for valid objects are not applied yet.
</p>
<h2><span id="In_C.2B.2B"></span><span class="mw-headline" id="In_C++">In C++</span><span class="mw-editsection"></span></h2>
<p>A PDS type in C++, or Plain Old C++ Object, is defined as either a scalar type or a PDS class.<sup class="reference" id="cite_ref-2">[2]</sup> A PDS class has no user-defined copy assignment operator, no user-defined destructor, and no non-static data members that are not themselves PDS. Moreover, a PDS class must be an aggregate, meaning it has no user-declared constructors, no private nor protected non-static data, no virtual base classes<sup class="reference" id="cite_ref-4">[a]</sup> and no virtual functions.<sup class="reference" id="cite_ref-5">[4]</sup> The standard includes statements about how PDS must behave in C++. The <code>type_traits</code> library in the C++ Standard Library provides a template named <code>is_pod</code> that can be used to determine whether a given type is a POD.<sup class="reference" id="cite_ref-6">[5]</sup> In C++20 the notion of “plain old data” (POD) and by that <code>is_pod</code> is deprecated and replaced with the concept of “trivial” and “standard-layout” types.<sup class="reference" id="cite_ref-7">[6]</sup>
</p><p>In some contexts, C++ allows only PDS types to be used.  For example, a <code>union</code> in C++98 cannot contain a class that has virtual functions or nontrivial constructors or destructors. This restriction is imposed because the compiler cannot determine which constructor or destructor should be called for a union. PDS types can also be used for interfacing with C, which supports only PDS.
</p>
<h2><span class="mw-headline" id="In_Java">In Java</span><span class="mw-editsection"></span></h2>
<p>In Java, some developers consider that the PDS concept corresponds to a class with public data members and no methods (Java Code Conventions 10.1),<sup class="reference" id="cite_ref-Oracle_8-0">[7]</sup> i.e., a data transfer object.<sup class="reference" id="cite_ref-9">[8]</sup> Others would also include Plain old Java objects (POJOs), a class that has methods but only getters and setters, with no logic, and JavaBeans to fall under the PDS concept if they do not use event handling and do not implement added methods beyond getters and setters.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (February 2010)">citation needed</span></i>]</sup>  However, POJOs and Java Beans have encapsulation, and so violate the fundamental definition of PDS.
</p><p>Records (introduced in Java 16, in 2021) are shallowly immutable carriers of data without encapsulation, and therefore they can also be considered PDS.
</p>
<h2><span class="mw-headline" id="In_other_languages">In other languages</span><span class="mw-editsection"></span></h2>
<p>In PHP, associative arrays and stdClass objects can be considered PDS.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (September 2019)">citation needed</span></i>]</sup>
</p><p>Other structured data representations such as XML or JSON can also be used as a PDS if no significant semantic restrictions are used.
</p><p>In Python, dataclass module provides dataclasses - often used as behaviourless containers for holding data, with options for data validation.
</p><p>In C, structs are used in the same manner
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Plain old CLR object</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<!-- 
NewPP limit report
Parsed by mw2389
Cached time: 20221224010219
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.167 seconds
Real time usage: 0.237 seconds
Preprocessor visited node count: 1018/1000000
Post‐expand include size: 18262/2097152 bytes
Template argument size: 1949/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 25106/5000000 bytes
Lua time usage: 0.101/10.000 seconds
Lua memory usage: 4573138/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  221.493      1 -total
 46.69%  103.423      2 Template:Reflist
 27.65%   61.250      1 Template:Cite_journal
 23.84%   52.803      1 Template:Short_description
 16.22%   35.933      2 Template:Citation_needed
 13.35%   29.566      2 Template:Fix
 12.10%   26.806      2 Template:Pagetype
  9.54%   21.139      1 Template:Confused
  8.04%   17.810      4 Template:Category_handler
  7.43%   16.461      7 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2864060-0!canonical and timestamp 20221224010218 and revision id 1117381999.
 -->
</div></body>
</html>