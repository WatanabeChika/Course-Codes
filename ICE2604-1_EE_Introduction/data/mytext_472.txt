Munkres'_assignment_algorithmThe Hungarian method is a combinatorial optimization algorithm that solves the assignment problem in polynomial time and which anticipated later primal–dual methods. It was developed and published in 1955 by Harold Kuhn, who gave the name "Hungarian method" because the algorithm was largely based on the earlier works of two Hungarian mathematicians: Dénes Kőnig and Jenő Egerváry.[1][2]James Munkres reviewed the algorithm in 1957 and observed that it is (strongly) polynomial.[3] Since then the algorithm has been known also as the Kuhn–Munkres algorithm or Munkres assignment algorithm. The time complexity of the original algorithm was , however Edmonds and Karp, and independently Tomizawa noticed that it can be modified to achieve an  running time.[4][5][] One of the most popular[]  variants is the Jonker–Volgenant algorithm.[6] Ford and Fulkerson extended the method to general maximum flow problems in form of the Ford–Fulkerson algorithm. In 2006, it was discovered that Carl Gustav Jacobi had solved the assignment problem in the 19th century, and the solution had been published posthumously in 1890 in Latin.[7]In this simple example there are three workers: Paul, Dave, and Chris. One of them has to clean the bathroom, another sweep the floors and the third washes the windows, but they each demand different pay for the various tasks. The problem is to find the lowest-cost way to assign the jobs. The problem can be represented in a matrix of the costs of the workers doing the jobs. For example:Clean bathroomSweep floorsWash windowsPaul$2$3$3Dave$3$2$3Chris$3$3$2The Hungarian method, when applied to the above table, would give the minimum cost: this is $6, achieved by having Paul clean the bathroom, Dave sweep the floors, and Chris wash the windows.In the matrix formulation, we are given a nonnegative n×n matrix, where the element in the i-th row and j-th column represents the cost of assigning the j-th job to the i-th worker. We have to find an assignment of the jobs to the workers, such that each job is assigned to one worker and each worker is assigned one job, such that the total cost of assignment is minimum.This can be expressed as permuting the rows and columns of a cost matrix C to minimize the trace of a matrix:where L and R are permutation matrices.If the goal is to find the assignment that yields the maximum cost, the problem can be solved by negating the cost matrix C.The algorithm can equivalently be described by formulating the problem using a bipartite graph. We have a complete bipartite graph  with  worker vertices () and  job vertices (), and each edge has a nonnegative cost . We want to find a perfect matching with a minimum total cost.Let us call a function  a potential if  for each . The value of potential  is the sum of the potential over all vertices: .The cost of each perfect matching is at least the value of each potential: the total cost of the matching is the sum of costs of all edges; the cost of each edge is at least the sum of potentials of its endpoints; since the matching is perfect, each vertex is an endpoint of exactly one edge; hence the total cost is at least the total potential.The Hungarian method finds a perfect matching and a potential such that the matching cost equals the potential value. This proves that both of them are optimal. In fact, the Hungarian method finds a perfect matching of tight edges: an edge  is called tight for a potential  if . Let us denote the subgraph of tight edges by . The cost of a perfect matching in  (if there is one) equals the value of .During the algorithm we maintain a potential   and an orientation of  (denoted by ) which has the property that the edges oriented from  to  form a matching . Initially,  is 0 everywhere, and all edges are oriented from  to  (so  is empty). In each step, either we modify  so that its value increases, or modify the orientation to obtain a matching with more edges. We maintain the invariant that all the edges of  are tight.  We are done if  is a perfect matching.In a general step, let  and  be the vertices not covered by  (so  consists of the vertices in  with no incoming edge and  consists of the vertices in  with no outgoing edge). Let  be the set of vertices reachable in  from  by a directed path only following edges that are tight. This can be computed by breadth-first search.If  is nonempty, then reverse the orientation of a directed path in  from  to . Thus the size of the corresponding matching increases by 1.If  is empty, then let is well defined because at least one such edge  must exist whenever the matching is not yet of maximum possible size (see the following section); it is positive because there are no tight edges between  and . Increase  by  on the vertices of  and decrease  by  on the vertices of . The resulting  is still a potential, and although the graph  changes, it still contains  (see the next subsections). We orient the new edges from  to . By the definition of  the set  of vertices reachable from  increases (note that the number of tight edges does not necessarily increase).We repeat these steps until  is a perfect matching, in which case it gives a minimum cost assignment. The running time of this version of the method is :  is augmented  times, and in a phase where  is unchanged, there are at most  potential changes (since  increases every time). The time sufficient for a potential change is .We must show that as long as the matching is not of maximum possible size, the algorithm is always able to make progress — that is, to either increase the number of matched edges, or tighten at least one edge. It suffices to show that at least one of the following holds at every step: is of maximum possible size. contains an augmenting path. contains a loose-tailed path: a path from some vertex in  to a vertex in  that consists of any number (possibly zero) of tight edges followed by a single loose edge. The trailing loose edge of a loose-tailed path is thus from , guaranteeing that  is well defined.If  is of maximum possible size, we are of course finished. Otherwise, by Berge's lemma, there must exist an augmenting path  with respect to  in the underlying graph . However, this path may not exist in : Although every even-numbered edge in  is tight by the definition of , odd-numbered edges may be loose and thus absent from . One endpoint of  is in , the other in ; w.l.o.g., suppose it begins in . If every edge on  is tight, then it remains an augmenting path in  and we are done. Otherwise, let  be the first loose edge on . If  then we have found a loose-tailed path and we are done. Otherwise,  is reachable from some other path  of tight edges from a vertex in . Let  be the subpath of  beginning at  and continuing to the end, and let  be the path formed by travelling along  until a vertex on  is reached, and then continuing to the end of . Observe that  is an augmenting path in  with at least one fewer loose edge than .  can be replaced with  and this reasoning process iterated (formally, using induction on the number of loose edges) until either an augmenting path in  or a loose-tailed path in  is found.To show that every edge in  remains after adjusting , it suffices to show that for an arbitrary edge in , either both of its endpoints, or neither of them, are in . To this end let  be an edge in  from  to . It is easy to see that if  is in  then  must be too, since every edge in  is tight. Now suppose, toward contradiction, that  but .  itself cannot be in  because it is the endpoint of a matched edge, so there must be some directed path of tight edges from a vertex in  to . This path must avoid , since that is by assumption not in , so the vertex immediately preceding  in this path is some other vertex .  is a tight edge from  to  and is thus in . But then  contains two edges that share the vertex , contradicting the fact that  is a matching. Thus every edge in  has either both endpoints or neither endpoint in . remains a potentialTo show that  remains a potential after being adjusted, it suffices to show that no edge has its total potential increased beyond its cost. This is already established for edges in  by the preceding paragraph, so consider an arbitrary edge  from  to . If  is increased by , then either , in which case  is decreased by , leaving the total potential of the edge unchanged, or , in which case the definition of  guarantees that . Thus  remains a potential.Given  workers and tasks, and an ×  matrix containing the cost of assigning each worker to a task, find the cost minimizing assignment.First the problem is written in the form of a matrix as given belowa1 a2 a3 a4b1 b2 b3 b4c1 c2 c3 c4d1 d2 d3 d4where a, b, c and d are the workers who have to perform tasks 1, 2, 3 and 4. a1, a2, a3, a4 denote the penalties incurred when worker "a" does task 1, 2, 3, 4 respectively. The same holds true for the other symbols as well. The matrix is square, so each worker can perform only one task.Then we perform row operations on the matrix. To do this, the lowest of all ai (i belonging to 1-4) is taken and is subtracted from each element in that row. This will lead to at least one zero in that row (We get multiple zeros when there are two equal elements which also happen to be the lowest in that row). This procedure is repeated for all rows. We now have a matrix with at least one zero per row.As there are  workers and  tasks, adding or subtracting a fixed number to each item in a row or a column will only change the cost of the assignment by that amount; but the minimum cost assignment under old weights will remain a minimum cost assignment under new weights. Now we try to assign tasks to agents such that each agent is doing only one task and the penalty incurred in each case is zero. As all weights are non-negative, the assignment will be of minimum cost. This is illustrated below.0a2'a3'a4'b1'b2'b3'0c1'0c3'c4'd1'd2'0d4'The zeros that are indicated as 0 are the assigned tasks.Sometimes it may turn out that the matrix at this stage cannot be used for assigning, as is the case for the matrix below.0a2'0a4'b1'0b3'00c2'c3'c4'0d2'd3'd4'In the above case, no assignment can be made. Note that task 1 is done efficiently by both agents c and d. Both can't be assigned the same task. Also note that no one does task 3 efficiently.To overcome this, we repeat the above procedure for all columns (i.e. the minimum element in each column is subtracted from all the elements in that column) and then check if an assignment is possible.In most situations this will give the result, but if it is still not possible then we need to keep going.All zeros in the matrix must be covered by marking as few rows and/or columns as possible. The following procedure is one way to accomplish this:First, assign as many tasks as possible. The assigned tasks are represented by starring a zero.We assign the first zero of Row 1. The second zero of Row 1 can't be assigned, because it is on the same row as the first zero.We assign the first zero of Row 2. The second zero of Row 2 can't be assigned.Zeros on Row 3 and Row 4 can't be assigned, because they are on the same column as the zero assigned on Row 1.We could end with another assignment if we choose another ordering of the rows and columns.0*a2'0a4'b1'0*b3'00c2'c3'c4'0d2'd3'd4'Cover all columns having an assignment (columns 1 and 2).××0*a2'0a4'b1'0*b3'00c2'c3'c4'0d2'd3'd4'Find a non-covered zero and prime it. If the zero is on the same row as a starred zero, cover the corresponding row, and uncover the column of the starred zero.Here, the second zero of Row 1 is uncovered. Because there is another zero starred on Row 1, we cover Row 1 and uncover Column 1.Then, the second zero of Row 2 is uncovered. We cover Row 2 and uncover Column 2.×0*a2'0'a4'×b1'0*b3'00c2'c3'c4'0d2'd3'd4'0*a2'0'a4'×b1'0*b3'0'×0c2'c3'c4'0d2'd3'd4'If a non-covered zero has no assigned zero on its row, perform the following steps :Step 1: Find a starred zero on the corresponding column. If there is one, go to Step 2, else, stop.Step 2: Find a primed zero on the corresponding row (there should always be one). Go to Step 1.The zero on Row 3 is uncovered. We find on the path the first zero of Row 1, then the second zero of Row 1, then we are done.a2'a4'×b1'0*b3'0'×c2'c3'c4'0d2'd3'd4'For all zeros encountered during the path, star primed zeros and unstar starred zeros, remove all covered lines and primed zeros.As the path begins and ends by a primed zero when swapping starred zeros, we have assigned one more zero.0a2'0*a4'b1'0*b3'00*c2'c3'c4'0d2'd3'd4'Repeat the previous stepswe cover columns 1, 2 and 3. The second zero on Row 2 is uncovered, so we cover Row 2 and uncover Column 2××0a2'0*a4'b1'0*b3'0'×0*c2'c3'c4'0d2'd3'd4'All zeros are now covered with a minimal number of rows and columns.The aforementioned detailed description is just one way to draw the minimum number of lines to cover all the 0s. Other methods work as well. From the elements that are left, find the lowest value. Subtract this from every unmarked element and add it to every element covered by two lines.This is equivalent to subtracting a number from all rows which are not covered and adding the same number to all columns which are covered. These operations do not change optimal assignments. Repeat steps 3–4 until an assignment is possible; this is when the minimum number of lines used to cover all the 0s is equal to min(number of people, number of assignments), assuming dummy variables (usually the max cost) are used to fill in when the number of people is greater than the number of assignments. From Kőnig's theorem,[8] the minimum number of lines (minimum Vertex cover[9]) will be  (the size of maximum matching[10]). Thus, when   lines are required, minimum cost assignment can be found by looking at only zeroes in the matrix.R.E. Burkard, M. Dell'Amico, S. Martello: Assignment Problems (Revised reprint). SIAM, Philadelphia (PA.) 2012. ISBN 978-1-61197-222-1M. Fischetti, "Lezioni di Ricerca Operativa", Edizioni Libreria Progetto Padova, Italia, 1995.R. Ahuja, T. Magnanti, J. Orlin, "Network Flows", Prentice Hall, 1993.S. Martello, "Jeno Egerváry: from the origins of the Hungarian algorithm to satellite communication". Central European Journal of Operational Research 18, 47–58, 2010Bruff, Derek, The Assignment Problem and the Hungarian Method (matrix formalism).Mordecai J. Golin, Bipartite Matching and the Hungarian Method (bigraph formalism), Course Notes, Hong Kong University of Science and Technology.Hungarian maximum matching algorithm (both formalisms), in Brilliant website.R. A. Pilgrim, Munkres' Assignment Algorithm. Modified for Rectangular Matrices, Course notes, Murray State University.Mike Dawes, The Optimal Assignment Problem, Course notes, University of Western Ontario.On Kuhn's Hungarian Method – A tribute from Hungary, András Frank, Egervary Research Group, Pazmany P. setany 1/C, H1117, Budapest, Hungary.Lecture: Fundamentals of Operations Research - Assignment Problem - Hungarian Algorithm, Prof. G. Srinivasan, Department of Management Studies, IIT Madras.Extension: Assignment sensitivity analysis (with O(n^4) time complexity), Liu, Shell.Solve any Assignment Problem online, provides a step by step explanation of the Hungarian Algorithm.Note that not all of these satisfy the  time complexity, even if they claim so. Some may contain errors, implement the slower  algorithm, or have other inefficiencies. In the worst case, a code example linked from Wikipedia could later be modified to include exploit code. Verification and benchmarking is necessary when using such code examples from unknown authors.Julia implementationC implementation claiming  time complexityJava implementation claiming  time complexityPython implementationRuby implementation with unit testsC# implementation claiming  time complexityD implementation with unit tests (port of a Java version claiming )Online interactive implementationSerial and parallel implementations.Matlab and CPerl implementationC++ implementationC++ implementation claiming  time complexity (BSD style open source licensed)MATLAB implementationC implementationJavaScript implementation with unit tests (port of a Java version claiming  time complexity)Clue R package proposes an implementation, solve_LSAPNode.js implementation on GitHubPython implementation in scipy package