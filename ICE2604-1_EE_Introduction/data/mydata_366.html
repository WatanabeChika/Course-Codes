<!DOCTYPE html>
<html>
<head>
<title>interpolation_search</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p><b>Interpolation search</b> is an algorithm for searching for a key in an array that has been ordered by numerical values assigned to the keys (<i>key values</i>). It was first described by W. W. Peterson in 1957.<sup class="reference" id="cite_ref-1">[1]</sup> Interpolation search resembles the method by which people search a telephone directory for a name (the key value by which the book's entries are ordered): in each step the algorithm calculates where in the remaining search space the sought item might be, based on the key values at the bounds of the search space and the value of the sought key, usually via a linear interpolation. The key value actually found at this estimated position is then compared to the key value being sought. If it is not equal, then depending on the comparison, the remaining search space is reduced to the part before or after the estimated position. This method will only work if calculations on the size of differences between key values are sensible.
</p><p class="mw-empty-elt">
</p>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Interpolation search</caption><tbody><tr><td class="infobox-image" colspan="2"><img alt="Interpolation sort.gif" data-file-height="225" data-file-width="498" decoding="async" height="99" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/08/Interpolation_sort.gif/220px-Interpolation_sort.gif" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/0/08/Interpolation_sort.gif/330px-Interpolation_sort.gif 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/0/08/Interpolation_sort.gif/440px-Interpolation_sort.gif 2x" width="220"/></td></tr><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Search algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row">Best-case performance</th><td class="infobox-data"><i>O</i>(1)</td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data"><i>O</i>(log(log(<i>n</i>)))<sup class="reference" id="cite_ref-2">[2]</sup></td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><i>O</i>(1)</td></tr></tbody></table>
<p>By comparison, binary search always chooses the middle of the remaining search space, discarding one half or the other, depending on the comparison between the key found at the estimated position and the key sought — it does not require numerical values for the keys, just a total order on them. The remaining search space is reduced to the part before or after the estimated position. The linear search uses equality only as it compares elements one-by-one from the start, ignoring any sorting.
</p><p>On average the interpolation search makes about log(log(<i>n</i>)) comparisons (if the elements are uniformly distributed), where <i>n</i> is the number of elements to be searched. In the worst case (for instance where the numerical values of the keys increase exponentially) it can make up to O(<i>n</i>) comparisons.
</p><p>In interpolation-sequential search, interpolation is used to find an item near the one being searched for, then linear search is used to find the exact item.
</p>

<h2><span class="mw-headline" id="Performance">Performance</span><span class="mw-editsection"></span></h2>
<p>Using big-O notation, the performance of the interpolation algorithm on a data set of size <i>n</i> is <i>O</i>(<i>n</i>); however under the assumption of a uniform distribution of the data on the linear scale used for interpolation, the performance can be shown to be <i>O</i>(log log <i>n</i>).<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup><sup class="reference" id="cite_ref-5">[5]</sup> However, Dynamic Interpolation Search is possible in <i>o</i>(log log <i>n</i>) time using a novel data structure.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>Practical performance of interpolation search depends on whether the reduced number of probes is outweighed by the more complicated calculations needed for each probe.  It can be useful for locating a record in a large sorted file on disk, where each probe involves a disk seek and is much slower than the interpolation arithmetic.
</p><p>Index structures like B-trees also reduce the number of disk accesses, and are more often used to index on-disk data in part because they can index many types of data and can be updated online.  Still, interpolation search may be useful when one is forced to search certain sorted but unindexed on-disk datasets.
</p>
<h2><span class="mw-headline" id="Adaptation_to_different_datasets">Adaptation to different datasets</span><span class="mw-editsection"></span></h2>
<p>When sort keys for a dataset are uniformly distributed numbers, linear interpolation is straightforward to implement and will find an index very near the sought value.
</p><p>On the other hand, for a phone book sorted by name, the straightforward approach to interpolation search does not apply.  The same high-level principles can still apply, though: one can estimate a name's position in the phone book using the relative frequencies of letters in names and use that as a probe location.
</p><p>Some interpolation search implementations may not work as expected when a run of equal key values exists.  The simplest implementation of interpolation search won't necessarily select the first (or last) element of such a run.
</p>
<h2><span class="mw-headline" id="Book-based_searching">Book-based searching</span><span class="mw-editsection"></span></h2>
<p>The conversion of names in a telephone book to some sort of number clearly will not provide numbers having a uniform distribution (except via immense effort such as sorting the names and calling them name #1, name #2, etc.) and further, it is well known that some names are much more common than others (Smith, Jones,) Similarly with dictionaries, where there are many more words starting with some letters than others. Some publishers go to the effort of preparing marginal annotations or even cutting into the side of the pages to show markers for each letter so that at a glance a segmented interpolation can be performed.
</p>
<h2><span class="mw-headline" id="Sample_implementation">Sample implementation</span><span class="mw-editsection"></span></h2>
<p>The following C++ code example is a simple implementation. At each stage it computes a probe position then as with the binary search, moves either the upper or lower bound in to define a smaller interval containing the sought value. Unlike the binary search which guarantees a halving of the interval's size with each stage, a misled interpolation may reduce/i-case efficiency of O(<i>n</i>).
</p>

<p>Notice that having probed the list at index <i>mid</i>, for reasons of loop control administration, this code sets either <i>high</i> or <i>low</i> to be not <i>mid</i> but an adjacent index, which location is then probed during the next iteration. Since an adjacent entry's value will not be much different, the interpolation calculation is not much improved by this one step adjustment, at the cost of an additional reference to distant memory such as disk.
</p><p>Each iteration of the above code requires between five and six comparisons (the extra is due to the repetitions needed to distinguish the three states of &lt; &gt; and = via binary comparisons in the absence of a three-way comparison) plus some messy arithmetic, while the binary search algorithm can be written with one comparison per iteration and uses only trivial integer arithmetic. It would thereby search an array of a million elements with no more than twenty comparisons (involving accesses to slow memory where the array elements are stored); to beat that, the interpolation search, as written above, would be allowed no more than three iterations.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Linear search</li>
<li>Binary search</li>
<li>Exponential search</li>
<li>Ternary search</li>
<li>Hash table</li>
<li>Newton's method</li>
<li>Flashsort, using the distribution of values for sorting rather than searching</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Interpolation search</li>
<li>National Institute of Standards and Technology</li>
<li>Interpolation Search - A Log LogN Search</li></ul>
<!-- 
NewPP limit report
Parsed by mw2406
Cached time: 20221224042938
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.175 seconds
Real time usage: 0.256 seconds
Preprocessor visited node count: 680/1000000
Post‐expand include size: 19012/2097152 bytes
Template argument size: 995/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 18473/5000000 bytes
Lua time usage: 0.104/10.000 seconds
Lua memory usage: 3960996/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  221.886      1 -total
 27.66%   61.383      1 Template:Cite_journal
 24.83%   55.086      1 Template:More_citations_needed
 22.81%   50.609      1 Template:Ambox
 21.90%   48.604      1 Template:Short_description
 12.37%   27.440      2 Template:Pagetype
 11.51%   25.543      1 Template:Infobox_algorithm
 10.15%   22.518      1 Template:Infobox
  5.45%   12.085      1 Template:Find_sources_mainspace
  5.28%   11.715      1 Template:Use_dmy_dates
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:69895-0!canonical and timestamp 20221224042937 and revision id 1118570989.
 -->
</div></body>
</html>