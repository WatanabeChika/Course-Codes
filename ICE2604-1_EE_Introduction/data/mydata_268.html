<!DOCTYPE html>
<html>
<head>
<title>depth-first_search</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Depth-first search</caption><tbody><tr><td class="infobox-image" colspan="2"><small>Order in which the nodes are visited</small></td></tr><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Search algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Graph</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|V|+|E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>V</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|V|+|E|)}</annotation>
</semantics>
</math></span><img alt="O(|V| + |E|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" style="vertical-align: -0.838ex; width:12.573ex; height:2.843ex;"/></span> for explicit graphs traversed without repetition, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(b^{d})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>b</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>d</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(b^{d})}</annotation>
</semantics>
</math></span><img alt="O(b^d)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c99d691c81f015266d1626ef381d2a1a49466fbb" style="vertical-align: -0.838ex; width:5.672ex; height:3.176ex;"/></span> for implicit graphs with branching factor <i>b </i> searched to depth <i>d</i></td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|V|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>V</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|V|)}</annotation>
</semantics>
</math></span><img alt="O(|V|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3486d00c2ed0f7eb1db550af8f239ad68241a6c5" style="vertical-align: -0.838ex; width:6.664ex; height:2.843ex;"/></span> if entire graph is traversed without repetition, O(longest path length searched) =  <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(bd)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(bd)}</annotation>
</semantics>
</math></span><img alt="O(bd)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/39716f0489a8d178ee6e48d992b3b031cf987b9f" style="vertical-align: -0.838ex; width:5.796ex; height:2.843ex;"/></span>for implicit graphs without elimination of duplicate nodes</td></tr></tbody></table><style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p><b>Depth-first search</b> (<b>DFS</b>) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. Extra memory, usually a stack, is needed to keep track of the nodes discovered so far along a specified branch which helps in backtracking of the graph.
</p><p>A version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre Trémaux<sup class="reference" id="cite_ref-1">[1]</sup> as a strategy for solving mazes.<sup class="reference" id="cite_ref-2">[2]</sup><sup class="reference" id="cite_ref-3">[3]</sup>
</p>

<h2><span class="mw-headline" id="Properties">Properties</span><span class="mw-editsection"></span></h2>
<p>The time and space analysis of DFS differs according to its application area. In theoretical computer science, DFS is typically used to traverse an entire graph, and takes time <span class="nowrap"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|V|+|E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>V</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|V|+|E|)}</annotation>
</semantics>
</math></span><img alt="O(|V| + |E|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" style="vertical-align: -0.838ex; width:12.573ex; height:2.843ex;"/></span>,<sup class="reference" id="cite_ref-4">[4]</sup></span> where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle |V|}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>V</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle |V|}</annotation>
</semantics>
</math></span><img alt="|V|" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9ddcffc28643ac01a14dd0fb32c3157859e365a7" style="vertical-align: -0.838ex; width:3.081ex; height:2.843ex;"/></span> is the number of vertices  and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle |E|}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle |E|}</annotation>
</semantics>
</math></span><img alt="|E|" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8c2b9637808cf805d411190b4ae017dbd4ef8d8" style="vertical-align: -0.838ex; width:3.069ex; height:2.843ex;"/></span> the number of  edges. This is linear in the size of the graph. In these applications it also uses space <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|V|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>V</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|V|)}</annotation>
</semantics>
</math></span><img alt="O(|V|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3486d00c2ed0f7eb1db550af8f239ad68241a6c5" style="vertical-align: -0.838ex; width:6.664ex; height:2.843ex;"/></span> in the worst case to store the stack of vertices on the current search path as well as the set of already-visited vertices. Thus, in this setting, the time and space bounds are the same as for breadth-first search and the choice of which of these two algorithms to use depends less on their complexity and more on the different properties of the vertex orderings the two algorithms produce.
</p><p>For applications of DFS in relation to specific domains, such as searching for solutions in artificial intelligence or web-crawling, the graph to be traversed is often either too large to visit in its entirety or infinite (DFS may suffer from non-termination). In such cases, search is only performed to a limited depth; due to limited resources, such as memory or disk space, one typically does not use data structures to keep track of the set of all previously visited vertices. When search is performed to a limited depth, the time is still linear in terms of the number of expanded vertices and edges (although this number is not the same as the size of the entire graph because some vertices may be searched more than once and others not at all) but the space complexity of this variant of DFS is only proportional to the depth limit, and as a result, is much smaller than the space needed for searching to the same depth using breadth-first search. For such applications, DFS also lends itself much better to heuristic methods for choosing a likely-looking branch. When an appropriate depth limit is not known a priori, iterative deepening depth-first search applies DFS repeatedly with a sequence of increasing limits. In the artificial intelligence mode of analysis, with a branching factor greater than one, iterative deepening increases the running time by only a constant factor over the case in which the correct depth limit is known due to the geometric growth of the number of nodes per level.
</p><p>DFS may also be used to collect a sample of graph nodes. However, incomplete DFS, similarly to incomplete BFS, is biased towards nodes of high degree.
</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>

<p>For the following graph:
</p><p><img alt="An undirected graph with edges AB, BD, BF, FE, AC, CG, AE" data-file-height="269" data-file-width="332" decoding="async" height="162" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/61/Graph.traversal.example.svg/200px-Graph.traversal.example.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/61/Graph.traversal.example.svg/300px-Graph.traversal.example.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/61/Graph.traversal.example.svg/400px-Graph.traversal.example.svg.png 2x" width="200"/>
</p><p>a depth-first search starting at the node A, assuming that the left edges in the shown graph are chosen before right edges, and assuming the search remembers previously visited nodes and will not repeat them (since this is a small graph), will visit the nodes in the following order: A, B, D, F, E, C, G.  The edges traversed in this search form a Trémaux tree, a structure with important applications in graph theory.
Performing the same search without remembering previously visited nodes results in visiting the nodes in the order A, B, D, F, E, A, B, D, F, E, etc. forever, caught in the A, B, D, F, E cycle and never reaching C or G.
</p><p>Iterative deepening is one technique to avoid this infinite loop and would reach all nodes.
</p>
<h2><span class="mw-headline" id="Output_of_a_depth-first_search">Output of a depth-first search</span><span class="mw-editsection"></span></h2>

<p>The result of a depth-first search of a graph can be conveniently described in terms of a spanning tree of the vertices reached during the search. Based on this spanning tree, the edges of the original graph can be divided into three classes: <b>forward edges</b>, which point from a node of the tree to one of its descendants, <b>back edges</b>, which point from a node to one of its ancestors, and <b>cross edges</b>, which do neither. Sometimes <b>tree edges</b>, edges which belong to the spanning tree itself, are classified separately from forward edges. If the original graph is undirected then all of its edges are tree edges or back edges.
</p>
<h3><span class="mw-headline" id="Vertex_orderings">Vertex orderings</span><span class="mw-editsection"></span></h3>
<p>It is also possible to use depth-first search to linearly order the vertices of a graph or tree. There are four possible ways of doing this:
</p>
<ul><li>A <b>preordering</b> is a list of the vertices in the order that they were first visited by the depth-first search algorithm. This is a compact and natural way of describing the progress of the search, as was done earlier in this article. A preordering of an expression tree is the expression in Polish notation.</li>
<li>A <b>postordering</b> is a list of the vertices in the order that they were <i>last</i> visited by the algorithm. A postordering of an expression tree is the expression in reverse Polish notation.</li>
<li>A <b>reverse preordering</b> is the reverse of a preordering, i.e. a list of the vertices in the opposite order of their first visit. Reverse preordering is not the same as postordering.</li>
<li>A <b>reverse postordering</b> is the reverse of a postordering, i.e. a list of the vertices in the opposite order of their last visit. Reverse postordering is not the same as preordering.</li></ul>
<p>For binary trees there is additionally <b>in-ordering</b> and <b>reverse in-ordering</b>.
</p><p>For example, when searching the directed graph below beginning at node A, the sequence of traversals is either A B D B A C A or A C D C A B A (choosing to first visit B or C from A is up to the algorithm). Note that repeat visits in the form of backtracking to a node, to check if it has still unvisited neighbors, are included here (even if it is found to have none). Thus the possible preorderings are A B D C and A C D B, while the possible postorderings are D B C A and D C B A, and the possible reverse postorderings are A C B D and A B C D.
</p>
<dl><dd><img alt="A directed graph with edges AB, BD, AC, CD" data-file-height="245" data-file-width="125" decoding="async" height="245" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/68/If-then-else-control-flow-graph.svg/125px-If-then-else-control-flow-graph.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/68/If-then-else-control-flow-graph.svg/188px-If-then-else-control-flow-graph.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/68/If-then-else-control-flow-graph.svg/250px-If-then-else-control-flow-graph.svg.png 2x" width="125"/></dd></dl>
<p>Reverse postordering produces a topological sorting of any directed acyclic graph. This ordering is also useful in control-flow analysis as it often represents a natural linearization of the control flows. The graph above might represent the flow of control in the code fragment below, and it is natural to consider this code in the order A B C D or A C B D but not natural to use the order A B D C or A C D B.
</p>
<pre>if (<b>A</b>) then {
    <b>B</b>
} else {
    <b>C</b>
}
<b>D</b>
</pre>
<h2><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h2>
<p><b>Input</b>: 
<b>Output</b>: 
A recursive implementation of DFS:<sup class="reference" id="cite_ref-5">[5]</sup>
</p>
<pre><b>procedure</b> DFS(<i>G</i>, <i>v</i>) <b>is</b>
    label <i>v</i> as discovered
    <b>for all</b> directed edges from <i>v</i> to <i>w that are</i> <b>in</b> <i>G</i>.adjacentEdges(<i>v</i>) <b>do</b>
        <b>if</b> vertex <i>w</i> is not labeled as discovered <b>then</b>
            recursively call DFS(<i>G</i>, <i>w</i>)
</pre>
<p>A non-recursive implementation of DFS with worst-case space complexity <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|E|)}</annotation>
</semantics>
</math></span><img alt="O(|E|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" style="vertical-align: -0.838ex; width:6.652ex; height:2.843ex;"/></span>, with the possibility of duplicate vertices on the stack:<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<pre><b>procedure</b> DFS_iterative(<i>G</i>, <i>v</i>) <b>is</b>
    let <i>S</i> be a stack
    <i>S</i>.push(<i>v</i>)
    <b>while</b> <i>S</i> is not empty <b>do</b>
        <i>v</i> = <i>S</i>.pop()
        <b>if</b> <i>v</i> is not labeled as discovered <b>then</b>
            label <i>v</i> as discovered
            <b>for all</b> edges from <i>v</i> to <i>w</i> <b>in</b> <i>G</i>.adjacentEdges(<i>v</i>) <b>do</b> 
                <i>S</i>.push(<i>w</i>)
</pre>

<p>These two variations of DFS visit the neighbors of each vertex in the opposite order from each other: the first neighbor of <i>v</i> visited by the recursive variation is  the first one in the list of adjacent edges, while in the iterative variation the first visited neighbor is the last one in the list of adjacent edges. The recursive implementation will visit the nodes from the example graph in the following order: A, B, D, F, E, C, G. The non-recursive implementation will visit the nodes as: A, E, F, B, D, C, G.
</p><p>The non-recursive implementation is similar to breadth-first search but differs from it in two ways: 
</p>
<ol><li>it uses a stack instead of a queue, and</li>
<li>it delays checking whether a vertex has been discovered until the vertex is popped from the stack rather than making this check before adding the vertex.</li></ol>
<p>If <span class="texhtml mvar" style="font-style:italic;">G</span> is a tree, replacing the queue of the breadth-first search algorithm with a stack will yield a depth-first search algorithm. For general graphs, replacing the stack of the iterative depth-first search implementation with a queue would also produce a breadth-first search algorithm, although a somewhat nonstandard one.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>Another possible implementation of iterative depth-first search uses a stack of iterators of the list of neighbors of a node, instead of a stack of nodes. This yields the same traversal as recursive DFS.<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<pre><b>procedure</b> DFS_iterative(<i>G</i>, <i>v</i>) <b>is</b>
    let <i>S</i> be a stack
    label <i>v</i> as discovered
    <i>S</i>.push(iterator of <i>G</i>.adjacentEdges(<i>v</i>))
    <b>while</b> <i>S</i> is not empty <b>do</b>
        <b>if</b> <i>S</i>.peek().hasNext() <b>then</b>
            <i>w</i> = <i>S</i>.peek().next()
            <b>if</b> <i>w</i> is not labeled as discovered <b>then</b>
                label <i>w</i> as discovered
                <i>S</i>.push(iterator of <i>G</i>.adjacentEdges(<i>w</i>))
        <b>else</b>
            <i>S</i>.pop()
</pre>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>

<p>Algorithms that use depth-first search as a building block include:
</p>
<ul><li>Finding connected components.</li>
<li>Topological sorting.</li>
<li>Finding 2-(edge or vertex)-connected components.</li>
<li>Finding 3-(edge or vertex)-connected components.</li>
<li>Finding the bridges of a graph.</li>
<li>Generating words in order to plot the limit set of a group.</li>
<li>Finding strongly connected components.</li>
<li>Determining whether a species is closer to one species or another in a phylogenetic tree.</li>
<li>Planarity testing.<sup class="reference" id="cite_ref-9">[9]</sup><sup class="reference" id="cite_ref-10">[10]</sup></li>
<li>Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)</li>
<li>Maze generation may use a randomized DFS.</li>
<li>Finding biconnectivity in graphs.</li>
<li>Succession to the throne shared by the Commonwealth realms.<sup class="reference" id="cite_ref-11">[11]</sup></li></ul>
<h2><span class="mw-headline" id="Complexity">Complexity</span><span class="mw-editsection"></span></h2>
<p>The computational complexity of DFS was investigated by John Reif. More precisely, given a graph <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle G}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>G</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle G}</annotation>
</semantics>
</math></span><img alt="G" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" style="vertical-align: -0.338ex; width:1.827ex; height:2.176ex;"/></span>, let <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O=(v_{1},\dots ,v_{n})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo>=</mo>
<mo stretchy="false">(</mo>
<msub>
<mi>v</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>v</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O=(v_{1},\dots ,v_{n})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O=(v_{1},\dots ,v_{n})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/90a47bca827f9a7b1d72f77316d986207d0096ed" style="vertical-align: -0.838ex; width:16.387ex; height:2.843ex;"/></span> be the ordering computed by the standard recursive DFS algorithm. This ordering is called the lexicographic depth-first search ordering. John Reif considered the complexity of computing the lexicographic depth-first search ordering, given a graph and a source. A decision version of the problem (testing whether some vertex <span class="texhtml mvar" style="font-style:italic;">u</span> occurs before some vertex <span class="texhtml mvar" style="font-style:italic;">v</span> in this order) is <b>P</b>-complete,<sup class="reference" id="cite_ref-12">[12]</sup> meaning that it is "a nightmare for parallel processing".<sup class="reference" id="cite_ref-mehlhorn_13-0">[13]</sup><sup class="reference nowrap"><span title="Page / location: 189">: 189 </span></sup>
</p><p>A depth-first search ordering (not necessarily the lexicographic one), can be computed by a randomized parallel algorithm in the complexity class RNC.<sup class="reference" id="cite_ref-14">[14]</sup> As of 1997, it remained unknown whether a depth-first traversal could be constructed by a deterministic parallel algorithm, in the complexity class NC.<sup class="reference" id="cite_ref-15">[15]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Tree traversal (for details about pre-order, in-order and post-order depth-first traversal)</li>
<li>Breadth-first search</li>
<li>Iterative deepening depth-first search</li>
<li>Search game</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Open Data Structures - Section 12.3.2 - Depth-First-Search, Pat Morin</li>
<li>C++ Boost Graph Library: Depth-First Search</li>
<li>Depth-First Search Animation (for a directed graph)</li>
<li>Depth First and Breadth First Search: Explanation and Code</li>
<li>QuickGraph<sup class="noprint Inline-Template"><span style="white-space: nowrap;">[<i><span title=" Dead link tagged October 2022">permanent dead link</span></i>]</span></sup>, depth first search example for .Net</li>
<li>Depth-first search algorithm illustrated explanation (Java and C++ implementations)</li>
<li>YAGSBPL – A template-based C++ library for graph search and planning</li></ul>
<!-- 
NewPP limit report
Parsed by mw2373
Cached time: 20221220205509
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.399 seconds
Real time usage: 0.567 seconds
Preprocessor visited node count: 2274/1000000
Post‐expand include size: 57300/2097152 bytes
Template argument size: 2836/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 55047/5000000 bytes
Lua time usage: 0.215/10.000 seconds
Lua memory usage: 9378488/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  449.614      1 -total
 37.87%  170.262      1 Template:Reflist
 21.83%   98.170     10 Template:Citation
 12.17%   54.727      1 Template:Refimprove
 10.96%   49.256      1 Template:Ambox
 10.69%   48.072      1 Template:Graph_search_algorithm
 10.45%   46.971      1 Template:Short_description
 10.13%   45.543      1 Template:Sidebar
  8.80%   39.584      1 Template:ISSN
  7.52%   33.811      1 Template:Commons_category
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:97034-0!canonical and timestamp 20221220205509 and revision id 1127130104.
 -->
</div></body>
</html>