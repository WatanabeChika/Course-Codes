<!DOCTYPE html>
<html>
<head>
<title>strongly_connected_graph</title>
</head>
<body>
<div class="mw-parser-output">

<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks"><tbody><tr><td class="sidebar-pretitle" style="background-color: wheat">Relevant topics on</td></tr><tr><th class="sidebar-title-with-pretitle" style="background-color: wheat">Graph connectivity</th></tr><tr><td class="sidebar-content hlist">
<ul><li>Connectivity</li>
<li>Algebraic connectivity</li>
<li>Cycle rank</li>
<li>Rank (graph theory)</li>
<li>SPQR tree</li>
<li>St-connectivity</li>
<li>K-connectivity certificate</li>
<li>Pixel connectivity</li>
<li>Vertex separator</li>
<li>Strongly connected component</li>
<li>Biconnected graph</li>
<li>Bridge</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p>In the mathematical theory of directed graphs, a graph is said to be <b>strongly connected</b> if every vertex is reachable from every other vertex. The <b>strongly connected components</b> of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected. It is possible to test the strong connectivity of a graph, or to find its strongly connected components, in linear time (that is, Θ(<i>V</i> + <i>E</i>)).
</p>

<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"></span></h2>
<p>A directed graph is called <b>strongly connected</b> if there is a path in each direction between each pair of vertices of the graph. That is, a path exists from the first vertex in the pair to the second, and another path exists from the second vertex to the first.
In a directed graph <i>G</i> that may not itself be strongly connected, a pair of vertices <i>u</i> and <i>v</i> are said to be strongly connected to each other if there is a path in each direction between them.
</p><p>The binary relation of being strongly connected is an equivalence relation, and the induced subgraphs of its equivalence classes are called <b>strongly connected components</b>.
Equivalently, a <b>strongly connected component</b> of a directed graph <i>G</i> is a subgraph that is strongly connected, and is maximal with this property: no additional edges or vertices from <i>G</i> can be included in the subgraph without breaking its property of being strongly connected. The collection of strongly connected components forms a partition of the set of vertices of <i>G</i>. A strongly connected component <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>C</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C}</annotation>
</semantics>
</math></span><img alt="C" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" style="vertical-align: -0.338ex; width:1.766ex; height:2.176ex;"/></span> is called <i>trivial</i> when <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle C}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>C</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle C}</annotation>
</semantics>
</math></span><img alt="C" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" style="vertical-align: -0.338ex; width:1.766ex; height:2.176ex;"/></span> consists of a single vertex which is not connected to itself with an edge and <i>non-trivial</i> otherwise.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>

<p>If each strongly connected component is contracted to a single vertex, the resulting graph is a directed acyclic graph, the <b>condensation</b> of <i>G</i>. A directed graph is acyclic if and only if it has no strongly connected subgraphs with more than one vertex, because a directed cycle is strongly connected and every non-trivial strongly connected component contains at least one directed cycle.
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="DFS-based_linear-time_algorithms">DFS-based linear-time algorithms</span><span class="mw-editsection"></span></h3>
<p>Several algorithms based on depth-first search compute strongly connected components in linear time.
</p>
<ul><li>Kosaraju's algorithm uses two passes of depth-first search. The first, in the original graph, is used to choose the order in which the outer loop of the second depth-first search tests vertices for having been visited already and recursively explores them if not. The second depth-first search is on the transpose graph of the original graph, and each recursive exploration finds a single new strongly connected component.<sup class="reference" id="cite_ref-2">[2]</sup><sup class="reference" id="cite_ref-hong2013fast_3-0">[3]</sup> It is named after S. Rao Kosaraju, who described it (but did not publish his results) in 1978; Micha Sharir later published it in 1981.<sup class="reference" id="cite_ref-4">[4]</sup></li>
<li>Tarjan's strongly connected components algorithm, published by Robert Tarjan in 1972,<sup class="reference" id="cite_ref-5">[5]</sup> performs a single pass of depth-first search. It maintains a stack of vertices that have been explored by the search but not yet assigned to a component, and calculates "low numbers" of each vertex (an index number of the highest ancestor reachable in one step from a descendant of the vertex) which it uses to determine when a set of vertices should be popped off the stack into a new component.</li>
<li>The path-based strong component algorithm uses a depth-first search, like Tarjan's algorithm, but with two stacks. One of the stacks is used to keep track of the vertices not yet assigned to components, while the other keeps track of the current path in the depth-first search tree. The first linear time version of this algorithm was published by Edsger W. Dijkstra in 1976.<sup class="reference" id="cite_ref-6">[6]</sup></li></ul>
<p>Although Kosaraju's algorithm is conceptually simple, Tarjan's and the path-based algorithm require only one depth-first search rather than two.
</p>
<h3><span class="mw-headline" id="Reachability-based_algorithms">Reachability-based algorithms</span><span class="mw-editsection"></span></h3>
<p>Previous linear-time algorithms are based on depth-first search which is generally considered hard to parallelize.  Fleischer et al.<sup class="reference" id="cite_ref-Fleischer_7-0">[7]</sup> in 2000 proposed a divide-and-conquer approach based on reachability queries, and such algorithms are usually called reachability-based SCC algorithms.  The idea of this approach is to pick a random pivot vertex and apply forward and backward reachability queries from this vertex.  The two queries partition the vertex set into 4 subsets: vertices reached by both, either one, or none of the searches.  One can show that a strongly connected component has to be contained in one of the subsets.  The vertex subset reached by both searches forms a strongly connected component, and the algorithm then recurses on the other 3 subsets.
</p><p>The expected sequential running time of this algorithm is shown to be O(<i>n</i> log <i>n</i>), a factor of O(log <i>n</i>) more than the classic algorithms.  The parallelism comes from: (1) the reachability queries can be parallelized more easily (e.g. by a breadth-first search (BFS), and it can be fast if the diameter of the graph is small); and (2) the independence between the subtasks in the divide-and-conquer process.
This algorithm performs well on real-world graphs,<sup class="reference" id="cite_ref-hong2013fast_3-1">[3]</sup> but does not have theoretical guarantee on the parallelism (consider if a graph has no edges, the algorithm requires O(<i>n</i>) levels of recursions).
</p><p>Blelloch et al.<sup class="reference" id="cite_ref-Parallel_8-0">[8]</sup> in 2016 shows that if the reachability queries are applied in a random order, the cost bound of O(<i>n</i> log <i>n</i>) still holds.  Furthermore, the queries then can be batched in a prefix-doubling manner (i.e. 1, 2, 4, 8 queries) and run simultaneously in one round.  The overall span of this algorithm is log<sub>2</sub> <i>n</i> reachability queries, which is probably the optimal parallelism that can be achieved using the reachability-based approach.
</p>
<h3><span class="mw-headline" id="Generating_random_strongly_connected_graphs">Generating random strongly connected graphs</span><span class="mw-editsection"></span></h3>
<p>Peter M. Maurer describes an algorithm for generating random strongly connected graphs,<sup class="reference" id="cite_ref-9">[9]</sup> based on a modification of an algorithm for strong connectivity augmentation, the problem of adding as few edges as possible to make a graph strongly connected.  When used in conjunction with the Gilbert or Erdős-Rényi models with node relabelling, the algorithm is capable of generating any strongly connected graph on <i>n</i> nodes, without restriction on the kinds of structures that can be generated.
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Algorithms for finding strongly connected components may be used to solve 2-satisfiability problems (systems of Boolean variables with constraints on the values of pairs of variables): as Aspvall, Plass &amp; Tarjan (1979) showed, a 2-satisfiability instance is unsatisfiable if and only if there is a variable <i>v</i> such that <i>v</i> and its complement are both contained in the same strongly connected component of the implication graph of the instance.<sup class="reference" id="cite_ref-10">[10]</sup>
</p><p>Strongly connected components are also used to compute the Dulmage–Mendelsohn decomposition, a classification of the edges of a bipartite graph, according to whether or not they can be part of a perfect matching in the graph.<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<h2><span class="mw-headline" id="Related_results">Related results</span><span class="mw-editsection"></span></h2>
<p>A directed graph is strongly connected if and only if it has an ear decomposition, a partition of the edges into a sequence of directed paths and cycles such that the first subgraph in the sequence is a cycle, and each subsequent subgraph is either a cycle sharing one vertex with previous subgraphs, or a path sharing its two endpoints with previous subgraphs.
</p><p>According to Robbins' theorem, an undirected graph may be oriented in such a way that it becomes strongly connected, if and only if it is 2-edge-connected. One way to prove this result is to find an ear decomposition of the underlying undirected graph and then orient each ear consistently.<sup class="reference" id="cite_ref-12">[12]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Clique (graph theory)</li>
<li>Connected component (graph theory)</li>
<li>Modular decomposition</li>
<li>Weak component</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Java implementation for computation of strongly connected components in the jBPT library (see StronglyConnectedComponents class).</li>
<li>C++ implementation of Strongly Connected Components</li></ul>
<!-- 
NewPP limit report
Parsed by mw2329
Cached time: 20221224035410
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.257 seconds
Real time usage: 0.364 seconds
Preprocessor visited node count: 1204/1000000
Post‐expand include size: 28748/2097152 bytes
Template argument size: 1629/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 39110/5000000 bytes
Lua time usage: 0.136/10.000 seconds
Lua memory usage: 7294357/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  298.257      1 -total
 58.06%  173.167      1 Template:Reflist
 27.48%   81.968     10 Template:Citation
 16.24%   48.431      1 Template:Short_description
 14.28%   42.595      1 Template:Graph_connectivity_sidebar
 13.75%   41.007      1 Template:Sidebar
 12.82%   38.238      1 Template:Isbn
 11.70%   34.884      1 Template:Bare_URL_PDF
 10.32%   30.766      1 Template:Fix
 10.08%   30.050      1 Template:Catalog_lookup_link
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:684680-0!canonical and timestamp 20221224035410 and revision id 1116542639.
 -->
</div></body>
</html>