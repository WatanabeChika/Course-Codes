<!DOCTYPE html>
<html>
<head>
<title>sorted_array</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">Sorted array</th></tr><tr><th class="infobox-label" scope="row">Type</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Invented</th><td class="infobox-data">1945</td></tr><tr><th class="infobox-label" scope="row">Invented by</th><td class="infobox-data">John von Neumann</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Space</th><td class="infobox-data infobox-data-a">
O(n)</td><td class="infobox-data infobox-data-b">
O(n)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
O(log n)</td><td class="infobox-data infobox-data-b">
O(log n)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
O(n)</td><td class="infobox-data infobox-data-b">
O(n)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Delete</th><td class="infobox-data infobox-data-a">
O(n)</td><td class="infobox-data infobox-data-b">
O(n)</td></tr></tbody></table></td></tr></tbody></table>
<p>A <b>sorted array</b> is an array data structure in which each element is sorted in numerical, alphabetical, or some other order, and placed at equally spaced addresses in computer memory. It is typically used in computer science to implement static lookup tables to hold multiple values which have the same data type. Sorting an array is useful in organising data in ordered form and recovering them rapidly.
</p>

<h2><span class="mw-headline" id="Methods">Methods</span><span class="mw-editsection"></span></h2>
<p>There are many well-known methods by which an array can be sorted, which include, but are not limited to: Selection sort, Bubble sort, Insertion sort, Merge sort, Quicksort, Heapsort, and Counting sort.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (November 2011)">citation needed</span></i>]</sup> These sorting techniques have different algorithms associated with them, and there are therefore different advantages to using each method.
</p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"></span></h2>
<p>Sorted arrays are the most space-efficient data structure with the best locality of reference for sequentially stored data.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (November 2011)">citation needed</span></i>]</sup>
</p><p>Elements within a sorted array are found using a binary search, in O(log <i>n</i>); thus sorted arrays are suited for cases when one needs to be able to look up elements quickly, e.g. as a set or multiset data structure. This complexity for lookups is the same as for self-balancing binary search trees.
</p><p>In some data structures, an array of structures is used. In such cases, the same sorting methods can be used to sort the structures according to some key as a structure element; for example, sorting records of students according to roll numbers or names or grades.
</p><p>If one is using a sorted dynamic array, then it is possible to insert and delete elements. The insertion and deletion of elements in a sorted array executes at O(<i>n</i>), due to the need to shift all the elements following the element to be inserted or deleted; in comparison a self-balancing binary search tree inserts and deletes at O(log <i>n</i>). In the case where elements are deleted or inserted at the end, a sorted dynamic array can do this in amortized O(1) time while a self-balancing binary search tree always operates at O(log <i>n</i>).
</p><p>Elements in a sorted array can be looked up by their index (random access) at O(1) time, an operation taking O(log <i>n</i>) or O(<i>n</i>) time for more complex data structures.
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>John von Neumann wrote the first array sorting program (merge sort) in 1945, when the first stored-program computer was still being built.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Applications_of_sorted_arrays">Applications of sorted arrays</span><span class="mw-editsection"></span></h2>
<h3><span id="Commercial_computing.5B2.5D"></span><span class="mw-headline" id="Commercial_computing[2]">Commercial computing<sup class="reference" id="cite_ref-2">[2]</sup></span><span class="mw-editsection"></span></h3>
<p>Government organizations, private companies and many web-based applications have to deal with huge amounts of data. The data will often have to be accessed multiple times. Keeping the data in a sorted format allows for quick and easy retrieval.
</p>
<h3><span class="mw-headline" id="In_discrete_mathematics">In discrete mathematics</span><span class="mw-editsection"></span></h3>
<p>Sorted arrays can be used to implement Dijkstra's algorithm or Prim's algorithm.  Also, algorithms like Kruskal's algorithm for finding minimal spanning trees.
</p>
<h3><span class="mw-headline" id="In_priority_scheduling">In priority scheduling</span><span class="mw-editsection"></span></h3>
<p>At the operating system level, many processes are pending at a time but they can handle only one process at a single instance in time. Therefore, priorities are associated to each process. Then the processes are sent to the CPU according to the highest priority by using sorted array of process IDs. Here, processes got sorted depending upon their priorities and then CPU is allocated to them. The process having the highest priority takes first position in sorted array. Hence priority-wise system processes scheduling is done.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h3><span class="mw-headline" id="In_shortest-job-first_scheduling">In shortest-job-first scheduling</span><span class="mw-editsection"></span></h3>
<p>This is the special case of priority scheduling. Here, processes get sorted according to burst time of the processes. The process requiring the shortest time will be allocated CPU first. Hence, processes are being sent to CPU according to their burst time.
</p>

<table class="wikitable">
<tbody><tr>
<th>Process</th>
<th>Burst time
</th></tr>
<tr>
<td>P1</td>
<td>3
</td></tr>
<tr>
<td>P2</td>
<td>4
</td></tr>
<tr>
<td>P3</td>
<td>1
</td></tr>
<tr>
<td>P4</td>
<td>8
</td></tr>
<tr>
<td>P5</td>
<td>6
</td></tr></tbody></table>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Sorting algorithm</li>
<li>Binary search algorithm</li>
<li>Heap (data structure)</li>
<li>Search data structure</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2390
Cached time: 20221224045251
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.169 seconds
Real time usage: 0.233 seconds
Preprocessor visited node count: 995/1000000
Post‐expand include size: 14890/2097152 bytes
Template argument size: 1660/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 7962/5000000 bytes
Lua time usage: 0.102/10.000 seconds
Lua memory usage: 3563725/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  209.776      1 -total
 43.63%   91.523      1 Template:Reflist
 35.12%   73.671      1 Template:Cite_web
 22.29%   46.755      1 Template:Short_description
 16.96%   35.573      1 Template:Infobox_data_structure
 16.15%   33.887      2 Template:Citation_needed
 15.40%   32.296      1 Template:Infobox
 13.23%   27.764      2 Template:Fix
 12.15%   25.497      2 Template:Pagetype
  9.43%   19.773      1 Template:Infobox3cols
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:15844857-0!canonical and timestamp 20221224045251 and revision id 1116905744.
 -->
</div></body>
</html>