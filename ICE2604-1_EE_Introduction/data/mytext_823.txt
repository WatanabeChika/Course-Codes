randomized_roundingWithin computer science and operations research,many combinatorial optimization problems are computationally intractable to solve exactly (to optimality).Many such problems do admit fast (polynomial time) approximation algorithms—that is, algorithms that are guaranteed to return an approximately optimal solution given any input.Randomized rounding(Raghavan &amp; Tompson 1987)is a widely used approach for designing and analyzing such approximation algorithms.[1][2]  The basic idea is to use the probabilistic methodto convert an optimal solution of a relaxationof the problem into an approximately optimal solution to the original problem.The basic approach has three steps:Formulate the problem to be solved as an integer linear program (ILP).Compute an optimal fractional solution  to the linear programming relaxation (LP) of the ILP.Round the fractional solution  of the LP to an integer solution  of the ILP.(Although the approach is most commonly applied with linear programs,other kinds of relaxations are sometimes used.For example, see Goemans' and Williamson's semidefinite programming-basedMax-Cut approximation algorithm.)The challenge in the first step is to choose a suitable integer linear program.Familiarity with linear programming, in particular modelling using linear programs and integer linear programs, is required. For many problems, there is a natural integer linear program that works well,such as in the Set Cover example below.  (The integer linear program should have a smallintegrality gap;indeed randomized rounding is often used to prove bounds on integrality gaps.)In the second step, the optimal fractional solution can typically  be computedin polynomial timeusing any standard linear programming algorithm.In the third step, the fractional solution must be converted into an integer solution(and thus a solution to the original problem).This is called rounding the fractional solution.The resulting integer solution should (provably) have costnot much larger than the cost of the fractional solution.This will ensure that the cost of the integer solutionis not much larger than the cost of the optimal integer solution.The main technique used to do the third step (rounding) is to use randomization,and then to use probabilistic arguments to bound the increase in cost due to the rounding(following the probabilistic method from combinatorics).Therein, probabilistic arguments are used to show the existence of discrete structures withdesired properties.  In this context, one uses such arguments to show the following:Given any fractional solution  of the LP, with positive probability the randomized rounding process produces an integer solution  that approximates  according to some desired criterion.Finally, to make the third step computationally efficient,one either shows that  approximates with high probability (so that the step can remain randomized)or one derandomizes the rounding step,typically using the method of conditional probabilities.The latter method converts the randomized rounding processinto an efficient deterministic process that is guaranteedto reach a good outcome.The randomized rounding step differs from most applications of the probabilistic method in two respects:The computational complexity of the rounding step is important.  It should be implementable by a fast (e.g. polynomial time) algorithm.The probability distribution underlying the random experiment is a function of the solution  of a relaxation of the problem instance.  This fact is crucial to proving the performance guarantee of the approximation algorithm --- that is, that for any problem instance, the algorithm returns a solution that approximates the optimal solution for that specific instance.  In comparison, applications of the probabilistic method in combinatorics typically show the existence of structures whose features depend on other parameters of the input.  For example, consider Turán's theorem, which can be stated as "any graph with  vertices of average degree  must have an independent set of size at least .   (See  this for a probabilistic proof of Turán's theorem.) While there are graphs for which this bound is tight, there are also graphs which have independent sets much larger than .  Thus, the size of the independent set shown to exist by Turán's theorem in a graph may, in general, be much smaller than the maximum independent set for that graph.The following example illustrates how randomized rounding can be used to design an approximation algorithm for the Set Cover problem.Fix any instance  of set cover over a universe .For step 1, let IP be the standard integer linear program for set cover for this instance.For step 2, let LP be the linear programming relaxation of IP,and compute an optimal solution  to LPusing any standard linear programming algorithm.(This takes time polynomial in the input size.)(The feasible solutions to LP are the vectors that assign each set a non-negative weight ,such that, for each element , covers -- the total weight assigned to the sets containing is at least 1, that is,The optimal solution is a feasible solution whose costis as small as possible.)Note that any set cover  for gives a feasible solution (where  for , otherwise).The cost of this  equals the cost of , that is,In other words, the linear program LP is a relaxationof the given set-cover problem.Since  has minimum cost among feasible solutions to the LP,the cost of  is a lower bound on the cost of the optimal set cover.Here is a description of the third step—the rounding step,which must convert the minimum-cost fractional set cover into a feasible integer solution  (corresponding to a true set cover).The rounding step should produce an  that, with positive probability,has cost  within a small factor of the cost of .Then (since the cost of  is a lower bound on the cost of the optimal set cover),the cost of  will be within a small factor of the optimal cost.As a starting point, consider the most natural rounding scheme:For each set  in turn, take  with probability , otherwise take .With this rounding scheme,the expected cost of the chosen sets is at most ,the cost of the fractional cover.This is good.  Unfortunately the coverage is not good.When the variables  are small,the probability that an element  is not covered is aboutSo only a constant fraction of the elements will be covered in expectation.To make  cover every element with high probability,the standard rounding schemefirst scales up the rounding probabilitiesby an appropriate factor .Here is the standard rounding scheme:Fix a parameter .  For each set  in turn,take  with probability , otherwise take .Scaling the probabilities up by increases the expected cost by ,but makes coverage of all elements likely.The idea is to choose  as smallas possible so that all elements are provablycovered with non-zero probability.Here is a detailed analysis.Fix .  With positive probability, the rounding scheme returns a set cover  of cost at most  (and thus of cost  times the cost of the optimal set cover).(Note: with care the  can be reduced to .)The output  of the random rounding scheme has the desired propertiesas long as none of the following "bad" events occur:the cost  of  exceeds , orfor some element ,  fails to cover .The expectation of each   is at most .By linearity of expectation,the expectation of  is at most .Thus, by Markov's inequality, the probability of the first bad eventabove is at most .For the remaining bad events (one for each element ), note that,since  for any given element ,the probability that  is not covered is(This uses the inequality ,which is strict for .)Thus, for each of the  elements,the probability that the element is not covered is less than .By the union bound,the probability that one of the  bad events happensis less than .Thus, with positive probability there are no bad eventsand  is a set cover of cost at most .QEDThe lemma above shows the existence of a set coverof cost ).In this context our goal is an efficient approximation algorithm,not just an existence proof, so we are not done.One approach would be to increase a little bit, then show that the probability of success is at least, say, 1/4.With this modification, repeating the random rounding step a few timesis enough to ensure a successful outcome with high probability.That approach weakens the approximation ratio.We next describe a different approach that yieldsa deterministic algorithm that is guaranteed tomatch the approximation ratio of the existence proof above.The approach is called the method of conditional probabilities.The deterministic algorithm emulates the randomized rounding scheme:it considers each set  in turn,and chooses .But instead of making each choice randomly based on ,it makes the choice deterministically, so as tokeep the conditional probability of failure, given the choices so far, below 1.We want to be able to set each variable  in turnso as to keep the conditional probability of failure below 1.To do this, we need a good bound on the conditional probability of failure.The bound will come by refining the original existence proof.That proof implicitly bounds the probability of failureby the expectation of the random variable,whereis the set of elements left uncovered at the end.The random variable  may appear a bit mysterious,but it mirrors the probabilistic proof in a systematic way.The first term in  comes from applying Markov's inequalityto bound the probability of the first bad event (the cost is too high).It contributes at least 1 to  if the cost of  is too high.The second termcounts the number of bad events of the second kind (uncovered elements).It contributes at least 1 to  if  leaves any element uncovered.Thus, in any outcome where  is less than 1, must cover all the elementsand have cost meeting the desired bound from the lemma.In short, if the rounding step fails, then .This implies (by Markov's inequality) that is an upper bound on the probability of failure.Note that the argument above is implicit already in the proof of the lemma,which also shows by calculation that .To apply the method of conditional probabilities,we need to extend the argument to bound the conditional probability of failureas the rounding step proceeds.Usually, this can be done in a systematic way,although it can be technically tedious.So, what about the conditional probability of failure as the rounding step iterates through the sets?Since  in any outcome where the rounding step fails,by Markov's inequality, the conditional probability of failureis at most the conditional expectation of .Next we calculate the conditional expectation of ,much as we calculated the unconditioned expectation of  in the original proof.Consider the state of the rounding process at the end of some iteration .Let  denote the sets considered so far(the first  sets in ).Let  denote the (partially assigned) vector (so  is determined only if ).For each set ,let denote the probability with which  will be set to 1.Let  contain the not-yet-covered elements.Then the conditional expectation of ,given the choices made so far, that is, given , isNote that  is determined only after iteration .To keep the conditional probability of failure below 1,it suffices to keep the conditional expectation of  below 1.To do this, it suffices to keep the conditional expectation of  from increasing.This is what the algorithm will do.It will set  in each iteration to ensure that(where ).In the th iteration,how can the algorithm set to ensure that ?It turns out that it can simply set so as to minimize the resulting value of .To see why, focus on the point in time when iteration  starts.At that time,  is determined,but  is not yet determined--- it can take two possible values depending on how is set in iteration .Let  denote the value of .Let  and ,denote the two possible values of  ,depending on whether  is set to 0, or 1, respectively.By the definition of conditional expectation,Since a weighted average of two quantitiesis always at least the minimum of those two quantities,it follows thatThus, setting so as to minimize the resulting value ofwill guarantee that.This is what the algorithm will do.In detail, what does this mean?Considered as a function of (with all other quantities fixed)is a linear function of ,and the coefficient of  in that function isThus, the algorithm should set  to 0 if this expression is positive,and 1 otherwise.  This gives the following algorithm.input: set system , universe , cost vector output:  set cover  (a solution to the standard integer linear program for set cover)Compute a min-cost fractional set cover  (an optimal solution to the LP relaxation).Let .  Let  for each .For each  do:Let .    ( contains the not-yet-decided sets.)If    then set ,else set  and .  ( contains the not-yet-covered elements.)Return .The algorithm above returns a set cover  of cost at most  times the minimum cost of any (fractional) set cover.The algorithm ensures that the conditional expectation of ,, does not increase at each iteration.Since this conditional expectation is initially less than 1 (as shown previously),the algorithm ensures that the conditional expectation stays below 1.Since the conditional probability of failureis at most the conditional expectation of ,in this way the algorithmensures that the conditional probability of failure stays below 1.Thus, at the end, when all choices are determined,the algorithm reaches a successful outcome.That is, the algorithm above returns a set cover of cost at most  timesthe minimum cost of any (fractional) set cover.In the example above, the algorithm was guided by the conditional expectation of a random variable .In some cases, instead of an exact conditional expectation,an upper bound (or sometimes a lower bound)on some conditional expectation is used instead.This is called a pessimistic estimator.Method of conditional probabilitiesRaghavan, Prabhakar; Tompson, Clark D. (1987), "Randomized rounding: A technique for provably good algorithms and algorithmic proofs", Combinatorica, 7 (4): 365–374, doi:10.1007/BF02579324, S2CID 5749936.Raghavan, Prabhakar (1988), "Probabilistic construction of deterministic algorithms: approximating packing integer programs", Journal of Computer and System Sciences, 37 (2): 130–143, doi:.Althöfer, Ingo (1994), "On sparse approximations to randomized strategies and convex combinations", Linear Algebra and Its Applications, 199: 339–355, doi:, MR 1274423Hofmeister, Thomas; Lefmann, Hanno (1996), "Computing sparse approximations deterministically", Linear Algebra and Its Applications, 240: 9–19, doi:, MR 1387283Lipton, Richard J.; Young, Neal E. (1994), "Simple strategies for large zero-sum games with applications to complexity theory", STOC '94: Proceedings of the twenty-sixth annual ACM symposium on theory of computing, New York, NY: ACM, pp. 734–740, arXiv:, doi:10.1145/195058.195447, ISBN 978-0-89791-663-9, S2CID 7524887