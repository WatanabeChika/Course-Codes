<!DOCTYPE html>
<html>
<head>
<title>prune_and_search</title>
</head>
<body>
<div class="mw-parser-output"><p><b>Prune and search</b> is a method of solving optimization problems suggested by Nimrod Megiddo in 1983.<sup class="reference" id="cite_ref-lp3_1-0">[1]</sup>
</p><p>The basic idea of the method is a recursive procedure in which at each step the input size is reduced ("pruned") by a constant factor <span class="texhtml">0 &lt; <i>p</i> &lt; 1</span>. As such, it is a form of decrease and conquer algorithm, where at each step the decrease is by a constant factor. Let <span class="texhtml mvar" style="font-style:italic;">n</span> be the input size, <span class="texhtml"><i>T</i>(<i>n</i>)</span> be the time complexity of the whole prune-and-search algorithm, and <span class="texhtml"><i>S</i>(<i>n</i>)</span> be the time complexity of the pruning step. Then <span class="texhtml"><i>T</i>(<i>n</i>)</span> obeys the following recurrence relation:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T(n)=S(n)+T(n(1-p)).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mi>S</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>−<!-- − --></mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T(n)=S(n)+T(n(1-p)).}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T(n)=S(n)+T(n(1-p)).}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f22c4da40f679abc31be666296492ce08c1bd8d6" style="vertical-align: -0.838ex; width:27.951ex; height:2.843ex;"/></span></dd></dl>
<p>This resembles the recurrence for binary search but has a larger <span class="texhtml"><i>S</i>(<i>n</i>)</span> term than the constant term of binary search. In prune and search algorithms S(n) is typically at least linear (since the whole input must be processed). With this assumption, the recurrence has the solution <span class="texhtml"><i>T</i>(<i>n</i>) = O(<i>S</i>(<i>n</i>))</span>. This can be seen either by applying the master theorem for divide-and-conquer recurrences or by observing that the times for the recursive subproblems decrease in a geometric series.
</p><p>In particular, Megiddo himself used this approach in his linear time algorithm for the linear programming problem when the dimension is fixed<sup class="reference" id="cite_ref-2">[2]</sup> and for the minimal enclosing sphere problem for a set of points in space.<sup class="reference" id="cite_ref-lp3_1-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2413
Cached time: 20221223230308
Cache expiry: 1814400
Reduced expiry: false
Complications: []
CPU time usage: 0.059 seconds
Real time usage: 0.104 seconds
Preprocessor visited node count: 453/1000000
Post‐expand include size: 2428/2097152 bytes
Template argument size: 646/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 5804/5000000 bytes
Lua time usage: 0.008/10.000 seconds
Lua memory usage: 1053409/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   67.693      1 -total
 67.11%   45.432      1 Template:Reflist
 49.14%   33.266      2 Template:Doi
 37.38%   25.303      2 Template:Catalog_lookup_link
 28.51%   19.300      6 Template:Math
  3.73%    2.526      7 Template:Main_other
  2.49%    1.686      1 Template:Mvar
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:26874356-0!canonical and timestamp 20221223230308 and revision id 1110889613.
 -->
</div></body>
</html>