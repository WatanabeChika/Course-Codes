<!DOCTYPE html>
<html>
<head>
<title>uncomputable_problem</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computability theory and computational complexity theory, an <b>undecidable problem</b> is a decision problem for which it is proved to be impossible to construct an algorithm that always leads to a correct yes-or-no answer.<sup class="reference" id="cite_ref-1">[1]</sup> The halting problem is an example: it can be proven that there is no algorithm that correctly determines whether arbitrary programs eventually halt when run.<sup class="reference" id="cite_ref-2">[2]</sup>
</p>

<h2><span class="mw-headline" id="Background">Background</span><span class="mw-editsection"></span></h2>
<p>A decision problem is any arbitrary yes-or-no question on an infinite set of inputs.<sup class="reference" id="cite_ref-3">[3]</sup> Because of this, it is traditional to define the decision problem equivalently as the set of inputs for which the problem returns <i>yes</i>. These inputs can be natural numbers, but also other values of some other kind, such as strings of a formal language. Using some encoding, such as a Gödel numbering, the strings can be encoded as natural numbers.  Thus, a decision problem informally phrased in terms of a formal language is also equivalent to a set of natural numbers.  To keep the formal definition simple, it is phrased in terms of subsets of the natural numbers.
</p><p>Formally, a decision problem is a subset of the natural numbers. The corresponding informal problem is that of deciding whether a given number is in the set. A decision problem <i>A</i> is called decidable or effectively solvable if <i>A</i> is a recursive set and undecidable otherwise. A problem is called partially decidable, semi-decidable, solvable, or provable if <i>A</i> is a recursively enumerable set.<sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<h2><span class="mw-headline" id="Example:_the_halting_problem_in_computability_theory">Example: the halting problem in computability theory</span><span class="mw-editsection"></span></h2>
<p>In computability theory, the halting problem is a decision problem which can be stated as follows:
</p>
<dl><dd>Given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever.</dd></dl>
<p>Alan Turing proved in 1936 that a general algorithm running on a Turing machine that solves the halting problem for <i>all</i> possible program-input pairs necessarily cannot exist. Hence, the halting problem is <i>undecidable</i> for Turing machines.
</p>
<h2><span id="Relationship_with_G.C3.B6del.27s_incompleteness_theorem"></span><span class="mw-headline" id="Relationship_with_Gödel's_incompleteness_theorem">Relationship with Gödel's incompleteness theorem</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-More_citations_needed_section plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>The concepts raised by Gödel's incompleteness theorems are very similar to those raised by the halting problem, and the proofs are quite similar. In fact, a weaker form of the First Incompleteness Theorem is an easy consequence of the undecidability of the halting problem. This weaker form differs from the standard statement of the incompleteness theorem by asserting that an axiomatization of the natural numbers that is both complete and sound is impossible. The "sound" part is the weakening: it means that we require the axiomatic system in question to prove only <i>true</i> statements about natural numbers. Since soundness implies consistency, this weaker form can be seen as a corollary of the strong form. It is important to observe that the statement of the standard form of Gödel's First Incompleteness Theorem is completely unconcerned with the truth value of a statement, but only concerns the issue of whether it is possible to find it through a mathematical proof.
</p><p>The weaker form of the theorem can be proved from the undecidability of the halting problem as follows.<sup class="reference" id="cite_ref-5">[5]</sup> Assume that we have a sound (and hence consistent) and complete axiomatization of all true first-order logic statements about natural numbers. Then we can build an algorithm that enumerates all these statements. This means that there is an algorithm <i>N</i>(<i>n</i>) that, given a natural number <i>n</i>, computes a true first-order logic statement about natural numbers, and that for all true statements, there is at least one <i>n</i> such that <i>N</i>(<i>n</i>) yields that statement. Now suppose we want to decide if the algorithm with representation <i>a</i> halts on input <i>i</i>.  We know that this statement can be expressed with a first-order logic statement, say <i>H</i>(<i>a</i>, <i>i</i>).  Since the axiomatization is complete it follows that either there is an <i>n</i> such that <i>N</i>(<i>n</i>) =  <i>H</i>(<i>a</i>, <i>i</i>) or there is an <i>n'</i> such that <i>N</i>(<i>n'</i>) = ¬ <i>H</i>(<i>a</i>, <i>i</i>).  So if we iterate over all <i>n</i> until we either find <i>H</i>(<i>a</i>, <i>i</i>) or its negation, we will always halt, and furthermore, the answer it gives us will be true (by soundness). This means that this gives us an algorithm to decide the halting problem. Since we know that there cannot be such an algorithm, it follows that the assumption that there is a consistent and complete axiomatization of all true first-order logic statements about natural numbers must be false.
</p>
<h2><span class="mw-headline" id="Examples_of_undecidable_problems">Examples of undecidable problems</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>Undecidable problems can be related to different topics, such as logic, abstract machines or topology. Since there are uncountably many undecidable problems,<sup class="reference" id="cite_ref-6">[6]</sup> any list, even one of infinite length, is necessarily incomplete.
</p>
<h2><span class="mw-headline" id="Examples_of_undecidable_statements">Examples of undecidable statements</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>There are two distinct senses of the word "undecidable" in contemporary use. The first of these is the sense used in relation to Gödel's theorems, that of a statement being neither provable nor refutable in a specified deductive system. The second sense is used in relation to computability theory and applies not to statements but to decision problems, which are countably infinite sets of questions each requiring a yes or no answer. Such a problem is said to be undecidable if there is no computable function that correctly answers every question in the problem set.  The connection between these two is that if a decision problem is undecidable (in the recursion theoretical sense) then there is no consistent, effective formal system which proves for every question <i>A</i> in the problem either "the answer to <i>A</i> is yes" or "the answer to <i>A</i> is no".
</p><p>Because of the two meanings of the word undecidable, the term independent is sometimes used instead of undecidable for the "neither provable nor refutable" sense. The usage of "independent" is also ambiguous, however. It can mean just "not provable", leaving open whether an independent statement might be refuted.
</p><p>Undecidability of a statement in a particular deductive system does not, in and of itself, address the question of whether the truth value of the statement is well-defined, or whether it can be determined by other means. Undecidability only implies that the particular deductive system being considered does not prove the truth or falsity of the statement. Whether there exist so-called "absolutely undecidable" statements, whose truth value can never be known or is ill-specified, is a controversial point among various philosophical schools.
</p><p>One of the first problems suspected to be undecidable, in the second sense of the term, was the word problem for groups, first posed by Max Dehn in 1911, which asks if there is a finitely presented group for which no algorithm exists to determine whether two words are equivalent.  This was shown to be the case in 1952.
</p><p>The combined work of Gödel and Paul Cohen has given two concrete examples of undecidable statements (in the first sense of the term): The continuum hypothesis can neither be proved nor refuted in ZFC (the standard axiomatization of set theory), and the axiom of choice can neither be proved nor refuted in ZF (which is all the ZFC axioms <i>except</i> the axiom of choice).  These results do not require the incompleteness theorem.   Gödel proved in 1940 that neither of these statements could be disproved in ZF or ZFC set theory. In the 1960s, Cohen proved that neither is provable from ZF, and the continuum hypothesis cannot be proven from ZFC.
</p><p>In 1970, Russian mathematician Yuri Matiyasevich showed that Hilbert's Tenth Problem, posed in 1900 as a challenge to the next century of mathematicians, cannot be solved.    Hilbert's challenge sought an algorithm which finds all solutions of a Diophantine equation.  A Diophantine equation is a more general case of Fermat's Last Theorem; we seek the integer roots of a polynomial in any number of variables with integer coefficients.  Since we have only one equation but <i>n</i> variables, infinitely many solutions exist (and are easy to find) in the complex plane; however, the problem becomes impossible if solutions are constrained to integer values only.  Matiyasevich showed this problem to be unsolvable by mapping a Diophantine equation to a recursively enumerable set and invoking Gödel's Incompleteness Theorem.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>In 1936, Alan Turing proved that the halting problem—the question of whether or not a Turing machine halts on a given program—is undecidable, in the second sense of the term. This result was later generalized by Rice's theorem.
</p><p>In 1973, Saharon Shelah showed the Whitehead problem in group theory is undecidable, in the first sense of the term, in standard set theory.<sup class="reference" id="cite_ref-8">[8]</sup>
</p><p>In 1977, Paris and Harrington proved that the Paris-Harrington principle, a version of the Ramsey theorem, is undecidable in the axiomatization of arithmetic given by the Peano axioms but can be proven to be true in the larger system of second-order arithmetic.
</p><p>Kruskal's tree theorem, which has applications in computer science, is also undecidable from the Peano axioms but provable in set theory. In fact Kruskal's tree theorem (or its finite form) is undecidable in a much stronger system codifying the principles acceptable on basis of a philosophy of mathematics called predicativism.
</p><p>Goodstein's theorem is a statement about the Ramsey theory of the natural numbers that Kirby and Paris showed is undecidable in Peano arithmetic.
</p><p>Gregory Chaitin produced undecidable statements in algorithmic information theory and proved another incompleteness theorem in that setting. Chaitin's theorem states that for any theory that can represent enough arithmetic, there is an upper bound <i>c</i> such that no specific number can be proven in that theory to have Kolmogorov complexity greater than <i>c</i>. While Gödel's theorem is related to the liar paradox, Chaitin's result is related to Berry's paradox.
</p><p>In 2007, researchers Kurtz and Simon, building on earlier work by J.H. Conway in the 1970s, proved that a natural generalization of the Collatz problem is undecidable.<sup class="reference" id="cite_ref-9">[9]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Decidability (logic)</li>
<li>Entscheidungsproblem</li>
<li>Proof of impossibility</li>
<li>Wicked problem</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<p><br/>
</p>

<!-- 
NewPP limit report
Parsed by mw2408
Cached time: 20221224000331
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.298 seconds
Real time usage: 0.445 seconds
Preprocessor visited node count: 1234/1000000
Post‐expand include size: 89819/2097152 bytes
Template argument size: 1467/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 30627/5000000 bytes
Lua time usage: 0.158/10.000 seconds
Lua memory usage: 5155589/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  331.819      1 -total
 38.29%  127.046      1 Template:Reflist
 21.78%   72.259      4 Template:Cite_web
 20.28%   67.300      4 Template:Navbox
 18.41%   61.089      1 Template:Mathematical_logic
 17.57%   58.292      1 Template:Short_description
 16.86%   55.938      2 Template:More_citations_needed
 15.36%   50.971      2 Template:Ambox
 11.37%   37.743      2 Template:Pagetype
  4.99%   16.570      1 Template:Isbn
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:15631055-0!canonical and timestamp 20221224000330 and revision id 1120140159.
 -->
</div></body>
</html>