<!DOCTYPE html>
<html>
<head>
<title>deque</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Lead_too_short plainlinks metadata ambox ambox-content ambox-lead_too_short" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Technical plainlinks metadata ambox ambox-style ambox-technical" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computer science, a <b>double-ended queue</b> (abbreviated to <b>deque</b>, pronounced <i>deck</i>, like "cheque"<sup class="reference" id="cite_ref-1">[1]</sup>) is an abstract data type that generalizes a queue, for which elements can be added to or removed from either the front (head) or back (tail).<sup class="reference" id="cite_ref-2">[2]</sup> It is also often called a <b>head-tail linked list</b>, though properly this refers to a specific data structure <i>implementation</i> of a deque (see below).
</p>

<h2><span class="mw-headline" id="Naming_conventions">Naming conventions</span><span class="mw-editsection"></span></h2>
<p><i>Deque</i> is sometimes written <i>dequeue</i>, but this use is generally deprecated in technical literature or technical writing because <i>dequeue</i> is also a verb meaning "to remove from a queue". Nevertheless, several libraries and some writers, such as Aho, Hopcroft, and Ullman in their textbook <i>Data Structures and Algorithms</i>, spell it <i>dequeue</i>. John Mitchell, author of <i>Concepts in Programming Languages,</i> also uses this terminology.
</p>
<h2><span class="mw-headline" id="Distinctions_and_sub-types">Distinctions and sub-types</span><span class="mw-editsection"></span></h2>
<p>This differs from the queue abstract data type or <i>first in first out</i> list (FIFO), where elements can only be added to one end and removed from the other. This general data class has some possible sub-types:
</p>
<ul><li>An input-restricted deque is one where deletion can be made from both ends, but insertion can be made at one end only.</li>
<li>An output-restricted deque is one where insertion can be made at both ends, but deletion can be made from one end only.</li></ul>
<p>Both the basic and most common list types in computing, queues and stacks can be considered specializations of deques, and can be implemented using deques.
</p>
<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<p>The basic operations on a deque are <i>enqueue</i> and <i>dequeue</i> on either end. Also generally implemented are <i>peek</i> operations, which return the value at that end without dequeuing it.
</p><p>Names vary between languages; major implementations include:
</p>
<table class="wikitable">
<tbody><tr>
<th>operation</th>
<th>common name(s)</th>
<th>Ada</th>
<th>C++</th>
<th>Java</th>
<th>Perl</th>
<th>PHP</th>
<th>Python</th>
<th>Ruby
</th>
<th>Rust
</th>
<th>JavaScript
</th></tr>
<tr>
<td>insert element at back</td>
<td>inject, snoc, push</td>
<td><code>Append</code></td>
<td><code>push_back</code></td>
<td><code>offerLast</code></td>
<td><code>push</code></td>
<td><code>array_push</code></td>
<td><code>append</code></td>
<td><code>push</code>
</td>
<td><code>push_back</code></td>
<td><code>push</code>
</td></tr>
<tr>
<td>insert element at front</td>
<td>push, cons</td>
<td><code>Prepend</code></td>
<td><code>push_front</code></td>
<td><code>offerFirst</code></td>
<td><code>unshift</code></td>
<td><code>array_unshift</code></td>
<td><code>appendleft</code></td>
<td><code>unshift</code>
</td>
<td><code>push_front</code></td>
<td><code>unshift</code>
</td></tr>
<tr>
<td>remove last element</td>
<td>eject</td>
<td><code>Delete_Last</code></td>
<td><code>pop_back</code></td>
<td><code>pollLast</code></td>
<td><code>pop</code></td>
<td><code>array_pop</code></td>
<td><code>pop</code></td>
<td><code>pop</code>
</td>
<td><code>pop_back</code></td>
<td><code>pop</code>
</td></tr>
<tr>
<td>remove first element</td>
<td>pop</td>
<td><code>Delete_First</code></td>
<td><code>pop_front</code></td>
<td><code>pollFirst</code></td>
<td><code>shift</code></td>
<td><code>array_shift</code></td>
<td><code>popleft</code></td>
<td><code>shift</code>
</td>
<td><code>pop_front</code></td>
<td><code>shift</code>
</td></tr>
<tr>
<td>examine last element</td>
<td>peek
</td>
<td><code>Last_Element</code></td>
<td><code>back</code></td>
<td><code>peekLast</code></td>
<td><code>$array[-1]</code></td>
<td><code>end</code></td>
<td><code>&lt;obj&gt;[-1]</code></td>
<td><code>last</code>
</td>
<td><code>back</code></td>
<td><code>&lt;obj&gt;.at(-1)</code>
</td></tr>
<tr>
<td>examine first element</td>
<td></td>
<td><code>First_Element</code></td>
<td><code>front</code></td>
<td><code>peekFirst</code></td>
<td><code>$array[0]</code></td>
<td><code>reset</code></td>
<td><code>&lt;obj&gt;[0]</code></td>
<td><code>first</code>
</td>
<td><code>front</code></td>
<td><code>&lt;obj&gt;[0]</code>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"></span></h2>
<p>There are at least two common ways to efficiently implement a deque: with a modified dynamic array or with a doubly linked list.
</p><p>The dynamic array approach uses a variant of a dynamic array that can grow from both ends, sometimes called <b>array deques</b>. These array deques have all the properties of a dynamic array, such as constant-time random access, good locality of reference, and inefficient insertion/removal in the middle, with the addition of amortized constant-time insertion/removal at both ends, instead of just one end. Three common implementations include:
</p>
<ul><li>Storing deque contents in a circular buffer, and only resizing when the buffer becomes full. This decreases the frequency of resizings.</li>
<li>Allocating deque contents from the center of the underlying array, and resizing the underlying array when either end is reached. This approach may require more frequent resizings and waste more space, particularly when elements are only inserted at one end.</li>
<li>Storing contents in multiple smaller arrays, allocating additional arrays at the beginning or end as needed. Indexing is implemented by keeping a dynamic array containing pointers to each of the smaller arrays.</li></ul>
<h3><span class="mw-headline" id="Purely_functional_implementation">Purely functional implementation</span><span class="mw-editsection"></span></h3>
<p>Double-ended queues can also be implemented as a purely functional data structure.<sup class="reference" id="cite_ref-functional_3-0">[3]</sup><sup class="reference nowrap"><span title="Page / location: 115">: 115 </span></sup> Two versions of the implementation exist. The first one, called '<i>real-time deque</i>, is presented below. It allows the queue to be persistent with operations in <span class="texhtml"><i>O</i>(1)</span> worst-case time, but requires lazy lists with memoization. The second one, with no lazy lists nor memoization is presented at the end of the sections. Its amortized time is <span class="texhtml"><i>O</i>(1)</span> if the persistency is not used; but the worst-time complexity of an operation is <span class="texhtml"><i>O</i>(<i>n</i>)</span> where <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of elements in the double-ended queue.
</p><p>Let us recall that, for a list <code>l</code>, <code>|l|</code> denotes its length, that <code>NIL</code> represents an empty list and <code>CONS(h, t)</code> represents the list whose head is <code>h</code> and whose tail is <code>t</code>. The functions <code>drop(i, l)</code> and <code>take(i, l)</code> return the list <code>l</code> without its first <code>i</code> elements, and the first <code>i</code> elements of <code>l</code>, respectively. Or, if <code>|l| &lt; i</code>, they return the empty list and <code>l</code> respectively.
</p>
<h4><span class="mw-headline" id="Real-time_deques_via_lazy_rebuilding_and_scheduling">Real-time deques via lazy rebuilding and scheduling</span><span class="mw-editsection"></span></h4>
<p>A double-ended queue is represented as a sextuple <code>(len_front, front, tail_front, len_rear, rear, tail_rear)</code> where <code>front</code> is a linked list which contains the front of the queue of length <code>len_front</code>. Similarly, <code>rear</code> is a linked list which represents the reverse of the rear of the queue, of length <code>len_rear</code>. Furthermore, it is assured that <code>|front| ≤ 2|rear|+1</code> and <code>|rear| ≤ 2|front|+1</code> - intuitively, it means that both the front and the rear contains between a third minus one and two thirds plus one of the elements. Finally, <code>tail_front</code> and <code>tail_rear</code> are tails of <code>front</code> and of <code>rear</code>, they allow scheduling the moment where some lazy operations are forced. Note that, when a double-ended queue contains <code>n</code> elements in the front list and <code>n</code> elements in the rear list, then the inequality invariant remains satisfied after <code>i</code> insertions and <code>d</code> deletions when <code>(i+d) ≤ n/2</code>. That is, at most <code>n/2</code> operations can happen between each rebalancing.
</p><p>Let us first give an implementation of the various operations that affect the front of the deque - cons, head and tail. Those implementation do not necessarily respect the invariant. In a second time we'll explain how to modify a deque which does not satisfy the invariant into one which satisfy it. However, they use the invariant, in that if the front is empty then the rear has at most one element. The operations affecting the rear of the list are defined similarly by symmetry. 
</p>

<p>It remains to explain how to define a method <code>balance</code> that rebalance the deque if <code>insert'</code> or <code>tail</code> broke the invariant. The method <code>insert</code> and <code>tail</code> can be defined by first applying <code>insert'</code> and <code>tail'</code> and then applying <code>balance</code>.
</p>

<p>where <code>rotateDrop(front, i, rear))</code> return the concatenation of <code>front</code> and of <code>drop(i, rear)</code>. That is<code>front' = rotateDrop(front, ceil_half_len, rear)</code> put into <code>front'</code> the content of <code>front</code> and the  content of <code>rear</code> that is not already in <code>rear'</code>. Since dropping <code>n</code> elements takes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation>
</semantics>
</math></span><img alt="O(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;"/></span> time, we use laziness to ensure that elements are dropped two by two, with two drops being done during each <code>tail'</code> and each <code>insert'</code> operation. 
</p>

<p>where <code>rotateRev(front, middle, rear)</code> is a function that returns the front, followed by the middle reversed, followed by the rear. This function is also defined using laziness to ensure that it can be computed step by step, with one step executed during each <code>insert'</code> and <code>tail'</code> and taking a constant time. This function uses the invariant that <code>|rear|-2|front|</code> is 2 or 3. 
</p>

<p>where <code>++</code> is the function concatenating two lists.
</p>
<h4><span class="mw-headline" id="Implementation_without_laziness">Implementation without laziness</span><span class="mw-editsection"></span></h4>
<p>Note that, without the lazy part of the implementation, this would be a non-persistent implementation of queue in <span class="texhtml"><i>O</i>(1)</span> amortized time. In this case, the lists <code>tail_front</code> and <code>tail_rear</code> could be removed from the representation of the double-ended queue.
</p>
<h2><span class="mw-headline" id="Language_support">Language support</span><span class="mw-editsection"></span></h2>
<p>Ada's containers provides the generic packages <code>Ada.Containers.Vectors</code> and <code>Ada.Containers.Doubly_Linked_Lists</code>, for the dynamic array and linked list implementations, respectively.
</p><p>C++'s Standard Template Library provides the class templates <code>std::deque</code> and <code>std::list</code>, for the multiple array and linked list implementations, respectively.
</p><p>As of Java 6, Java's Collections Framework provides a new <code>Deque</code> interface that provides the functionality of insertion and removal at both ends. It is implemented by classes such as <code>ArrayDeque</code> (also new in Java 6) and <code>LinkedList</code>, providing the dynamic array and linked list implementations, respectively. However, the <code>ArrayDeque</code>, contrary to its name, does not support random access.
</p><p>Javascript's Array prototype &amp; Perl's arrays have native support for both removing (shift and pop) and adding (unshift and push) elements on both ends.
</p><p>Python 2.4 introduced the <code>collections</code> module with support for deque objects. It is implemented using a doubly linked list of fixed-length subarrays.
</p><p>As of PHP 5.3, PHP's SPL extension contains the 'SplDoublyLinkedList' class that can be used to implement Deque datastructures. Previously to make a Deque structure the array functions array_shift/unshift/pop/push had to be used instead.
</p><p>GHC's Data.Sequence module implements an efficient, functional deque structure in Haskell. The implementation uses 2–3 finger trees annotated with sizes. There are other (fast) possibilities to implement purely functional (thus also persistent) double queues (most using heavily lazy evaluation).<sup class="reference" id="cite_ref-functional_3-1">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup> Kaplan and Tarjan were the first to implement optimal confluently persistent catenable deques.<sup class="reference" id="cite_ref-5">[5]</sup> Their implementation was strictly purely functional in the sense that it did not use lazy evaluation. Okasaki simplified the data structure by using lazy evaluation with a bootstrapped data structure and degrading the performance bounds from worst-case to amortized. Kaplan, Okasaki, and Tarjan produced a simpler, non-bootstrapped, amortized version that can be implemented either using lazy evaluation or more efficiently using mutation in a broader but still restricted fashion. Mihaesau and Tarjan created a simpler (but still highly complex) strictly purely functional implementation of catenable deques, and also a much simpler implementation of strictly purely functional non-catenable deques, both of which have optimal worst-case bounds.
</p><p>Rust's <code>std::collections</code> includes VecDeque which implements a double-ended queue using a growable ring buffer.
</p>
<h2><span class="mw-headline" id="Complexity">Complexity</span><span class="mw-editsection"></span></h2>
<ul><li>In a doubly-linked list implementation and assuming no allocation/deallocation overhead, the time complexity of all deque operations is O(1). Additionally, the time complexity of insertion or deletion in the middle, given an iterator, is O(1); however, the time complexity of random access by index is O(n).</li>
<li>In a growing array, the amortized time complexity of all deque operations is O(1). Additionally, the time complexity of random access by index is O(1); but the time complexity of insertion or deletion in the middle is O(n).</li></ul>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>

<p>One example where a deque can be used is the work stealing algorithm.<sup class="reference" id="cite_ref-jacm_6-0">[6]</sup> This algorithm implements task scheduling for several processors. A separate deque with threads to be executed is maintained for each processor. To execute the next thread, the processor gets the first element from the deque (using the "remove first element" deque operation). If the current thread forks, it is put back to the front of the deque ("insert element at front") and a new thread is executed. When one of the processors finishes execution of its own threads (i.e. its deque is empty), it can "steal" a thread from another processor: it gets the last element from the deque of another processor ("remove last element") and executes it. The work stealing algorithm is used by Intel's Threading Building Blocks (TBB) library for parallel programming.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Pipe</li>
<li>Queue</li>
<li>Priority queue</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Type-safe open source deque implementation at Comprehensive C Archive Network</li>
<li>SGI STL Documentation: deque&lt;T, Alloc&gt;</li>
<li>Code Project: An In-Depth Study of the STL Deque Container</li>
<li>Deque implementation in C</li>
<li>VBScript implementation of stack, queue, deque, and Red-Black Tree</li>
<li>Multiple implementations of non-catenable deques in Haskell</li></ul>

<!-- 
NewPP limit report
Parsed by mw1360
Cached time: 20221220210339
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.315 seconds
Real time usage: 0.416 seconds
Preprocessor visited node count: 1511/1000000
Post‐expand include size: 28671/2097152 bytes
Template argument size: 992/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 9/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 30778/5000000 bytes
Lua time usage: 0.146/10.000 seconds
Lua memory usage: 3951848/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  325.332      1 -total
 34.97%  113.762      1 Template:Reflist
 19.32%   62.852      1 Template:Data_structures
 18.94%   61.612      1 Template:Tooshort
 18.67%   60.725      1 Template:Navbox
 17.63%   57.353      2 Template:Ambox
 14.92%   48.555      1 Template:Cite_thesis
 12.15%   39.516      2 Template:ISBN
  9.48%   30.851      2 Template:Catalog_lookup_link
  8.71%   28.338      1 Template:Redirect-distinguish2
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:8904-0!canonical and timestamp 20221220210339 and revision id 1102750240.
 -->
</div></body>
</html>