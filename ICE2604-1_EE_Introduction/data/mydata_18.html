<!DOCTYPE html>
<html>
<head>
<title>adaptive_sort</title>
</head>
<body>
<div class="mw-parser-output"><p>A sorting algorithm falls into the <b>adaptive sort</b> family if it takes advantage of existing order in its input.  It benefits from the presortedness in the input sequence – or a limited amount of disorder for various definitions of measures of disorder – and sorts faster.  Adaptive sorting is usually performed by modifying existing sorting algorithms.
</p>

<h2><span class="mw-headline" id="Motivation">Motivation</span><span class="mw-editsection"></span></h2>
<p>Comparison-based sorting algorithms have traditionally dealt with achieving an optimal bound of <i>O</i>(<i>n</i> log <i>n</i>) when dealing with time complexity.  Adaptive sort takes advantage of the existing order of the input to try to achieve better times, so that the time taken by the algorithm to sort is a smoothly growing function of the size of the sequence <i>and</i> the disorder in the sequence.  In other words, the more presorted the input is, the faster it should be sorted.
</p><p>This is an attractive feature for a sorting algorithm because nearly sorted sequences are common in practice.  Thus, the performance of existing sort algorithms can be improved by taking into account the existing order in the input.
</p><p>Note that most worst-case sorting algorithms that do optimally well in the worst-case, notably heap sort and merge sort, do not take existing order within their input into account, although this deficiency is easily rectified in the case of merge sort by checking if the last element of the lefthand group is less than (or equal) to the first element of the righthand group, in which case a merge operation may be replaced by simple concatenation – a modification that is well within the scope of making an algorithm adaptive.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>A classic example of an adaptive sorting algorithm is <i>Straight Insertion Sort</i>.<sup class="reference" id="cite_ref-Estivill_1-0">[1]</sup>  In this sorting algorithm, we scan the input from left to right, repeatedly finding the position of the current item, and insert it into an array of previously sorted items.
</p><p>In pseudo-code form, the <i>Straight Insertion Sort</i> algorithm could look something like this (array X is zero-based):
</p>
<pre><b>procedure</b> Straight Insertion Sort (X):
    <b>for</b> j := 1 <b>to</b> length(X) - 1 <b>do</b>
        t := X[j]
        i := j
        <b>while</b> i &gt; 0 <b>and</b> X[i - 1] &gt; t <b>do</b>
            X[i] := X[i - 1]
            i := i - 1
        <b>end</b>
        X[i] := t
    <b>end</b>
</pre>
<p>The performance of this algorithm can be described in terms of the number of inversions in the input, and then <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T(n)}</annotation>
</semantics>
</math></span><img alt="T(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0be5a46684e1279c27414b285fa995f30407d002" style="vertical-align: -0.838ex; width:4.84ex; height:2.843ex;"/></span> will be roughly equal to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle I(A)+(n-1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>I</mi>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle I(A)+(n-1)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle I(A)+(n-1)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/07c32b12efc0edfb6a3beaa91dbf0fa78aa60628" style="vertical-align: -0.838ex; width:14.771ex; height:2.843ex;"/></span>, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle I(A)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>I</mi>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle I(A)}</annotation>
</semantics>
</math></span><img alt="I(A)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/30290c6cff7aaecd0952c8a71905ac26930c9aa3" style="vertical-align: -0.838ex; width:4.724ex; height:2.843ex;"/></span> is the number of Inversions.  Using this measure of presortedness – being relative to the number of inversions – <i>Straight Insertion Sort</i> takes less time to sort the closer it is to being sorted.
</p><p>Other examples of adaptive sorting algorithms are adaptive heap sort, adaptive merge sort, patience sort,<sup class="reference" id="cite_ref-Chandramouli_2-0">[2]</sup> Shellsort, smoothsort, splaysort, Timsort, and Cartesian tree sorting.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Sorting algorithms</li>
<li>Smoothsort</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><style data-mw-deduplicate="TemplateStyles:r1067248974">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style><cite class="citation book cs1" id="CITEREFHagerupJyrki_Katjainen2004">Hagerup, Torben; Jyrki Katjainen (2004). <i>Algorithm Theory – SWAT 2004</i>. Berlin Heidelberg: Springer-Verlag. pp. 221–222. ISBN <bdi>3-540-22339-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithm+Theory+%E2%80%93+SWAT+2004&amp;rft.place=Berlin+Heidelberg&amp;rft.pages=221-222&amp;rft.pub=Springer-Verlag&amp;rft.date=2004&amp;rft.isbn=3-540-22339-8&amp;rft.aulast=Hagerup&amp;rft.aufirst=Torben&amp;rft.au=Jyrki+Katjainen&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D2E-KNhKl3gEC%26q%3Dadaptive%2Bsort%26pg%3DPA221&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAdaptive+sort"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFMehtaSartaj_Sahni2005">Mehta, Dinesh P.; Sartaj Sahni (2005). <i>Data Structures and Applications</i>. USA: Chapman &amp; Hall/CRC. pp. 11‑8–11‑9. ISBN <bdi>1-58488-435-5</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Data+Structures+and+Applications&amp;rft.place=USA&amp;rft.pages=11%E2%80%918-11%E2%80%919&amp;rft.pub=Chapman+%26+Hall%2FCRC&amp;rft.date=2005&amp;rft.isbn=1-58488-435-5&amp;rft.aulast=Mehta&amp;rft.aufirst=Dinesh+P.&amp;rft.au=Sartaj+Sahni&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DfQVZy1zcpJkC%26q%3Dadaptive%2Bsort%26pg%3DPT230&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAdaptive+sort"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFPeterssonAlistair_Moffat1992">Petersson, Ola; Alistair Moffat (1992). <i>A framework for adaptive sorting</i>. Lecture Notes in Computer Science. Vol. 621. Berlin: Springer Berlin / Heidelberg. pp. 422–433. doi:10.1007/3-540-55706-7_38. ISBN <bdi>978-3-540-55706-7</bdi>. ISSN 1611-3349.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A+framework+for+adaptive+sorting&amp;rft.place=Berlin&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=422-433&amp;rft.pub=Springer+Berlin+%2F+Heidelberg&amp;rft.date=1992&amp;rft.issn=1611-3349&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-55706-7_38&amp;rft.isbn=978-3-540-55706-7&amp;rft.aulast=Petersson&amp;rft.aufirst=Ola&amp;rft.au=Alistair+Moffat&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAdaptive+sort"></span></li></ul>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>

<!-- 
NewPP limit report
Parsed by mw1452
Cached time: 20221221000708
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.159 seconds
Real time usage: 0.254 seconds
Preprocessor visited node count: 479/1000000
Post‐expand include size: 26388/2097152 bytes
Template argument size: 130/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 19151/5000000 bytes
Lua time usage: 0.096/10.000 seconds
Lua memory usage: 4505922/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  159.118      1 -total
 49.40%   78.597      3 Template:Cite_book
 27.90%   44.391      1 Template:Sorting
 26.49%   42.144      1 Template:Navbox
 20.50%   32.626      1 Template:Reflist
  5.59%    8.895      2 Template:Cite_conference
  3.76%    5.980      1 Template:Cite_journal
  1.35%    2.153      3 Template:Tmath
  0.83%    1.315      1 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:4261562-0!canonical and timestamp 20221221000707 and revision id 1094081777.
 -->
</div></body>
</html>