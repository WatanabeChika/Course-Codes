<!DOCTYPE html>
<html>
<head>
<title>postorder_traversal</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p>In computer science, <b>tree traversal</b> (also known as <b>tree search</b> and <b>walking the tree</b>) is a form of graph traversal and refers to the process of visiting (e.g. retrieving, updating, or deleting) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited. The following algorithms are described for a binary tree, but they may be generalized to other trees as well.
</p>

<h2><span class="mw-headline" id="Types">Types</span><span class="mw-editsection"></span></h2>
<p>Unlike linked lists, one-dimensional arrays and other linear data structures, which are canonically traversed in linear order, trees may be traversed in multiple ways. They may be traversed in depth-first or breadth-first order. There are three common ways to traverse them in depth-first order: in-order, pre-order and post-order.<sup class="reference" id="cite_ref-holtenotes_1-0">[1]</sup> Beyond these basic traversals, various more complex or hybrid schemes are possible, such as depth-limited searches like iterative deepening depth-first search. The latter, as well as breadth-first search, can also be used to traverse infinite trees, see below.
</p>
<h3><span class="mw-headline" id="Data_structures_for_tree_traversal">Data structures for tree traversal</span><span class="mw-editsection"></span></h3>
<p>Traversing a tree involves iterating over all nodes in some manner. Because from a given node there is more than one possible next node (it is not a linear data structure), then, assuming sequential computation (not parallel), some nodes must be deferred—stored in some way for later visiting. This is often done via a stack (LIFO) or queue (FIFO). As a tree is a self-referential (recursively defined) data structure, traversal can be defined by recursion or, more subtly, corecursion, in a natural and clear fashion; in these cases the deferred nodes are stored implicitly in the call stack.
</p><p>Depth-first search is easily implemented via a stack, including recursively (via the call stack), while breadth-first search is easily implemented via a queue, including corecursively.<sup class="reference" id="cite_ref-Pfaff_2-0">[2]</sup><sup class="reference nowrap"><span title="Page / location: 45−61">: 45−61 </span></sup>
</p>
<h3><span class="mw-headline" id="Depth-first_search">Depth-first search</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>

<p>In <i>depth-first search</i> (DFS), the search tree is deepened as much as possible before going to the next sibling.
</p><p>To traverse binary trees with depth-first search, perform the following operations at each node:<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<ol><li>If the current node is empty then return.</li>
<li>Execute the following three operations in a certain order:<sup class="reference" id="cite_ref-5">[5]</sup>
<dl><dd>N: Visit the current node.</dd>
<dd>L: Recursively traverse the current node's left subtree.</dd>
<dd>R: Recursively traverse the current node's right subtree.</dd></dl></li></ol>
<p>The trace of a traversal is called a sequentialisation of the tree. The traversal trace is a list of each visited node. No one sequentialisation according to pre-, in- or post-order describes the underlying tree uniquely. Given a tree with distinct elements, either pre-order or post-order paired with in-order is sufficient to describe the tree uniquely. However, pre-order with post-order leaves some ambiguity in the tree structure.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>There are three methods at which position of the traversal relative to the node (in the figure: red, green, or blue) the visit of the node shall take place. The choice of exactly one color determines exactly one visit of a node as described below. Visit at all three colors results in a threefold visit of the same node yielding the “all-order” sequentialisation:
</p>
<dl><dd><span style="color:red;">F</span>-<span style="color:red;">B</span>-<span style="color:red;">A</span>-<span style="color:green;">A</span>-<span style="color: #2A7FFF;">A</span>-<span style="color:green;">B</span>-<span style="color:red;">D</span>-<span style="color:red;">C</span>-<span style="color:green;">C</span>-<span style="color: #2A7FFF;">C</span>-<span style="color:green;">D</span>-<span style="color:red;">E</span>-<span style="color:green;">E</span>-<span style="color: #2A7FFF;">E</span>-<span style="color: #2A7FFF;">D</span>-<span style="color: #2A7FFF;">B</span>-<span style="color:green;">F</span>-<span style="color:red;">G</span>-<span style="color:green;">G</span>-<span style="color:red;"> I</span>-<span style="color:red;">H</span>-<span style="color:green;">H</span>-<span style="color: #2A7FFF;">H</span>-<span style="color:green;"> I</span>-<span style="color: #2A7FFF;"> I</span>-<span style="color: #2A7FFF;">G</span>-<span style="color: #2A7FFF;">F</span></dd></dl>
<h4><span id="Pre-order.2C_NLR"></span><span class="mw-headline" id="Pre-order,_NLR"><span class="anchor" id="Preorder_traversal"></span><span class="anchor" id="Pre-order_traversal"></span>Pre-order, NLR</span><span class="mw-editsection"></span></h4>
<ol><li>Visit the current node (in the figure: position red).</li>
<li>Recursively traverse the current node's left subtree.</li>
<li>Recursively traverse the current node's right subtree.</li></ol>
<p>The pre-order traversal is a topologically sorted one, because a parent node is processed before any of its child nodes is done.
</p>
<h4><span id="Post-order.2C_LRN"></span><span class="mw-headline" id="Post-order,_LRN"><span class="anchor" id="Postorder_traversal"></span><span class="anchor" id="Post-order_traversal"></span>Post-order, LRN</span><span class="mw-editsection"></span></h4>
<ol><li>Recursively traverse the current node's left subtree.</li>
<li>Recursively traverse the current node's right subtree.</li>
<li>Visit the current node (in the figure: position blue).</li></ol>
<p>Post-order traversal can be useful to get postfix expression of a binary expression tree.
</p>
<h4><span id="In-order.2C_LNR"></span><span class="mw-headline" id="In-order,_LNR"><span class="anchor" id="Inorder_traversal"></span><span class="anchor" id="In-order_traversal"></span>In-order, LNR</span><span class="mw-editsection"></span></h4>
<ol><li>Recursively traverse the current node's left subtree.</li>
<li>Visit the current node (in the figure: position green).</li>
<li>Recursively traverse the current node's right subtree.</li></ol>
<p>In a binary search tree ordered such that in each node the key is greater than all keys in its left subtree and less than all keys in its right subtree, in-order traversal retrieves the keys in <i>ascending</i> sorted order.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h4><span id="Reverse_pre-order.2C_NRL"></span><span class="mw-headline" id="Reverse_pre-order,_NRL"><span class="anchor" id="Reverse_preorder_traversal"></span><span class="anchor" id="Reverse_pre-order_traversal"></span>Reverse pre-order, NRL</span><span class="mw-editsection"></span></h4>
<ol><li>Visit the current node.</li>
<li>Recursively traverse the current node's right subtree.</li>
<li>Recursively traverse the current node's left subtree.</li></ol>
<h4><span id="Reverse_post-order.2C_RLN"></span><span class="mw-headline" id="Reverse_post-order,_RLN"><span class="anchor" id="Reverse_postorder_traversal"></span><span class="anchor" id="Reverse_post-order_traversal"></span>Reverse post-order, RLN</span><span class="mw-editsection"></span></h4>
<ol><li>Recursively traverse the current node's right subtree.</li>
<li>Recursively traverse the current node's left subtree.</li>
<li>Visit the current node.</li></ol>
<h4><span id="Reverse_in-order.2C_RNL"></span><span class="mw-headline" id="Reverse_in-order,_RNL"><span class="anchor" id="Reverse_inorder_traversal"></span><span class="anchor" id="Reverse_in-order_traversal"></span>Reverse in-order, RNL</span><span class="mw-editsection"></span></h4>
<ol><li>Recursively traverse the current node's right subtree.</li>
<li>Visit the current node.</li>
<li>Recursively traverse the current node's left subtree.</li></ol>
<p>In a binary search tree ordered such that in each node the key is greater than all keys in its left subtree and less than all keys in its right subtree, reverse in-order traversal retrieves the keys in <i>descending</i> sorted order.
</p>
<h4><span class="mw-headline" id="Arbitrary_trees">Arbitrary trees</span><span class="mw-editsection"></span></h4>
<p>To traverse arbitrary trees (not necessarily binary trees) with depth-first search, perform the following operations at each node:
</p>
<ol><li>If the current node is empty then return.</li>
<li>Visit the current node for pre-order traversal.</li>
<li>For each <i>i</i> from 1 to the current node's number of subtrees − 1, or from the latter to the former for reverse traversal, do:
<ol><li>Recursively traverse the current node's <i>i</i>-th subtree.</li>
<li>Visit the current node for in-order traversal.</li></ol></li>
<li>Recursively traverse the current node's last subtree.</li>
<li>Visit the current node for post-order traversal.</li></ol>
<p>Depending on the problem at hand, pre-order, post-order, and especially one of the number of subtrees − 1 in-order operations may be optional. Also, in practice more than one of pre-order, post-order, and in-order operations may be required. For example, when inserting into a ternary tree, a pre-order operation is performed by comparing items. A post-order operation may be needed afterwards to re-balance the tree.
</p>
<h3><span class="mw-headline" id="Breadth-first_search">Breadth-first search</span><span class="mw-editsection"></span></h3>

<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>In <i>breadth-first search</i> (BFS) or <i>level-order search</i>, the search tree is broadened as much as possible before going to the next depth.
</p>
<h3><span class="mw-headline" id="Other_types">Other types</span><span class="mw-editsection"></span></h3>
<p>There are also tree traversal algorithms that classify as neither depth-first search nor breadth-first search. One such algorithm is Monte Carlo tree search, which concentrates on analyzing the most promising moves, basing the expansion of the search tree on random sampling of the search space.
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>

<p>Pre-order traversal can be used to make a prefix expression (Polish notation) from expression trees: traverse the expression tree pre-orderly. For example, traversing the depicted arithmetic expression in pre-order yields "+ * <i>A</i> − <i>B</i> <i>C</i> + <i>D</i> <i>E</i>". In prefix notation, there is no need for any parentheses as long as each operator has a fixed number of operands. Preorder traversal is also used to create a copy of the tree.
</p><p>Post-order traversal can generate a postfix representation (Reverse Polish notation) of a binary tree. Traversing the depicted arithmetic expression in post-order yields "<i>A</i> <i>B</i> <i>C</i> − * <i>D</i> <i>E</i> + +"; the latter can easily be transformed into machine code to evaluate the expression by a stack machine. Postorder traversal is also used to delete the tree. Each node is freed after freeing its children.
</p><p>In-order traversal is very commonly used on binary search trees because it returns values from the underlying set in order, according to the comparator that set up the binary search tree.
</p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Unreferenced_section plainlinks metadata ambox ambox-content ambox-Unreferenced" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<h3><span class="mw-headline" id="Depth-first_search_implementation">Depth-first search implementation</span><span class="mw-editsection"></span></h3>
<h4><span class="mw-headline" id="Pre-order_implementation"><span class="anchor" id="Pre-order_traversal_code"></span><span class="anchor" id="Pre-order_traversal_code"></span>Pre-order implementation</span><span class="mw-editsection"></span></h4>
<table>
<tbody><tr style="vertical-align:top;">
<td>
<pre><b>procedure</b> preorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    visit(node)
    preorder(node.left)
    preorder(node.right) 
</pre>
</td>
<td>
<pre><b>procedure</b> iterativePreorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    stack ← <b>empty stack</b>
    stack.push(node)
    <b>while</b> <b>not</b> stack.isEmpty()
        node ← stack.pop()
        visit(node)
        // right child is pushed first so that left is processed first
        <b>if</b> node.right ≠ <b>null</b>
            stack.push(node.right)
        <b>if</b> node.left ≠ <b>null</b>
            stack.push(node.left)
</pre>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Post-order_implementation"><span class="anchor" id="Post-order_traversal_code"></span><span class="anchor" id="Post-order_traversal_code"></span>Post-order implementation</span><span class="mw-editsection"></span></h4>
<table>
<tbody><tr style="vertical-align:top">
<td>
<pre><b>procedure</b> postorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    postorder(node.left)
    postorder(node.right)
    visit(node)
</pre>
</td>
<td>
<pre><b>procedure</b> iterativePostorder(node)
    stack ← <b>empty stack</b>
    lastNodeVisited ← <b>null</b>
    <b>while</b> <b>not</b> stack.isEmpty() <b>or</b> node ≠ <b>null</b>
        <b>if</b> node ≠ <b>null</b>
            stack.push(node)
            node ← node.left
        <b>else</b>
            peekNode ← stack.peek()
            // if right child exists and traversing node
            // from left child, then move right
            <b>if</b> peekNode.right ≠ <b>null</b> <b>and</b> lastNodeVisited ≠ peekNode.right
                node ← peekNode.right
            <b>else</b>
                visit(peekNode)
                lastNodeVisited ← stack.pop()
</pre>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="In-order_implementation"><span class="anchor" id="Inorder_traversal_code"></span><span class="anchor" id="In-order_traversal_code"></span>In-order implementation</span><span class="mw-editsection"></span></h4>
<table>
<tbody><tr style="vertical-align:top;">
<td>
<pre><b>procedure</b> inorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    inorder(node.left)
    visit(node)
    inorder(node.right)
</pre>
</td>
<td>
<pre><b>procedure</b> iterativeInorder(node)
    stack ← <b>empty stack</b>
    <b>while</b> <b>not</b> stack.isEmpty() <b>or</b> node ≠ <b>null</b>
        <b>if</b> node ≠ <b>null</b>
            stack.push(node)
            node ← node.left
        <b>else</b>
            node ← stack.pop()
            visit(node)
            node ← node.right
</pre>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Another_variant_of_Pre-order">Another variant of Pre-order</span><span class="mw-editsection"></span></h4>
<p>If the tree is represented by an array (first index is 0), it is possible to calculate the index of the next element:<sup class="reference" id="cite_ref-8">[8]</sup><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="Explicitly mention the restrictions on trees in order to be handled by this algorithm. Since there is no isLeaf() test, it seems that all leaves must be on maximal depth or one level above it, like in a heap (data structure). (November 2021)">clarification needed</span></i>]</sup>
</p>
<pre><b>procedure</b> bubbleUp(array, i, leaf)
    k ← 1
    i ← (i - 1)/2
    <b>while</b> (leaf + 1) % (k * 2) ≠ k
        i ← (i - 1)/2
        k ← 2 * k
    <b>return</b> i

<b>procedure</b> preorder(array)
    i ← 0
    <b>while</b> i ≠ array.size
        visit(array[i])
        <b>if</b> i = size - 1
            i ← size
        <b>else if</b> i &lt; size/2
            i ← i * 2 + 1
        <b>else</b>
            leaf ← i - size/2
            parent ← bubble_up(array, i, leaf)
            i ← parent * 2 + 2
</pre>
<h4><span class="mw-headline" id="Advancing_to_the_next_or_previous_node">Advancing to the next or previous node</span><span class="mw-editsection"></span></h4>
<p>The <code>node</code> to be started with may have been found in the binary search tree <code>bst</code> by means of a standard <b>search</b> function, which is shown here in an implementation without parent pointers, i.e. it uses a <code>stack</code> for holding the ancestor pointers.
</p>
<pre><b>procedure</b> search(bst, key)
    // returns a (node, stack)
    node ← bst.root
    stack ← <b>empty stack</b>
    <b>while</b> node ≠ <b>null</b>
        stack.push(node)
        <b>if</b> key = node.key
            <b>return</b> (node, stack)
        <b>if</b> key &lt; node.key
            node ← node.left    
        <b>else</b>
            node ← node.right
    <b>return</b> (<b>null</b>, <b>empty stack</b>)
</pre>
<p>The function <b>inorderNext</b><sup class="reference" id="cite_ref-Pfaff_2-1">[2]</sup><sup class="reference nowrap"><span title="Page / location: 60">: 60 </span></sup> returns an in-order-neighbor of <code>node</code>, either the <span class="nowrap">in-order-<i>suc</i>cessor</span> (for <code>dir=1</code>) or the <span class="nowrap">in-order-<i>prede</i>cessor</span> (for <code>dir=0</code>), and the updated <code>stack</code>, so that the binary search tree may be sequentially in-order-traversed and searched in the given direction <code>dir</code> further on.
</p>
<pre><b>procedure</b> inorderNext(node, dir, stack)
    newnode ← node.child[dir]
    <b>if</b> newnode ≠ <b>null</b>
        <b>do</b>
            node ← newnode
            stack.push(node)
            newnode ← node.child[1-dir]
        <b>until</b> newnode = <b>null</b>
        <b>return</b> (node, stack)
    // node does not have a dir-child:
    <b>do</b>
        <b>if</b> stack.isEmpty()
            <b>return</b> (<b>null</b>, <b>empty stack</b>)
        oldnode ← node
        node ← stack.pop()   // parent of oldnode
    <b>until</b> oldnode ≠ node.child[dir]
    // now oldnode = node.child[1-dir],
    // i.e. node = ancestor (and predecessor/successor) of original node
    <b>return</b> (node, stack)
</pre>
<p>Note that the function does not use keys, which means that the sequential structure is completely recorded by the binary search tree’s edges. For traversals without change of direction, the (amortised) average complexity is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(1),}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(1),}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathcal {O}}(1),}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1aea554deef90268e33b9606ebbc68677263c386" style="vertical-align: -0.838ex; width:5.469ex; height:2.843ex;"/></span> because a full traversal takes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2n-2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2n-2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2n-2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a8593ff30008d016680ae67c34865b96087b62fa" style="vertical-align: -0.505ex; width:6.56ex; height:2.343ex;"/></span> steps for a BST of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle n,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/397bfafc701afdf14c2743278a097f6f2957eabb" style="vertical-align: -0.671ex; width:2.042ex; height:2.009ex;"/></span> 1 step for edge up and 1 for edge down. The worst-case complexity is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {O}}(h)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mi>h</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {O}}(h)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathcal {O}}(h)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5c6bba95209937a5d567d7f21c6e927a333669d4" style="vertical-align: -0.838ex; width:4.998ex; height:2.843ex;"/></span> with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle h}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>h</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle h}</annotation>
</semantics>
</math></span><img alt="h" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b26be3e694314bc90c3215047e4a2010c6ee184a" style="vertical-align: -0.338ex; width:1.339ex; height:2.176ex;"/></span> as the height of the tree.
</p><p>All the above implementations require stack space proportional to the height of the tree which is a call stack for the recursive and a parent (ancestor) stack for the iterative ones. In a poorly balanced tree, this can be considerable. With the iterative implementations we can remove the stack requirement by maintaining parent pointers in each node, or by threading the tree (next section).
</p>
<h4><span class="mw-headline" id="Morris_in-order_traversal_using_threading">Morris in-order traversal using threading</span><span class="mw-editsection"></span></h4>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A binary tree is threaded by making every left child pointer (that would otherwise be null) point to the in-order predecessor of the node (if it exists) and every right child pointer (that would otherwise be null) point to the in-order successor of the node (if it exists).
</p><p>Advantages:
</p>
<ol><li>Avoids recursion, which uses a call stack and consumes memory and time.</li>
<li>The node keeps a record of its parent.</li></ol>
<p>Disadvantages:
</p>
<ol><li>The tree is more complex.</li>
<li>We can make only one traversal at a time.</li>
<li>It is more prone to errors when both the children are not present and both values of nodes point to their ancestors.</li></ol>
<p>Morris traversal is an implementation of in-order traversal that uses threading:<sup class="reference" id="cite_ref-9">[9]</sup>
</p>
<ol><li>Create links to the in-order successor.</li>
<li>Print the data using these links.</li>
<li>Revert the changes to restore original tree.</li></ol>
<h3><span class="mw-headline" id="Breadth-first_search_2">Breadth-first search</span><span class="mw-editsection"></span></h3>
<p>Also, listed below is pseudocode for a simple queue based level-order traversal, and will require space proportional to the maximum number of nodes at a given depth. This can be as much as half the total number of nodes. A more space-efficient approach for this type of traversal can be implemented using an iterative deepening depth-first search.
</p>
<pre><b>procedure</b> levelorder(node)
    queue ← <b>empty queue</b>
    queue.enqueue(node)
    <b>while</b> <b>not</b> queue.isEmpty()
        node ← queue.dequeue()
        visit(node)
        <b>if</b> node.left ≠ <b>null</b>
            queue.enqueue(node.left)
        <b>if</b> node.right ≠ <b>null</b>
            queue.enqueue(node.right)
</pre>
<p>If the tree is represented by an array (first index is 0), it is sufficient iterating through all elements:
</p>
<pre><b>procedure</b> levelorder(array)
    <b>for</b> i <b>from</b> 0 <b>to</b> array.size
        visit(array[i])
</pre>
<h2><span class="mw-headline" id="Infinite_trees">Infinite trees</span><span class="mw-editsection"></span></h2>
<p>While traversal is usually done for trees with a finite number of nodes (and hence finite depth and finite branching factor) it can also be done for infinite trees. This is of particular interest in functional programming (particularly with lazy evaluation), as infinite data structures can often be easily defined and worked with, though they are not (strictly) evaluated, as this would take infinite time. Some finite trees are too large to represent explicitly, such as the game tree for chess or go, and so it is useful to analyze them as if they were infinite.
</p><p>A basic requirement for traversal is to visit every node eventually. For infinite trees, simple algorithms often fail this. For example, given a binary tree of infinite depth, a depth-first search will go down one side (by convention the left side) of the tree, never visiting the rest, and indeed an in-order or post-order traversal will never visit <i>any</i> nodes, as it has not reached a leaf (and in fact never will). By contrast, a breadth-first (level-order) traversal will traverse a binary tree of infinite depth without problem, and indeed will traverse any tree with bounded branching factor.
</p><p>On the other hand, given a tree of depth 2, where the root has infinitely many children, and each of these children has two children, a depth-first search will visit all nodes, as once it exhausts the grandchildren (children of children of one node), it will move on to the next (assuming it is not post-order, in which case it never reaches the root). By contrast, a breadth-first search will never reach the grandchildren, as it seeks to exhaust the children first.
</p><p>A more sophisticated analysis of running time can be given via infinite ordinal numbers; for example, the breadth-first search of the depth 2 tree above will take ω·2 steps: ω for the first level, and then another ω for the second level.
</p><p>Thus, simple depth-first or breadth-first searches do not traverse every infinite tree, and are not efficient on very large trees. However, hybrid methods can traverse any (countably) infinite tree, essentially via a diagonal argument ("diagonal"—a combination of vertical and horizontal—corresponds to a combination of depth and breadth).
</p><p>Concretely, given the infinitely branching tree of infinite depth, label the root (), the children of the root (1), (2), …, the grandchildren (1, 1), (1, 2), …, (2, 1), (2, 2), …, and so on. The nodes are thus in a one-to-one correspondence with finite (possibly empty) sequences of positive numbers, which are countable and can be placed in order first by sum of entries, and then by lexicographic order within a given sum (only finitely many sequences sum to a given value, so all entries are reached—formally there are a finite number of compositions of a given natural number, specifically 2<sup><i>n</i>−1</sup> compositions of <span class="nowrap"><i>n</i> ≥ 1</span>), which gives a traversal. Explicitly:
</p>
<ol><li>()</li>
<li>(1)</li>
<li>(1, 1) (2)</li>
<li>(1, 1, 1) (1, 2) (2, 1) (3)</li>
<li>(1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) (4)</li></ol>
<p>etc.
</p><p>This can be interpreted as mapping the infinite depth binary tree onto this tree and then applying breadth-first search: replace the "down" edges connecting a parent node to its second and later children with "right" edges from the first child to the second child, from the second child to the third child, etc. Thus at each step one can either go down (append a (, 1) to the end) or go right (add one to the last number) (except the root, which is extra and can only go down), which shows the correspondence between the infinite binary tree and the above numbering; the sum of the entries (minus one) corresponds to the distance from the root, which agrees with the 2<sup><i>n</i>−1</sup> nodes at depth <span class="nowrap"><i>n</i> − 1</span> in the infinite binary tree (2 corresponds to binary).
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Sources">Sources</span><span class="mw-editsection"></span></h2>
<ul><li>Dale, Nell. Lilly, Susan D. "Pascal Plus Data Structures". D. C. Heath and Company. Lexington, MA. 1995. Fourth Edition.</li>
<li>Drozdek, Adam. "Data Structures and Algorithms in C++". Brook/Cole. Pacific Grove, CA. 2001. Second edition.</li>
<li>"Tree Transversal" (math.northwestern.edu)</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Storing Hierarchical Data in a Database with traversal examples in PHP</li>
<li>Managing Hierarchical Data in MySQL</li>
<li>Working with Graphs in MySQL</li>
<li>Sample code for recursive tree traversal in Python.</li>
<li>See tree traversal implemented in various programming language on Rosetta Code</li>
<li>Tree traversal without recursion</li></ul>
<!-- 
NewPP limit report
Parsed by mw2392
Cached time: 20221224004110
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.306 seconds
Real time usage: 0.464 seconds
Preprocessor visited node count: 2424/1000000
Post‐expand include size: 47143/2097152 bytes
Template argument size: 2044/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 8/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 29876/5000000 bytes
Lua time usage: 0.168/10.000 seconds
Lua memory usage: 6453394/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  363.248      1 -total
 26.65%   96.808      1 Template:Reflist
 20.04%   72.797      5 Template:Cite_web
 15.67%   56.939      1 Template:Short_description
 14.29%   51.913      1 Template:Refimprove
 13.47%   48.920      2 Template:Ambox
 10.48%   38.054      1 Template:Graph_search_algorithm
 10.07%   36.592      1 Template:Sidebar
  7.36%   26.750      2 Template:Pagetype
  6.54%   23.768      2 Template:Rp
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:597584-0!canonical and timestamp 20221224004109 and revision id 1118847664.
 -->
</div></body>
</html>