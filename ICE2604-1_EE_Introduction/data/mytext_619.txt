minimal_perfect_hashingIn computer science, a perfect hash function  for a set  is a hash function that maps distinct elements in  to a set of  integers, with no collisions. In mathematical terms, it is an injective function.Perfect hash functions may be used to implement a lookup table with constant worst-case access time. A perfect hash function can, as any hash function, be used to implement hash tables, with the advantage that no collision resolution has to be implemented. In addition, if the keys are not the data and if it is known that queried keys will be valid, then the keys do not need to be stored in the lookup table, saving space.Disadvantages of perfect hash functions are that  needs to be known for the construction of the perfect hash function. Non-dynamic perfect hash functions need to be re-constructed if  changes. For frequently changing  dynamic perfect hash functions may be used at the cost of additional space.[1] The space requirement to store the perfect hash function is in .The important performance parameters for perfect hash functions are the evaluation time, which should be constant, the construction time, and the representation size.A perfect hash function with values in a limited range can be used for efficient lookup operations, by placing keys from  (or other associated values) in a lookup table indexed by the output of the function. One can then test whether a key is present in , or look up a value associated with that key, by looking for it at its cell of the table. Each such lookup takes constant time in the worst case.[2] With perfect hashing, the associated data can be read or written with a single access to the table.[3]The important performance parameters for perfect hashing are the representation size, the evaluation time, the construction time, and additionally the range requirement .[4] The evaluation time can be as fast as , which is optimal.[2][4] The construction time needs to be at least , because each element in  needs to be considered, and  contains  elements. This lower bound can be achieved in practice.[4]The lower bound for the representation size depends on  and . Let  and  a perfect hash function. A good approximation for the lower bound is  Bits per element. For minimal perfect hashing, , the lower bound is  bits per element.[4]A perfect hash function for a specific set  that can be evaluated in constant time, and with values in a small range, can be found by a randomized algorithm in a number of operations that is proportional to the size of S.The original construction of Fredman, Komlós &amp; Szemerédi (1984) uses a two-level scheme to map a set  of  elements to a range of  indices, and then map each index to a range of hash values. The first level of their construction chooses a large prime  (larger than the size of the universe from which  is drawn), and a parameter , and maps each element  of  to the indexIf  is chosen randomly, this step is likely to have collisions, but the number of elements  that are simultaneously mapped to the same index  is likely to be small.The second level of their construction assigns disjoint ranges of  integers to each index . It uses a second set of linear modular functions, one for each index , to map each member  of  into the range associated with .[2]As Fredman, Komlós &amp; Szemerédi (1984) show, there exists a choice of the parameter  such that the sum of the lengths of the ranges for the  different values of  is . Additionally, for each value of , there exists a linear modular function that maps the corresponding subset of  into the range associated with that value. Both , and the second-level functions for each value of , can be found in polynomial time by choosing values randomly until finding one that works.[2]The hash function itself requires storage space  to store , , and all of the second-level linear modular functions. Computing the hash value of a given key  may be performed in constant time by computing , looking up the second-level function associated with , and applying this function to .A modified version of this two-level scheme with a larger number of values at the top level can be used to construct a perfect hash function that maps  into a smaller range of length .[2]A more recent method for constructing a perfect hash function is described by Belazzougui, Botelho &amp; Dietzfelbinger (2009) as "hash, displace, and compress". Here a first-level hash function  is also used to map elements onto a range of  integers. An element  is stored in the Bucket .[4]Then, in descending order of size, each bucket's elements are hashed by a hash function of a sequence of independent fully random hash functions , starting with . If the hash function does not produce any collisions for the bucket, and the resulting values are not yet occupied by other elements from other buckets, the function is chosen for that bucket. If not, the next hash function in the sequence is tested.[4]To evaluate the perfect hash function  one only has to save the mapping σ of the bucket index  onto the correct hash function in the sequence, resulting in .[4]Finally, to reduce the representation size, the ( are compressed into a form that still allows the evaluation in .[4]This approach needs linear time in  for construction, and constant evaluation time. The representation size is in , and depends on the achieved range. For example, with  Belazzougui, Botelho &amp; Dietzfelbinger (2009) achieved a representation size between 3.03 bits/key and 1.40 bits/key for their given example set of 10 million entries, with lower values needing a higher computation time. The space lower bound in this scenario is 0.88 bits/key.[4]algorithm hash, displace, and compress is(1) Split S into buckets (2) Sort buckets Bi in falling order according to size |Bi|(3) Initialize array T[0...m-1] with 0's(4) for all i∈[r], in the order from (2), do(5)     for l←1,2,...(6)         repeat forming Ki←{l(x)|x∈Bi}(6)         until |Ki|=|Bi| and Ki∩{j|T[j]=1}=∅(7)     let σ(i):= the successful l(8)     for all j∈Ki let T[j]:=1(9) Transform (σi)0≤i&lt;r into compressed form, retaining  access.The use of  words of information to store the function of Fredman, Komlós &amp; Szemerédi (1984) is near-optimal: any perfect hash function that can be calculated in constant timerequires at least a number of bits that is proportional to the size of .[5]For minimal perfect hash functions the information theoretic space lower bound isbits/key.[4]For perfect hash functions, it is first assumed that the range of  is bounded by  as . With the formula given by Belazzougui, Botelho &amp; Dietzfelbinger (2009) and for a universe  whose size  tends towards infinity, the space lower bounds isbits/key, minus  bits overall.[4]A trivial but pervasive example of perfect hashing is implicit in the (virtual) memory address space of a computer. Since each byte of virtual memory is a distinct, unique, directly addressable storage location, the value of the (starting) address of any object stored in memory can be considered a de-facto perfect hash of that object into the entire memory address range.[6]Using a perfect hash function is best in situations where there is a frequently queried large set, , which is seldom updated. This is because any modification of the set  may cause the hash function to no longer be perfect for the modified set. Solutions which update the hash function any time the set is modified are known as dynamic perfect hashing,[1] but these methods are relatively complicated to implement.A minimal perfect hash function is a perfect hash function that maps  keys to  consecutive integers – usually the numbers from  to  or from  to .  A more formal way of expressing this is:  Let  and  be elements of some finite set .  Then  is a minimal perfect hash function if and only if  implies  (injectivity) and there exists an integer  such that the range of  is . It has been proven that a general purpose minimal perfect hash scheme requires at least  bits/key.[4] Although this space bound has been achieved by theoretical works, in practice, the best known minimal perfect hashing schemes require roughly 1.56 bits/key if given enough time.[7]A hash function is -perfect if at most  elements from  are mapped onto the same value in the range. The "hash, displace, and compress" algorithm can be used to construct -perfect hash functions by allowing up to  collisions. The changes necessary to accomplish this are minimal, and are underlined in the adapted pseudocode below:(4) for all i∈[r], in the order from (2), do(5)     for l←1,2,...(6)         repeat forming Ki←{l(x)|x∈Bi}(6)         until |Ki|=|Bi| and Ki∩{j|T[j]=k}=∅(7)     let σ(i):= the successful l(8)     for all j∈Ki set T[j]←T[j]+1A minimal perfect hash function  is order preserving if keys are given in some order  and for any keys  and ,  implies .[8] In this case, the function value is just the position of each key in the sorted ordering of all of the keys. A simple implementation of order-preserving minimal perfect hash functions with constant access time is to use an (ordinary) perfect hash function or cuckoo hashing to store a lookup table of the positions of each key. If the keys to be hashed are themselves stored in a sorted array, it is possible to store a small number of additional bits per key in a data structure that can be used to compute hash values quickly.[9] Order-preserving minimal perfect hash functions require necessarily  bits to be represented.[10]A simple alternative to perfect hashing, which also allows dynamic updates, is cuckoo hashing. This scheme maps keys to two or more locations within a range (unlike perfect hashing which maps each key to a single location) but does so in such a way that the keys can be assigned one-to-one to locations to which they have been mapped. Lookups with this scheme are slower, because multiple locations must be checked, but nevertheless take constant worst-case time.[11]Richard J. Cichelli. Minimal Perfect Hash Functions Made Simple, Communications of the ACM, Vol. 23, Number 1, January 1980.Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Third Edition. MIT Press, 2009. ISBN 978-0262033848. Section 11.5: Perfect hashing, pp. 267, 277–282.Fabiano C. Botelho, Rasmus Pagh and Nivio Ziviani. "Perfect Hashing for Data Management Applications".Fabiano C. Botelho and Nivio Ziviani. "External perfect hashing for very large key sets". 16th ACM Conference on Information and Knowledge Management (CIKM07), Lisbon, Portugal, November 2007.Djamal Belazzougui, Paolo Boldi, Rasmus Pagh, and Sebastiano Vigna. "Monotone minimal perfect hashing: Searching a sorted table with O(1) accesses". In Proceedings of the 20th Annual ACM-SIAM Symposium On Discrete Mathematics (SODA), New York, 2009. ACM Press.Marshall D. Brain and Alan L. Tharp. "Near-perfect Hashing of Large Word Sets". Software--Practice and Experience, vol. 19(10), 967-078, October 1989. John Wiley &amp; Sons.Douglas C. Schmidt, GPERF: A Perfect Hash Function Generator, C++ Report, SIGS, Vol. 10, No. 10, November/December, 1998.gperf is an Open Source C and C++ perfect hash generator (very fast, but only works for small sets)Minimal Perfect Hashing (bob algorithm) by Bob Jenkinscmph: C Minimal Perfect Hashing Library, open source implementations for many (minimal) perfect hashes (works for big sets)Sux4J: open source monotone minimal perfect hashing in JavaMPHSharp: perfect hashing methods in C#BBHash: minimal perfect hash function in header-only C++Perfect::Hash, perfect hash generator in Perl that makes C code. Has a "prior art" section worth looking at.