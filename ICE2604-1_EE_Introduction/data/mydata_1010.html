<!DOCTYPE html>
<html>
<head>
<title>ternary_search_tree</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Expert_needed plainlinks metadata ambox ambox-content" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">Ternary Search Tree (TST)</th></tr><tr><th class="infobox-label" scope="row">Type</th><td class="infobox-data">tree</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
O(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
O(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
O(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
O(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Delete</th><td class="infobox-data infobox-data-a">
O(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
O(<i>n</i>)</td></tr></tbody></table></td></tr></tbody></table>
<p>In computer science, a <b>ternary search tree</b> is a type of trie (sometimes called a <i>prefix tree</i>) where nodes are arranged in a manner similar to a binary search tree, but with up to three children rather than the binary tree's limit of two. Like other prefix trees, a ternary search tree can be used as an associative map structure with the ability for incremental string search. However, ternary search trees are more space efficient compared to standard prefix trees, at the cost of speed. Common applications for ternary search trees include spell-checking and auto-completion.
</p>

<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"></span></h2>
<p>Each node of a ternary search tree stores a single character, an object (or a pointer to an object depending on implementation), and pointers to its three children conventionally named <i>equal kid</i>, <i>lo kid</i> and <i>hi kid</i>, which can also be referred respectively as <i>middle (child)</i>, <i>lower (child)</i> and <i>higher (child)</i>.<sup class="reference" id="cite_ref-dobbs_1-0">[1]</sup> A node may also have a pointer to its parent node as well as an indicator as to whether or not the node marks the end of a word.<sup class="reference" id="cite_ref-ostrov_2-0">[2]</sup> The <i>lo kid</i> pointer must point to a node whose character value is <i>less than the current node</i>. The <i>hi kid</i> pointer must point to a node whose character is <i>greater than the current node</i>.<sup class="reference" id="cite_ref-dobbs_1-1">[1]</sup> The <i>equal kid</i> points to the next character in the word.
The figure below shows a ternary search tree with the strings "cute","cup","at","as","he","us" and "i":
</p>
<pre>          c
        / | \
       a  u  h
       |  |  | \
       t  t  e  u
     /  / |   / |
    s  p  e  i  s
</pre>
<p>As with other trie data structures, each node in a ternary search tree represents a prefix of the stored strings. All strings in the middle subtree of a node start with that prefix.
</p>
<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Insertion">Insertion</span><span class="mw-editsection"></span></h3>
<p>Inserting a value into a ternary search can be defined recursively or iteratively much as lookups are defined. This recursive method is continually called on nodes of the tree given a key which gets progressively shorter by pruning characters off the front of the key. If this method reaches a node that has not been created, it creates the node and assigns it the character value of the first character in the key. Whether a new node is created or not, the method checks to see if the first character in the string is greater than or less than the character value in the node and makes a recursive call on the appropriate node as in the lookup operation. If, however, the key's first character is equal to the node's value then the insertion procedure is called on the equal kid and the key's first character is pruned away.<sup class="reference" id="cite_ref-dobbs_1-2">[1]</sup>  Like binary search trees and other data structures, ternary search trees can become degenerate depending on the order of the keys.<sup class="reference" id="cite_ref-wrobel_3-0">[3]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="The material near this tag may rely on a self-published source. (May 2015)">self-published source?</span></i>]</sup> Inserting keys in alphabetical order is one way to attain the worst possible degenerate tree.<sup class="reference" id="cite_ref-dobbs_1-3">[1]</sup> Inserting the keys in random order often produces a well-balanced tree.<sup class="reference" id="cite_ref-dobbs_1-4">[1]</sup>
</p>

<h3><span class="mw-headline" id="Search">Search</span><span class="mw-editsection"></span></h3>
<p>To look up a particular node or the data associated with a node, a string key is needed. A lookup procedure begins by checking the root node of the tree and determining which of the following conditions has occurred. If the first character of the string is less than the character in the root node, a recursive lookup can be called on the tree whose root is the lo kid of the current root. Similarly, if the first character is greater than the current node in the tree, then a recursive call can be made to the tree whose root is the hi kid of the current node.<sup class="reference" id="cite_ref-dobbs_1-5">[1]</sup>
As a final case, if the first character of the string is equal to the character of the current node then the function returns the node if there are no more characters in the key. If there are more characters in the key then the first character of the key must be removed and a recursive call is made given the equal kid node and the modified key.<sup class="reference" id="cite_ref-dobbs_1-6">[1]</sup>
This can also be written in a non-recursive way by using a pointer to the current node and a pointer to the current character of the key.<sup class="reference" id="cite_ref-dobbs_1-7">[1]</sup>
</p>
<h4><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h4>

<h3><span class="mw-headline" id="Deletion">Deletion</span><span class="mw-editsection"></span></h3>
<p>The delete operation consists of searching for a key string in the search tree and finding a node, called firstMid in the below pseudocode, such that the path from the middle child of firstMid to the end of the search path for the key string has no left or right children. This would represent a unique suffix in the ternary tree corresponding to the key string. If there is no such path, this means that the key string is either fully contained as a prefix of another string, or is not in the search tree. Many implementations make use of an end of string character to ensure only the latter case occurs. The path is then deleted from firstMid.mid to the end of the search path. In the case that firstMid is the root, the key string must have been the last string in the tree, and thus the root is set to null after the deletion. 
</p>

<h3><span class="mw-headline" id="Traversal">Traversal</span><span class="mw-editsection"></span></h3><p><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (September 2016)">clarification needed</span></i>]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="An editor has requested that an example be provided. (September 2016)"><span style="font-style:italic; padding-right:0.15em;">example  needed</span></span></i>]</sup>
</p><h3><span class="mw-headline" id="Partial-match_searching">Partial-match searching</span><span class="mw-editsection"></span></h3><p><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (September 2016)">clarification needed</span></i>]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="An editor has requested that an example be provided. (September 2016)"><span style="font-style:italic; padding-right:0.15em;">example  needed</span></span></i>]</sup>
</p><h3><span class="mw-headline" id="Near-neighbor_searching">Near-neighbor searching</span><span class="mw-editsection"></span></h3><p><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (September 2016)">clarification needed</span></i>]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="An editor has requested that an example be provided. (September 2016)"><span style="font-style:italic; padding-right:0.15em;">example  needed</span></span></i>]</sup>
</p><h2><span class="mw-headline" id="Running_time">Running time</span><span class="mw-editsection"></span></h2>
<p>The running time of ternary search trees varies significantly with the input. Ternary search trees run best when given several <i>similar strings</i>, especially when those strings <i>share a common prefix</i>. Alternatively, ternary search trees are effective when storing a large number of relatively <i>short strings</i> (such as words in a dictionary).<sup class="reference" id="cite_ref-dobbs_1-8">[1]</sup>
Running times for ternary search trees are similar to binary search trees, in that they typically run in logarithmic time, but can run in linear time in the degenerate (worst) case. Further, the size of the strings must also be kept in mind when considering runtime. For example, in the search path for a string of length <i>k</i>, there will be <i>k</i> traversals down middle children in the tree, as well as a logarithmic number of traversals down left and right children in the tree. Thus, in a ternary search tree on a small number of very large strings the lengths of the strings can dominate the runtime.<sup class="reference" id="cite_ref-sedgewick_4-0">[4]</sup>
</p><p>Time complexities for ternary search tree operations:<sup class="reference" id="cite_ref-dobbs_1-9">[1]</sup>
</p>
<table class="wikitable">
<tbody><tr>
<th></th>
<th>Average-case running time</th>
<th>Worst-case running time
</th></tr>
<tr>
<td>Lookup</td>
<td><i>O</i>(log <i>n</i> + <i>k</i>)</td>
<td><i>O</i>(<i>n</i>  + <i>k</i>)
</td></tr>
<tr>
<td>Insertion</td>
<td><i>O</i>(log <i>n</i>  + <i>k</i>)</td>
<td><i>O</i>(<i>n</i>  + <i>k</i>)
</td></tr>
<tr>
<td>Delete</td>
<td><i>O</i>(log <i>n</i>  + <i>k</i>)</td>
<td><i>O</i>(<i>n</i>  + <i>k</i>)
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Comparison_to_other_data_structures">Comparison to other data structures</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Tries">Tries</span><span class="mw-editsection"></span></h3>
<p>While being slower than other prefix trees, ternary search trees can be better suited for larger data sets due to their space-efficiency.<sup class="reference" id="cite_ref-dobbs_1-10">[1]</sup>
</p>
<h3><span class="mw-headline" id="Hash_maps">Hash maps</span><span class="mw-editsection"></span></h3>
<p>Hashtables can also be used in place of ternary search trees for mapping strings to values. However, hash maps also frequently use more memory than ternary search trees (but not as much as tries). Additionally, hash maps are typically slower at reporting a string that is not in the same data structure, because it must compare the entire string rather than just the first few characters. There is some evidence that shows ternary search trees running faster than hash maps.<sup class="reference" id="cite_ref-dobbs_1-11">[1]</sup> Additionally, hash maps do not allow for many of the uses of ternary search trees, such as <i>near-neighbor lookups</i>.
</p>
<h3><span id="DAFSAs_.28deterministic_acyclic_finite_state_automaton.29"></span><span class="mw-headline" id="DAFSAs_(deterministic_acyclic_finite_state_automaton)">DAFSAs (deterministic acyclic finite state automaton)</span><span class="mw-editsection"></span></h3>
<p>If storing dictionary words is all that is required (i.e., storage of information auxiliary to each word is not required), a minimal deterministic acyclic finite state automaton (DAFSA) would use less space than a trie or a ternary search tree. This is because a DAFSA can compress identical branches from the trie which correspond to the same suffixes (or parts) of different words being stored.
</p>
<h2><span class="mw-headline" id="Uses">Uses</span><span class="mw-editsection"></span></h2>
<p>Ternary search trees can be used to solve many problems in which a large number of strings must be stored and retrieved in an arbitrary order. Some of the most common or most useful of these are below:
</p>
<ul><li>Anytime a trie could be used but a less memory-consuming structure is preferred.<sup class="reference" id="cite_ref-dobbs_1-12">[1]</sup></li>
<li>A quick and space-saving data structure for mapping strings to other data.<sup class="reference" id="cite_ref-wrobel_3-1">[3]</sup></li>
<li>To implement auto-completion.<sup class="reference" id="cite_ref-ostrov_2-1">[2]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="The material near this tag may rely on a self-published source. (May 2015)">self-published source?</span></i>]</sup></li>
<li>As a spell check.<sup class="reference" id="cite_ref-wally_5-0">[5]</sup></li>
<li>Near-neighbor searching (of which spell-checking is a special case).<sup class="reference" id="cite_ref-dobbs_1-13">[1]</sup></li>
<li>As a database especially when indexing by several non-key fields is desirable.<sup class="reference" id="cite_ref-wally_5-1">[5]</sup></li>
<li>In place of a hash table.<sup class="reference" id="cite_ref-wally_5-2">[5]</sup></li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Three-way radix quicksort</li>
<li>Trie</li>
<li>Binary search tree</li>
<li>Hashtable</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Ternary Search Trees  page with papers (by Jon Bentley and Robert Sedgewick) about ternary search trees and algorithms for "sorting and searching strings"</li>
<li>Ternary Search Tries – a video by Robert Sedgewick</li>
<li>TST.java.html Implementation in Java of a TST by Robert Sedgewick and Kevin Wayne</li></ul>


<!-- 
NewPP limit report
Parsed by mw1365
Cached time: 20221220211920
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.443 seconds
Real time usage: 1.256 seconds
Preprocessor visited node count: 2127/1000000
Post‐expand include size: 59005/2097152 bytes
Template argument size: 5681/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 9/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 39313/5000000 bytes
Lua time usage: 0.245/10.000 seconds
Lua memory usage: 4806515/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1110.057      1 -total
 16.12%  178.910      2 Template:Navbox
 15.98%  177.440      1 Template:CS-Trees
 10.84%  120.376      1 Template:Reflist
  7.38%   81.963      1 Template:Cite_journal
  4.70%   52.186      1 Template:Expert_needed
  4.66%   51.764      5 Template:Fix
  4.33%   48.025      1 Template:Infobox_data_structure
  3.78%   41.934      1 Template:Infobox
  3.78%   41.928      1 Template:Ambox
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:3025819-0!canonical and timestamp 20221220211918 and revision id 1080145790.
 -->
</div></body>
</html>