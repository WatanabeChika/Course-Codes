<!DOCTYPE html>
<html>
<head>
<title>shortest_common_supersequence</title>
</head>
<body>
<div class="mw-parser-output"><p>In computer science, the <b>shortest common supersequence</b> of two sequences <b>X</b> and <b>Y</b> is the shortest sequence which has <b>X</b> and <b>Y</b> as subsequences. This is a problem closely related to the longest common subsequence problem. Given two sequences <b>X</b> = &lt; x<sub>1</sub>,...,x<sub>m</sub> &gt; and <b>Y</b> = &lt; y<sub>1</sub>,...,y<sub>n</sub> &gt;, a sequence <b>U</b> = &lt; u<sub>1</sub>,...,u<sub>k</sub> &gt; is a common supersequence of <b>X</b> and <b>Y</b> if items can be removed from <b>U</b> to produce <b>X</b> and <b>Y</b>.
</p><p>A shortest common supersequence (SCS) is a common supersequence of minimal length.  In the shortest common supersequence problem, two sequences <b>X</b> and <b>Y</b> are given, and the task is to find a shortest possible common supersequence of these sequences.  In general, an SCS is not unique.
</p><p>For two input sequences, an SCS can be formed from a longest common subsequence (LCS) easily.  For example, the longest common subsequence of <b>X</b><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle [1..m]=abcbdab}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">[</mo>
<mn>1..</mn>
<mi>m</mi>
<mo stretchy="false">]</mo>
<mo>=</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mi>b</mi>
<mi>d</mi>
<mi>a</mi>
<mi>b</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle [1..m]=abcbdab}</annotation>
</semantics>
</math></span><img alt="[1..m]=abcbdab" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a81f42392c43a0b0298789a903338bf76dc97223" style="vertical-align: -0.838ex; width:16.564ex; height:2.843ex;"/></span> and <b>Y</b><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle [1..n]=bdcaba}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">[</mo>
<mn>1..</mn>
<mi>n</mi>
<mo stretchy="false">]</mo>
<mo>=</mo>
<mi>b</mi>
<mi>d</mi>
<mi>c</mi>
<mi>a</mi>
<mi>b</mi>
<mi>a</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle [1..n]=bdcaba}</annotation>
</semantics>
</math></span><img alt="[1..n]=bdcaba" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c34a14553055e81f2d6a800b4b8a81818503a8b" style="vertical-align: -0.838ex; width:14.92ex; height:2.843ex;"/></span> is <b>Z</b><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle [1..L]=bcba}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">[</mo>
<mn>1..</mn>
<mi>L</mi>
<mo stretchy="false">]</mo>
<mo>=</mo>
<mi>b</mi>
<mi>c</mi>
<mi>b</mi>
<mi>a</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle [1..L]=bcba}</annotation>
</semantics>
</math></span><img alt="{\displaystyle [1..L]=bcba}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/650337a86ee10a285698a036e6bc6c051142551a" style="vertical-align: -0.838ex; width:12.663ex; height:2.843ex;"/></span>.  By inserting the non-LCS symbols into <b>Z</b> while preserving their original order, we obtain a shortest common supersequence <b>U</b><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle [1..S]=abdcabdab}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">[</mo>
<mn>1..</mn>
<mi>S</mi>
<mo stretchy="false">]</mo>
<mo>=</mo>
<mi>a</mi>
<mi>b</mi>
<mi>d</mi>
<mi>c</mi>
<mi>a</mi>
<mi>b</mi>
<mi>d</mi>
<mi>a</mi>
<mi>b</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle [1..S]=abdcabdab}</annotation>
</semantics>
</math></span><img alt="{\displaystyle [1..S]=abdcabdab}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d2cc9828f4d32339be1fc26d946996bd3da65e3" style="vertical-align: -0.838ex; width:18.468ex; height:2.843ex;"/></span>.  In particular, the equation <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle L+S=m+n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>L</mi>
<mo>+</mo>
<mi>S</mi>
<mo>=</mo>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle L+S=m+n}</annotation>
</semantics>
</math></span><img alt="{\displaystyle L+S=m+n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4732f49d7d0399398c846bf4587942a4ea804514" style="vertical-align: -0.505ex; width:15.296ex; height:2.343ex;"/></span> holds for any two input sequences.
</p><p>There is no similar relationship between shortest common supersequences and longest common subsequences of three or more input sequences.  (In particular, LCS and SCS are not dual problems.)  However, both problems can be solved in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n^{k})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n^{k})}</annotation>
</semantics>
</math></span><img alt="O(n^{k})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1247a36dbf5f27981eb76f42c2848931af165029" style="vertical-align: -0.838ex; width:6.066ex; height:3.176ex;"/></span> time using dynamic programming, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k}</annotation>
</semantics>
</math></span><img alt="k" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" style="vertical-align: -0.338ex; width:1.211ex; height:2.176ex;"/></span> is the number of sequences, and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> is their maximum length.  For the general case of an arbitrary number of input sequences, the problem is NP-hard.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>

<h2><span class="mw-headline" id="Shortest_common_superstring">Shortest common superstring</span><span class="mw-editsection"></span></h2>
<p>The closely related problem of finding a minimum-length string which is a superstring of a finite set of strings <var style="padding-right: 1px;">S</var> = { <var style="padding-right: 1px;">s</var><sub>1</sub>,<var style="padding-right: 1px;">s</var><sub>2</sub>,...,<var style="padding-right: 1px;">s</var><sub>n</sub> } is also NP-hard.<sup class="reference" id="cite_ref-2">[2]</sup>  Several constant factor approximations have been proposed throughout the years, and the current best known algorithm has an approximation factor of 2.475.<sup class="reference" id="cite_ref-3">[3]</sup> However, perhaps the simplest solution is to reformulate the problem as an instance of weighted set cover in such a way that the weight of the optimal solution to the set cover instance is less than twice the length of the shortest superstring <var style="padding-right: 1px;">S</var>. One can then use the O(log(<var style="padding-right: 1px;">n</var>))-approximation for weighted set-cover to obtain an O(log(<var style="padding-right: 1px;">n</var>))-approximation for the shortest superstring (note that this is <i>not</i> a constant factor approximation).
</p><p>For any string <var style="padding-right: 1px;">x</var> in this alphabet, define <var style="padding-right: 1px;">P</var>(<var style="padding-right: 1px;">x</var>) to be the set of all strings which are substrings of <var style="padding-right: 1px;">x</var>. The instance <var style="padding-right: 1px;">I</var> of set cover is formulated as follows: 
</p>
<ul><li>Let <var style="padding-right: 1px;">M</var> be empty.</li>
<li>For each pair of strings <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">i</var></sub> and <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">j</var></sub>, if the last <var style="padding-right: 1px;">k</var> symbols of <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">i</var></sub> are the same as the first <var style="padding-right: 1px;">k</var> symbols of <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">j</var></sub>, then add a string to <var style="padding-right: 1px;">M</var> that consists of the concatenation with maximal overlap of <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">i</var></sub> with <var style="padding-right: 1px;">s</var><sub><var style="padding-right: 1px;">j</var></sub>.</li>
<li>Define the universe <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathcal {U}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">U</mi>
</mrow>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathcal {U}}}</annotation>
</semantics>
</math></span><img alt="{\mathcal {U}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4e63ea009de5efbca2fc285b8550daaed577c6b8" style="vertical-align: -0.338ex; margin-left: -0.038ex; width:1.635ex; height:2.176ex;"/></span> of the set cover instance to be <var style="padding-right: 1px;">S</var></li>
<li>Define the set of subsets of the universe to be { <var style="padding-right: 1px;">P</var>(<var style="padding-right: 1px;">x</var>) | <var style="padding-right: 1px;">x</var> ∈ <var style="padding-right: 1px;">S</var> ∪ <var style="padding-right: 1px;">M</var> }</li>
<li>Define the cost of each subset <var style="padding-right: 1px;">P</var>(x) to be |<var style="padding-right: 1px;">x</var>|, the length of <var style="padding-right: 1px;">x</var>.</li></ul>
<p>The instance <var style="padding-right: 1px;">I</var> can then be solved using an algorithm for weighted set cover, and the algorithm can output an arbitrary concatenation of the strings <var style="padding-right: 1px;">x</var> for which the weighted set cover algorithm outputs <var style="padding-right: 1px;">P</var>(<var style="padding-right: 1px;">x</var>).<sup class="reference" id="cite_ref-FOOTNOTEVazirani20_4-0">[4]</sup>
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h3>
<p>Consider the set <var style="padding-right: 1px;">S</var> = { abc, cde, fab }, which becomes the universe of the weighted set cover instance. In this case, <var style="padding-right: 1px;">M</var> = { abcde, fabc }. Then the set of subsets of the universe is
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\begin{aligned}\{P(x)|x\in S\cup M\}&amp;=\{P(x)|x\in \{abc,cde,fab,abcde,fabc\}\}\\&amp;=\{P(abc),P(cde),P(fab),P(abcde),P(fabc)\}\}\\&amp;=\{\{a,b,c,ab,bc,abc\},\{c,d,e,cd,de,cde\},\ldots ,\{f,a,b,c,fa,ab,bc,fab,abc,fabc\}\}\}\\\end{aligned}}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true" rowspacing="3pt">
<mtr>
<mtd>
<mo fence="false" stretchy="false">{</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mi>S</mi>
<mo>∪<!-- ∪ --></mo>
<mi>M</mi>
<mo fence="false" stretchy="false">}</mo>
</mtd>
<mtd>
<mi></mi>
<mo>=</mo>
<mo fence="false" stretchy="false">{</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mo fence="false" stretchy="false">{</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo>,</mo>
<mi>c</mi>
<mi>d</mi>
<mi>e</mi>
<mo>,</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mo>,</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mi>d</mi>
<mi>e</mi>
<mo>,</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo fence="false" stretchy="false">}</mo>
<mo fence="false" stretchy="false">}</mo>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd>
<mi></mi>
<mo>=</mo>
<mo fence="false" stretchy="false">{</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mi>d</mi>
<mi>e</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mi>d</mi>
<mi>e</mi>
<mo stretchy="false">)</mo>
<mo>,</mo>
<mi>P</mi>
<mo stretchy="false">(</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo stretchy="false">)</mo>
<mo fence="false" stretchy="false">}</mo>
<mo fence="false" stretchy="false">}</mo>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd>
<mi></mi>
<mo>=</mo>
<mo fence="false" stretchy="false">{</mo>
<mo fence="false" stretchy="false">{</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi>a</mi>
<mi>b</mi>
<mo>,</mo>
<mi>b</mi>
<mi>c</mi>
<mo>,</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo fence="false" stretchy="false">}</mo>
<mo>,</mo>
<mo fence="false" stretchy="false">{</mo>
<mi>c</mi>
<mo>,</mo>
<mi>d</mi>
<mo>,</mo>
<mi>e</mi>
<mo>,</mo>
<mi>c</mi>
<mi>d</mi>
<mo>,</mo>
<mi>d</mi>
<mi>e</mi>
<mo>,</mo>
<mi>c</mi>
<mi>d</mi>
<mi>e</mi>
<mo fence="false" stretchy="false">}</mo>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mo fence="false" stretchy="false">{</mo>
<mi>f</mi>
<mo>,</mo>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi>f</mi>
<mi>a</mi>
<mo>,</mo>
<mi>a</mi>
<mi>b</mi>
<mo>,</mo>
<mi>b</mi>
<mi>c</mi>
<mo>,</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mo>,</mo>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo>,</mo>
<mi>f</mi>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mo fence="false" stretchy="false">}</mo>
<mo fence="false" stretchy="false">}</mo>
<mo fence="false" stretchy="false">}</mo>
</mtd>
</mtr>
</mtable>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\begin{aligned}\{P(x)|x\in S\cup M\}&amp;=\{P(x)|x\in \{abc,cde,fab,abcde,fabc\}\}\\&amp;=\{P(abc),P(cde),P(fab),P(abcde),P(fabc)\}\}\\&amp;=\{\{a,b,c,ab,bc,abc\},\{c,d,e,cd,de,cde\},\ldots ,\{f,a,b,c,fa,ab,bc,fab,abc,fabc\}\}\}\\\end{aligned}}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\begin{aligned}\{P(x)|x\in S\cup M\}&amp;=\{P(x)|x\in \{abc,cde,fab,abcde,fabc\}\}\\&amp;=\{P(abc),P(cde),P(fab),P(abcde),P(fabc)\}\}\\&amp;=\{\{a,b,c,ab,bc,abc\},\{c,d,e,cd,de,cde\},\ldots ,\{f,a,b,c,fa,ab,bc,fab,abc,fabc\}\}\}\\\end{aligned}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6ebc55b3c04e385643e1619e3f7440b1654e9157" style="vertical-align: -4.005ex; width:103.06ex; height:9.176ex;"/></span></dd></dl>
<p>which have costs 3, 3, 3, 5, and 4, respectively.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFGareyJohnson1979">Garey, Michael R.; Johnson, David S. (1979). <i>Computers and Intractability: A Guide to the Theory of NP-Completeness</i>. W.H. Freeman. p. 228 A4.2: SR8. ISBN <bdi>0-7167-1045-5</bdi>. Zbl 0411.68039.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computers+and+Intractability%3A+A+Guide+to+the+Theory+of+NP-Completeness&amp;rft.pages=p.+228+A4.2%3A+SR8&amp;rft.pub=W.H.+Freeman&amp;rft.date=1979&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A0411.68039%23id-name%3DZbl&amp;rft.isbn=0-7167-1045-5&amp;rft.aulast=Garey&amp;rft.aufirst=Michael+R.&amp;rft.au=Johnson%2C+David+S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AShortest+common+supersequence+problem"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFSzpankowski2001">Szpankowski, Wojciech (2001). <i>Average case analysis of algorithms on sequences</i>. Wiley-Interscience Series in Discrete Mathematics and Optimization. With a foreword by Philippe Flajolet. Chichester: Wiley. ISBN <bdi>0-471-24063-X</bdi>. Zbl 0968.68205.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Average+case+analysis+of+algorithms+on+sequences&amp;rft.place=Chichester&amp;rft.series=Wiley-Interscience+Series+in+Discrete+Mathematics+and+Optimization&amp;rft.pub=Wiley&amp;rft.date=2001&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A0968.68205%23id-name%3DZbl&amp;rft.isbn=0-471-24063-X&amp;rft.aulast=Szpankowski&amp;rft.aufirst=Wojciech&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AShortest+common+supersequence+problem"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFVazirani2001">Vazirani, Vijay V. (2001), <i>Approximation Algorithms</i>, Springer-Verlag, ISBN <bdi>3-540-65367-8</bdi></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Approximation+Algorithms&amp;rft.pub=Springer-Verlag&amp;rft.date=2001&amp;rft.isbn=3-540-65367-8&amp;rft.aulast=Vazirani&amp;rft.aufirst=Vijay+V.&amp;rft_id=http%3A%2F%2Fwww.cc.gatech.edu%2Ffac%2FVijay.Vazirani%2Fbook.pd&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AShortest+common+supersequence+problem"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Dictionary of Algorithms and Data Structures: shortest common supersequence</li></ul>
<!-- 
NewPP limit report
Parsed by mw2325
Cached time: 20221214141921
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.146 seconds
Real time usage: 0.222 seconds
Preprocessor visited node count: 1120/1000000
Post‐expand include size: 15499/2097152 bytes
Template argument size: 241/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 17278/5000000 bytes
Lua time usage: 0.079/10.000 seconds
Lua memory usage: 4648971/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  143.695      1 -total
 57.66%   82.849      1 Template:Reflist
 47.30%   67.972      3 Template:Cite_journal
 25.99%   37.349      1 Template:Sfn
  6.60%    9.491      2 Template:Cite_book
  4.05%    5.822     43 Template:Var
  3.77%    5.422      1 Template:Citation
  1.10%    1.586      2 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2699476-0!canonical and timestamp 20221214141921 and revision id 1127159874.
 -->
</div></body>
</html>