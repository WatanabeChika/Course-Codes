<!DOCTYPE html>
<html>
<head>
<title>bottleneck_traveling_salesman</title>
</head>
<body>
<div class="mw-parser-output"><p>The <b>Bottleneck traveling salesman problem</b> (<b>bottleneck TSP</b>) is a problem in discrete or combinatorial optimization.  The problem is to find the Hamiltonian cycle (visiting each node exactly once) in a weighted graph which minimizes the weight of the highest-weight edge of the cycle.<sup class="reference" id="cite_ref-kp07_1-0">[1]</sup> It was first formulated by Gilmore &amp; Gomory (1964) with some additional constraints, and in its full generality by Garfinkel &amp; Gilbert (1978).<sup class="reference" id="cite_ref-kp07_1-1">[1]</sup><sup class="reference" id="cite_ref-2">[2]</sup><sup class="reference" id="cite_ref-3">[3]</sup>
</p>

<h2><span class="mw-headline" id="Complexity">Complexity</span><span class="mw-editsection"></span></h2>
<p>The problem is known to be NP-hard. The decision problem version of this, "for a given length <span class="texhtml mvar" style="font-style:italic;">x</span> is there a Hamiltonian cycle in a graph <span class="texhtml mvar" style="font-style:italic;">G</span> with no edge longer than <span class="texhtml mvar" style="font-style:italic;">x</span>?", is NP-complete. NP-completeness follows immediately by a reduction from the problem of finding a Hamiltonian cycle.<sup class="reference" id="cite_ref-gj_4-0">[4]</sup>
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>Another reduction, from the bottleneck TSP to the usual TSP (where the goal is to minimize the sum of edge lengths), allows any algorithm for the usual TSP to also be used to solve the bottleneck TSP.
If the edge weights of  the bottleneck TSP are replaced by any other numbers that have the same relative order, then the bottleneck solution remains unchanged.
If, in addition, each number in the sequence exceeds the sum of all smaller numbers, then the bottleneck solution will also equal the usual TSP solution.
For instance, such a result may be attained by resetting each weight to <span class="texhtml"><i>n</i><sup><i>i</i></sup></span> where <span class="texhtml mvar" style="font-style:italic;">n</span> is the number of vertices in the graph and <span class="texhtml mvar" style="font-style:italic;">i</span> is the rank of the original weight of the edge in the sorted sequence of weights. For instance, following this transformation, the Held–Karp algorithm could be used to solve the bottleneck TSP in time <span class="texhtml"><i>O</i>(<i>n</i><sup>2</sup>2<sup><i>n</i></sup>)</span>.<sup class="reference" id="cite_ref-kp07_1-2">[1]</sup>
</p><p>Alternatively, the problem can be solved by performing a binary search or sequential search for the smallest <span class="texhtml mvar" style="font-style:italic;">x</span> such that the subgraph of edges of weight at most <span class="texhtml mvar" style="font-style:italic;">x</span> has a Hamiltonian cycle. This method leads to solutions whose running time is only a logarithmic factor larger than the time to find a Hamiltonian cycle.<sup class="reference" id="cite_ref-kp07_1-3">[1]</sup>
</p>
<h2><span class="mw-headline" id="Variations">Variations</span><span class="mw-editsection"></span></h2>
<p>In an <b>asymmetric bottleneck TSP</b>, there are cases where the weight from node <i>A</i> to <i>B</i> is different from the weight from B to A (e. g. travel time between two cities with a traffic jam in one direction).
</p><p>The <b>Euclidean bottleneck TSP</b>, or planar bottleneck TSP, is the bottleneck TSP with the distance being the ordinary Euclidean distance. The problem still remains NP-hard. However, many heuristics work better for it than for other distance functions.
</p><p>The <b>maximum scatter traveling salesman problem</b> is another variation of the traveling salesman problem in which the goal is to find a Hamiltonian cycle that maximizes the minimum edge length rather than minimizing the maximum length. Its applications include the analysis of medical images, and the scheduling of metalworking steps in aircraft manufacture to avoid heat buildup from steps that are nearby in both time and space. It can be translated into an instance of the bottleneck TSP problem by negating all edge lengths (or, to keep the results positive, subtracting them all from a large enough constant). However, although this transformation preserves the optimal solution, it does not preserve the quality of approximations to that solution.<sup class="reference" id="cite_ref-kp07_1-4">[1]</sup>
</p>
<h2><span class="mw-headline" id="Metric_approximation_algorithm">Metric approximation algorithm</span><span class="mw-editsection"></span></h2>
<p>If the graph is a metric space then there is an efficient approximation algorithm that finds a Hamiltonian cycle with maximum edge weight being no more than twice the optimum.
This result follows by Fleischner's theorem, that the square of a 2-vertex-connected graph always contains a Hamiltonian cycle. It is easy to find a threshold value <span class="texhtml mvar" style="font-style:italic;">θ</span>, the smallest value such that the edges of weight <span class="texhtml mvar" style="font-style:italic;">θ</span> form a 2-connected graph. Then <span class="texhtml mvar" style="font-style:italic;">θ</span> provides a valid lower bound on the bottleneck TSP weight, for the bottleneck TSP is itself a 2-connected graph and necessarily contains an edge of weight at least <span class="texhtml mvar" style="font-style:italic;">θ</span>. However, the square of the subgraph of edges of weight at most <span class="texhtml mvar" style="font-style:italic;">θ</span> is Hamiltonian. By the triangle inequality for metric spaces, its Hamiltonian cycle has edges of weight at most <span class="texhtml">2<i>θ</i></span>.<sup class="reference" id="cite_ref-5">[5]</sup><sup class="reference" id="cite_ref-hs_6-0">[6]</sup>
</p><p>This approximation ratio is best possible. For, any unweighted graph can be transformed into a metric space by setting its edge weights to <span class="texhtml">1</span> and setting the distance between all nonadjacent pairs of vertices to <span class="texhtml">2</span>. An approximation with ratio better than <span class="texhtml">2</span> in this metric space could be used to determine whether the original graph contains a Hamiltonian cycle, an NP-complete problem.<sup class="reference" id="cite_ref-hs_6-1">[6]</sup>
</p><p>Without the assumption that the input is a metric space, no finite approximation ratio is possible.<sup class="reference" id="cite_ref-kp07_1-5">[1]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Travelling salesman problem</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw1481
Cached time: 20221214135342
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.172 seconds
Real time usage: 0.201 seconds
Preprocessor visited node count: 853/1000000
Post‐expand include size: 14371/2097152 bytes
Template argument size: 556/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 20744/5000000 bytes
Lua time usage: 0.105/10.000 seconds
Lua memory usage: 4669376/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  181.702      1 -total
 66.64%  121.092      1 Template:Reflist
 56.20%  102.115      6 Template:Citation
 23.99%   43.582      2 Template:Harvtxt
  5.45%    9.909      6 Template:Math
  1.39%    2.528      7 Template:Main_other
  0.84%    1.527     12 Template:Mvar
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:420524-0!canonical and timestamp 20221214135342 and revision id 1013929442.
 -->
</div></body>
</html>