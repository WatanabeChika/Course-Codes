<!DOCTYPE html>
<html>
<head>
<title>recursive_data_structure</title>
</head>
<body>
<div class="mw-parser-output">
<p>In computer programming languages, a <b>recursive data type</b> (also known as a <b>recursively-defined</b>, <b>inductively-defined</b> or <b>inductive data type</b>) is a data type for values that may contain other values of the same type. Data of recursive types are usually viewed as directed graphs<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="Don't you mean a tree? (July 2022)">citation needed</span></i>]</sup>.
</p><p>An important application of recursion in computer science is in defining dynamic data structures such as Lists and Trees.  Recursive data structures can dynamically grow to an arbitrarily large size in response to runtime requirements; in contrast, a static array's size requirements must be set at compile time.
</p><p>Sometimes the term "inductive data type" is used for algebraic data types which are not necessarily recursive.
</p>

<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>An example is the list type, in Haskell:
</p>

<p>This indicates that a list of a's is either an empty list or a <b>cons cell</b> containing an 'a' (the "head" of the list) and another list (the "tail").
</p><p>Another example is a similar singly linked type in Java:
</p>

<p>This indicates that non-empty list of type E contains a data member of type E, and a reference to another List object for the rest of the list (or a null reference to indicate that this is the end of the list).
</p>
<h3><span class="mw-headline" id="Mutually_recursive_data_types">Mutually recursive data types</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Data types can also be defined by mutual recursion. The most important basic example of this is a tree, which can be defined mutually recursively in terms of a forest (a list of trees). Symbolically:
</p>
<pre>f: [t[1], ..., t[k]]
t: v f
</pre>
<p>A forest <i>f</i> consists of a list of trees, while a tree <i>t</i> consists of a pair of a value <i>v</i> and a forest <i>f</i> (its children). This definition is elegant and easy to work with abstractly (such as when proving theorems about properties of trees), as it expresses a tree in simple terms: a list of one type, and a pair of two types.
</p><p>This mutually recursive definition can be converted to a singly recursive definition by inlining the definition of a forest:
</p>
<pre>t: v [t[1], ..., t[k]]
</pre>
<p>A tree <i>t</i> consists of a pair of a value <i>v</i> and a list of trees (its children). This definition is more compact, but somewhat messier: a tree consists of a pair of one type and a list another, which require disentangling to prove results about.
</p><p>In Standard ML, the tree and forest data types can be mutually recursively defined as follows, allowing empty trees:<sup class="reference" id='cite_ref-FOOTNOTEHarper2000"[httpswwwcscmuedu~rwhintrosmlcoredatatypeshtm_Data_Types]"_1-0'>[1]</sup>
</p>
<p>In Haskell, the tree and forest data types can be defined similarly:</p>
<h2><span class="mw-headline" id="Theory">Theory</span><span class="mw-editsection"></span></h2>
<p>In type theory, a recursive type has the general form μα.T where the type variable α may appear in the type T and stands for the entire type itself.
</p><p>For example, the natural numbers (see Peano arithmetic) may be defined by the Haskell datatype:
</p>

<p>In type theory, we would say: <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle nat=\mu \alpha .1+\alpha }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mi>a</mi>
<mi>t</mi>
<mo>=</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mn>.1</mn>
<mo>+</mo>
<mi>α<!-- α --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle nat=\mu \alpha .1+\alpha }</annotation>
</semantics>
</math></span><img alt="nat=\mu \alpha .1+\alpha " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c441aa78f783b3798a06b688e218f9801529388f" style="vertical-align: -0.838ex; width:15.589ex; height:2.676ex;"/></span> where the two arms of the sum type represent the Zero and Succ data constructors. Zero takes no arguments (thus represented by the unit type) and Succ takes another Nat (thus another element of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mu \alpha .1+\alpha }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mn>.1</mn>
<mo>+</mo>
<mi>α<!-- α --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mu \alpha .1+\alpha }</annotation>
</semantics>
</math></span><img alt="\mu \alpha .1+\alpha " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ea41fbf58e9873244ca36c56c9d11b2156339765" style="vertical-align: -0.838ex; width:9.027ex; height:2.676ex;"/></span>).
</p><p>There are two forms of recursive types: the so-called isorecursive types, and equirecursive types.  The two forms differ in how terms of a recursive type are introduced and eliminated.
</p>
<h3><span class="mw-headline" id="Isorecursive_types">Isorecursive types</span><span class="mw-editsection"></span></h3>
<p>With isorecursive types, the recursive type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mu \alpha .T}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mu \alpha .T}</annotation>
</semantics>
</math></span><img alt="\mu \alpha .T" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e536f74795348aa746443152f30b594270a0237e" style="vertical-align: -0.838ex; width:5.56ex; height:2.676ex;"/></span> and its expansion (or <i>unrolling</i>) <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T[\mu \alpha .T/\alpha ]}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">[</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>α<!-- α --></mi>
<mo stretchy="false">]</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T[\mu \alpha .T/\alpha ]}</annotation>
</semantics>
</math></span><img alt="T[\mu \alpha .T/\alpha ]" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/efbc5122f9ac522ed8a510aa156993f362d194ae" style="vertical-align: -0.838ex; width:11.14ex; height:2.843ex;"/></span> (Where the notation <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle X[Y/Z]}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>X</mi>
<mo stretchy="false">[</mo>
<mi>Y</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>Z</mi>
<mo stretchy="false">]</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle X[Y/Z]}</annotation>
</semantics>
</math></span><img alt="X[Y/Z]" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/00989088ec91a5662c617a728e9d8e5095ba39d3" style="vertical-align: -0.838ex; width:7.89ex; height:2.843ex;"/></span> indicates that all instances of Z are replaced with Y in X) are distinct (and disjoint) types with special term constructs, usually called <i>roll</i> and <i>unroll</i>, that form an isomorphism between them.  To be precise: <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle roll:T[\mu \alpha .T/\alpha ]\to \mu \alpha .T}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>r</mi>
<mi>o</mi>
<mi>l</mi>
<mi>l</mi>
<mo>:</mo>
<mi>T</mi>
<mo stretchy="false">[</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>α<!-- α --></mi>
<mo stretchy="false">]</mo>
<mo stretchy="false">→<!-- → --></mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle roll:T[\mu \alpha .T/\alpha ]\to \mu \alpha .T}</annotation>
</semantics>
</math></span><img alt="roll:T[\mu \alpha .T/\alpha ]\to \mu \alpha .T" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6b6f8d541d2489945bdb60a01c590421274564d2" style="vertical-align: -0.838ex; width:25.813ex; height:2.843ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle unroll:\mu \alpha .T\to T[\mu \alpha .T/\alpha ]}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>u</mi>
<mi>n</mi>
<mi>r</mi>
<mi>o</mi>
<mi>l</mi>
<mi>l</mi>
<mo>:</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
<mo stretchy="false">→<!-- → --></mo>
<mi>T</mi>
<mo stretchy="false">[</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>α<!-- α --></mi>
<mo stretchy="false">]</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle unroll:\mu \alpha .T\to T[\mu \alpha .T/\alpha ]}</annotation>
</semantics>
</math></span><img alt="unroll:\mu \alpha .T\to T[\mu \alpha .T/\alpha ]" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c8146ae5a168a59afea5f32932b583a4b67aa17" style="vertical-align: -0.838ex; width:28.538ex; height:2.843ex;"/></span>, and these two are inverse functions.
</p>
<h3><span class="mw-headline" id="Equirecursive_types">Equirecursive types</span><span class="mw-editsection"></span></h3>
<p>Under equirecursive rules, a recursive type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \mu \alpha .T}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \mu \alpha .T}</annotation>
</semantics>
</math></span><img alt="\mu \alpha .T" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e536f74795348aa746443152f30b594270a0237e" style="vertical-align: -0.838ex; width:5.56ex; height:2.676ex;"/></span> and its unrolling <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T[\mu \alpha .T/\alpha ]}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mo stretchy="false">[</mo>
<mi>μ<!-- μ --></mi>
<mi>α<!-- α --></mi>
<mo>.</mo>
<mi>T</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mi>α<!-- α --></mi>
<mo stretchy="false">]</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T[\mu \alpha .T/\alpha ]}</annotation>
</semantics>
</math></span><img alt="T[\mu \alpha .T/\alpha ]" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/efbc5122f9ac522ed8a510aa156993f362d194ae" style="vertical-align: -0.838ex; width:11.14ex; height:2.843ex;"/></span> are <i>equal</i> -- that is, those two type expressions are understood to denote the same type.  In fact, most theories of equirecursive types go further and essentially specify that any two type expressions with the same "infinite expansion" are equivalent.  As a result of these rules, equirecursive types contribute significantly more complexity to a type system than isorecursive types do.  Algorithmic problems such as type checking and type inference are more difficult for equirecursive types as well.  Since direct comparison does not make sense on an equirecursive type, they can be converted into a canonical form in O(n log n) time, which can easily be compared.<sup class="reference" id="cite_ref-canonicalize_2-0">[2]</sup>
</p><p>Isorecursive types capture the form of self-referential (or mutually referential) type definitions seen in nominal object-oriented programming languages, and also arise in type-theoretic semantics of objects and classes. In functional programming languages, isorecursive types (in the guise of datatypes) are common too.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="Recursive_type_synonyms">Recursive type synonyms</span><span class="mw-editsection"></span></h2>
<p>Recursion is allowed in the type alias of TypeScript.<sup class="reference" id="cite_ref-4">[4]</sup> Following example is allowed.
</p>

<p>However, recursion is not allowed in type synonyms in Miranda, OCaml (unless <code>-rectypes</code> flag is used or it's a record or variant), and Haskell; so for example the following Haskell types are illegal:
</p>

<p>Instead, it must be wrapped inside an algebraic data type (even if it only has one constructor):
</p>

<p>This is because type synonyms, like typedefs in C, are replaced with their definition at compile time. (Type synonyms are not "real" types; they are just "aliases" for convenience of the programmer.) But if this is attempted with a recursive type, it will loop infinitely because no matter how many times the alias is substituted, it still refers to itself, e.g. "Bad" will grow indefinitely: <code>Bad</code> → <code>(Int, Bad)</code> → <code>(Int, (Int, Bad))</code> → <code>...</code> .
</p><p>Another way to see it is that a level of indirection (the algebraic data type) is required to allow the isorecursive type system to figure out when to <i>roll</i> and <i>unroll</i>.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Recursive definition</li>
<li>Algebraic data type</li>
<li>Inductive type</li>
<li>Node (computer science)</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>

<!-- 
NewPP limit report
Parsed by mw2413
Cached time: 20221224023607
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.209 seconds
Real time usage: 0.339 seconds
Preprocessor visited node count: 735/1000000
Post‐expand include size: 22361/2097152 bytes
Template argument size: 1272/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 11/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 16171/5000000 bytes
Lua time usage: 0.119/10.000 seconds
Lua memory usage: 4448937/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  252.999      1 -total
 27.58%   69.786      1 Template:Reflist
 23.91%   60.490      1 Template:Short_description
 22.94%   58.035      1 Template:Cite_document
 15.79%   39.953      1 Template:Data_types
 14.98%   37.906      1 Template:Navbox
 12.78%   32.336      2 Template:Pagetype
 10.90%   27.577      1 Template:Citation_needed
  8.95%   22.656      1 Template:Fix
  8.92%   22.561      1 Template:Sfn
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2227485-0!canonical and timestamp 20221224023607 and revision id 1100271366.
 -->
</div></body>
</html>