<!DOCTYPE html>
<html>
<head>
<title>spanning_tree</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In the mathematical field of graph theory, a <b>spanning tree</b> <i>T</i> of an undirected graph <i>G</i> is a subgraph that is a tree which includes all of the vertices of <i>G</i>.<sup class="reference" id="cite_ref-NetworkX_2.6.2_documentation_1-0">[1]</sup> In general, a graph may have several spanning trees, but a graph that is not connected will not contain a spanning tree (see about spanning forests below). If all of the edges of <i>G</i> are also edges of a spanning tree <i>T</i> of <i>G</i>, then <i>G</i> is a tree and is identical to <i>T</i> (that is, a tree has a unique spanning tree and it is itself).
</p>

<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Several pathfinding algorithms, including Dijkstra's algorithm and the A* search algorithm, internally build a spanning tree as an intermediate step in solving the problem.
</p><p>In order to minimize the cost of power networks, wiring connections, piping, automatic speech recognition, etc., people often use algorithms that gradually build a spanning tree (or many such trees) as intermediate steps in the process of finding the minimum spanning tree.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>The Internet and many other telecommunications networks have transmission links that connect nodes together in a mesh topology that includes some loops.
In order to avoid bridge loops and routing loops, many routing protocols designed for such networks—including the Spanning Tree Protocol, Open Shortest Path First, Link-state routing protocol, Augmented tree-based routing, etc.—require each router to remember a spanning tree.<sup class="reference" id="cite_ref-https://en.wikipedia.org/w/index.php?title=Spanning_tree&amp;action=edit#_3-0">[3]</sup>
</p><p>A special kind of spanning tree, the Xuong tree, is used in topological graph theory to find graph embeddings with maximum genus. A Xuong tree is a spanning tree such that, in the remaining graph, the number of connected components with an odd number of edges is as small as possible. A Xuong tree and an associated maximum-genus embedding can be found in polynomial time.<sup class="reference" id="cite_ref-4">[4]</sup>
</p>
<h2><span class="mw-headline" id="Definitions">Definitions</span><span class="mw-editsection"></span></h2>
<p>A tree is a connected undirected graph with no cycles. It is a spanning tree of a graph <i>G</i> if it spans <i>G</i> (that is, it includes every vertex of <i>G</i>) and is a subgraph of <i>G</i> (every edge in the tree belongs to <i>G</i>). A spanning tree of a connected graph <i>G</i> can also be defined as a maximal set of edges of <i>G</i> that contains no cycle, or as a minimal set of edges that connect all vertices.
</p>
<h3><span class="mw-headline" id="Fundamental_cycles">Fundamental cycles</span><span class="mw-editsection"></span></h3>
<p>Adding just one edge to a spanning tree will create a cycle; such a cycle is called a <b>fundamental cycle</b> with respect to that tree. There is a distinct fundamental cycle for each edge not in the spanning tree; thus, there is a one-to-one correspondence between fundamental cycles and  edges not in the spanning tree.  For a connected graph with <i>V</i> vertices, any spanning tree will have <i>V</i> − 1 edges, and thus, a graph of <i>E</i> edges and one of its spanning trees will have <i>E</i> − <i>V</i> + 1 fundamental cycles (The number of edges subtracted by number of edges included in a spanning tree; giving the number of edges not included in the spanning tree). For any given spanning tree the set of all <i>E</i> − <i>V</i> + 1 fundamental cycles forms a cycle basis, i.e., a basis for the cycle space.<sup class="reference" id="cite_ref-5">[5]</sup>
</p>
<h3><span class="mw-headline" id="Fundamental_cutsets">Fundamental cutsets</span><span class="mw-editsection"></span></h3>
<p>Dual to the notion of a fundamental cycle is the notion of a <b>fundamental cutset</b> with respect to a given spanning tree. By deleting just one edge of the spanning tree, the vertices are partitioned into two disjoint sets. The fundamental cutset is defined as the set of edges that must be removed from the graph <i>G</i> to accomplish the same partition. Thus, each spanning tree defines a set of <i>V</i> − 1 fundamental cutsets, one for each edge of the spanning tree.<sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>The duality between fundamental cutsets and fundamental cycles is established by noting that cycle edges not in the spanning tree can only appear in the cutsets of the other edges in the cycle; and <i>vice versa</i>: edges in a cutset can only appear in those cycles containing the edge corresponding to the cutset. This duality can also be expressed using the theory of matroids, according to which a spanning tree is a base of the graphic matroid, a fundamental cycle is the unique circuit within the set formed by adding one element to the base, and fundamental cutsets are defined in the same way from the dual matroid.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h3><span class="mw-headline" id="Spanning_forests">Spanning forests</span><span class="mw-editsection"></span></h3>
<p>A spanning forest in a graph is a subgraph that is a forest with an additional requirement.  There are two incompatible requirements in use, of which one is relatively rare.
</p>
<ul><li>Almost all graph theory books and articles define a spanning forest as a forest that spans all of the vertices, meaning only that each vertex of the graph is a vertex in the forest. A connected graph may have a disconnected spanning forest, such as the forest with no edges, in which each vertex forms a single-vertex tree.<sup class="reference" id="cite_ref-pearls_8-0">[8]</sup><sup class="reference" id="cite_ref-9">[9]</sup></li></ul>
<ul><li>A few graph theory authors define a spanning forest to be a maximal acyclic subgraph of the given graph, or equivalently a subgraph consisting of a spanning tree in each connected component of the graph.<sup class="reference" id="cite_ref-10">[10]</sup></li></ul>
<p>To avoid confusion between these two definitions, Gross &amp; Yellen (2005) suggest the term "full spanning forest" for a spanning forest with the same number of components as the given graph (i.e., a maximal forest), while Bondy &amp; Murty (2008) instead call this kind of forest a "maximal spanning forest" (which is redundant, as a maximal forest necessarily contains every vertex).<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<h2><span class="mw-headline" id="Counting_spanning_trees">Counting spanning trees</span><span class="mw-editsection"></span></h2>

<p>The number <i>t</i>(<i>G</i>) of spanning trees of a connected graph is a well-studied invariant.
</p>
<h3><span class="mw-headline" id="In_specific_graphs">In specific graphs</span><span class="mw-editsection"></span></h3>
<p>In some cases, it is easy to calculate <i>t</i>(<i>G</i>) directly:
</p>
<ul><li>If <i>G</i> is itself a tree, then <span class="texhtml"><i>t</i>(<i>G</i>) = 1</span>.</li>
<li>When <i>G</i> is the cycle graph <i>C<sub>n</sub></i> with <i>n</i> vertices, then <span class="texhtml"><i>t</i>(<i>G</i>) = <i>n</i></span>.</li>
<li>For a complete graph  with <i>n</i> vertices, Cayley's formula<sup class="reference" id="cite_ref-12">[12]</sup> gives the number of spanning trees as <span class="texhtml"><i>n</i><sup><i>n</i> − 2</sup></span>.</li>
<li>If <i>G</i> is the complete bipartite graph <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle K_{p,q}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>K</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>,</mo>
<mi>q</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle K_{p,q}}</annotation>
</semantics>
</math></span><img alt="K_{{p,q}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/02b81315083e992bb78dce593d13f84354e8df9d" style="vertical-align: -1.005ex; width:4.246ex; height:2.843ex;"/></span>,then <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle t(G)=p^{q-1}q^{p-1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>t</mi>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<msup>
<mi>p</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>q</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle t(G)=p^{q-1}q^{p-1}}</annotation>
</semantics>
</math></span><img alt="t(G)=p^{{q-1}}q^{{p-1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d98e65a190ab58a9626676f602f032d4b66d9a56" style="vertical-align: -0.838ex; width:16.072ex; height:3.176ex;"/></span>.<sup class="reference" id="cite_ref-pearls_8-1">[8]</sup></li>
<li>For the <i>n</i>-dimensional hypercube graph <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{n}}</annotation>
</semantics>
</math></span><img alt="Q_{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/503d0af3998f76cd4eaf8b3cc5e8834e254cb71b" style="vertical-align: -0.671ex; width:3.057ex; height:2.509ex;"/></span>,<sup class="reference" id="cite_ref-13">[13]</sup> the number of spanning trees is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle t(G)=2^{2^{n}-n-1}\prod _{k=2}^{n}k^{n \choose k}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>t</mi>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">)</mo>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msup>
<munderover>
<mo>∏<!-- ∏ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</munderover>
<msup>
<mi>k</mi>
<mrow class="MJX-TeXAtom-ORD">
<mrow>
<mrow class="MJX-TeXAtom-OPEN">
<mo maxsize="1.2em" minsize="1.2em">(</mo>
</mrow>
<mfrac linethickness="0">
<mi>n</mi>
<mi>k</mi>
</mfrac>
<mrow class="MJX-TeXAtom-CLOSE">
<mo maxsize="1.2em" minsize="1.2em">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle t(G)=2^{2^{n}-n-1}\prod _{k=2}^{n}k^{n \choose k}}</annotation>
</semantics>
</math></span><img alt="t(G)=2^{{2^{n}-n-1}}\prod _{{k=2}}^{n}k^{{{n \choose k}}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2d1bcdf70d9a4229afcf3e4e61a9bec9ac6c4fdd" style="vertical-align: -3.005ex; width:23.071ex; height:6.843ex;"/></span>.</li></ul>
<h3><span class="mw-headline" id="In_arbitrary_graphs">In arbitrary graphs</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>More generally, for any graph <i>G</i>, the number <i>t</i>(<i>G</i>) can be calculated in polynomial time as the determinant of a matrix derived from the graph,
using Kirchhoff's matrix-tree theorem.<sup class="reference" id="cite_ref-14">[14]</sup>
</p><p>Specifically, to compute <i>t</i>(<i>G</i>), one constructs the Laplacian matrix of the graph, a square matrix in which the rows and columns are both indexed by the vertices of <i>G</i>. The entry in row <i>i</i> and column <i>j</i> is one of three values:
</p>
<ul><li>The degree of vertex <i>i</i>, if <i>i</i> = <i>j</i>,</li>
<li>−1, if vertices <i>i</i> and <i>j</i> are adjacent, or</li>
<li>0, if vertices <i>i</i> and <i>j</i> are different from each other but not adjacent.</li></ul>
<p>The resulting matrix is singular, so its determinant is zero. However, deleting the row and column for an arbitrarily chosen vertex leads to a smaller matrix whose determinant is exactly <i>t</i>(<i>G</i>).
</p>
<h3><span class="mw-headline" id="Deletion-contraction">Deletion-contraction</span><span class="mw-editsection"></span></h3>
<p>If <i>G</i> is a graph or multigraph and <i>e</i> is an arbitrary edge of <i>G</i>, then the number <i>t</i>(<i>G</i>) of spanning trees of <i>G</i> satisfies the <i>deletion-contraction recurrence</i>
<i>t</i>(<i>G</i>) = <i>t</i>(<i>G</i> − <i>e</i>) + <i>t</i>(<i>G</i>/<i>e</i>), where <i>G</i> − <i>e</i> is the multigraph obtained by deleting <i>e</i>
and <i>G</i>/<i>e</i> is the contraction of <i>G</i> by <i>e</i>.<sup class="reference" id="cite_ref-15">[15]</sup> The term <i>t</i>(<i>G</i> − <i>e</i>) in this formula counts the spanning trees of <i>G</i> that do not use edge <i>e</i>, and the term <i>t</i>(<i>G</i>/<i>e</i>) counts the spanning trees of <i>G</i> that use <i>e</i>.
</p><p>In this formula, if the given graph <i>G</i> is a multigraph, or if a contraction causes two vertices to be connected to each other by multiple edges,
then the redundant edges should not be removed, as that would lead to the wrong total. For instance a bond graph connecting two vertices by <i>k</i> edges has <i>k</i> different spanning trees, each consisting of a single one of these edges.
</p>
<h3><span class="mw-headline" id="Tutte_polynomial">Tutte polynomial</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The Tutte polynomial of a graph can be defined as a sum, over the spanning trees of the graph, of terms computed from the "internal activity" and "external activity" of the tree. Its value at the arguments (1,1) is the number of spanning trees or, in a disconnected graph, the number of maximal spanning forests.<sup class="reference" id="cite_ref-16">[16]</sup>
</p><p>The Tutte polynomial can also be computed using a deletion-contraction recurrence, but its computational complexity is high: for many values of its arguments, computing it exactly is #P-complete, and it is also hard to approximate with a guaranteed approximation ratio. The point (1,1), at which it can be evaluated using Kirchhoff's theorem, is one of the few exceptions.<sup class="reference" id="cite_ref-17">[17]</sup>
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Construction">Construction</span><span class="mw-editsection"></span></h3>
<p>A single spanning tree of a graph can be found in linear time by either depth-first search or breadth-first search. Both of these algorithms explore the given graph, starting from an arbitrary vertex <i>v</i>, by looping through the neighbors of the vertices they discover and adding each unexplored neighbor to a data structure to be explored later. They differ in whether this data structure is a  stack (in the case of depth-first search) or a  queue (in the case of breadth-first search). In either case, one can form a spanning tree by connecting each vertex, other than the root vertex <i>v</i>, to the vertex from which it was discovered. This tree is known as a depth-first search tree or a breadth-first search tree according to the graph exploration algorithm used to construct it.<sup class="reference" id="cite_ref-18">[18]</sup> Depth-first search trees are a special case of a class of spanning trees called Trémaux trees, named after the 19th-century discoverer of depth-first search.<sup class="reference" id="cite_ref-19">[19]</sup>
</p><p>Spanning trees are important in parallel and distributed computing, as a way of maintaining communications between a set of processors; see for instance the Spanning Tree Protocol used by OSI link layer devices or the Shout (protocol) for distributed computing. However, the depth-first and breadth-first methods for constructing spanning trees on sequential computers are not well suited for parallel and distributed computers.<sup class="reference" id="cite_ref-20">[20]</sup> Instead, researchers have devised several more specialized algorithms for finding spanning trees in these models of computation.<sup class="reference" id="cite_ref-21">[21]</sup>
</p>
<h3><span class="mw-headline" id="Optimization">Optimization</span><span class="mw-editsection"></span></h3>
<p>In certain fields of graph theory it is often useful to find a minimum spanning tree of a weighted graph. Other optimization problems on spanning trees have also been studied, including the maximum spanning tree, the minimum tree that spans at least k vertices, the spanning tree with the fewest edges per vertex, the spanning tree with the largest number of leaves, the spanning tree with the fewest leaves (closely related to the Hamiltonian path problem), the minimum diameter spanning tree, and the minimum dilation spanning tree.<sup class="reference" id="cite_ref-sts_22-0">[22]</sup><sup class="reference" id="cite_ref-23">[23]</sup>
</p><p>Optimal spanning tree problems have also been studied for finite sets of points in a geometric space such as the Euclidean plane. For such an input, a spanning tree is again a tree that has as its vertices the given points. The quality of the tree is measured in the same way as in a graph, using the Euclidean distance between pairs of points as the weight for each edge. Thus, for instance, a Euclidean minimum spanning tree is the same as a graph minimum spanning tree in a complete graph with Euclidean edge weights. However, it is not necessary to construct this graph in order to solve the optimization problem; the Euclidean minimum spanning tree problem, for instance, can be solved more efficiently in <i>O</i>(<i>n</i> log <i>n</i>) time by constructing the Delaunay triangulation and then applying a linear time planar graph minimum spanning tree algorithm to the resulting triangulation.<sup class="reference" id="cite_ref-sts_22-1">[22]</sup>
</p>
<h3><span class="mw-headline" id="Randomization">Randomization</span><span class="mw-editsection"></span></h3>
<p>A spanning tree chosen randomly from among all the spanning trees with equal probability is called a uniform spanning tree. Wilson's algorithm can be used to generate uniform spanning trees in polynomial time by a process of taking a random walk on the given graph and erasing the cycles created by this walk.<sup class="reference" id="cite_ref-24">[24]</sup>
</p><p>An alternative model for generating spanning trees randomly but not uniformly is the random minimal spanning tree. In this model, the edges of the graph are assigned random weights and then the minimum spanning tree of the weighted graph is constructed.<sup class="reference" id="cite_ref-25">[25]</sup>
</p>
<h3><span class="mw-headline" id="Enumeration">Enumeration</span><span class="mw-editsection"></span></h3>
<p>Because a graph may have exponentially many spanning trees, it is not possible to list them all in polynomial time. However, algorithms are known for listing all spanning trees in polynomial time per tree.<sup class="reference" id="cite_ref-26">[26]</sup>
</p>
<h2><span class="mw-headline" id="In_infinite_graphs">In infinite graphs</span><span class="mw-editsection"></span></h2>
<p>Every finite connected graph has a spanning tree. However, for infinite connected graphs, the existence of spanning trees is equivalent to the axiom of choice. An infinite graph is connected if each pair of its vertices forms the pair of endpoints of a finite path. As with finite graphs, a tree is a connected graph with no finite cycles, and a spanning tree can be defined either as a maximal acyclic set of edges or as a tree that contains every vertex.<sup class="reference" id="cite_ref-serre_27-0">[27]</sup>
</p><p>The trees within a graph may be partially ordered by their subgraph relation, and any infinite chain in this partial order has an upper bound (the union of the trees in the chain). Zorn's lemma, one of many equivalent statements to the axiom of choice, requires that a partial order in which all chains are upper bounded have a maximal element; in the partial order on the trees of the graph, this maximal element must be a spanning tree. Therefore, if Zorn's lemma is assumed, every infinite connected graph has a spanning tree.<sup class="reference" id="cite_ref-serre_27-1">[27]</sup>
</p><p>In the other direction, given a family of sets, it is possible to construct an infinite graph such that every spanning tree of the graph corresponds to a choice function of the family of sets. Therefore,
if every infinite connected graph has a spanning tree, then the axiom of choice is true.<sup class="reference" id="cite_ref-28">[28]</sup>
</p>
<h2><span class="mw-headline" id="In_directed_multigraphs">In directed multigraphs</span><span class="mw-editsection"></span></h2>
<p>The idea of a spanning tree can be generalized to directed multigraphs.<sup class="reference" id="cite_ref-Levine09_29-0">[29]</sup> Given a vertex <i>v</i> on a directed multigraph <i>G</i>, an <i>oriented spanning tree</i> <i>T</i> rooted at <i>v</i> is an acyclic subgraph of <i>G</i> in which every vertex other than <i>v</i> has outdegree 1. This definition is only satisfied when the "branches" of <i>T</i> point towards <i>v</i>.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Flooding algorithm</li>
<li>Good spanning tree – Spanning tree for embedded planar graph</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>

<!-- 
NewPP limit report
Parsed by mw2378
Cached time: 20221221145133
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.396 seconds
Real time usage: 0.554 seconds
Preprocessor visited node count: 2156/1000000
Post‐expand include size: 60350/2097152 bytes
Template argument size: 842/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 96979/5000000 bytes
Lua time usage: 0.246/10.000 seconds
Lua memory usage: 8128350/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  418.158      1 -total
 53.50%  223.706      1 Template:Reflist
 23.36%   97.682     26 Template:Citation
 19.85%   83.019      3 Template:Cite_web
 13.35%   55.827      1 Template:Short_description
 13.06%   54.599      1 Template:Authority_control
 10.32%   43.168      6 Template:Harvtxt
  6.28%   26.269      2 Template:Pagetype
  4.65%   19.462      6 Template:Main_other
  4.52%   18.899      1 Template:About
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:455770-0!canonical and timestamp 20221221145133 and revision id 1121900925.
 -->
</div></body>
</html>