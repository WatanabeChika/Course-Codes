<!DOCTYPE html>
<html>
<head>
<title>leftist_tree</title>
</head>
<body>
<div class="mw-parser-output">
<p>In computer science, a <b>leftist tree</b> or <b>leftist heap</b> is a priority queue implemented with a variant of a binary heap. Every node x has an <i>s-value</i> which is the distance to the nearest leaf in subtree rooted at x.<sup class="reference" id="cite_ref-:0_1-0">[1]</sup> In contrast to a <i>binary heap</i>, a leftist tree attempts to be very unbalanced. In addition to the heap property, leftist trees are maintained so the right descendant of each node has the lower s-value.
</p><p>The height-biased leftist tree was invented by Clark Allan Crane.<sup class="reference" id="cite_ref-Crane1972_2-0">[2]</sup> The name comes from the fact that the left subtree is usually taller than the right subtree.
</p><p>A leftist tree is a mergeable heap.  When inserting a new node into a tree, a new one-node tree is created and merged into the existing tree. To delete an item, it is replaced by the merge of its left and right sub-trees. Both these operations take O(log <i>n</i>) time. For insertions, this is slower than Fibonacci heaps, which support insertion in O(1) (constant) amortized time, and O(log <i>n</i>) worst-case.
</p><p>Leftist trees are advantageous because of their ability to merge quickly, compared to binary heaps which take Θ(<i>n</i>). In almost all cases, the merging of skew heaps has better performance. However merging leftist heaps has worst-case O(log <i>n</i>) complexity while merging skew heaps has only amortized O(log <i>n</i>) complexity.
</p>

<h2><span class="mw-headline" id="Bias">Bias</span><span class="mw-editsection"></span></h2>
<p>The usual leftist tree is a <i>height-biased</i> leftist tree.<sup class="reference" id="cite_ref-Crane1972_2-1">[2]</sup> However, other biases can exist, such as in the <i>weight-biased</i> leftist tree.<sup class="reference" id="cite_ref-Cho96_3-0">[3]</sup>
</p>
<h2><span class="mw-headline" id="S-value">S-value</span><span class="mw-editsection"></span></h2>

<p>The <b>s-value</b> (or <b>rank</b>) of a node is the distance from that node to the nearest empty position in the subtree rooted at that node.  Put another way, the s-value of a <code>null</code> child is implicitly zero.  Other nodes have an s-value equal to one more the minimum of their children's s-values.  Thus, in the example at right, all nodes with at least one missing child have an s-value of 1, while node 4 has an s-value of 2, since its right child (8) has an s-value of 1.  (In some descriptions, the s-value of null children is assumed to be −1.<sup class="reference" id="cite_ref-4">[4]</sup>)
</p><p>Knowing the shortest path to the nearest missing leaf in the subtree rooted at <i>x</i> is exactly of <i>s</i>(<i>x</i>), every node at depth <i>s</i>(<i>x</i>)−1 or less has exactly 2 children since <i>s</i>(<i>x</i>) would have been less if not. Meaning that the size of the tree rooted at <i>x</i> is at least <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{s(x)}-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>s</mi>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{s(x)}-1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2^{s(x)}-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1c8b9044268fd9d38024524af84841e9febf89ed" style="vertical-align: -0.505ex; width:8.388ex; height:3.009ex;"/></span>. Thus, <i>s</i>(<i>x</i>) is at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \log {(m+1)}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \log {(m+1)}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \log {(m+1)}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/efe13c4efa2d3a001eb944afd318c04ff38de0c4" style="vertical-align: -0.838ex; width:11.211ex; height:2.843ex;"/></span>, <i>m</i> being the number of nodes of the subtree rooted at <i>x</i>.<sup class="reference" id="cite_ref-:0_1-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Operations_on_a_height_biased_leftist_tree">Operations on a height biased leftist tree</span><span class="mw-editsection"></span></h2>
<p>Most operations on a Height Biased Leftist Tree are done using the merge operation.<sup class="reference" id="cite_ref-:0_1-2">[1]</sup>
</p>
<h3><span class="mw-headline" id="Merging_two_Min_HBLTs">Merging two Min HBLTs</span><span class="mw-editsection"></span></h3>
<p>The merge operation takes two Min HBLTs as input and returns a Min HBLT containing all the nodes in the original Min HBLTs put together.
</p><p>If either of A or B is empty, the merge returns the other one.
</p><p>In case of Min HBLTs, assume we have two trees rooted at A and B where A.key <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \leq }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo>≤<!-- ≤ --></mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \leq }</annotation>
</semantics>
</math></span><img alt="\leq " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/440568a09c3bfdf0e1278bfa79eb137c04e94035" style="vertical-align: -0.505ex; width:1.808ex; height:2.176ex;"/></span> B.key. Otherwise we can swap A and B so that the condition above holds.
</p><p>The merge is done recursively by merging B with A's right subtree. This might change the S-value of A's right subtree. To maintain the leftist tree property, after each merge is done, we check if the S-value of right subtree became bigger than the S-value of left subtree during the recursive merge calls. If so, we swap the right and left subtrees (If one child is missing, it should be the right one).
</p><p>Since we assumed that A's root is greater than B's, the heap property is also maintained.
</p>
<h4><span class="mw-headline" id="Pseudocode_for_merging_two_min_height_biased_leftist_trees">Pseudocode for merging two min height biased leftist trees</span><span class="mw-editsection"></span></h4>
<pre>MERGE(A, B)
    <b>if</b> A = null <b>return</b> B
    <b>if</b> B = null <b>return</b> A
    <b>if</b> A.key &gt; B.key <b>return</b> MERGE(B, A)
    A.right := MERGE (A.right, B) <i>// the result cannot be null since B is non-null</i>
    <b>if</b> A.left = null <b>then</b>
        SWAP(A.left, A.right)
        A.s_value := 1 <i>// since the right subtree is null, the shortest path to a descendant leaf from node A is 1</i>
        <b>return</b> A
    <b>if</b> A.right.s_value &gt; A.left.s_value <b>then</b>
        SWAP (A.right, A.left)
    A.s_value := A.right.s_value + 1
    <b>return</b> A
</pre>
<h4><span class="mw-headline" id="Java_code_for_merging_two_min_height_biased_leftist_trees">Java code for merging two min height biased leftist trees</span><span class="mw-editsection"></span></h4>

<h4><span class="mw-headline" id="Haskell_code_for_merging_two_min_height_biased_leftist_trees">Haskell code for merging two min height biased leftist trees</span><span class="mw-editsection"></span></h4>

<h4><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h4><p>
An example of how the merge operation in a leftist tree works is depicted. The boxes represent each merge call.</p><ul class="gallery mw-gallery-packed">
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
</ul><p>When the recursion unwinds, we swap left and right children if x.right.s_value &gt; x.left.s_value for every node x. In this case we swapped the subtrees rooted at nodes with keys 7 and 10.
</p><h3><span class="mw-headline" id="Insertion_into_a_Min_HBLT">Insertion into a Min HBLT</span><span class="mw-editsection"></span></h3>
<p>Insertion is done using the merge operation. An insertion of a node into an already existing
</p><p>Min HBLT, creates a HBLT tree of size one with that node and merges it with the existing tree.
</p>
<pre>INSERT (<i>A</i>, <i>x</i>)
    <i>B</i> := CREATE_TREE(<i>x</i>)
    <b>return</b> MERGE(<i>A</i>, <i>B</i>)
</pre>
<h3><span class="mw-headline" id="Deletion_of_Min_element_from_Min_HBLT">Deletion of Min element from Min HBLT</span><span class="mw-editsection"></span></h3>
<p>The Min element in a Min HBLT is the root. Thus, in order to delete the Min, the root is deleted and its subtrees are merged to form the new Min HBLT.
</p>
<pre>DELETE_MIN(<i>A</i>)
    <i>x</i> := <i>A</i>.key
    <i>A</i> := MERGE (<i>A</i>.right, <i>A</i>.left)
    <b>return</b> <i>x</i>
</pre>
<h3><span class="mw-headline" id="Initializing_a_height_biased_leftist_tree">Initializing a height biased leftist tree</span><span class="mw-editsection"></span></h3>

<p>Initializing a height biased leftist tree is primarily done in one of two ways.  The first is to merge each node one at a time into one HBLT.  This process is inefficient and takes O(<i>nlogn</i>) time.  The other approach is to use a queue to store each node and resulting tree.  The first two items in the queue are removed, merged, and placed back into the queue.  This can initialize a HBLT in O(<i>n</i>) time.  This approach is detailed in the three diagrams supplied.  A min height biased leftist tree is shown.
</p><p>To initialize a min HBLT, place each element to be added to the tree into a queue.  In the example (see Part 1 to the left), the set of numbers [4, 8, 10, 9, 1, 3, 5, 6, 11] are initialized.  Each line of the diagram represents another cycle of the algorithm, depicting the contents of the queue.  The first five steps are easy to follow.  Notice that the freshly created HBLT is added to the end of the queue.  In the fifth step, the first occurrence of an s-value greater than 1 occurs.  The sixth step shows two trees merged with each other, with predictable results.
</p>


<p>In part 2 a slightly more complex merge happens.  The tree with the lower value (tree x) has a right child, so merge must be called again on the subtree rooted by tree x's right child and the other tree.  After the merge with the subtree, the resulting tree is put back into tree x.  The s-value of the right child (s=2) is now greater than the s-value of the left child (s=1), so they must be swapped.  The s-value of the root node 4 is also now 2.
</p>


<p>Part 3 is the most complex.  Here, we recursively call merge twice (each time with the right child 's subtree that is not grayed out).  This uses the same process described for part 2.
</p>

<h3><span class="mw-headline" id="Deletion_of_an_arbitrary_element_from_a_Min_HBLT">Deletion of an arbitrary element from a Min HBLT</span><span class="mw-editsection"></span></h3>

<p>If we have a pointer to a node x in a Min HBLT, we can delete it as follows: Replace the node x with the result of merging its two subtrees and update the s-values of the nodes on the path from x to the root, swapping the right and left subtrees if necessary to maintain the leftist tree property.
</p><p>The upward traversal is continued until either we hit the root or the s-values does not change. Since we are deleting an element, the S-values on the path traversed cannot be increased. Every node that is already the right child of its parent and causes its parent's s-value to be decreased, will remain on the right. Every node that is its parent's left child and causes the parent's s-value to be decreased has to be swapped with its right sibling if the s-value becomes lower than the current s-value of the right child.
</p><p>Each node needs to have a pointer to its parent, so that we can traverse the path to the root updating the s-values.
</p><p>When the traversal ends at some node y, the nodes traversed all lie on the rightmost path rooted at node y. An example is shown below. It follows that the number of nodes traversed is at most log(m), m being the size of the subtree rooted at y. Thus, this operation also takes O(lg m) to perform.
</p>
<h2><span id="Weight_biased_leftist_tree.5B5.5D"></span><span class="mw-headline" id="Weight_biased_leftist_tree[5]">Weight biased leftist tree<sup class="reference" id="cite_ref-5">[5]</sup></span><span class="mw-editsection"></span></h2>
<p>Leftist trees can also be weight biased. In this case, instead of storing s-values in node x, we store an attribute w(<i>x</i>) denoting the number of nodes in the subtree rooted at <var style="padding-right: 1px;">x</var>:
</p><p>w(<i>x</i>) = w(<i>x</i>.right) + w(<i>x</i>.left) + 1
</p><p>WBLTs ensure w(x.left) ≥ w(x.right) for all internal nodes x. WBLT operations ensure this invariant by swapping the children of a node when the right subtree outgrows the left one, just as in HBLT operations.
</p>
<h3><span class="mw-headline" id="Merging_two_Min_WBLTs">Merging two Min WBLTs</span><span class="mw-editsection"></span></h3>
<p>The merge operation in WBLTs can be done using a single top to bottom traversal since the number of nodes in the subtrees are known prior to recursive call to merge. Thus, we can swap left and right subtrees if the total number of nodes in the right subtree and the tree to be merged is bigger than the number of nodes in the left subtree. This allows the operations be completed in a single path and so improves the time complexity of the operations by a constant factor.
</p><p>
The merge operation is depicted in the graph below.</p><ul class="gallery mw-gallery-packed">
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
<li class="gallerybox" style="width: 362px"></li>
</ul>
<h3><span class="mw-headline" id="Other_operations_on_WBLT">Other operations on WBLT</span><span class="mw-editsection"></span></h3>

<p>Insertions and deletion of the min element can be done in the same as for HBLTs using the merge operation.
</p><p>Although WBLTs outperform HBLTs in merge, insertion and deletion of the Min key by a constant factor, the <i>O</i>(log <i>n</i>) bound is not guaranteed when deleting an arbitrary element from WBLTs, since θ(<i>n</i>) nodes have to be traversed.
</p><p>If this was an HBLT, then deleting the leaf node with key 60 would take <i>O</i>(1) time and updating the s-values is not needed since the length of rightmost path for all the nodes does not change.
</p><p>But in an WBLT tree, we have to update the weight of each node back to the root, which takes <i>O</i>(<i>n</i>) worst case.
</p>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"></span></h2>
<p>Several variations on the basic leftist tree exist, which make only minor changes to the basic algorithm:
</p>
<ul><li>The choice of the left child as the taller one is arbitrary;  a "rightist tree" would work just as well.</li>
<li>It is possible to avoid swapping children, but instead record <i>which</i> child is the tallest (in, for example, the least significant bit of the s-value) and use that in the merge operation.</li>
<li>The s-value used to decide which side to merge with could use a metric other than height.  For example, weight (number of nodes) could be used.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFRobert_E._Tarjan1983">Robert E. Tarjan (1983). <i>Data Structures and Network Algorithms</i>. SIAM. pp. 38–42. ISBN <bdi>978-0-89871-187-5</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Data+Structures+and+Network+Algorithms&amp;rft.pages=38-42&amp;rft.pub=SIAM&amp;rft.date=1983&amp;rft.isbn=978-0-89871-187-5&amp;rft.au=Robert+E.+Tarjan&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALeftist+tree"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFDinesh_P._MehtaSartaj_Sahni2004">Dinesh P. Mehta; Sartaj Sahni (28 October 2004). "Chapter 5: Leftist trees". <i>Handbook of Data Structures and Applications</i>. CRC Press. ISBN <bdi>978-1-4200-3517-9</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Chapter+5%3A+Leftist+trees&amp;rft.btitle=Handbook+of+Data+Structures+and+Applications&amp;rft.pub=CRC+Press&amp;rft.date=2004-10-28&amp;rft.isbn=978-1-4200-3517-9&amp;rft.au=Dinesh+P.+Mehta&amp;rft.au=Sartaj+Sahni&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DfQVZy1zcpJkC%26pg%3DSA5-PA1%26lpg%3DSA5-PA1&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALeftist+tree"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Leftist Trees, Sartaj Sahni</li></ul>
<!-- 
NewPP limit report
Parsed by mw2313
Cached time: 20221215225132
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.187 seconds
Real time usage: 0.709 seconds
Preprocessor visited node count: 603/1000000
Post‐expand include size: 13070/2097152 bytes
Template argument size: 675/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 42925/5000000 bytes
Lua time usage: 0.080/10.000 seconds
Lua memory usage: 4504585/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  627.479      1 -total
 16.19%  101.602      1 Template:Reflist
 11.22%   70.405      2 Template:Cite_web
  8.62%   54.102      1 Template:Short_description
  4.49%   28.205      2 Template:Pagetype
  2.57%   16.127      3 Template:Main_other
  2.27%   14.214      1 Template:SDcat
  1.48%    9.280      2 Template:Cite_book
  1.41%    8.878      2 Template:Citation
  0.81%    5.099      1 Template:Cite_journal
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2754256-0!canonical and timestamp 20221215225131 and revision id 1112342109.
 -->
</div></body>
</html>