<!DOCTYPE html>
<html>
<head>
<title>optimal</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>


<p><b>Mathematical optimization</b> (alternatively spelled <i>optimisation</i>) or <b>mathematical programming</b> is the selection of a best element, with regard to some criterion, from some set of available alternatives.<sup class="reference" id="cite_ref-1">[1]</sup> It is generally divided into two subfields: discrete optimization and continuous optimization. Optimization problems of sorts arise in all quantitative disciplines from computer science and engineering<sup class="reference" id="cite_ref-edo2021_2-0">[2]</sup> to operations research and economics, and the development of solution methods has been of interest in mathematics for centuries.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>In the more general approach, an optimization problem consists of maximizing or minimizing a real function by systematically choosing input values from within an allowed set and computing the value of the function. The generalization of optimization theory and techniques to other formulations constitutes a large area of applied mathematics. More generally, optimization includes finding "best available" values of some objective function given a defined domain (or input), including a variety of different types of objective functions and different types of domains.
</p>

<h2><span class="mw-headline" id="Optimization_problems">Optimization problems</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Optimization problems can be divided into two categories, depending on whether the variables are continuous or discrete: 
</p>
<ul><li>An optimization problem with discrete variables is known as a <i>discrete optimization</i>, in which an object such as an integer, permutation or graph must be found from a countable set.</li>
<li>A problem with continuous variables is known as a <i>continuous optimization</i>, in which an optimal value from a continuous function must be found. They can include constrained problems and multimodal problems.</li></ul>
<p>An optimization problem can be represented in the following way:
</p>
<dl><dd><i>Given:</i> a function <span class="texhtml"><i>f</i> : <i>A</i> → ℝ</span> from some set <span class="texhtml mvar" style="font-style:italic;">A</span> to the real numbers</dd>
<dd><i>Sought:</i> an element <span class="texhtml"><b>x</b><sub>0</sub> ∈ <i>A</i></span> such that <span class="texhtml"><i>f</i>(<b>x</b><sub>0</sub>) ≤ <i>f</i>(<b>x</b>)</span> for all <span class="texhtml"><b>x</b> ∈ <i>A</i></span> ("minimization") or such that <span class="texhtml"><i>f</i>(<b>x</b><sub>0</sub>) ≥ <i>f</i>(<b>x</b>)</span> for all <span class="texhtml"><b>x</b> ∈ <i>A</i></span> ("maximization").</dd></dl>
<p>Such a formulation is called an <b>optimization problem</b> or a <b>mathematical programming problem</b> (a term not directly related to computer programming, but still in use for example in linear programming – see History below). Many real-world and theoretical problems may be modeled in this general framework.
</p><p>Since the following is valid
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(\mathbf {x} _{0})\geq f(\mathbf {x} )\Leftrightarrow -f(\mathbf {x} _{0})\leq -f(\mathbf {x} ),}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>≥<!-- ≥ --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
<mo stretchy="false">⇔<!-- ⇔ --></mo>
<mo>−<!-- − --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>≤<!-- ≤ --></mo>
<mo>−<!-- − --></mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo stretchy="false">)</mo>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(\mathbf {x} _{0})\geq f(\mathbf {x} )\Leftrightarrow -f(\mathbf {x} _{0})\leq -f(\mathbf {x} ),}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(\mathbf {x} _{0})\geq f(\mathbf {x} )\Leftrightarrow -f(\mathbf {x} _{0})\leq -f(\mathbf {x} ),}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b16621e3e03e9543826d663fced8f3f167561a0b" style="vertical-align: -0.838ex; width:34.178ex; height:2.843ex;"/></span></dd></dl>
<p>it suffices to solve only minimization problems. However, the opposite perspective of considering only maximization problems would be valid, too.
</p><p>Problems formulated using this technique in the fields of physics may refer to the technique as <i>energy minimization</i>, speaking of the value of the function <span class="texhtml mvar" style="font-style:italic;">f</span> as representing the energy of the system being modeled. In machine learning, it is always necessary to continuously evaluate the quality of a data model by using a cost function where a minimum implies a set of possibly optimal parameters with an optimal (lowest) error.
</p><p>Typically, <span class="texhtml mvar" style="font-style:italic;">A</span> is some subset of the Euclidean space <span class="texhtml">ℝ<sup><i>n</i></sup></span>, often specified by a set of <i>constraints</i>, equalities or inequalities that the members of <span class="texhtml mvar" style="font-style:italic;">A</span> have to satisfy.  The domain <span class="texhtml mvar" style="font-style:italic;">A</span> of <span class="texhtml mvar" style="font-style:italic;">f</span> is called the <i>search space</i> or the <i>choice set</i>, while the elements of <span class="texhtml mvar" style="font-style:italic;">A</span> are called <i>candidate solutions</i> or <i>feasible solutions</i>.
</p><p>The function <span class="texhtml mvar" style="font-style:italic;">f</span> is called, variously, an <i>objective function</i>, a <i>loss function</i> or <i>cost function</i> (minimization),<sup class="reference" id="cite_ref-4">[4]</sup>  a <i>utility function</i> or <i>fitness function</i> (maximization), or, in certain fields, an <i>energy function</i> or <i>energy functional</i>. A feasible solution that minimizes (or maximizes, if that is the goal) the objective function is called an <i>optimal solution</i>.
</p><p>In mathematics, conventional optimization problems are usually stated in terms of minimization.
</p><p>A <i>local minimum</i> <span class="texhtml"><b>x</b>*</span> is defined as an element for which there exists some <span class="texhtml"><i>δ</i> &gt; 0</span> such that
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \forall \mathbf {x} \in A\;{\text{where}}\;\left\Vert \mathbf {x} -\mathbf {x} ^{\ast }\right\Vert \leq \delta ,\,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">∀<!-- ∀ --></mi>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo>∈<!-- ∈ --></mo>
<mi>A</mi>
<mspace width="thickmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>where</mtext>
</mrow>
<mspace width="thickmathspace"></mspace>
<mrow>
<mo symmetric="true">‖</mo>
<mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mo>−<!-- − --></mo>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="bold">x</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mo>∗<!-- ∗ --></mo>
</mrow>
</msup>
</mrow>
<mo symmetric="true">‖</mo>
</mrow>
<mo>≤<!-- ≤ --></mo>
<mi>δ<!-- δ --></mi>
<mo>,</mo>
<mspace width="thinmathspace"></mspace>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \forall \mathbf {x} \in A\;{\text{where}}\;\left\Vert \mathbf {x} -\mathbf {x} ^{\ast }\right\Vert \leq \delta ,\,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \forall \mathbf {x} \in A\;{\text{where}}\;\left\Vert \mathbf {x} -\mathbf {x} ^{\ast }\right\Vert \leq \delta ,\,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b2c45ce12a77abe61366d96dcffae4378f357976" style="vertical-align: -0.838ex; width:29.134ex; height:2.843ex;"/></span></dd></dl>
<p>the expression <span class="texhtml"><i>f</i>(<b>x</b>*) ≤ <i>f</i>(<b>x</b>)</span> holds;
</p><p>that is to say, on some region around <span class="texhtml"><b>x</b>*</span> all of the function values are greater than or equal to the value at that element. 
Local maxima are defined similarly.
</p><p>While a local minimum is at least as good as any nearby elements, a global minimum is at least as good as every feasible element.
Generally, unless the objective function is convex in a minimization problem, there may be several local minima.
In a convex problem, if there is a local minimum that is interior (not on the edge of the set of feasible elements), it is also the global minimum, but a nonconvex problem may have more than one local minimum not all of which need be global minima.
</p><p>A large number of algorithms proposed for solving the nonconvex problems – including the majority of commercially available solvers – are  not capable of making a distinction between locally optimal solutions and globally optimal solutions, and will treat the former as actual solutions to the original problem. Global optimization is the branch of applied mathematics and numerical analysis that is concerned with the development of deterministic algorithms that are capable of guaranteeing convergence in finite time to the actual optimal solution of a nonconvex problem.
</p>
<h2><span class="mw-headline" id="Notation">Notation</span><span class="mw-editsection"></span></h2>
<p>Optimization problems are often expressed with special notation. Here are some examples:
</p>
<h3><span class="mw-headline" id="Minimum_and_maximum_value_of_a_function">Minimum and maximum value of a function</span><span class="mw-editsection"></span></h3>
<p>Consider the following notation:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \min _{x\in \mathbb {R} }\;\left(x^{2}+1\right)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo form="prefix" movablelimits="true">min</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mrow>
</munder>
<mspace width="thickmathspace"></mspace>
<mrow>
<mo>(</mo>
<mrow>
<msup>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo>)</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \min _{x\in \mathbb {R} }\;\left(x^{2}+1\right)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \min _{x\in \mathbb {R} }\;\left(x^{2}+1\right)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e63529e0c09654712ebdefef0445a12017794b3b" style="vertical-align: -2.005ex; width:13.424ex; height:4.343ex;"/></span></dd></dl>
<p>This denotes the minimum value of the objective function <span class="texhtml"><i>x</i><sup>2</sup> + 1</span>, when choosing <span class="texhtml mvar" style="font-style:italic;">x</span> from the set of real numbers <span class="texhtml">ℝ</span>. The minimum value in this case is 1, occurring at <span class="texhtml">x = 0</span>.
</p><p>Similarly, the notation
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \max _{x\in \mathbb {R} }\;2x}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo form="prefix" movablelimits="true">max</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mrow>
</munder>
<mspace width="thickmathspace"></mspace>
<mn>2</mn>
<mi>x</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \max _{x\in \mathbb {R} }\;2x}</annotation>
</semantics>
</math></span><img alt="\max _{x\in \mathbb {R} }\;2x" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a128d2c279975694f4c98533554a03f500780804" style="vertical-align: -2.171ex; width:7.85ex; height:4.009ex;"/></span></dd></dl>
<p>asks for the maximum value of the objective function <span class="texhtml">2<i>x</i></span>, where <span class="texhtml mvar" style="font-style:italic;">x</span> may be any real number. In this case, there is no such maximum as the objective function is unbounded, so the answer is "infinity" or "undefined".
</p>
<h3><span class="mw-headline" id="Optimal_input_arguments">Optimal input arguments</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Consider the following notation:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\underset {x\in (-\infty ,-1]}{\operatorname {arg\,min} }}\;x^{2}+1,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<munder>
<mrow class="MJX-TeXAtom-OP MJX-fixedlimits">
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">r</mi>
<mi mathvariant="normal">g</mi>
<mspace width="thinmathspace"></mspace>
<mi mathvariant="normal">m</mi>
<mi mathvariant="normal">i</mi>
<mi mathvariant="normal">n</mi>
</mrow>
<mrow>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mo stretchy="false">(</mo>
<mo>−<!-- − --></mo>
<mi mathvariant="normal">∞<!-- ∞ --></mi>
<mo>,</mo>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</munder>
</mrow>
<mspace width="thickmathspace"></mspace>
<msup>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>1</mn>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\underset {x\in (-\infty ,-1]}{\operatorname {arg\,min} }}\;x^{2}+1,}</annotation>
</semantics>
</math></span><img alt="{\underset {x\in (-\infty ,-1]}{\operatorname {arg\,min} }}\;x^{2}+1," aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/39c071258fcecb43aaf25920b9833589bc35036c" style="vertical-align: -3.005ex; width:16.292ex; height:5.343ex;"/></span></dd></dl>
<p>or equivalently
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\underset {x}{\operatorname {arg\,min} }}\;x^{2}+1,\;{\text{subject to:}}\;x\in (-\infty ,-1].}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<munder>
<mrow class="MJX-TeXAtom-OP MJX-fixedlimits">
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">r</mi>
<mi mathvariant="normal">g</mi>
<mspace width="thinmathspace"></mspace>
<mi mathvariant="normal">m</mi>
<mi mathvariant="normal">i</mi>
<mi mathvariant="normal">n</mi>
</mrow>
<mi>x</mi>
</munder>
</mrow>
<mspace width="thickmathspace"></mspace>
<msup>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>+</mo>
<mn>1</mn>
<mo>,</mo>
<mspace width="thickmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>subject to:</mtext>
</mrow>
<mspace width="thickmathspace"></mspace>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mo stretchy="false">(</mo>
<mo>−<!-- − --></mo>
<mi mathvariant="normal">∞<!-- ∞ --></mi>
<mo>,</mo>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\underset {x}{\operatorname {arg\,min} }}\;x^{2}+1,\;{\text{subject to:}}\;x\in (-\infty ,-1].}</annotation>
</semantics>
</math></span><img alt="{\underset {x}{\operatorname {arg\,min} }}\;x^{2}+1,\;{\text{subject to:}}\;x\in (-\infty ,-1]." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a2ecc7504e271936684860c5d738740d0841edac" style="vertical-align: -2.338ex; width:41.837ex; height:4.676ex;"/></span></dd></dl>
<p>This represents the value (or values) of the argument <span class="texhtml mvar" style="font-style:italic;">x</span> in the interval <span class="texhtml">(−∞,−1]</span> that minimizes (or minimize) the objective function <span class="texhtml"><i>x</i><sup>2</sup> + 1</span> (the actual minimum value of that function is not what the problem asks for). In this case, the answer is <span class="texhtml"><i>x</i> = −1</span>, since <span class="texhtml"><i>x</i> = 0</span> is infeasible, that is, it does not belong to the feasible set.
</p><p>Similarly,
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\underset {x\in [-5,5],\;y\in \mathbb {R} }{\operatorname {arg\,max} }}\;x\cos y,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<munder>
<mrow class="MJX-TeXAtom-OP MJX-fixedlimits">
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">r</mi>
<mi mathvariant="normal">g</mi>
<mspace width="thinmathspace"></mspace>
<mi mathvariant="normal">m</mi>
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">x</mi>
</mrow>
<mrow>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mo stretchy="false">[</mo>
<mo>−<!-- − --></mo>
<mn>5</mn>
<mo>,</mo>
<mn>5</mn>
<mo stretchy="false">]</mo>
<mo>,</mo>
<mspace width="thickmathspace"></mspace>
<mi>y</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
</mrow>
</munder>
</mrow>
<mspace width="thickmathspace"></mspace>
<mi>x</mi>
<mi>cos</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>y</mi>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\underset {x\in [-5,5],\;y\in \mathbb {R} }{\operatorname {arg\,max} }}\;x\cos y,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\underset {x\in [-5,5],\;y\in \mathbb {R} }{\operatorname {arg\,max} }}\;x\cos y,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ee3de833a31bfb33700e63b8d5df04565e899915" style="vertical-align: -3.005ex; width:18.196ex; height:4.343ex;"/></span></dd></dl>
<p>or equivalently
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\underset {x,\;y}{\operatorname {arg\,max} }}\;x\cos y,\;{\text{subject to:}}\;x\in [-5,5],\;y\in \mathbb {R} ,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<munder>
<mrow class="MJX-TeXAtom-OP MJX-fixedlimits">
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">r</mi>
<mi mathvariant="normal">g</mi>
<mspace width="thinmathspace"></mspace>
<mi mathvariant="normal">m</mi>
<mi mathvariant="normal">a</mi>
<mi mathvariant="normal">x</mi>
</mrow>
<mrow>
<mi>x</mi>
<mo>,</mo>
<mspace width="thickmathspace"></mspace>
<mi>y</mi>
</mrow>
</munder>
</mrow>
<mspace width="thickmathspace"></mspace>
<mi>x</mi>
<mi>cos</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>y</mi>
<mo>,</mo>
<mspace width="thickmathspace"></mspace>
<mrow class="MJX-TeXAtom-ORD">
<mtext>subject to:</mtext>
</mrow>
<mspace width="thickmathspace"></mspace>
<mi>x</mi>
<mo>∈<!-- ∈ --></mo>
<mo stretchy="false">[</mo>
<mo>−<!-- − --></mo>
<mn>5</mn>
<mo>,</mo>
<mn>5</mn>
<mo stretchy="false">]</mo>
<mo>,</mo>
<mspace width="thickmathspace"></mspace>
<mi>y</mi>
<mo>∈<!-- ∈ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="double-struck">R</mi>
</mrow>
<mo>,</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\underset {x,\;y}{\operatorname {arg\,max} }}\;x\cos y,\;{\text{subject to:}}\;x\in [-5,5],\;y\in \mathbb {R} ,}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\underset {x,\;y}{\operatorname {arg\,max} }}\;x\cos y,\;{\text{subject to:}}\;x\in [-5,5],\;y\in \mathbb {R} ,}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29cd276141e8e134eb156b2fa537ced38c14a5b3" style="vertical-align: -2.671ex; width:46.398ex; height:4.676ex;"/></span></dd></dl>
<p>represents the <span class="texhtml">{<i>x</i>, <i>y</i>}</span> pair (or pairs) that maximizes (or maximize) the value of the objective function <span class="texhtml"><i>x</i> cos <i>y</i></span>, with the added constraint that <span class="texhtml mvar" style="font-style:italic;">x</span> lie in the interval <span class="texhtml">[−5,5]</span> (again, the actual maximum value of the expression does not matter). In this case, the solutions are the pairs of the form <span class="texhtml">{5, 2<i>k</i><span class="texhtml mvar" style="font-style:italic;">π</span>}</span> and <span class="texhtml">{−5, (2<i>k</i> + 1)<span class="texhtml mvar" style="font-style:italic;">π</span>}</span>, where <span class="texhtml mvar" style="font-style:italic;">k</span> ranges over all integers.
</p><p>Operators <span class="texhtml">arg min</span> and <span class="texhtml">arg max</span> are sometimes also written as <span class="texhtml">argmin</span> and <span class="texhtml">argmax</span>, and stand for <i>argument of the minimum</i> and <i>argument of the maximum</i>.
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>Fermat and Lagrange found calculus-based formulae for identifying optima, while Newton and Gauss proposed iterative methods for moving towards an optimum.
</p><p>The term "linear programming" for certain optimization cases was due to George B. Dantzig, although much of the theory had been introduced by Leonid Kantorovich in 1939. (<i>Programming</i> in this context does not refer to computer programming, but comes from the use of <i>program</i> by the United States military to refer to proposed training and logistics schedules, which were the problems Dantzig studied at that time.) Dantzig published the Simplex algorithm in 1947, and John von Neumann developed the theory of duality in the same year.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (January 2020)">citation needed</span></i>]</sup>
</p><p>Other notable researchers in mathematical optimization include the following:
</p>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Major_subfields">Major subfields</span><span class="mw-editsection"></span></h2>
<ul><li>Convex programming studies the case when the objective function is convex (minimization) or concave (maximization) and the constraint set is convex. This can be viewed as a particular case of nonlinear programming or as generalization of linear or convex quadratic programming.
<ul><li>Linear programming (LP), a type of convex programming, studies the case in which the objective function <i>f</i> is linear and the constraints are specified using only linear equalities and inequalities. Such a constraint set is called a polyhedron or a polytope if it is bounded.</li>
<li>Second-order cone programming (SOCP) is a convex program, and includes certain types of quadratic programs.</li>
<li>Semidefinite programming (SDP) is a subfield of convex optimization where the underlying variables are semidefinite matrices. It is a generalization of linear and convex quadratic programming.</li>
<li>Conic programming is a general form of convex programming.  LP, SOCP and SDP can all be viewed as conic programs with the appropriate type of cone.</li>
<li>Geometric programming is a technique whereby objective and inequality constraints expressed as posynomials and equality constraints as monomials can be transformed into a convex program.</li></ul></li>
<li>Integer programming studies linear programs in which some or all variables are constrained to take on integer values.  This is not convex, and in general much more difficult than regular linear programming.</li>
<li>Quadratic programming allows the objective function to have quadratic terms, while the feasible set must be specified with linear equalities and inequalities.  For specific forms of the quadratic term, this is a type of convex programming.</li>
<li>Fractional programming studies optimization of ratios of two nonlinear functions. The special class of concave fractional programs can be transformed to a convex optimization problem.</li>
<li>Nonlinear programming studies the general case in which the objective function or the constraints or both contain nonlinear parts.  This may or may not be a convex program. In general, whether the program is convex affects the difficulty of solving it.</li>
<li>Stochastic programming studies the case in which some of the constraints or parameters depend on random variables.</li>
<li>Robust optimization is, like stochastic programming, an attempt to capture uncertainty in the data underlying the optimization problem. Robust optimization aims to find solutions that are valid under all possible realizations of the uncertainties defined by an uncertainty set.</li>
<li>Combinatorial optimization is concerned with problems where the set of feasible solutions is discrete or can be reduced to a discrete one.</li>
<li>Stochastic optimization is used with random (noisy) function measurements or random inputs in the search process.</li>
<li>Infinite-dimensional optimization studies the case when the set of feasible solutions is a subset of an infinite-dimensional space, such as a space of functions.</li>
<li>Heuristics and metaheuristics make few or no assumptions about the problem being optimized. Usually, heuristics do not guarantee that any optimal solution need be found. On the other hand, heuristics are used to find approximate solutions for many complicated optimization problems.</li>
<li>Constraint satisfaction studies the case in which the objective function <i>f</i> is constant (this is used in artificial intelligence, particularly in automated reasoning).
<ul><li>Constraint programming is a programming paradigm wherein relations between variables are stated in the form of constraints.</li></ul></li>
<li>Disjunctive programming is used where at least one constraint must be satisfied but not all. It is of particular use in scheduling.</li>
<li>Space mapping is a concept for modeling and optimization of an engineering system to high-fidelity (fine) model accuracy exploiting a suitable physically meaningful coarse or surrogate model.</li></ul>
<p>In a number of subfields, the techniques are designed primarily for optimization in dynamic contexts (that is, decision making over time):
</p>
<ul><li>Calculus of variations Is concerned with finding the best way to achieve some goal, such as finding a surface whose boundary is a specific curve, but with the least possible area.</li>
<li>Optimal control theory is a generalization of the calculus of variations which introduces control policies.</li>
<li>Dynamic programming is the approach to solve the stochastic optimization problem with stochastic, randomness, and unknown model parameters. It studies the case in which the optimization strategy is based on splitting the problem into smaller subproblems. The equation that describes the relationship between these subproblems is called the Bellman equation.</li>
<li>Mathematical programming with equilibrium constraints is where the constraints include variational inequalities or  complementarities.</li></ul>
<h3><span class="mw-headline" id="Multi-objective_optimization">Multi-objective optimization</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Adding more than one objective to an optimization problem adds complexity. For example, to optimize a structural design, one would desire a design that is both light and rigid. When two objectives conflict, a trade-off must be created. There may be one lightest design, one stiffest design, and an infinite number of designs that are some compromise of weight and rigidity. The set of trade-off designs that improve upon one criterion at the expense of another is known as the Pareto set. The curve created plotting weight against stiffness of the best designs is known as the Pareto frontier.
</p><p>A design is judged to be "Pareto optimal" (equivalently, "Pareto efficient" or in the Pareto set) if it is not dominated by any other design: If it is worse than another design in some respects and no better in any respect, then it is dominated and is not Pareto optimal.
</p><p>The choice among "Pareto optimal" solutions to determine the "favorite solution" is delegated to the decision maker. In other words, defining the problem as multi-objective optimization signals that some information is missing: desirable objectives are given but combinations of them are not rated relative to each other. In some cases, the missing information can be derived by interactive sessions with the decision maker.
</p><p>Multi-objective optimization problems have been generalized further into vector optimization problems where the (partial) ordering is no longer given by the Pareto ordering.
</p>
<h3><span class="mw-headline" id="Multi-modal_or_global_optimization">Multi-modal or global optimization</span><span class="mw-editsection"></span></h3>
<p>Optimization problems are often multi-modal; that is, they possess multiple good solutions. They could all be globally good (same cost function value) or there could be a mix of globally good and locally good solutions. Obtaining all (or at least some of) the multiple solutions is the goal of a multi-modal optimizer.
</p><p>Classical optimization techniques due to their iterative approach do not perform satisfactorily when they are used to obtain multiple solutions, since it is not guaranteed that different solutions will be obtained even with different starting points in multiple runs of the algorithm.
</p><p>Common approaches to global optimization problems, where multiple local extrema may be present include evolutionary algorithms, Bayesian optimization and simulated annealing.
</p>
<h2><span class="mw-headline" id="Classification_of_critical_points_and_extrema">Classification of critical points and extrema</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Feasibility_problem">Feasibility problem</span><span class="mw-editsection"></span></h3>
<p>The <i>satisfiability problem</i>, also called the <i>feasibility problem</i>, is just the problem of finding any feasible solution at all without regard to objective value. This can be regarded as the special case of mathematical optimization where the objective value is the same for every solution, and thus any solution is optimal.
</p><p>Many optimization algorithms need to start from a feasible point. One way to obtain such a point is to relax the feasibility conditions using a slack variable; with enough slack, any starting point is feasible. Then, minimize that slack variable until the slack is null or negative.
</p>
<h3><span class="mw-headline" id="Existence">Existence</span><span class="mw-editsection"></span></h3>
<p>The extreme value theorem of Karl Weierstrass states that a continuous real-valued function on a compact set attains its maximum and minimum value. More generally, a lower semi-continuous function on a compact set attains its minimum; an upper semi-continuous function on a compact set attains its maximum point or view.
</p>
<h3><span class="mw-headline" id="Necessary_conditions_for_optimality">Necessary conditions for optimality</span><span class="mw-editsection"></span></h3>
<p>One of Fermat's theorems states that optima of unconstrained problems are found at stationary points, where the first derivative or the gradient of the objective function is zero (see first derivative test). More generally, they may be found at critical points, where the first derivative or gradient of the objective function is zero or is undefined, or on the boundary of the choice set. An equation (or set of equations) stating that the first derivative(s) equal(s) zero at an interior optimum is called a 'first-order condition' or a set of first-order conditions.
</p><p>Optima of equality-constrained problems can be found by the Lagrange multiplier method. The optima of problems with equality and/or inequality constraints can be found using the 'Karush–Kuhn–Tucker conditions'.
</p>
<h3><span class="mw-headline" id="Sufficient_conditions_for_optimality">Sufficient conditions for optimality</span><span class="mw-editsection"></span></h3>
<p>While the first derivative test identifies points that might be extrema, this test does not distinguish a point that is a minimum from one that is a maximum or one that is neither. When the objective function is twice differentiable, these cases can be distinguished by checking the second derivative or the matrix of second derivatives (called the Hessian matrix) in unconstrained problems, or the matrix of second derivatives of the objective function and the constraints called the bordered Hessian in constrained problems. The conditions that distinguish maxima, or minima, from other stationary points are called 'second-order conditions' (see 'Second derivative test'). If a candidate solution satisfies the first-order conditions, then the satisfaction of the second-order conditions as well is sufficient to establish at least local optimality.
</p>
<h3><span class="mw-headline" id="Sensitivity_and_continuity_of_optima">Sensitivity and continuity of optima</span><span class="mw-editsection"></span></h3>
<p>The envelope theorem describes how the value of an optimal solution changes when an underlying parameter changes. The process of computing this change is called comparative statics.
</p><p>The maximum theorem of Claude Berge (1963) describes the continuity of an optimal solution as a function of underlying parameters.
</p>
<h3><span class="mw-headline" id="Calculus_of_optimization">Calculus of optimization</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>For unconstrained problems with twice-differentiable functions, some critical points can be found by finding the points where the gradient of the objective function is zero (that is, the stationary points). More generally, a zero subgradient certifies that a local minimum has been found for minimization problems with convex functions and other locally Lipschitz functions.
</p><p>Further, critical points can be classified using the definiteness of the Hessian matrix: If the Hessian is <i>positive</i> definite at a critical point, then the point is a local minimum; if the Hessian matrix is negative definite, then the point is a local maximum; finally, if indefinite, then the point is some kind of saddle point.
</p><p>Constrained problems can often be transformed into unconstrained problems with the help of Lagrange multipliers. Lagrangian relaxation can also provide approximate solutions to difficult constrained problems.
</p><p>When the objective function is a convex function, then any local minimum will also be a global minimum. There exist efficient numerical techniques for minimizing convex functions, such as interior-point methods.
</p>
<h3><span class="mw-headline" id="Global_convergence">Global convergence</span><span class="mw-editsection"></span></h3>
<p>More generally, if the objective function is not a quadratic function, then many optimization methods use other methods to ensure that some subsequence of iterations converges to an optimal solution. The first and still popular method for ensuring convergence relies on line searches, which optimize a function along one dimension. A second and increasingly popular method for ensuring convergence uses trust regions. Both line searches and trust regions are used in modern methods of non-differentiable optimization. Usually, a global optimizer is much slower than advanced local optimizers (such as BFGS), so often an efficient global optimizer can be constructed by starting the local optimizer from different starting points.
</p>
<h2><span class="mw-headline" id="Computational_optimization_techniques">Computational optimization techniques</span><span class="mw-editsection"></span></h2>
<p>To solve problems, researchers may use algorithms that terminate in a finite number of steps, or iterative methods that converge to a solution (on some specified class of problems), or heuristics that may provide approximate solutions to some problems (although their iterates need not converge).
</p>
<h3><span class="mw-headline" id="Optimization_algorithms">Optimization algorithms</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<ul><li>Simplex algorithm of George Dantzig, designed for linear programming</li>
<li>Extensions of the simplex algorithm, designed for quadratic programming and for linear-fractional programming</li>
<li>Variants of the simplex algorithm that are especially suited for network optimization</li>
<li>Combinatorial algorithms</li>
<li>Quantum optimization algorithms</li></ul>
<h3><span class="mw-headline" id="Iterative_methods">Iterative methods</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>The iterative methods used to solve problems of nonlinear programming differ according to whether they evaluate Hessians, gradients, or only function values. While evaluating Hessians (H) and gradients (G) improves the rate of convergence, for functions for which these quantities exist and vary sufficiently smoothly, such evaluations increase the computational complexity (or computational cost) of each iteration. In some cases, the computational complexity may be excessively high.
</p><p>One major criterion for optimizers is just the number of required function evaluations as this often is already a large computational effort, usually much more effort than within the optimizer itself, which mainly has to operate over the N variables. The derivatives provide detailed information for such optimizers, but are even harder to calculate, e.g. approximating the gradient takes at least N+1 function evaluations. For approximations of the 2nd derivatives (collected in the Hessian matrix), the number of function evaluations is in the order of N². Newton's method requires the 2nd-order derivatives, so for each iteration, the number of function calls is in the order of N², but for a simpler pure gradient optimizer it is only N. However, gradient optimizers need usually more iterations than Newton's algorithm. Which one is best with respect to the number of function calls depends on the problem itself.
</p>
<ul><li>Methods that evaluate Hessians (or approximate Hessians, using finite differences):
<ul><li>Newton's method</li>
<li>Sequential quadratic programming: A Newton-based method for small-medium scale <i>constrained</i> problems. Some versions can handle large-dimensional problems.</li>
<li>Interior point methods: This is a large class of methods for constrained optimization, some of which use only (sub)gradient information and others of which require the evaluation of Hessians.</li></ul></li>
<li>Methods that evaluate gradients, or approximate gradients in some way (or even subgradients):
<ul><li>Coordinate descent methods: Algorithms which update a single coordinate in each iteration</li>
<li>Conjugate gradient methods: Iterative methods for large problems. (In theory, these methods terminate in a finite number of steps with quadratic objective functions, but this finite termination is not observed in practice on finite–precision computers.)</li>
<li>Gradient descent (alternatively, "steepest descent" or "steepest ascent"): A (slow) method of historical and theoretical interest, which has had renewed interest for finding approximate solutions of enormous problems.</li>
<li>Subgradient methods: An iterative method for large locally Lipschitz functions using generalized gradients. Following Boris T. Polyak, subgradient–projection methods are similar to conjugate–gradient methods.</li>
<li>Bundle method of descent: An iterative method for small–medium-sized problems with locally Lipschitz functions, particularly for convex minimization problems (similar to conjugate gradient methods).</li>
<li>Ellipsoid method: An iterative method for small problems with quasiconvex objective functions and of great theoretical interest, particularly in establishing the polynomial time complexity of some combinatorial optimization problems. It has similarities with Quasi-Newton methods.</li>
<li>Conditional gradient method (Frank–Wolfe) for approximate minimization of specially structured problems with linear constraints, especially with traffic networks. For general unconstrained problems, this method reduces to the gradient method, which is regarded as obsolete (for almost all problems).</li>
<li>Quasi-Newton methods: Iterative methods for medium-large problems (e.g. N&lt;1000).</li>
<li>Simultaneous perturbation stochastic approximation (SPSA) method for stochastic optimization; uses random (efficient) gradient approximation.</li></ul></li>
<li>Methods that evaluate only function values: If a problem is continuously differentiable, then gradients can be approximated using finite differences, in which case a gradient-based method can be used.
<ul><li>Interpolation methods</li>
<li>Pattern search methods, which have better convergence properties than the Nelder–Mead heuristic (with simplices), which is listed below.</li>
<li>Mirror descent</li></ul></li></ul>
<h3><span class="mw-headline" id="Heuristics">Heuristics</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Besides (finitely terminating) algorithms and (convergent) iterative methods, there are heuristics. A heuristic is any algorithm which is not guaranteed (mathematically) to find the solution, but which is nevertheless useful in certain practical situations. List of some well-known heuristics:
</p>
<link href="mw-data:TemplateStyles:r998391716" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Mechanics">Mechanics</span><span class="mw-editsection"></span></h3>
<p>Problems in rigid body dynamics (in particular articulated rigid body dynamics) often require mathematical programming techniques, since you can view rigid body dynamics as attempting to solve an ordinary differential equation on a constraint manifold;<sup class="reference" id="cite_ref-5">[5]</sup> the constraints are various nonlinear geometric constraints such as "these two points must always coincide", "this surface must not penetrate any other", or "this point must always lie somewhere on this curve". Also, the problem of computing contact forces can be done by solving a linear complementarity problem, which can also be viewed as a QP (quadratic programming) problem.
</p><p>Many design problems can also be expressed as optimization programs. This application is called design optimization. One subset is the engineering optimization, and another recent and growing subset of this field is multidisciplinary design optimization, which, while useful in many problems, has in particular been applied to aerospace engineering problems.
</p><p>This approach may be applied in cosmology and astrophysics.<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<h3><span class="mw-headline" id="Economics_and_finance">Economics and finance</span><span class="mw-editsection"></span></h3>
<p>Economics is closely enough linked to optimization of agents that an influential definition relatedly describes economics <i>qua</i> science as the "study of human behavior as a relationship between ends and scarce means" with alternative uses.<sup class="reference" id="cite_ref-7">[7]</sup>  Modern optimization theory includes traditional optimization theory but also overlaps with game theory and the study of economic equilibria. The <i>Journal of Economic Literature</i> codes classify mathematical programming, optimization techniques, and related topics under JEL:C61-C63.
</p><p>In microeconomics, the utility maximization problem and its dual problem, the expenditure minimization problem, are economic optimization problems. Insofar as they behave consistently, consumers are assumed to maximize their utility, while firms are usually assumed to maximize their profit. Also, agents are often modeled as being risk-averse, thereby preferring to avoid risk. Asset prices are also modeled using optimization theory, though the underlying mathematics relies on optimizing stochastic processes rather than on static optimization. International trade theory also uses optimization to explain trade patterns between nations. The optimization of portfolios is an example of multi-objective optimization in economics.
</p><p>Since the 1970s, economists have modeled dynamic decisions over time using control theory.<sup class="reference" id="cite_ref-8">[8]</sup> For example, dynamic search models are used to study labor-market behavior.<sup class="reference" id="cite_ref-9">[9]</sup> A crucial distinction is between deterministic and stochastic models.<sup class="reference" id="cite_ref-10">[10]</sup> Macroeconomists build dynamic stochastic general equilibrium (DSGE) models that describe the dynamics of the whole economy as the result of the interdependent optimizing decisions of workers, consumers, investors, and governments.<sup class="reference" id="cite_ref-11">[11]</sup><sup class="reference" id="cite_ref-12">[12]</sup>
</p>
<h3><span class="mw-headline" id="Electrical_engineering">Electrical engineering</span><span class="mw-editsection"></span></h3>
<p>Some common applications of optimization techniques in electrical engineering include active filter design,<sup class="reference" id="cite_ref-13">[13]</sup> stray field reduction in superconducting magnetic energy storage systems, space mapping design of microwave structures,<sup class="reference" id="cite_ref-14">[14]</sup> handset antennas,<sup class="reference" id="cite_ref-15">[15]</sup><sup class="reference" id="cite_ref-16">[16]</sup><sup class="reference" id="cite_ref-17">[17]</sup> electromagnetics-based design. Electromagnetically validated design optimization of microwave components and antennas has made extensive use of an appropriate physics-based or empirical surrogate model and space mapping methodologies since the discovery of space mapping in 1993.<sup class="reference" id="cite_ref-18">[18]</sup><sup class="reference" id="cite_ref-19">[19]</sup>
</p>
<h3><span class="mw-headline" id="Civil_engineering">Civil engineering</span><span class="mw-editsection"></span></h3>
<p>Optimization has been widely used in civil engineering. Construction management and transportation engineering are among the main branches of civil engineering that heavily rely on optimization. The most common civil engineering problems that are solved by optimization are cut and fill of roads, life-cycle analysis of structures and infrastructures,<sup class="reference" id="cite_ref-20">[20]</sup> resource leveling,<sup class="reference" id="cite_ref-21">[21]</sup><sup class="reference" id="cite_ref-:0_22-0">[22]</sup> water resource allocation, traffic management<sup class="reference" id="cite_ref-23">[23]</sup> and schedule optimization.
</p>
<h3><span class="mw-headline" id="Operations_research">Operations research</span><span class="mw-editsection"></span></h3>
<p>Another field that uses optimization techniques extensively is operations research.<sup class="reference" id="cite_ref-24">[24]</sup> Operations research also uses stochastic modeling and simulation to support improved decision-making. Increasingly, operations research uses stochastic programming to model dynamic decisions that adapt to events; such problems can be solved with large-scale optimization and stochastic optimization methods.
</p>
<h3><span class="mw-headline" id="Control_engineering">Control engineering</span><span class="mw-editsection"></span></h3>
<p>Mathematical optimization is used in much modern controller design. High-level controllers such as model predictive control (MPC) or real-time optimization (RTO) employ mathematical optimization. These algorithms run online and repeatedly determine values for decision variables, such as choke openings in a process plant, by iteratively solving a mathematical optimization problem including constraints and a model of the system to be controlled.
</p>
<h3><span class="mw-headline" id="Geophysics">Geophysics</span><span class="mw-editsection"></span></h3>
<p>Optimization techniques are regularly used in geophysical parameter estimation problems. Given a set of geophysical measurements, e.g. seismic recordings, it is common to solve for the physical properties and geometrical shapes of the underlying rocks and fluids.  The majority of problems in geophysics are nonlinear with both deterministic and stochastic methods being widely used.
</p>
<h3><span class="mw-headline" id="Molecular_modeling">Molecular modeling</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Nonlinear optimization methods are widely used in conformational analysis.
</p>
<h3><span class="mw-headline" id="Computational_systems_biology">Computational systems biology</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Optimization techniques are used in many facets of computational systems biology such as model building, optimal experimental design, metabolic engineering, and synthetic biology.<sup class="reference" id="cite_ref-Papoutsakis_1984_25-0">[25]</sup> Linear programming has been applied to calculate the maximal possible yields of fermentation products,<sup class="reference" id="cite_ref-Papoutsakis_1984_25-1">[25]</sup> and to infer gene regulatory networks from multiple microarray datasets<sup class="reference" id="cite_ref-26">[26]</sup> as well as transcriptional regulatory networks from high-throughput data.<sup class="reference" id="cite_ref-27">[27]</sup> Nonlinear programming has been used to analyze energy metabolism<sup class="reference" id="cite_ref-28">[28]</sup> and has been applied to metabolic engineering and parameter estimation in biochemical pathways.<sup class="reference" id="cite_ref-29">[29]</sup>
</p>
<h3><span class="mw-headline" id="Machine_learning">Machine learning</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="Solvers">Solvers</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r998391716" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1">Boyd, Stephen P.; Vandenberghe, Lieven (2004). <i>Convex Optimization</i>. Cambridge: Cambridge University Press. ISBN <bdi>0-521-83378-7</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Convex+Optimization&amp;rft.place=Cambridge&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2004&amp;rft.isbn=0-521-83378-7&amp;rft.aulast=Boyd&amp;rft.aufirst=Stephen+P.&amp;rft.au=Vandenberghe%2C+Lieven&amp;rft_id=https%3A%2F%2Fweb.stanford.edu%2F~boyd%2Fcvxbook%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1">Gill, P. E.; Murray, W.; Wright, M. H. (1982). <i>Practical Optimization</i>. London: Academic Press. ISBN <bdi>0-12-283952-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Practical+Optimization&amp;rft.place=London&amp;rft.pub=Academic+Press&amp;rft.date=1982&amp;rft.isbn=0-12-283952-8&amp;rft.aulast=Gill&amp;rft.aufirst=P.+E.&amp;rft.au=Murray%2C+W.&amp;rft.au=Wright%2C+M.+H.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1">Lee, Jon (2004). <i>A First Course in Combinatorial Optimization</i>. Cambridge University Press. ISBN <bdi>0-521-01012-8</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A+First+Course+in+Combinatorial+Optimization&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2004&amp;rft.isbn=0-521-01012-8&amp;rft.aulast=Lee&amp;rft.aufirst=Jon&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1">Nocedal, Jorge; Wright, Stephen J. (2006). <i>Numerical Optimization</i> (2nd ed.). Berlin: Springer. ISBN <bdi>0-387-30303-0</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Numerical+Optimization&amp;rft.place=Berlin&amp;rft.edition=2nd&amp;rft.pub=Springer&amp;rft.date=2006&amp;rft.isbn=0-387-30303-0&amp;rft.aulast=Nocedal&amp;rft.aufirst=Jorge&amp;rft.au=Wright%2C+Stephen+J.&amp;rft_id=http%3A%2F%2Fwww.ece.northwestern.edu%2F~nocedal%2Fbook%2Fnum-opt.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1">Snyman, J. A.; Wilke, D. N. (2018). <i>Practical Mathematical Optimization : Basic Optimization Theory and Gradient-Based Algorithms</i> (2nd ed.). Berlin: Springer. ISBN <bdi>978-3-319-77585-2</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Practical+Mathematical+Optimization+%3A+Basic+Optimization+Theory+and+Gradient-Based+Algorithms&amp;rft.place=Berlin&amp;rft.edition=2nd&amp;rft.pub=Springer&amp;rft.date=2018&amp;rft.isbn=978-3-319-77585-2&amp;rft.aulast=Snyman&amp;rft.aufirst=J.+A.&amp;rft.au=Wilke%2C+D.+N.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation web cs1">"Decision Tree for Optimization Software".</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Decision+Tree+for+Optimization+Software&amp;rft_id=http%3A%2F%2Fplato.asu.edu%2Fguide.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span> Links to optimization source codes</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation web cs1">"Global optimization".</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Global+optimization&amp;rft_id=https%3A%2F%2Fwww.mat.univie.ac.at%2F~neum%2Fglopt.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation web cs1">"EE364a: Convex Optimization I". <i>Course from Stanford University</i>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Course+from+Stanford+University&amp;rft.atitle=EE364a%3A+Convex+Optimization+I&amp;rft_id=https%3A%2F%2Fsee.stanford.edu%2FCourse%2FEE364A&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation web cs1" id="CITEREFVaroquaux">Varoquaux, Gaël. "Mathematical Optimization: Finding Minima of Functions".</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Mathematical+Optimization%3A+Finding+Minima+of+Functions&amp;rft.aulast=Varoquaux&amp;rft.aufirst=Ga%C3%ABl&amp;rft_id=https%3A%2F%2Fscipy-lectures.org%2Fadvanced%2Fmathematical_optimization%2Findex.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMathematical+optimization"></span></li></ul>




<!-- 
NewPP limit report
Parsed by mw2268
Cached time: 20221223232805
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.731 seconds
Real time usage: 0.955 seconds
Preprocessor visited node count: 4839/1000000
Post‐expand include size: 173376/2097152 bytes
Template argument size: 4343/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 33/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 116312/5000000 bytes
Lua time usage: 0.394/10.000 seconds
Lua memory usage: 7603663/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  723.630      1 -total
 33.24%  240.501      1 Template:Reflist
 14.92%  107.967      8 Template:Cite_book
 14.23%  102.963     19 Template:Cite_journal
  9.60%   69.492      1 Template:Optimization_algorithms
  9.24%   66.872      1 Template:Navbox_with_collapsible_groups
  8.72%   63.083      1 Template:Short_description
  7.96%   57.601      1 Template:Commons_category
  7.64%   55.271      1 Template:Sister_project
  7.37%   53.334      1 Template:Side_box
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:52033-0!canonical and timestamp 20221223232804 and revision id 1127783738.
 -->
</div></body>
</html>