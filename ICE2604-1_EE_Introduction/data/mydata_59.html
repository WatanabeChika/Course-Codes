<!DOCTYPE html>
<html>
<head>
<title>associative_array</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>In computer science, an <b>associative array</b>, <b>map</b>, <b>symbol table</b>, or <b>dictionary</b> is an abstract data type that stores a collection of (key, value) pairs, such that each possible key appears at most once in the collection. In mathematical terms an associative array is a function with <i>finite</i> domain.<sup class="reference" id="cite_ref-1">[1]</sup> It supports 'lookup', 'remove', and 'insert' operations. 
</p><p>The <b>dictionary problem</b> is the classic problem of designing efficient data structures that implement associative arrays.<sup class="reference" id="cite_ref-2">[2]</sup>
The two major solutions to the dictionary problem are hash tables and search trees.<sup class="reference" id="cite_ref-gt_3-0">[3]</sup><sup class="reference" id="cite_ref-ms_4-0">[4]</sup><sup class="reference" id="cite_ref-clrs_5-0">[5]</sup><sup class="reference" id="cite_ref-dietzfelbinger_6-0">[6]</sup>
In some cases it is also possible to solve the problem using directly addressed arrays, binary search trees, or other more specialized structures.
</p><p>Many programming languages include associative arrays as primitive data types, and they are available in software libraries for many others. Content-addressable memory is a form of direct hardware-level support for associative arrays.
</p><p>Associative arrays have many applications including such fundamental programming patterns as memoization and the decorator pattern.<sup class="reference" id="cite_ref-decorator_7-0">[7]</sup>
</p><p>The name does not come from the associative property known in mathematics. Rather, it arises from the fact that values are associated with keys. It is not to be confused with associative processors.
</p>

<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<p>In an associative array, the association between a key and a value is often known as a "mapping", and the same word mapping may also be used to refer to the process of creating a new association.
</p><p>The operations that are usually defined for an associative array are:<sup class="reference" id="cite_ref-gt_3-1">[3]</sup><sup class="reference" id="cite_ref-ms_4-1">[4]</sup><sup class="reference" id="cite_ref-Black_8-0">[8]</sup>
</p>
<ul><li><b>Insert</b> or <b>put</b>: add a new <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (key,value)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>k</mi>
<mi>e</mi>
<mi>y</mi>
<mo>,</mo>
<mi>v</mi>
<mi>a</mi>
<mi>l</mi>
<mi>u</mi>
<mi>e</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (key,value)}</annotation>
</semantics>
</math></span><img alt="(key,value)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2362d80ab2b2e3530f179bd081a2af7e0aa936b7" style="vertical-align: -0.838ex; width:11.757ex; height:2.843ex;"/></span> pair to the collection, mapping the key to its new value. Any existing mapping is overwritten. The arguments to this operation are the key and the value.</li>
<li><b>Remove</b> or <b>delete</b>: remove a <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (key,value)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>k</mi>
<mi>e</mi>
<mi>y</mi>
<mo>,</mo>
<mi>v</mi>
<mi>a</mi>
<mi>l</mi>
<mi>u</mi>
<mi>e</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (key,value)}</annotation>
</semantics>
</math></span><img alt="(key,value)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2362d80ab2b2e3530f179bd081a2af7e0aa936b7" style="vertical-align: -0.838ex; width:11.757ex; height:2.843ex;"/></span> pair from the collection, unmapping a given key from its value. The argument to this operation is the key.</li>
<li><b>Lookup</b>, <b>find</b>, or <b>get</b>: find the value (if any) that is bound to a given key. The argument to this operation is the key, and the value is returned from the operation. If no value is found, some lookup functions raise an exception, while others return a default value (zero, null, specific value passed to the constructor, ...).</li></ul>
<p>In addition, associative arrays may also include other operations such as determining the number of mappings or constructing an iterator to loop over all the mappings. Usually, for such an operation, the order in which the mappings are returned may be implementation-defined.
</p><p>A multimap generalizes an associative array by allowing multiple values to be associated with a single key.<sup class="reference" id="cite_ref-9">[9]</sup> A bidirectional map is a related abstract data type in which the mappings operate in both directions: each value must be associated with a unique key, and a second lookup operation takes a value as an argument and looks up the key associated with that value.
</p>
<h3><span class="mw-headline" id="Properties">Properties</span><span class="mw-editsection"></span></h3>
<p>The operations of the associative array should satisfy various properties:<sup class="reference" id="cite_ref-Black_8-1">[8]</sup>
</p>
<ul><li><code>lookup(k, insert(j, v, D)) = if k == j then v else lookup(k, D)</code></li>
<li><code>lookup(k, new()) = fail</code>, where <code>fail</code> is an exception or default value</li>
<li><code>remove(k, insert(j, v, D)) = if k == j then remove(k, D) else insert(j, v, remove(k, D))</code></li>
<li><code>remove(k, new()) = new()</code></li></ul>
<p>where <code>k</code> and <code>j</code> are keys, <code>v</code> is a value, <code>D</code> is an associative array, and <code>new()</code> creates a new, empty associative array.
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h3>
<p>Suppose that the set of loans made by a library is represented in a data structure.  Each book in a library may be checked out only by a single library patron at a time.  However, a single patron may be able to check out multiple books.  Therefore, the information about which books are checked out to which patrons may be represented by an associative array, in which the books are the keys and the patrons are the values.  Using notation from Python or JSON, the data structure would be:
</p>

<p>A lookup operation on the key "Great Expectations" would return "John".  If John returns his book, that would cause a deletion operation, and if Pat checks out a book, that would cause an insertion operation, leading to a different state:
</p>

<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>For dictionaries with very small numbers of mappings, it may make sense to implement the dictionary using an association list, a linked list of mappings. With this implementation, the time to perform the basic dictionary operations is linear in the total number of mappings; however, it is easy to implement and the constant factors in its running time are small.<sup class="reference" id="cite_ref-gt_3-2">[3]</sup><sup class="reference" id="cite_ref-10">[10]</sup>
</p><p>Another very simple implementation technique, usable when the keys are restricted to a narrow range, is direct addressing into an array: the value for a given key <i>k</i> is stored at the array cell <i>A</i>[<i>k</i>], or if there is no mapping for <i>k</i> then the cell stores a special sentinel value that indicates the absence of a mapping. As well as being simple, this technique is fast: each dictionary operation takes constant time. However, the space requirement for this structure is the size of the entire keyspace, making it impractical unless the keyspace is small.<sup class="reference" id="cite_ref-clrs_5-1">[5]</sup>
</p><p>The two major approaches to implementing dictionaries are a hash table or a search tree.<sup class="reference" id="cite_ref-gt_3-3">[3]</sup><sup class="reference" id="cite_ref-ms_4-2">[4]</sup><sup class="reference" id="cite_ref-clrs_5-2">[5]</sup><sup class="reference" id="cite_ref-dietzfelbinger_6-1">[6]</sup>
</p>
<h3><span class="mw-headline" id="Hash_table_implementations">Hash table implementations</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>

<p>The most frequently used general purpose implementation of an associative array is with a hash table: an array combined with a hash function that separates each key into a separate "bucket" of the array. The basic idea behind a hash table is that accessing an element of an array via its index is a simple, constant-time operation. Therefore, the average overhead of an operation for a hash table is only the computation of the key's hash, combined with accessing the corresponding bucket within the array. As such, hash tables usually perform in O(1) time, and outperform alternatives in most situations.
</p><p>Hash tables need to be able to handle collisions: when the hash function maps two different keys to the same bucket of the array. The two most widespread approaches to this problem are separate chaining and open addressing.<sup class="reference" id="cite_ref-gt_3-4">[3]</sup><sup class="reference" id="cite_ref-ms_4-3">[4]</sup><sup class="reference" id="cite_ref-clrs_5-3">[5]</sup><sup class="reference" id="cite_ref-fklm_11-0">[11]</sup> In separate chaining, the array does not store the value itself but stores a pointer to another container, usually an association list, that stores all of the values matching the hash. On the other hand, in open addressing, if a hash collision is found, then the table seeks an empty spot in an array to store the value in a deterministic manner, usually by looking at the next immediate position in the array.
</p><p>Open addressing has a lower cache miss ratio than separate chaining when the table is mostly empty. However, as the table becomes filled with more elements, open addressing's performance degrades exponentially. Additionally, separate chaining uses less memory in most cases, unless the entries are very small (less than four times the size of a pointer).
</p>
<h3><span class="mw-headline" id="Tree_implementations">Tree implementations</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<h4><span class="mw-headline" id="Self-balancing_binary_search_trees">Self-balancing binary search trees</span><span class="mw-editsection"></span></h4>
<p>Another common approach is to implement an associative array with a self-balancing binary search tree, such as an AVL tree or a red–black tree.<sup class="reference" id="cite_ref-12">[12]</sup>
</p><p>Compared to hash tables, these structures have both advantages and weaknesses. The worst-case performance of self-balancing binary search trees is significantly better than that of a hash table, with a time complexity in big O notation of O(log <i>n</i>). This is in contrast to hash tables, whose worst-case performance involves all elements sharing a single bucket, resulting in O(<i>n</i>) time complexity. In addition, and like all binary search trees, self-balancing binary search trees keep their elements in order. Thus, traversing its elements follows a least-to-greatest pattern, whereas traversing a hash table can result in elements being in seemingly random order. Because they are in-order, tree-based maps can also satisfy range queries (find all values between two bounds) where a hashmap can only find exact values. However, hash tables have a much better average-case time complexity than self-balancing binary search trees of O(1), and their worst-case performance is highly unlikely when a good hash function is used.
</p><p>It is worth noting that a self-balancing binary search tree can be used to implement the buckets for a hash table that uses separate chaining. This allows for average-case constant lookup, but assures a worst-case performance of O(log <i>n</i>). However, this introduces extra complexity into the implementation, and may cause even worse performance for smaller hash tables, where the time spent inserting into and balancing the tree is greater than the time needed to perform a linear search on all of the elements of a linked list or similar data structure.<sup class="reference" id="cite_ref-knuth_13-0">[13]</sup><sup class="reference" id="cite_ref-14">[14]</sup>
</p>
<h4><span class="mw-headline" id="Other_trees">Other trees</span><span class="mw-editsection"></span></h4>
<p>Associative arrays may also be stored in unbalanced binary search trees or in data structures specialized to a particular type of keys such as radix trees, tries, Judy arrays, or van Emde Boas trees, though the ability of these implementation methods within comparison to hash tables varies; for instance, Judy trees remain indicated to perform with a smaller quantity of efficiency than hash tables, while carefully selected hash tables generally perform with increased efficiency in comparison to adaptive radix trees, with potentially greater restrictions on the types of data that they can handle.<sup class="reference" id="cite_ref-15">[15]</sup> The advantages of these alternative structures come from their ability to handle operations beyond the basic ones of an associative array, such as finding the mapping whose key is the closest to a queried key, when the query is not itself present in the set of mappings.
</p>
<h3><span class="mw-headline" id="Comparison">Comparison</span><span class="mw-editsection"></span></h3>
<table class="wikitable">
<tbody><tr>
<th rowspan="2">Underlying data structure
</th>
<th colspan="2">Lookup or Removal
</th>
<th colspan="2">Insertion
</th>
<th rowspan="2">Ordered
</th></tr>
<tr>
<th>average
</th>
<th>worst case
</th>
<th>average
</th>
<th>worst case
</th></tr>
<tr>
<th>Hash table
</th>
<td style="background:#ddffdd">O(1)
</td>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td style="background:#ddffdd">O(1)
</td>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td class="table-no" style="background:#FFC7C7;vertical-align:middle;text-align:center;">No
</td></tr>
<tr>
<th>Self-balancing binary search tree
</th>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td class="table-yes" style="background:#9EFF9E;vertical-align:middle;text-align:center;">Yes
</td></tr>
<tr>
<th>unbalanced binary search tree
</th>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td style="background:#ffffdd">O(log <i>n</i>)
</td>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td class="table-yes" style="background:#9EFF9E;vertical-align:middle;text-align:center;">Yes
</td></tr>
<tr>
<th>Sequential container of key–value pairs<br/>(e.g. association list)
</th>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td style="background:#ffdddd">O(<i>n</i>)
</td>
<td style="background:#ddffdd">O(1)
</td>
<td style="background:#ddffdd">O(1)
</td>
<td class="table-no" style="background:#FFC7C7;vertical-align:middle;text-align:center;">No
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Ordered_dictionary">Ordered dictionary</span><span class="mw-editsection"></span></h2>
<p>The basic definition of the dictionary does not mandate an order. To guarantee a fixed order of enumeration, ordered versions of the associative array are often used. There are two senses of an ordered dictionary:
</p>
<ul><li>The order of enumeration is always deterministic for a given set of keys by sorting. This is the case for tree-based implementations, one representative being the <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">&lt;map&gt;</code> container of C++.<sup class="reference" id="cite_ref-16">[16]</sup></li>
<li>The order of enumeration is key-independent and is instead based on the order of insertion. This is the case for the "ordered dictionary" in .NET Framework, the LikedHashMap of Java and Python.<sup class="reference" id="cite_ref-17">[17]</sup><sup class="reference" id="cite_ref-18">[18]</sup><sup class="reference" id="cite_ref-19">[19]</sup></li></ul>
<p>The latter sense of ordered dictionaries are more commonly encountered. They can be implemented using an association list, by overlaying a doubly linked list on top of a normal dictionary, or by moving the actual data out of the sparse (unordered) array and into a dense insertion-ordered one.
</p>
<h2><span class="mw-headline" id="Language_support">Language support</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Associative arrays can be implemented in any programming language as a package and many language systems provide them as part of their standard library. In some languages, they are not only built into the standard system, but have special syntax, often using array-like subscripting.
</p><p>Built-in syntactic support for associative arrays was introduced in 1969 by SNOBOL4, under the name "table". TMG offered tables with string keys and integer values. MUMPS made multi-dimensional associative arrays, optionally persistent, its key data structure. SETL supported them as one possible implementation of sets and maps. Most modern scripting languages, starting with AWK and including Rexx,  Perl, PHP, Tcl, JavaScript, Maple, Python, Ruby, Wolfram Language, Go, and Lua, support associative arrays as a primary container type. In many more languages, they are available as library functions without special syntax.
</p><p>In Smalltalk, Objective-C, .NET,<sup class="reference" id="cite_ref-20">[20]</sup> Python, REALbasic, Swift, VBA and Delphi<sup class="reference" id="cite_ref-21">[21]</sup> they are called <i>dictionaries</i>; in Perl, Ruby and Seed7 they are called <i>hashes</i>; in C++, Java, Go, Clojure, Scala, OCaml, Haskell they are called <i>maps</i> (see map (C++), unordered_map (C++), and <code>Map</code>); in Common Lisp and Windows PowerShell, they are called <i>hash tables</i> (since both typically use this implementation);  in Maple and Lua, they are called <i>tables</i>. In PHP, all arrays can be associative, except that the keys are limited to integers and strings. In JavaScript (see also JSON), all objects behave as associative arrays with string-valued keys, while the Map and WeakMap types take arbitrary objects as keys. In Lua, they are used as the primitive building block for all data structures. In Visual FoxPro, they are called <i>Collections</i>. The D language also has support for associative arrays.<sup class="reference" id="cite_ref-22">[22]</sup>
</p>
<h2><span class="mw-headline" id="Permanent_storage">Permanent storage</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Many programs using associative arrays will at some point need to store that data in a more permanent form, like in a computer file. A common solution to this problem is a generalized concept known as <i>archiving</i> or <i>serialization</i>, which produces a text or binary representation of the original objects that can be written directly to a file. This is most commonly implemented in the underlying object model, like .Net or Cocoa, which include standard functions that convert the internal data into text form. The program can create a complete text representation of any group of objects by calling these methods, which are almost always already implemented in the base associative array class.<sup class="reference" id="cite_ref-23">[23]</sup>
</p><p>For programs that use very large data sets, this sort of individual file storage is not appropriate, and a database management system (DB) is required. Some DB systems natively store associative arrays by serializing the data and then storing that serialized data and the key. Individual arrays can then be loaded or saved from the database using the key to refer to them. These key–value stores have been used for many years and have a history as long as that as the more common relational database (RDBs), but a lack of standardization, among other reasons, limited their use to certain niche roles. RDBs were used for these roles in most cases, although saving objects to a RDB can be complicated, a problem known as object-relational impedance mismatch.
</p><p>After <abbr title="circa">c.</abbr><span style="white-space:nowrap;"> 2010</span>, the need for high performance databases suitable for cloud computing and more closely matching the internal structure of the programs using them led to a renaissance in the key–value store market. These systems can store and retrieve associative arrays in a native fashion, which can greatly improve performance in common web-related workflows.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1128808480">.mw-parser-output .portalbox{padding:0;display:table;box-sizing:border-box;max-width:175px}.mw-parser-output .portalborder{border:solid #aaa 1px;padding:0.1em;background:#f9f9f9}.mw-parser-output .portalbox-entry{display:table-row;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox-image{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox-link{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}@media(min-width:720px){.mw-parser-output .portalleft{clear:left;float:left;margin:0.5em 1em 0.5em 0}.mw-parser-output .portalright{clear:right;float:right;margin:0.5em 0 0.5em 1em}}</style>
<ul><li>Key–value database</li>
<li>Tuple</li>
<li>Function (mathematics)</li>
<li>JSON</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>NIST's Dictionary of Algorithms and Data Structures: Associative Array</li></ul>


<!-- 
NewPP limit report
Parsed by mw2268
Cached time: 20221223230925
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.454 seconds
Real time usage: 0.620 seconds
Preprocessor visited node count: 1815/1000000
Post‐expand include size: 63050/2097152 bytes
Template argument size: 873/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 14/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 70694/5000000 bytes
Lua time usage: 0.251/10.000 seconds
Lua memory usage: 8612523/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  491.899      1 -total
 48.09%  236.534      1 Template:Reflist
 17.27%   84.937      3 Template:Cite_journal
 14.39%   70.800      1 Template:Short_description
 10.30%   50.679      2 Template:Navbox
  9.95%   48.958      1 Template:Data_structures
  7.23%   35.582      2 Template:Harvtxt
  6.99%   34.393     10 Template:Cite_web
  6.92%   34.025      2 Template:Pagetype
  5.32%   26.182      1 Template:Redirect-distinguish
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:95154-0!canonical and timestamp 20221223230924 and revision id 1124515188.
 -->
</div></body>
</html>