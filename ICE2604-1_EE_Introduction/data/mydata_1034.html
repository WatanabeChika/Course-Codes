<!DOCTYPE html>
<html>
<head>
<title>treap</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><tbody><tr><th class="infobox-above" colspan="2">Treap</th></tr><tr><td class="infobox-image" colspan="2"><img alt="Treap.svg" data-file-height="233" data-file-width="286" decoding="async" height="179" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Treap.svg/220px-Treap.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Treap.svg/330px-Treap.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Treap.svg/440px-Treap.svg.png 2x" width="220"/></td></tr><tr><th class="infobox-label" scope="row">Type</th><td class="infobox-data">Randomized binary search tree</td></tr><tr><th class="infobox-header" colspan="2">Time complexity in big O notation</th></tr><tr><td class="infobox-full-data" colspan="2"><link href="mw-data:TemplateStyles:r1066479718" rel="mw-deduplicated-inline-style"/><table class="infobox-subbox infobox-3cols-child"><tbody><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Algorithm</th><td class="infobox-data infobox-data-a">
<b>Average</b></td><td class="infobox-data infobox-data-b">
<b>Worst case</b></td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Space</th><td class="infobox-data infobox-data-a">
<i>O</i>(<i>n</i>)</td><td class="infobox-data infobox-data-b">
<i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Search</th><td class="infobox-data infobox-data-a">
<i>O</i>(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
<i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Insert</th><td class="infobox-data infobox-data-a">
<i>O</i>(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
<i>O</i>(<i>n</i>)</td></tr><tr><th class="infobox-label" scope="row" style="white-space:nowrap;">Delete</th><td class="infobox-data infobox-data-a">
<i>O</i>(log <i>n</i>)</td><td class="infobox-data infobox-data-b">
<i>O</i>(<i>n</i>)</td></tr></tbody></table></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks"><tbody><tr><td class="sidebar-pretitle">Part of a series on</td></tr><tr><th class="sidebar-title-with-pretitle" style="background:#ccccff;">Probabilistic<br/>data structures</th></tr><tr><td class="sidebar-content hlist">
<ul><li>Bloom filter</li>
<li>Count–min sketch</li>
<li>Quotient filter</li>
<li>Skip list</li></ul></td>
</tr><tr><th class="sidebar-heading" style="background:#ddddff;">
Random trees</th></tr><tr><td class="sidebar-content hlist">
<ul><li>Random binary tree</li>
<li>Treap</li>
<li>Rapidly-exploring random tree</li></ul></td>
</tr><tr><th class="sidebar-heading" style="background:#ddddff;">
Related</th></tr><tr><td class="sidebar-content hlist">
<ul><li>Randomized algorithm</li>
<li>HyperLogLog</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p>In computer science, the <b>treap</b> and the <b>randomized binary search tree</b> are two closely related forms of binary search tree data structures that maintain a dynamic set of ordered keys and allow binary searches among the keys. After any sequence of insertions and deletions of keys, the shape of the tree is a random variable with the same probability distribution as a random binary tree; in particular, with high probability its height is proportional to the logarithm of the number of keys, so that each search, insertion, or deletion operation takes logarithmic time to perform.
</p>

<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"></span></h2>

<p>The treap was first described by Raimund Seidel and Cecilia R. Aragon in 1989;<sup class="reference" id="cite_ref-paper89_1-0">[1]</sup><sup class="reference" id="cite_ref-paper96_2-0">[2]</sup> its name is a portmanteau of tree and heap.
It is a Cartesian tree in which each key is given a (randomly chosen) numeric priority. As with any binary search tree, the inorder traversal order of the nodes is the same as the sorted order of the keys. The structure of the tree is determined by the requirement that it be heap-ordered: that is, the priority number for any non-leaf node must be greater than or equal to the priority of its children. Thus, as with Cartesian trees more generally, the root node is the maximum-priority node, and its left and right subtrees are formed in the same manner from the subsequences of the sorted order to the left and right of that node.
</p><p>An equivalent way of describing the treap is that it could be formed by inserting the nodes highest priority-first into a binary search tree without doing any rebalancing. Therefore, if the priorities are independent random numbers (from a distribution over a large enough space of possible priorities to ensure that two nodes are very unlikely to have the same priority) then the shape of a treap has the same probability distribution as the shape of a random binary search tree, a search tree formed by inserting the nodes without rebalancing in a randomly chosen insertion order.  Because random binary search trees are known to have logarithmic height with high probability, the same is true for treaps.  This mirrors the binary search tree argument that quicksort runs in expected <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n\log n)}</annotation>
</semantics>
</math></span><img alt="O(n\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1" style="vertical-align: -0.838ex; width:10.118ex; height:2.843ex;"/></span> time.  If binary search trees are solutions to the dynamic problem version of sorting, then Treaps correspond specifically to dynamic quicksort where priorities guide pivot choices.
</p><p>Aragon and Seidel also suggest assigning higher priorities to frequently accessed nodes, for instance by a process that, on each access, chooses a random number and replaces the priority of the node with that number if it is higher than the previous priority. This modification would cause the tree to lose its random shape; instead, frequently accessed nodes would be more likely to be near the root of the tree, causing searches for them to be faster.
</p><p>Naor and Nissim<sup class="reference" id="cite_ref-3">[3]</sup> describe an application in maintaining authorization certificates in public-key cryptosystems.
</p>
<h2><span class="mw-headline" id="Operations">Operations</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Basic_operations">Basic operations</span><span class="mw-editsection"></span></h3>
<p>Treaps support the following basic operations:
</p>
<ul><li>To search for a given key value, apply a standard binary search algorithm in a binary search tree, ignoring the priorities.</li>
<li>To insert a new key <i>x</i> into the treap, generate a random priority <i>y</i> for <i>x</i>. Binary search for <i>x</i> in the tree, and create a new node at the leaf position where the binary search determines a node for <i>x</i> should exist. Then, as long as <i>x</i> is not the root of the tree and has a larger priority number than its parent <i>z</i>, perform a tree rotation that reverses the parent-child relation between <i>x</i> and <i>z</i>.</li>
<li>To delete a node <i>x</i> from the treap, if <i>x</i> is a leaf of the tree, simply remove it. If <i>x</i> has a single child <i>z</i>, remove <i>x</i> from the tree and make <i>z</i> be the child of the parent of <i>x</i> (or make <i>z</i> the root of the tree if <i>x</i> had no parent). Finally, if <i>x</i> has two children, swap its position in the tree with the position of its immediate successor <i>z</i> in the sorted order, resulting in one of the previous cases. In this final case, the swap may violate the heap-ordering property for <i>z</i>, so additional rotations may need to be performed to restore this property.</li></ul>
<h3><span class="mw-headline" id="Building_a_treap">Building a treap</span><span class="mw-editsection"></span></h3>
<ul><li>To build a treap we can simply insert n values in the treap where each takes <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log n)}</annotation>
</semantics>
</math></span><img alt="O(\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" style="vertical-align: -0.838ex; width:8.336ex; height:2.843ex;"/></span> time. Therefore a treap can be built in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n\log n)}</annotation>
</semantics>
</math></span><img alt="O(n\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1" style="vertical-align: -0.838ex; width:10.118ex; height:2.843ex;"/></span> time from a list values.</li></ul>
<h3><span class="mw-headline" id="Bulk_operations">Bulk operations</span><span class="mw-editsection"></span></h3>
<p>In addition to the single-element insert, delete and lookup operations, several fast "bulk" operations have been defined on treaps: union, intersection and set difference. These rely on two helper operations, <i>split</i> and <i>join</i>.
</p>
<ul><li>To split a treap into two smaller treaps, those smaller than key <i>x</i>, and those larger than key <i>x</i>, insert <i>x</i> into the treap with maximum priority—larger than the priority of any node in the treap. After this insertion, <i>x</i> will be the root node of the treap, all values less than <i>x</i> will be found in the left subtreap, and all values greater than <i>x</i> will be found in the right subtreap. This costs as much as a single insertion into the treap.</li>
<li>Joining two treaps that are the product of a former split, one can safely assume that the greatest value in the first treap is less than the smallest value in the second treap. Create a new node with value <i>x</i>, such that <i>x</i> is larger than this max-value in the first treap and smaller than the min-value in the second treap, assign it the minimum priority, then set its left child to the first heap and its right child to the second heap. Rotate as necessary to fix the heap order. After that, it will be a leaf node, and can easily be deleted. The result is one treap merged from the two original treaps. This is effectively "undoing" a split, and costs the same. More generally, the join operation can work on two treaps and a key with arbitrary priority (i.e., not necessary to be the highest).</li></ul>

<p>The join algorithm is as follows:
</p>
<pre><b>function</b> join(L, k, R)
    <b>if</b> prior(k, k(L)) and prior(k, k(R)) <b>return</b> Node(L, k, R)
    <b>if</b> prior(k(L), k(R)) <b>return</b> Node(left(L), k(L), join(right(L), k, R))
    <b>return</b> Node(join(L, k, left(R)), k(R), right(R))
</pre>

<p>The split algorithm is as follows:
</p>
<pre><b>function</b> split(T, k)
    <b>if</b> (T = nil) <b>return</b> (nil, false, nil)
    (L, (m, c), R) = expose(T)
    <b>if</b> (k = m) <b>return</b> (L, true, R)
    <b>if</b> (k &lt; m) 
        (L', b, R') = split(L, k)
        <b>return</b> (L', b, join(R', m, R))
    <b>if</b> (k &gt; m) 
        (L', b, R') = split(R, k)
        <b>return</b> (join(L, m, L'), b, R'))
</pre>
<p>The union of two treaps <span class="texhtml"><i>t</i><sub>1</sub></span> and <span class="texhtml"><i>t</i><sub>2</sub></span>, representing sets <span class="texhtml mvar" style="font-style:italic;">A</span> and <span class="texhtml mvar" style="font-style:italic;">B</span> is a treap <span class="texhtml mvar" style="font-style:italic;"><i>t</i></span> that represents <span class="texhtml"><i>A</i> ∪ <i>B</i></span>. The following recursive algorithm computes the union:
</p>
<pre><b>function</b> union(t<sub>1</sub>, t<sub>2</sub>):
    <b>if</b> t<sub>1</sub> = nil:
        <b>return</b> t<sub>2</sub>
    <b>if</b> t<sub>2</sub> = nil:
        <b>return</b> t<sub>1</sub>
    <b>if</b> priority(t<sub>1</sub>) &lt; priority(t<sub>2</sub>):
        <b>swap</b> t<sub>1</sub> and t<sub>2</sub>
    t<sub>&lt;</sub>, t<sub>&gt;</sub> ← split t<sub>2</sub> on key(t<sub>1</sub>)
    <b>return</b> join(union(left(t<sub>1</sub>), t<sub>&lt;</sub>), key(t<sub>1</sub>),
                    union(right(t<sub>1</sub>), t<sub>&gt;</sub>))
</pre>
<p>Here, <i>split</i> is presumed to return two trees: one holding the keys less than its input key, one holding the greater keys. (The algorithm is non-destructive, but an in-place destructive version exists as well.)
</p><p>The algorithm for intersection is similar, but requires the <i>join</i> helper routine. The complexity of each of union, intersection and difference is <span class="texhtml"><i>O</i>(<i>m</i> log <style data-mw-deduplicate="TemplateStyles:r1050945101">.mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="sfrac tion" role="math"><span class="num"><i>n</i></span><span class="sr-only">/</span><span class="den"><i>m</i></span></span>)</span> for treaps of sizes <span class="texhtml mvar" style="font-style:italic;">m</span> and <span class="texhtml mvar" style="font-style:italic;">n</span>, with <span class="texhtml"><i>m</i> ≤ <i>n</i></span>. Moreover, since the recursive calls to union are independent of each other, they can be executed in parallel.<sup class="reference" id="cite_ref-4">[4]</sup>
</p><p>Split and Union call Join but do not deal with the balancing criteria of treaps directly, such an implementation is usually called the "join-based" implementation.
</p><p>Note that if hash values of keys are used as priorities and structurally equal nodes are merged already at construction, then each merged node will be a unique representation of a set of keys. Provided that there can only be one simultaneous root node representing a given set of keys, two sets can be tested for equality by pointer comparison, which is constant in time.
</p><p>This technique can be used to enhance the merge algorithms to perform fast also when the difference between two sets is small. If input sets are equal, the union and intersection functions could break immediately returning one of the input sets as result, while the difference function should return the empty set.
</p><p>Let <span class="texhtml mvar" style="font-style:italic;">d</span> be the size of the symmetric difference. The modified merge algorithms will then also be bounded by <span class="texhtml"><i>O</i>(<i>d</i> log <link href="mw-data:TemplateStyles:r1050945101" rel="mw-deduplicated-inline-style"/><span class="sfrac tion" role="math"><span class="num"><i>n</i></span><span class="sr-only">/</span><span class="den"><i>d</i></span></span>)</span>.<sup class="reference" id="cite_ref-5">[5]</sup><sup class="reference" id="cite_ref-Confluent_Sets_and_Maps_6-0">[6]</sup>
</p>
<h2><span class="mw-headline" id="Randomized_binary_search_tree">Randomized binary search tree</span><span class="mw-editsection"></span></h2>
<p>The randomized binary search tree, introduced by Martínez and Roura subsequently to the work of Aragon and Seidel on treaps,<sup class="reference" id="cite_ref-7">[7]</sup> stores the same nodes with the same random distribution of tree shape, but maintains different information within the nodes of the tree in order to maintain its randomized structure.
</p><p>Rather than storing random priorities on each node, the randomized binary search tree stores a small integer at each node, the number of its descendants (counting itself as one); these numbers may be maintained during tree rotation operations at only a constant additional amount of time per rotation. When a key <i>x</i> is to be inserted into a tree that already has <i>n</i> nodes, the insertion algorithm chooses with probability 1/(<i>n</i> + 1) to place <i>x</i> as the new root of the tree, and otherwise, it calls the insertion procedure recursively to insert <i>x</i> within the left or right subtree (depending on whether its key is less than or greater than the root). The numbers of descendants are used by the algorithm to calculate the necessary probabilities for the random choices at each step. Placing <i>x</i> at the root of a subtree may be performed either as in the treap by inserting it at a leaf and then rotating it upwards, or by an alternative algorithm described by Martínez and Roura that splits the subtree into two pieces to be used as the left and right children of the new node.
</p><p>The deletion procedure for a randomized binary search tree uses the same information per node as the insertion procedure, but unlike the insertion procedure, it only needs on average O(1) random decisions to join the two subtrees descending from the left and right children of the deleted node into a single tree. That is because the subtrees to be joined are on average at depth Θ(log n); joining two trees of size n and m needs Θ(log(n+m)) random choices on average. If the left or right subtree of the node to be deleted is empty, the join operation is trivial; otherwise, the left or right child of the deleted node is selected as the new subtree root with probability proportional to its number of descendants, and the join proceeds recursively.
</p>
<h3><span class="mw-headline" id="Comparison">Comparison</span><span class="mw-editsection"></span></h3>
<p>The information stored per node in the randomized binary tree is simpler than in a treap (a small integer rather than a high-precision random number), but it makes a greater number of calls to the random number generator (O(log <i>n</i>) calls per insertion or deletion rather than one call per insertion) and the insertion procedure is slightly more complicated due to the need to update the numbers of descendants per node. A minor technical difference is that, in a treap, there is a small probability of a collision (two keys getting the same priority), and in both cases, there will be statistical differences between a true random number generator and the pseudo-random number generator typically used on digital computers. However, in any case, the differences between the theoretical model of perfect random choices used to design the algorithm and the capabilities of actual random number generators are vanishingly small.
</p><p>Although the treap and the randomized binary search tree both have the same random distribution of tree shapes after each update, the history of modifications to the trees performed by these two data structures over a sequence of insertion and deletion operations may be different. For instance, in a treap, if the three numbers 1, 2, and 3 are inserted in the order 1, 3, 2, and then the number 2 is deleted, the remaining two nodes will have the same parent-child relationship that they did prior to the insertion of the middle number. In a randomized binary search tree, the tree after the deletion is equally likely to be either of the two possible trees on its two nodes, independently of what the tree looked like prior to the insertion of the middle number.
</p>
<h2><span class="mw-headline" id="Implicit_treap">Implicit treap</span><span class="mw-editsection"></span></h2>
<p>An implicit treap <sup class="reference" id="cite_ref-:0_8-0">[8]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><span title="The material near this tag may rely on an unreliable source. (December 2021)">unreliable source?</span></i>]</sup> is a simple variation of an ordinary treap which can be viewed as a dynamic array that supports the following operations in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log n)}</annotation>
</semantics>
</math></span><img alt="O(\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" style="vertical-align: -0.838ex; width:8.336ex; height:2.843ex;"/></span>:
</p>
<ul><li>Inserting an element in any position</li>
<li>Removing an element from any position</li>
<li>Finding sum, minimum or maximum element in a given range.</li>
<li>Addition, painting in a given range</li>
<li>Reversing elements in a given range</li></ul>
<p>The idea behind an implicit treap is to store the indices of the array elements in the treap. The actual values of elements will not be explicitly stored in the treap otherwise an update (insertion/deletion) would result in changes of the key in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation>
</semantics>
</math></span><img alt="O(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;"/></span> nodes of the tree and this is very slow. 
</p><p>The key value (<b>implicit key)</b> of a node T is the number of nodes less than that node plus one. Note that such nodes can be present not only in its left subtree but also in left subtrees of its ancestors P,  if T is in the right subtree of P.
</p><p>Therefore we can quickly calculate the implicit key of the current node as we perform an operation by accumulating the sum of all nodes as we descend the tree. Note that this sum does not change when we visit the left subtree but it will increase by <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle cnt(T\rightarrow L)+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>c</mi>
<mi>n</mi>
<mi>t</mi>
<mo stretchy="false">(</mo>
<mi>T</mi>
<mo stretchy="false">→<!-- → --></mo>
<mi>L</mi>
<mo stretchy="false">)</mo>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle cnt(T\rightarrow L)+1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle cnt(T\rightarrow L)+1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1ac469de00351eecb8649a1f4f5be6443148a7c8" style="vertical-align: -0.838ex; width:15.887ex; height:2.843ex;"/></span> when we visit the right subtree.
</p><p>
The join algorithm for an implicit treap is as follows:</p><p><sup class="reference" id="cite_ref-:0_8-1">[8]</sup>
The split algorithm for an implicit treap is as follows:</p><p><sup class="reference" id="cite_ref-:0_8-2">[8]</sup>
</p><h3><span class="mw-headline" id="Operations_2">Operations</span><span class="mw-editsection"></span></h3>
<h4><span class="mw-headline" id="Insert_element">Insert element</span><span class="mw-editsection"></span></h4>
<p>To insert an element at position <i>pos</i> we divide the array into two subsections <i>[0...pos-1]</i> and <i>[pos..sz]</i> by calling the <i><b>split</b></i> function and we get two trees <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T1}</annotation>
</semantics>
</math></span><img alt="T1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/94f4fd16a519756f5b03cf0222c305c9a6ddc8f0" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1635c7fd497b7dc6e33f845aa9dd0525430ecc48" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> . Then we merge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T1}</annotation>
</semantics>
</math></span><img alt="T1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/94f4fd16a519756f5b03cf0222c305c9a6ddc8f0" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> with the new node by calling the <i><b>join</b></i> function. Finally we call the join function to merge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T1}</annotation>
</semantics>
</math></span><img alt="T1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/94f4fd16a519756f5b03cf0222c305c9a6ddc8f0" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1635c7fd497b7dc6e33f845aa9dd0525430ecc48" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span>.
</p>
<h4><span class="mw-headline" id="Delete_element">Delete element</span><span class="mw-editsection"></span></h4>
<p>We find the element to be deleted and perform a join on its children L and R. We then replace the element to be deleted with the tree that resulted from the join operation. 
</p>
<h4><span id="Find_sum.2C_minimum_or_maximum_in_a_given_range"></span><span class="mw-headline" id="Find_sum,_minimum_or_maximum_in_a_given_range">Find sum, minimum or maximum in a given range</span><span class="mw-editsection"></span></h4>
<p>To perform this calculation we will proceed as follows:
</p>
<ul><li>First we will create an additional field F to store the value of the target function for the range represented by that node. we will create a function that calculates the value F based on the values of the L and R children of the node. We will call this target function at the end of all functions that modify the tree, <i>i.e.</i>, split and join.</li>
<li>Second we need to process a query for a given range [A..B]: We will call the <b>s<i>plit</i></b> function twice and split the treap into <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T1}</annotation>
</semantics>
</math></span><img alt="T1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/94f4fd16a519756f5b03cf0222c305c9a6ddc8f0" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> which contains <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \{1..A-1\}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">{</mo>
<mn>1..</mn>
<mi>A</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo fence="false" stretchy="false">}</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \{1..A-1\}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \{1..A-1\}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9afd65ec48b1fce512e29f42004ac88403e68c50" style="vertical-align: -0.838ex; width:10.527ex; height:2.843ex;"/></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1635c7fd497b7dc6e33f845aa9dd0525430ecc48" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span> which contains <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \{A..B\}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">{</mo>
<mi>A</mi>
<mo>.</mo>
<mo>.</mo>
<mi>B</mi>
<mo fence="false" stretchy="false">}</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \{A..B\}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \{A..B\}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a3603f5fcfcd8d7f1eb8a876bdacf6bce6e39445" style="vertical-align: -0.838ex; width:7.9ex; height:2.843ex;"/></span>, and <i><b><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle T3}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>T</mi>
<mn>3</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle T3}</annotation>
</semantics>
</math></span><img alt="{\displaystyle T3}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2bd33f8a66ad38a4c7ae885b620805551a53dbda" style="vertical-align: -0.338ex; width:2.799ex; height:2.176ex;"/></span></b></i> which contains <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \{B+1..n\}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo fence="false" stretchy="false">{</mo>
<mi>B</mi>
<mo>+</mo>
<mn>1..</mn>
<mi>n</mi>
<mo fence="false" stretchy="false">}</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \{B+1..n\}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \{B+1..n\}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e2c3f9eb82ae10d90df7efb02b50fd75df8fdc40" style="vertical-align: -0.838ex; width:10.78ex; height:2.843ex;"/></span>. After the query is answered we will call the <i><b>join</b></i> function twice to restore the original treap.</li></ul>
<h4><span id="Addition.2Fpainting_in_a_given_range"></span><span class="mw-headline" id="Addition/painting_in_a_given_range">Addition/painting in a given range</span><span class="mw-editsection"></span></h4>
<p>To perform this operation we will proceed as follows:
</p>
<ul><li>We will create an extra field D which will contain the added value for the subtree. We will create a function <i><b>push</b></i> which will be used to propagate this change from a node to its children. We will call this function at the beginning of all functions which modify the tree, <i>i.e.</i>, split and join so that after any changes made to the tree the information will not be lost.</li></ul>
<h4><span class="mw-headline" id="Reverse_in_a_given_range">Reverse in a given range</span><span class="mw-editsection"></span></h4>
<p>To show that the subtree of a given node needs to be reversed for each node we will create an extra boolean field R and set its value to true. To propagate this change we will swap the children of the node and set R to true for all of them.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Finger search</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Collection of treap references and info by Cecilia Aragon</li>
<li>Open Data Structures - Section 7.2 - Treap: A Randomized Binary Search Tree, Pat Morin</li>
<li>Animated treap</li>
<li>Randomized binary search trees. Lecture notes from a course by Jeff Erickson at UIUC. Despite the title, this is primarily about treaps and skip lists; randomized binary search trees are mentioned only briefly.</li>
<li>A high-performance key-value store based on treap by Junyi Sun</li>
<li>VB6 implementation of treaps. Visual basic 6 implementation of treaps as a COM object.</li>
<li>ActionScript3 implementation of a treap</li>
<li>Pure Python and Cython in-memory treap and duptreap</li>
<li>Treaps in C#. By Roy Clemmons</li>
<li>Pure Go in-memory, immutable treaps</li>
<li>Pure Go persistent treap key-value storage library</li></ul>

<!-- 
NewPP limit report
Parsed by mw2390
Cached time: 20221220211216
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.336 seconds
Real time usage: 0.852 seconds
Preprocessor visited node count: 1871/1000000
Post‐expand include size: 48343/2097152 bytes
Template argument size: 2673/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 4/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 43729/5000000 bytes
Lua time usage: 0.170/10.000 seconds
Lua memory usage: 6573706/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  332.051      1 -total
 33.63%  111.668      1 Template:Reflist
 24.55%   81.525      5 Template:Citation
 14.84%   49.263      1 Template:Infobox_data_structure
 13.43%   44.592      1 Template:Infobox
 12.45%   41.356      1 Template:Commonscat
 12.41%   41.222      1 Template:Probabilistic
 11.98%   39.791      1 Template:Sidebar
 11.61%   38.558      1 Template:Sister_project
 11.10%   36.853      1 Template:Side_box
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:249855-0!canonical and timestamp 20221220211215 and revision id 1102216662.
 -->
</div></body>
</html>