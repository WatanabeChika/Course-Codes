<!DOCTYPE html>
<html>
<head>
<title>compact_DAWG</title>
</head>
<body>
<div class="mw-parser-output">
<p>In computer science, a <b>deterministic acyclic finite state automaton</b> (<b>DAFSA</b>),<sup class="reference" id="cite_ref-daciuk_1-0">[1]</sup>
also called a <b>directed acyclic word graph</b> (<b>DAWG</b>; though that name also refers to a related data structure that functions as a suffix index<sup class="reference" id="cite_ref-2">[2]</sup>)
is a data structure that represents a set of strings, and allows for a query operation that tests whether a given string belongs to the set in time proportional to its length. Algorithms exist to construct and maintain such automata,<sup class="reference" id="cite_ref-daciuk_1-1">[1]</sup> while keeping them minimal.
</p><p>A DAFSA is a special case of a finite state recognizer that takes the form of a directed acyclic graph with a single source vertex (a vertex with no incoming edges), in which each edge of the graph is labeled by a letter or symbol, and in which each vertex has at most one outgoing edge for each possible letter or symbol. The strings represented by the DAFSA are formed by the symbols on paths in the graph from the source vertex to any sink vertex (a vertex with no outgoing edges). In fact, a deterministic finite state automaton is acyclic if and only if it recognizes a finite set of strings.<sup class="reference" id="cite_ref-daciuk_1-2">[1]</sup>
</p>
<h2><span class="mw-headline" id="Comparison_to_tries">Comparison to tries</span><span class="mw-editsection"></span></h2>
<p>By allowing the same vertices to be reached by multiple paths, a DAFSA may use significantly fewer vertices than the strongly related trie data structure. Consider, for example, the four English words "tap", "taps", "top", and "tops". A trie for those four words would have 12 vertices, one for each of the strings formed as a prefix of one of these words, or for one of the words followed by the end-of-string marker. However, a DAFSA can represent these same four words using only six vertices <i>v<sub>i</sub></i> for 0 ≤ <i>i</i> ≤ 5, and the following edges: an edge from <i>v</i><sub>0</sub> to <i>v</i><sub>1</sub> labeled "t", two edges from <i>v</i><sub>1</sub> to <i>v</i><sub>2</sub> labeled "a" and "o", an edge from <i>v</i><sub>2</sub> to <i>v</i><sub>3</sub> labeled "p", an edge <i>v</i><sub>3</sub> to <i>v</i><sub>4</sub> labeled "s", and edges from <i>v</i><sub>3</sub> and <i>v</i><sub>4</sub> to <i>v</i><sub>5</sub> labeled with the end-of-string marker. There is a tradeoff between memory and functionality, because a standard DAFSA can tell you if a word exists within it, but it cannot point you to auxiliary information about that word, whereas a trie can.
</p><p>The primary difference between DAFSA and trie is the elimination of suffix and infix redundancy in storing strings. The trie eliminates prefix redundancy since all common prefixes are shared between strings, such as between <i>doctors</i> and <i>doctorate</i> the <i>doctor</i> prefix is shared. In a DAFSA common suffixes are also shared, for words that have the same set of possible suffixes as each other. For dictionary sets of common English words, this translates into major memory usage reduction.
</p><p>Because the terminal nodes of a DAFSA can be reached by multiple paths, a DAFSA cannot directly store auxiliary information relating to each path, e.g. a word's frequency in the English language. However, if for each node we store the number of unique paths through that point in the structure, we can use it to retrieve the index of a word, or a word given its index.<sup class="reference" id="cite_ref-kowaltowski1993_3-0">[3]</sup> The auxiliary information can then be stored in an array.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFBlumerBlumerHausslerEhrenfeucht1985">Blumer, A.; Blumer, J.; Haussler, D.; Ehrenfeucht, A.; Chen, M.T.; Seiferas, J. (1985), "The smallest automaton recognizing the subwords of a text", <i>Theoretical Computer Science</i>, <b>40</b>: 31–55, doi:<span class="cs1-lock-free" title="Freely accessible">10.1016/0304-3975(85)90157-4</span></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.atitle=The+smallest+automaton+recognizing+the+subwords+of+a+text&amp;rft.volume=40&amp;rft.pages=31-55&amp;rft.date=1985&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2885%2990157-4&amp;rft.aulast=Blumer&amp;rft.aufirst=A.&amp;rft.au=Blumer%2C+J.&amp;rft.au=Haussler%2C+D.&amp;rft.au=Ehrenfeucht%2C+A.&amp;rft.au=Chen%2C+M.T.&amp;rft.au=Seiferas%2C+J.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADeterministic+acyclic+finite+state+automaton"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFAppelJacobsen1988">Appel, Andrew; Jacobsen, Guy (1988), "The World's Fastest Scrabble Program" <span class="cs1-format">(PDF)</span>, <i>Communications of the ACM</i>, <b>31</b> (5): 572–578, doi:10.1145/42411.42420</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=The+World%27s+Fastest+Scrabble+Program&amp;rft.volume=31&amp;rft.issue=5&amp;rft.pages=572-578&amp;rft.date=1988&amp;rft_id=info%3Adoi%2F10.1145%2F42411.42420&amp;rft.aulast=Appel&amp;rft.aufirst=Andrew&amp;rft.au=Jacobsen%2C+Guy&amp;rft_id=https%3A%2F%2Fwww.cs.cmu.edu%2Fafs%2Fcs%2Facademic%2Fclass%2F15451-s06%2Fwww%2Flectures%2Fscrabble.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADeterministic+acyclic+finite+state+automaton"></span>. One of the early mentions of the data structure.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFJansenBoekee1990">Jansen, Cees J. A.; Boekee, Dick E. (1990), "On the significance of the directed acyclic word graph in cryptology", <i>Advances in Cryptology — AUSCRYPT '90</i>, Lecture Notes in Computer Science, vol. 453, Springer-Verlag, pp. 318–326, doi:10.1007/BFb0030372, ISBN <bdi>3-540-53000-2</bdi></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=On+the+significance+of+the+directed+acyclic+word+graph+in+cryptology&amp;rft.btitle=Advances+in+Cryptology+%E2%80%94+AUSCRYPT+%2790&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=318-326&amp;rft.pub=Springer-Verlag&amp;rft.date=1990&amp;rft_id=info%3Adoi%2F10.1007%2FBFb0030372&amp;rft.isbn=3-540-53000-2&amp;rft.aulast=Jansen&amp;rft.aufirst=Cees+J.+A.&amp;rft.au=Boekee%2C+Dick+E.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADeterministic+acyclic+finite+state+automaton"></span>.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFEpifanioMignosiShallitVenturini2004">Epifanio, Chiara; Mignosi, Filippo; Shallit, Jeffrey; Venturini, Ilaria (2004), "Sturmian graphs and a conjecture of Moser",  in Calude, Cristian S.; Calude, Elena; Dineen, Michael J. (eds.), <i>Developments in language theory. Proceedings, 8th international conference (DLT 2004), Auckland, New Zealand, December 2004</i>, Lecture Notes in Computer Science, vol. 3340, Springer-Verlag, pp. 175–187, ISBN <bdi>3-540-24014-4</bdi>, Zbl 1117.68454</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Sturmian+graphs+and+a+conjecture+of+Moser&amp;rft.btitle=Developments+in+language+theory.+Proceedings%2C+8th+international+conference+%28DLT+2004%29%2C+Auckland%2C+New+Zealand%2C+December+2004&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=175-187&amp;rft.pub=Springer-Verlag&amp;rft.date=2004&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A1117.68454%23id-name%3DZbl&amp;rft.isbn=3-540-24014-4&amp;rft.aulast=Epifanio&amp;rft.aufirst=Chiara&amp;rft.au=Mignosi%2C+Filippo&amp;rft.au=Shallit%2C+Jeffrey&amp;rft.au=Venturini%2C+Ilaria&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADeterministic+acyclic+finite+state+automaton"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFTresoldi2020">Tresoldi, Tiago (2020), "DAFSA: a Python library for Deterministic Acyclic Finite State Automata", <i>Journal of Open Source Software</i>, <b>5</b> (46): 1986, doi:<span class="cs1-lock-free" title="Freely accessible">10.21105/joss.01986</span></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+Open+Source+Software&amp;rft.atitle=DAFSA%3A+a+Python+library+for+Deterministic+Acyclic+Finite+State+Automata&amp;rft.volume=5&amp;rft.issue=46&amp;rft.pages=1986&amp;rft.date=2020&amp;rft_id=info%3Adoi%2F10.21105%2Fjoss.01986&amp;rft.aulast=Tresoldi&amp;rft.aufirst=Tiago&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADeterministic+acyclic+finite+state+automaton"></span> An open source Python implementation.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>"Directed Acyclic Word Graph or DAWG" – JohnPaul Adamovsky teaches how to construct a DAFSA using an array of integers (Archived 22 July 2022 at the Wayback Machine)</li>
<li>"Caroline Word Graph or CWG" – JohnPaul Adamovsky teaches how to construct a DAFSA hash function using a novel encoding with multiple integer arrays (Archived 27 July 2022 at the Wayback Machine)</li></ul>



<!-- 
NewPP limit report
Parsed by mw2375
Cached time: 20221220231354
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.258 seconds
Real time usage: 0.404 seconds
Preprocessor visited node count: 1317/1000000
Post‐expand include size: 64852/2097152 bytes
Template argument size: 5494/2097152 bytes
Highest expansion depth: 19/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 27439/5000000 bytes
Lua time usage: 0.152/10.000 seconds
Lua memory usage: 5429772/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  280.864      1 -total
 47.71%  133.998      1 Template:Reflist
 37.60%  105.603      1 Template:DADS
 33.71%   94.691      3 Template:If_empty
 17.41%   48.910      1 Template:Commonscat
 16.28%   45.735      1 Template:Sister_project
 15.88%   44.597      1 Template:Formal_languages_and_grammars
 15.76%   44.259      1 Template:Side_box
 15.20%   42.693      1 Template:Navbox_with_columns
  9.13%   25.652      2 Template:If_then_show
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:6022680-0!canonical and timestamp 20221220231353 and revision id 1118341453.
 -->
</div></body>
</html>