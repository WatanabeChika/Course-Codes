<!DOCTYPE html>
<html>
<head>
<title>reduced_ordered_binary_decision_diagram</title>
</head>
<body>
<div class="mw-parser-output">
<p class="mw-empty-elt">
</p>
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>In computer science, a <b>binary decision diagram</b> (<b>BDD</b>) or <b>branching program</b> is a data structure that is used to represent a Boolean function. On a more abstract level, BDDs can be considered as a compressed representation of sets or relations. Unlike other compressed representations, operations are performed directly on the compressed representation, i.e. without decompression.
</p><p>Similar data structures include negation normal form (NNF), Zhegalkin polynomials, and propositional directed acyclic graphs (PDAG).
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>A Boolean function can be represented as a rooted, directed, acyclic graph, which consists of several (decision) nodes and two terminal nodes. The two terminal nodes are labeled 0 (FALSE) and 1 (TRUE). Each (decision) node <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle u}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>u</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle u}</annotation>
</semantics>
</math></span><img alt="u" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span> is labeled by a Boolean variable <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}}</annotation>
</semantics>
</math></span><img alt="x_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e87000dd6142b81d041896a30fe58f0c3acb2158" style="vertical-align: -0.671ex; width:2.129ex; height:2.009ex;"/></span> and has two child nodes called low child and high child. The edge from node <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle u}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>u</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle u}</annotation>
</semantics>
</math></span><img alt="u" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" style="vertical-align: -0.338ex; width:1.33ex; height:1.676ex;"/></span> to a low (or high) child represents an assignment of the value FALSE (or TRUE, respectively) to variable <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{i}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{i}}</annotation>
</semantics>
</math></span><img alt="x_{i}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e87000dd6142b81d041896a30fe58f0c3acb2158" style="vertical-align: -0.671ex; width:2.129ex; height:2.009ex;"/></span>. Such a <b>BDD</b> is called 'ordered' if different variables appear in the same order on all paths from the root. A BDD is said to be 'reduced' if the following two rules have been applied to its graph:
</p>
<ul><li>Merge any isomorphic subgraphs.</li>
<li>Eliminate any node whose two children are isomorphic.</li></ul>
<p>In popular usage, the term <b>BDD</b> almost always refers to <b>Reduced Ordered Binary Decision Diagram</b> (<b>ROBDD</b> in the literature, used when the ordering and reduction aspects need to be emphasized). The advantage of an ROBDD is that it is canonical (unique) for a particular function and variable order.<sup class="reference" id="cite_ref-Bryant1986_1-0">[1]</sup> This property makes it useful in functional equivalence checking and other operations like functional technology mapping.
</p><p>A path from the root node to the 1-terminal represents a (possibly partial) variable assignment for which the represented Boolean function is true. As the path descends to a low (or high) child from a node, then that node's variable is assigned to 0 (respectively 1).
</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h3>
<p>The left figure below shows a binary decision <i>tree</i> (the reduction rules are not applied), and a truth table, each representing the function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(x1,x2,x3)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mn>1</mn>
<mo>,</mo>
<mi>x</mi>
<mn>2</mn>
<mo>,</mo>
<mi>x</mi>
<mn>3</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(x1,x2,x3)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(x1,x2,x3)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d7c7b99770c8dff4ebef7f45d2cad3f8e2f4d6d" style="vertical-align: -0.838ex; width:12.632ex; height:2.843ex;"/></span>. In the tree on the left, the value of the function can be determined for a given variable assignment by following a path down the graph to a terminal. In the figures below, dotted lines represent edges to a low child, while solid lines represent edges to a high child. Therefore, to find <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(0,1,1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(0,1,1)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(0,1,1)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ef2534a25c2b7984d4531b70b5a5dd3e9b528ccf" style="vertical-align: -0.838ex; width:8.643ex; height:2.843ex;"/></span>, begin at x1, traverse down the dotted line to x2 (since x1 has an assignment to 0), then down two solid lines (since x2 and x3 each have an assignment to one). This leads to the terminal 1, which is the value of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(0,1,1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(0,1,1)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle f(0,1,1)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ef2534a25c2b7984d4531b70b5a5dd3e9b528ccf" style="vertical-align: -0.838ex; width:8.643ex; height:2.843ex;"/></span>.
</p><p>The binary decision <i>tree</i> of the left figure can be transformed into a binary decision <i>diagram</i> by maximally reducing it according to the two reduction rules. The resulting <b>BDD</b> is shown in the right figure.
</p>
<table align="center">
<tbody><tr>
<td>
</td>
<td>
</td></tr></tbody></table>
<p>Another notation for writing this Boolean function is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\overline {x}}_{1}{\overline {x}}_{2}{\overline {x}}_{3}+x_{1}x_{2}+x_{2}x_{3}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>x</mi>
<mo accent="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>x</mi>
<mo accent="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<msub>
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mi>x</mi>
<mo accent="false">¯<!-- ¯ --></mo>
</mover>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\overline {x}}_{1}{\overline {x}}_{2}{\overline {x}}_{3}+x_{1}x_{2}+x_{2}x_{3}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\overline {x}}_{1}{\overline {x}}_{2}{\overline {x}}_{3}+x_{1}x_{2}+x_{2}x_{3}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d021c22850cf4c11efd9c2b391a71d5c465f3e63" style="vertical-align: -0.671ex; width:22.713ex; height:2.676ex;"/></span>.
</p>
<h3><span class="mw-headline" id="Complemented_edges">Complemented edges</span><span class="mw-editsection"></span></h3>

<p>An ROBDD can be represented even more compactly, using complemented edges.<sup class="reference" id="cite_ref-Brace_2-0">[2]</sup><sup class="reference" id="cite_ref-Somenzi1999_3-0">[3]</sup> Complemented edges are formed by annotating low edges as complemented or not. If an edge is complemented, then it refers to the negation of the Boolean function that corresponds to the node that the edge points to (the Boolean function represented by the BDD with root that node). High edges are not complemented, in order to ensure that the resulting BDD representation is a canonical form. In this representation, BDDs have a single leaf node, for reasons explained below.
</p><p>Two advantages of using complemented edges when representing BDDs are:
</p>
<ul><li>computing the negation of a BDD takes constant time</li>
<li>space usage (i.e., required memory) is reduced</li></ul>
<p>A reference to a BDD in this representation is a (possibly complemented) "edge" that points to the root of the BDD. This is in contrast to a reference to a BDD in the representation without use of complemented edges, which is the root node of the BDD. The reason why a reference in this representation needs to be an edge is that for each Boolean function, the function and its negation are represented by an edge to the root of a BDD, and a complemented edge to the root of the same BDD. This is why negation takes constant time. It also explains why a single leaf node suffices: FALSE is represented by a complemented edge that points to the leaf node, and TRUE is represented by an ordinary edge (i.e., not complemented) that points to the leaf node.
</p><p>For example, assume that a Boolean function is represented with a BDD represented using complemented edges. To find the value of the Boolean function for a given assignment of (Boolean) values to the variables, we start at the reference edge, which points to the BDD's root, and follow the path that is defined by the given variable values (following a low edge if the variable that labels a node equals FALSE, and following the high edge if the variable that labels a node equals TRUE), until we reach the leaf node. While following this path, we count how many complemented edges we have traversed. If when we reach the leaf node we have crossed an odd number of complemented edges, then the value of the Boolean function for the given variable assignment is FALSE, otherwise (if we have crossed an even number of complemented edges), then the value of the Boolean function for the given variable assignment is TRUE.
</p><p>An example diagram of a BDD in this representation is shown on the right, and represents the same Boolean expression as shown in diagrams above, i.e., <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (\neg x_{1}\wedge \neg x_{2}\wedge \neg x_{3})\vee (x_{1}\wedge x_{2})\vee (x_{2}\wedge x_{3})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi mathvariant="normal">¬<!-- ¬ --></mi>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<mi mathvariant="normal">¬<!-- ¬ --></mi>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<mi mathvariant="normal">¬<!-- ¬ --></mi>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>∨<!-- ∨ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>∨<!-- ∨ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>∧<!-- ∧ --></mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (\neg x_{1}\wedge \neg x_{2}\wedge \neg x_{3})\vee (x_{1}\wedge x_{2})\vee (x_{2}\wedge x_{3})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle (\neg x_{1}\wedge \neg x_{2}\wedge \neg x_{3})\vee (x_{1}\wedge x_{2})\vee (x_{2}\wedge x_{3})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b682e94f83d732c838e0e047f47bdc53631ba48" style="vertical-align: -0.838ex; width:42.262ex; height:2.843ex;"/></span>. Low edges are dashed, high edges solid, and complemented edges are signified by a "-1" label. The node whose label starts with an @ symbol represents the reference to the BDD, i.e., the reference edge is the edge that starts from this node.
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>The basic idea from which the data structure was created is the Shannon expansion. A switching function is split into two sub-functions (cofactors) by assigning one variable (cf. <i>if-then-else normal form</i>). If such a sub-function is considered as a sub-tree, it can be represented by a <i>binary decision tree</i>. Binary decision diagrams (BDDs) were introduced by C. Y. Lee,<sup class="reference" id="cite_ref-Lee_4-0">[4]</sup> and further studied and made known by Sheldon B. Akers<sup class="reference" id="cite_ref-Akers_5-0">[5]</sup> and Raymond T. Boute.<sup class="reference" id="cite_ref-Boute_1976_6-0">[6]</sup> Independently of these authors, a BDD under the name "canonical bracket form" was realized Yu. V. Mamrukov in a CAD for analysis of speed-independent circuits.<sup class="reference" id="cite_ref-7">[7]</sup> The full potential for efficient algorithms based on the data structure was investigated by Randal Bryant at Carnegie Mellon University: his key extensions were to use a fixed variable ordering (for canonical representation) and shared sub-graphs (for compression). Applying these two concepts results in an efficient data structure and algorithms for the representation of sets and relations.<sup class="reference" id="cite_ref-Bryant-1986_8-0">[8]</sup><sup class="reference" id="cite_ref-Bryant-1992_9-0">[9]</sup> By extending the sharing to several BDDs, i.e. one sub-graph is used by several BDDs, the data structure <i>Shared Reduced Ordered Binary Decision Diagram</i> is defined.<sup class="reference" id="cite_ref-Brace_2-1">[2]</sup> The notion of a BDD is now generally used to refer to that particular data structure.
</p><p>In his video lecture <i>Fun With Binary Decision Diagrams (BDDs)</i>,<sup class="reference" id="cite_ref-Stanford_10-0">[10]</sup> Donald Knuth calls BDDs "one of the only really fundamental data structures that came out in the last twenty-five years" and mentions that Bryant's 1986 paper was for some time one of the most-cited papers in computer science.
</p><p>Adnan Darwiche and his collaborators have shown that BDDs are one of several normal forms for Boolean functions, each induced by a different combination of requirements. Another important normal form identified by Darwiche is decomposable negation normal form or DNNF.
</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>BDDs are extensively used in CAD software to synthesize circuits (logic synthesis) and in formal verification. There are several lesser known applications of BDD, including fault tree analysis, Bayesian reasoning, product configuration, and private information retrieval.<sup class="reference" id="cite_ref-Jensen_11-0">[11]</sup><sup class="reference" id="cite_ref-Lipmaa_12-0">[12]</sup><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="Please provide examples of these applications in the literature. (June 2010)">citation needed</span></i>]</sup>
</p><p>Every arbitrary BDD (even if it is not reduced or ordered) can be directly implemented in hardware by replacing each node with a 2 to 1 multiplexer; each multiplexer can be directly implemented by a 4-LUT in a FPGA. It is not so simple to convert from an arbitrary network of logic gates to a BDD<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (March 2008)">citation needed</span></i>]</sup> (unlike the and-inverter graph).
</p>
<h2><span class="mw-headline" id="Variable_ordering">Variable ordering</span><span class="mw-editsection"></span></h2>
<p>The size of the BDD is determined both by the function being represented and by the chosen ordering of the variables. There exist Boolean functions <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(x_{1},\ldots ,x_{n})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(x_{1},\ldots ,x_{n})}</annotation>
</semantics>
</math></span><img alt="f(x_{1},\ldots ,x_{{n}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/61d6311d8c66acc1a5755c4c7cb688d3b1fa0fcb" style="vertical-align: -0.838ex; width:13.198ex; height:2.843ex;"/></span> for which depending upon the ordering of the variables we would end up getting a graph whose number of nodes would be linear (in <i>n</i>) at best and exponential at worst (e.g., a ripple carry adder). Consider the Boolean function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle f(x_{1},\ldots ,x_{2n})=x_{1}x_{2}+x_{3}x_{4}+\cdots +x_{2n-1}x_{2n}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>f</mi>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>=</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>4</mn>
</mrow>
</msub>
<mo>+</mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>+</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
</mrow>
</msub>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle f(x_{1},\ldots ,x_{2n})=x_{1}x_{2}+x_{3}x_{4}+\cdots +x_{2n-1}x_{2n}.}</annotation>
</semantics>
</math></span><img alt="f(x_{1},\ldots ,x_{{2n}})=x_{1}x_{2}+x_{3}x_{4}+\cdots +x_{{2n-1}}x_{{2n}}." aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d3c11771a2a595ecc332972ffa6881394825b490" style="vertical-align: -0.838ex; width:47.386ex; height:2.843ex;"/></span> Using the variable ordering <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{1}&lt;x_{3}&lt;\cdots &lt;x_{2n-1}&lt;x_{2}&lt;x_{4}&lt;\cdots &lt;x_{2n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>4</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{1}&lt;x_{3}&lt;\cdots &lt;x_{2n-1}&lt;x_{2}&lt;x_{4}&lt;\cdots &lt;x_{2n}}</annotation>
</semantics>
</math></span><img alt="x_{1}&lt;x_{3}&lt;\cdots &lt;x_{{2n-1}}&lt;x_{2}&lt;x_{4}&lt;\cdots &lt;x_{{2n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/57d1b63f47a2d32344d8468b37c70165f1df8179" style="vertical-align: -0.671ex; width:45.512ex; height:2.176ex;"/></span>, the BDD needs <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{n+1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{n+1}}</annotation>
</semantics>
</math></span><img alt="2^{n+1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87ec7da881b9da391c503b68a69a46ba3c43e189" style="vertical-align: -0.338ex; width:4.481ex; height:2.676ex;"/></span> nodes to represent the function.  Using the ordering <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle x_{1}&lt;x_{2}&lt;x_{3}&lt;x_{4}&lt;\cdots &lt;x_{2n-1}&lt;x_{2n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>4</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>&lt;</mo>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle x_{1}&lt;x_{2}&lt;x_{3}&lt;x_{4}&lt;\cdots &lt;x_{2n-1}&lt;x_{2n}}</annotation>
</semantics>
</math></span><img alt="x_{1}&lt;x_{2}&lt;x_{3}&lt;x_{4}&lt;\cdots &lt;x_{{2n-1}}&lt;x_{{2n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3fe4147015540234dd811270e827f1153a44db67" style="vertical-align: -0.671ex; width:39.69ex; height:2.176ex;"/></span>, the BDD consists of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2n+2}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>2</mn>
<mi>n</mi>
<mo>+</mo>
<mn>2</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2n+2}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2n+2}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2605e13cf9776ba0b511e395b804e8105efab862" style="vertical-align: -0.505ex; width:6.56ex; height:2.343ex;"/></span> nodes.
</p>
<table align="center">
<tbody><tr>
<td>
</td>
<td>
</td></tr></tbody></table>
<p>It is of crucial importance to care about variable ordering when applying this data structure in practice. The problem of finding the best variable ordering is NP-hard.<sup class="reference" id="cite_ref-Bollig_13-0">[13]</sup> For any constant <i>c</i> &gt; 1 it is even NP-hard to compute a variable ordering resulting in an OBDD with a size that is at most <i>c</i> times larger than an optimal one.<sup class="reference" id="cite_ref-Sieling_14-0">[14]</sup> However, there exist efficient heuristics to tackle the problem.<sup class="reference" id="cite_ref-Rice_15-0">[15]</sup>
</p><p>There are functions for which the graph size is always exponential—independent of variable ordering. This holds e.g. for the multiplication function.<sup class="reference" id="cite_ref-Bryant1986_1-1">[1]</sup> In fact, the function computing the middle bit of the product of two <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n}</annotation>
</semantics>
</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span>-bit numbers does not have an OBDD smaller than <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 2^{\lfloor n/2\rfloor }/61-4}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo fence="false" stretchy="false">⌊<!-- ⌊ --></mo>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>2</mn>
<mo fence="false" stretchy="false">⌋<!-- ⌋ --></mo>
</mrow>
</msup>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mn>61</mn>
<mo>−<!-- − --></mo>
<mn>4</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 2^{\lfloor n/2\rfloor }/61-4}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 2^{\lfloor n/2\rfloor }/61-4}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b5dfcb672db51c29c8bba68124e6c41a9fe3d472" style="vertical-align: -0.838ex; width:12.975ex; height:3.343ex;"/></span> vertices.<sup class="reference" id="cite_ref-Woelfel_2005_16-0">[16]</sup> (If the multiplication function had polynomial-size OBDDs, it would show that integer factorization is in P/poly, which is not known to be true.<sup class="reference" id="cite_ref-Lipton_2009_17-0">[17]</sup>)
</p><p>Researchers have suggested refinements on the BDD data structure giving way to a number of related graphs, such as BMD (binary moment diagrams), ZDD (zero-suppressed decision diagram), FDD (free binary decision diagrams), PDD (parity decision diagrams), and MTBDDs (multiple terminal BDDs).
</p>
<h2><span class="mw-headline" id="Logical_operations_on_BDDs">Logical operations on BDDs</span><span class="mw-editsection"></span></h2>
<p>Many logical operations on BDDs can be implemented by polynomial-time graph manipulation algorithms:<sup class="reference" id="cite_ref-Andersen_1999_18-0">[18]</sup><sup class="reference nowrap"><span title="Page / location: 20">: 20 </span></sup>
</p>
<ul><li>conjunction</li>
<li>disjunction</li>
<li>negation</li></ul>
<p>However, repeating these operations several times, for example forming the conjunction or disjunction of a set of BDDs, may in the worst case result in an exponentially big BDD. This is because any of the preceding operations for two BDDs may result in a BDD with a size proportional to the product of the BDDs' sizes, and consequently for several BDDs the size may be exponential in the number of operations. Variable ordering needs to be considered afresh; what may be a good ordering for (some of) the set of BDDs may not be a good ordering for the result of the operation. Also, since constructing the BDD of a Boolean function solves the NP-complete Boolean satisfiability problem and the co-NP-complete tautology problem, constructing the BDD can take exponential time in the size of the Boolean formula even when the resulting BDD is small.
</p><p>Computing existential abstraction over multiple variables of reduced BDDs is NP-complete.<sup class="reference" id="cite_ref-Huth_19-0">[19]</sup>
</p><p>Model-counting, counting the number of satisfying assignments of a Boolean formula, can be done in polynomial time for BDDs. For general propositional formulas the problem is ♯P-complete and the best known algorithms require an exponential time in the worst case.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Boolean satisfiability problem, the canonical NP-complete computational problem</li>
<li>L/poly, a complexity class that strictly contains the set of problems with polynomially sized BDDs<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (February 2020)">citation needed</span></i>]</sup></li>
<li>Model checking</li>
<li>Radix tree</li>
<li>Barrington's theorem</li>
<li>Hardware acceleration</li>
<li>Karnaugh map, a method of simplifying Boolean algebra expressions</li>
<li>Zero-suppressed decision diagram</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1 cs1-prop-foreign-lang-source" id="CITEREFUbar1976">Ubar, R. (1976). "Test Generation for Digital Circuits Using Alternative Graphs". <i>Proc. Tallinn Technical University</i> (in Russian). Tallinn, Estonia (409): 75–81.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proc.+Tallinn+Technical+University&amp;rft.atitle=Test+Generation+for+Digital+Circuits+Using+Alternative+Graphs&amp;rft.issue=409&amp;rft.pages=75-81&amp;rft.date=1976&amp;rft.aulast=Ubar&amp;rft.aufirst=R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+decision+diagram"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFKnuth2009">Knuth, D.E. (2009). <i>Fascicle 1: Bitwise tricks &amp; techniques; Binary Decision Diagrams</i>. The Art of Computer Programming. Vol. 4. Addison–Wesley. ISBN <bdi>978-0-321-58050-4</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Fascicle+1%3A+Bitwise+tricks+%26+techniques%3B+Binary+Decision+Diagrams&amp;rft.series=The+Art+of+Computer+Programming&amp;rft.pub=Addison%E2%80%93Wesley&amp;rft.date=2009&amp;rft.isbn=978-0-321-58050-4&amp;rft.aulast=Knuth&amp;rft.aufirst=D.E.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+decision+diagram"></span> Draft of Fascicle 1b available for download.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFMeinelTheobald2012">Meinel, C.; Theobald, T. (2012) [1998]. <i>Algorithms and Data Structures in VLSI-Design: OBDD – Foundations and Applications</i> <span class="cs1-format">(PDF)</span>. Springer. ISBN <bdi>978-3-642-58940-9</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithms+and+Data+Structures+in+VLSI-Design%3A+OBDD+%E2%80%93+Foundations+and+Applications&amp;rft.pub=Springer&amp;rft.date=2012&amp;rft.isbn=978-3-642-58940-9&amp;rft.aulast=Meinel&amp;rft.aufirst=C.&amp;rft.au=Theobald%2C+T.&amp;rft_id=http%3A%2F%2Fwww.hpi.uni-potsdam.de%2Ffileadmin%2Fhpi%2FFG_ITS%2Fbooks%2FOBDD-Book.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+decision+diagram"></span> Complete textbook available for download.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFEbendtFeyDrechsler2005">Ebendt, Rüdiger; Fey, Görschwin; Drechsler, Rolf (2005). <i>Advanced BDD optimization</i>. Springer. ISBN <bdi>978-0-387-25453-1</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Advanced+BDD+optimization&amp;rft.pub=Springer&amp;rft.date=2005&amp;rft.isbn=978-0-387-25453-1&amp;rft.aulast=Ebendt&amp;rft.aufirst=R%C3%BCdiger&amp;rft.au=Fey%2C+G%C3%B6rschwin&amp;rft.au=Drechsler%2C+Rolf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+decision+diagram"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBeckerDrechsler1998">Becker, Bernd; Drechsler, Rolf (1998). <i>Binary Decision Diagrams: Theory and Implementation</i>. Springer. ISBN <bdi>978-1-4419-5047-5</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Binary+Decision+Diagrams%3A+Theory+and+Implementation&amp;rft.pub=Springer&amp;rft.date=1998&amp;rft.isbn=978-1-4419-5047-5&amp;rft.aulast=Becker&amp;rft.aufirst=Bernd&amp;rft.au=Drechsler%2C+Rolf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABinary+decision+diagram"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Fun With Binary Decision Diagrams (BDDs), lecture by Donald Knuth</li>
<li>List of BDD software libraries for several programming languages.</li></ul>


<!-- 
NewPP limit report
Parsed by mw2367
Cached time: 20221224003738
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.468 seconds
Real time usage: 0.693 seconds
Preprocessor visited node count: 2528/1000000
Post‐expand include size: 67117/2097152 bytes
Template argument size: 3814/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 7/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 74020/5000000 bytes
Lua time usage: 0.278/10.000 seconds
Lua memory usage: 7301950/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  514.456      1 -total
 41.51%  213.555      1 Template:Reflist
 26.00%  133.765     10 Template:Cite_journal
 11.32%   58.246      1 Template:Short_description
  8.78%   45.174      3 Template:Citation_needed
  8.67%   44.594      9 Template:Cite_book
  8.35%   42.980      1 Template:Commons_category
  8.24%   42.416      1 Template:Data_structures
  7.97%   40.990      1 Template:Sister_project
  7.83%   40.265      1 Template:Navbox
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:576855-0!canonical and timestamp 20221224003737 and revision id 1124624694.
 -->
</div></body>
</html>