<!DOCTYPE html>
<html>
<head>
<title>Euler_cycle</title>
</head>
<body>
<div class="mw-parser-output">


<p>In graph theory, an <b>Eulerian trail</b> (or <b>Eulerian path</b>) is a trail in a finite graph that visits every edge exactly once (allowing for revisiting vertices). Similarly, an <b>Eulerian circuit</b> or <b>Eulerian cycle</b> is an Eulerian trail that starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Königsberg problem in 1736. The problem can be stated mathematically like this:
</p>
<dl><dd>Given the graph in the image, is it possible to construct a path (or a cycle; i.e., a path starting and ending on the same vertex) that visits each edge exactly once?</dd></dl>
<p>Euler proved that a necessary condition for the existence of Eulerian circuits is that all vertices in the graph have an even degree, and stated without proof that connected graphs with all vertices of even degree have an Eulerian circuit. The first complete proof of this latter claim was published posthumously in 1873 by Carl Hierholzer.<sup class="reference" id="cite_ref-1">[1]</sup> This is known as <b>Euler's Theorem:</b>
</p>
<dl><dd>A connected graph has an Euler cycle if and only if every vertex has even degree.</dd></dl>
<p>The term <b>Eulerian graph</b> has two common meanings in graph theory. One meaning is a graph with an Eulerian circuit, and the other is a graph with every vertex of even degree. These definitions coincide for connected graphs.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>For the existence of Eulerian trails it is necessary that zero or two vertices have an odd degree; this means the Königsberg graph is <i>not</i> Eulerian. If there are no vertices of odd degree, all Eulerian trails are circuits. If there are exactly two vertices of odd degree, all Eulerian trails start at one of them and end at the other. A graph that has an Eulerian trail but not an Eulerian circuit is called <b>semi-Eulerian</b>.
</p>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"></span></h2>
<p>An <b>Eulerian trail</b>,<sup class="reference" id="cite_ref-pathcycle_3-0">[3]</sup>  or <b>Euler walk</b>, in an undirected graph is a walk that uses each edge exactly once. If such a walk exists, the graph is called <b>traversable</b> or <b>semi-eulerian</b>.<sup class="reference" id="cite_ref-4">[4]</sup>
</p><p>An <b>Eulerian cycle</b>,<sup class="reference" id="cite_ref-pathcycle_3-1">[3]</sup> also called an <b>Eulerian circuit</b> or <b>Euler tour</b>, in an undirected graph is a cycle that uses each edge exactly once.  If such a cycle exists, the graph is called <b>Eulerian</b> or <b>unicursal</b>.<sup class="reference" id="cite_ref-5">[5]</sup>  The term "Eulerian graph" is also sometimes used in a weaker sense to denote a graph where every vertex has even degree. For finite connected graphs the two definitions are equivalent, while a possibly unconnected graph is Eulerian in the weaker sense if and only if each connected component has an Eulerian cycle.
</p><p>For directed graphs, "path" has to be replaced with <i>directed path</i> and "cycle" with <i>directed cycle</i>.
</p><p>The definition and properties of Eulerian trails, cycles and graphs are valid for multigraphs as well.
</p><p>An <b>Eulerian orientation</b> of an undirected graph <i>G</i> is an assignment of a direction to each edge of <i>G</i> such that, at each vertex <i>v</i>, the indegree of <i>v</i> equals the outdegree of <i>v</i>. Such an orientation exists for any undirected graph in which every vertex has even degree, and may be found by constructing an Euler tour in each connected component of <i>G</i> and then orienting the edges according to the tour.<sup class="reference" id="cite_ref-6">[6]</sup> Every Eulerian orientation of a connected graph is a strong orientation, an orientation that makes the resulting directed graph strongly connected.
</p>
<h2><span class="mw-headline" id="Properties">Properties</span><span class="mw-editsection"></span></h2>
<ul><li>An undirected graph has an Eulerian cycle if and only if every vertex has even degree, and all of its vertices with nonzero degree belong to a single connected component.</li>
<li>An undirected graph can be decomposed into edge-disjoint cycles if and only if all of its vertices have even degree. So, a graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint cycles and its nonzero-degree vertices belong to a single connected component.</li>
<li>An undirected graph has an Eulerian trail if and only if exactly zero or two vertices have odd degree, and all of its vertices with nonzero degree belong to a single connected component</li>
<li>A directed graph has an Eulerian cycle if and only if every vertex has equal in degree and out degree, and all of its vertices with nonzero degree belong to a single strongly connected component. Equivalently, a directed graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint directed cycles and all of its vertices with nonzero degree belong to a single strongly connected component.</li>
<li>A directed graph has an Eulerian trail if and only if at most one vertex has <span class="nowrap">(out-degree) − (in-degree) = 1,</span> at most one vertex has <span class="nowrap">(in-degree) − (out-degree) = 1,</span> every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="why this instead of just in the same SCC? (June 2021)">citation needed</span></i>]</sup></li></ul>
<h2><span class="mw-headline" id="Constructing_Eulerian_trails_and_circuits">Constructing Eulerian trails and circuits</span><span class="mw-editsection"></span></h2>

<h3><span id="Fleury.27s_algorithm"></span><span class="mw-headline" id="Fleury's_algorithm">Fleury's algorithm</span><span class="mw-editsection"></span></h3>
<p><b>Fleury's algorithm</b> is an elegant but inefficient algorithm that dates to 1883.<sup class="reference" id="cite_ref-7">[7]</sup> Consider a graph known to have all edges in the same component and at most two vertices of odd degree. The algorithm starts at a vertex of odd degree, or, if the graph has none, it starts with an arbitrarily chosen vertex. At each step it chooses the next edge in the path to be one whose deletion would not disconnect the graph, unless there is no such edge, in which case it picks the remaining edge left at the current vertex. It then moves to the other endpoint of that edge and deletes the edge. At the end of the algorithm there are no edges left, and the sequence from which the edges were chosen forms an Eulerian cycle if the graph has no vertices of odd degree, or an Eulerian trail if there are exactly two vertices of odd degree.
</p><p>While the <i>graph traversal</i> in Fleury's algorithm is linear in the number of edges, i.e. <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|E|)}</annotation>
</semantics>
</math></span><img alt="O(|E|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" style="vertical-align: -0.838ex; width:6.652ex; height:2.843ex;"/></span>, we also need to factor in the complexity of detecting bridges. If we are to re-run Tarjan's linear time bridge-finding algorithm<sup class="reference" id="cite_ref-8">[8]</sup> after the removal of every edge,  Fleury's algorithm will have a time complexity of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|E|^{2})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<msup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|E|^{2})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(|E|^{2})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/430cae9262acb02aa62e68e9835fb0e577f735d7" style="vertical-align: -0.838ex; width:7.706ex; height:3.343ex;"/></span>. A dynamic bridge-finding algorithm of Thorup (2000) allows this to be improved to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|E|\cdot \log ^{3}|E|\cdot \log \log |E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<msup>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>3</mn>
</mrow>
</msup>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>⋅<!-- ⋅ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|E|\cdot \log ^{3}|E|\cdot \log \log |E|)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(|E|\cdot \log ^{3}|E|\cdot \log \log |E|)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cd17fd356eb91b705b87da3f3c7b07e0e1e7cdbe" style="vertical-align: -0.838ex; width:27.279ex; height:3.176ex;"/></span>, but this is still significantly slower than alternative algorithms.
</p>
<h3><span id="Hierholzer.27s_algorithm"></span><span class="mw-headline" id="Hierholzer's_algorithm">Hierholzer's algorithm</span><span class="mw-editsection"></span></h3>
<p>Hierholzer's 1873 paper provides a different method for finding Euler cycles that is more efficient than Fleury's algorithm:
</p>
<ul><li>Choose any starting vertex <i>v</i>, and follow a trail of edges from that vertex until returning to <i>v</i>. It is not possible to get stuck at any vertex other than <i>v</i>, because the even degree of all vertices ensures that, when the trail enters another vertex <i>w</i> there must be an unused edge leaving <i>w</i>. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph.</li>
<li>As long as there exists a vertex <i>u</i> that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from <i>u</i>, following unused edges until returning to <i>u</i>, and join the tour formed in this way to the previous tour.</li>
<li>Since we assume the original graph is connected, repeating the previous step will exhaust all edges of the graph.</li></ul>
<p>By using a data structure such as a doubly linked list to maintain the set of unused edges incident to each vertex, to maintain the list of vertices on the current tour that have unused edges, and to maintain the tour itself, the individual operations of the algorithm (finding unused edges exiting each vertex, finding a new starting vertex for a tour, and connecting two tours that share a vertex) may be performed in constant time each, so the overall algorithm takes linear time, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(|E|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(|E|)}</annotation>
</semantics>
</math></span><img alt="O(|E|)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" style="vertical-align: -0.838ex; width:6.652ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-9">[9]</sup>
</p><p>This algorithm may also be implemented with a deque. Because it is only possible to get stuck when the deque represents a closed tour, one should rotate the deque by removing edges from the tail and adding them to the head until unstuck, and then continue until all edges are accounted for. This also takes linear time, as the number of rotations performed is never larger than <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle |E|}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>E</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle |E|}</annotation>
</semantics>
</math></span><img alt="|E|" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8c2b9637808cf805d411190b4ae017dbd4ef8d8" style="vertical-align: -0.838ex; width:3.069ex; height:2.843ex;"/></span> (intuitively, any "bad" edges are moved to the head, while fresh edges are added to the tail)
</p>

<h2><span class="mw-headline" id="Counting_Eulerian_circuits">Counting Eulerian circuits</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Complexity_issues">Complexity issues</span><span class="mw-editsection"></span></h3>
<p>The number of Eulerian circuits in <i>digraphs</i> can be calculated using the so-called <b>BEST theorem</b>, named after de <b>B</b>ruijn, van Aardenne-<b>E</b>hrenfest, <b>S</b>mith and <b>T</b>utte.  The formula states that the number of Eulerian circuits in a digraph is the product of certain degree factorials and the number of rooted arborescences.  The latter can be computed as a determinant, by the matrix tree theorem, giving a polynomial time algorithm.
</p><p>BEST theorem is first stated in this form in a "note added in proof" to the Aardenne-Ehrenfest and de Bruijn paper (1951).  The original proof was bijective and generalized the de Bruijn sequences.  It is a variation on an earlier result by Smith and Tutte (1941).
</p><p>Counting the number of Eulerian circuits on <i>undirected</i> graphs is much more difficult. This problem is known to be #P-complete.<sup class="reference" id="cite_ref-10">[10]</sup> In a positive direction, a Markov chain Monte Carlo approach, via the <i>Kotzig transformations</i> (introduced by Anton Kotzig in 1968) is believed to give a sharp approximation for the number of Eulerian circuits in a graph, though as yet there is no proof of this fact (even for graphs of bounded degree).
</p>
<h3><span class="mw-headline" id="Special_cases">Special cases</span><span class="mw-editsection"></span></h3>
<p>The asymptotic formula for the number of Eulerian circuits in the complete graphs was determined by McKay and Robinson (1995):<sup class="reference" id="cite_ref-11">[11]</sup>
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \operatorname {ec} (K_{n})=2^{\frac {(n+1)}{2}}\pi ^{\frac {1}{2}}e^{{\frac {-n^{2}}{2}}+{\frac {11}{12}}}n^{\frac {(n-2)(n+1)}{2}}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ec</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mi>K</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</msup>
<msup>
<mi>π<!-- π --></mi>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
</msup>
<msup>
<mi>e</mi>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mo>−<!-- − --></mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>11</mn>
<mn>12</mn>
</mfrac>
</mrow>
</mrow>
</msup>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>2</mn>
<mo stretchy="false">)</mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</msup>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-OPEN">
<mo maxsize="1.2em" minsize="1.2em">(</mo>
</mrow>
</mrow>
<mn>1</mn>
<mo>+</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>−<!-- − --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
<mo>+</mo>
<mi>ϵ<!-- ϵ --></mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-CLOSE">
<mo maxsize="1.2em" minsize="1.2em">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \operatorname {ec} (K_{n})=2^{\frac {(n+1)}{2}}\pi ^{\frac {1}{2}}e^{{\frac {-n^{2}}{2}}+{\frac {11}{12}}}n^{\frac {(n-2)(n+1)}{2}}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \operatorname {ec} (K_{n})=2^{\frac {(n+1)}{2}}\pi ^{\frac {1}{2}}e^{{\frac {-n^{2}}{2}}+{\frac {11}{12}}}n^{\frac {(n-2)(n+1)}{2}}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b17e3e06f478e361a860afeb76c7d2bdf6574cf8" style="vertical-align: -1.005ex; width:53.52ex; height:4.843ex;"/></span></dd></dl>
<p>A similar formula was later obtained by M.I. Isaev (2009) for complete bipartite graphs:<sup class="reference" id="cite_ref-12">[12]</sup>
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \operatorname {ec} (K_{n,n})=({\frac {n}{2}}-1)!^{2n}2^{n^{2}-n+{\frac {1}{2}}}\pi ^{-n+{\frac {1}{2}}}n^{n-1}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ec</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<msub>
<mi>K</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>n</mi>
<mn>2</mn>
</mfrac>
</mrow>
<mo>−<!-- − --></mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<msup>
<mo>!</mo>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
<mi>n</mi>
</mrow>
</msup>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>−<!-- − --></mo>
<mi>n</mi>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
</mrow>
</msup>
<msup>
<mi>π<!-- π --></mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>−<!-- − --></mo>
<mi>n</mi>
<mo>+</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
</mrow>
</msup>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msup>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-OPEN">
<mo maxsize="1.2em" minsize="1.2em">(</mo>
</mrow>
</mrow>
<mn>1</mn>
<mo>+</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo>−<!-- − --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
<mo>+</mo>
<mi>ϵ<!-- ϵ --></mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-CLOSE">
<mo maxsize="1.2em" minsize="1.2em">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \operatorname {ec} (K_{n,n})=({\frac {n}{2}}-1)!^{2n}2^{n^{2}-n+{\frac {1}{2}}}\pi ^{-n+{\frac {1}{2}}}n^{n-1}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \operatorname {ec} (K_{n,n})=({\frac {n}{2}}-1)!^{2n}2^{n^{2}-n+{\frac {1}{2}}}\pi ^{-n+{\frac {1}{2}}}n^{n-1}{\bigl (}1+O(n^{-{\frac {1}{2}}+\epsilon }){\bigr )}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47d1b45b11f58c219cdb6d6493c9b06c32b3e832" style="vertical-align: -1.838ex; width:58.641ex; height:5.009ex;"/></span></dd></dl>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Eulerian trails are used in bioinformatics to reconstruct the DNA sequence from its fragments.<sup class="reference" id="cite_ref-13">[13]</sup> They are also used in CMOS circuit design to find an optimal logic gate ordering.<sup class="reference" id="cite_ref-14">[14]</sup> There are some algorithms for processing trees that rely on an Euler tour of the tree (where each edge is treated as a pair of arcs).<sup class="reference" id="cite_ref-15">[15]</sup><sup class="reference" id="cite_ref-16">[16]</sup> The de Bruijn sequences can be constructed as Eulerian trails of de Bruijn graphs.<sup class="reference" id="cite_ref-17">[17]</sup>
</p>
<h2><span class="mw-headline" id="In_infinite_graphs">In infinite graphs</span><span class="mw-editsection"></span></h2>

<p>In an infinite graph, the corresponding concept to an Eulerian trail or Eulerian cycle is an Eulerian line, a doubly-infinite trail that covers all of the edges of the graph. It is not sufficient for the existence of such a trail that the graph be connected and that all vertex degrees be even; for instance, the infinite Cayley graph shown, with all vertex degrees equal to four, has no Eulerian line. The infinite graphs that contain Eulerian lines were characterized by Erdõs, Grünwald &amp; Weiszfeld (1936). For an infinite graph or multigraph <span class="texhtml mvar" style="font-style:italic;">G</span> to have an Eulerian line, it is necessary and sufficient that all of the following conditions be met:<sup class="reference" id="cite_ref-18">[18]</sup><sup class="reference" id="cite_ref-19">[19]</sup>
</p>
<ul><li><span class="texhtml mvar" style="font-style:italic;">G</span> is connected.</li>
<li><span class="texhtml mvar" style="font-style:italic;">G</span> has countable sets of vertices and edges.</li>
<li><span class="texhtml mvar" style="font-style:italic;">G</span> has no vertices of (finite) odd degree.</li>
<li>Removing any finite subgraph <span class="texhtml mvar" style="font-style:italic;">S</span> from <span class="texhtml mvar" style="font-style:italic;">G</span> leaves at most two infinite connected components in the remaining graph, and if <span class="texhtml mvar" style="font-style:italic;">S</span> has even degree at each of its vertices then removing <span class="texhtml mvar" style="font-style:italic;">S</span> leaves exactly one infinite connected component.</li></ul>
<h2><span class="mw-headline" id="Undirected_Eulerian_graphs">Undirected Eulerian graphs</span><span class="mw-editsection"></span></h2>
<p>Euler stated a necessary condition for a graph to be Eulerian as all vertices must have even degree. Hierholzer proved this is a sufficient condition in a paper published in 1873. This leads to the following necessary and sufficient statement for what a graph must have to be Eulerian: An undirected connected graph is Eulerian if and only if every vertex of G has even degree.<sup class="reference" id="cite_ref-:0_20-0">[20]</sup>
</p><p>
The following result was proved by Veblen in 1912: An undirected connected graph is Eulerian if and only if it is the disjoint union of some cycles.<sup class="reference" id="cite_ref-:0_20-1">[20]</sup></p><p>Hierholzer developed a linear time algorithm for constructing an Eulerian tour in an undirected graph.
</p><h2><span class="mw-headline" id="Directed_Eulerian_graphs">Directed Eulerian graphs</span><span class="mw-editsection"></span></h2>
<p>It is possible to have a directed graph that has all even degrees but is not Eulerian. This means that even degrees is not a sufficient condition for a digraph to be Eulerian. König proved that a digraph must also have the same number of arcs entering and leaving each vertex to be Eulerian. In other words, the directed graph must be symmetric. A directed and strongly connected graph is Eulerian if and only if every vertex of G is symmetric.<sup class="reference" id="cite_ref-:0_20-2">[20]</sup>
</p><p>Hierholzer's linear time algorithm for constructing an Eulerian tour is also applicable to directed graphs.<sup class="reference" id="cite_ref-:0_20-3">[20]</sup>
</p>
<h2><span class="mw-headline" id="Mixed_Eulerian_graphs">Mixed Eulerian graphs</span><span class="mw-editsection"></span></h2>

<p>If a mixed graph has even degrees only, it is not guaranteed to be an Eulerian graph. This means that evenness is a necessary but not sufficient condition for a mixed graph to be Eulerian. If a mixed graph is even and symmetric, it is guaranteed to be symmetric. This means that evenness and being symmetric is a necessary condition for a mixed graph to be Eulerian. This is not a necessary and sufficient condition however, because it is possible to construct a graph that is even and not symmetric that is still Eulerian.<sup class="reference" id="cite_ref-:02_21-0">[21]</sup>
</p><p>Ford and Fulkerson proved in 1962 in their book Flows in Networks a necessary and sufficient condition for a graph to be Eulerian, viz., that every vertex must be even and satisfy the balance condition. For every subset of vertices S, the difference between the number of arcs leaving S and entering S must be less than or equal to the number of edges incident with S. This is the balanced set condition. A mixed and strongly connected graph is Eulerian if and only if G is even and balanced.<sup class="reference" id="cite_ref-:02_21-1">[21]</sup>
</p><p>
The process of checking if a mixed graph is Eulerian is harder than checking if an undirected or directed graph is Eulerian because the balanced set condition concerns every possible subset of vertices.</p>

<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Eulerian matroid, an abstract generalization of Eulerian graphs</li>
<li>Five room puzzle</li>
<li>Handshaking lemma, proven by Euler in his original paper, showing that any undirected connected graph has an even number of odd-degree vertices</li>
<li>Hamiltonian path – a path that visits each <i>vertex</i> exactly once.</li>
<li>Route inspection problem, search for the shortest path that visits all edges, possibly repeating edges if an Eulerian path does not exist.</li>
<li>Veblen's theorem, which states that graphs with even vertex degree can be partitioned into edge-disjoint cycles regardless of their connectivity</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2 cs1-prop-foreign-lang-source" id="CITEREFErdõsGrünwaldWeiszfeld1936">Erdõs, Pál; Grünwald, Tibor; Weiszfeld, Endre (1936), "Végtelen gráfok Euler vonalairól" [On Euler lines of infinite graphs] <span class="cs1-format">(PDF)</span>, <i>Mat. Fix. Lapok</i> (in Hungarian), <b>43</b>: 129–140</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Mat.+Fix.+Lapok&amp;rft.atitle=V%C3%A9gtelen+gr%C3%A1fok+Euler+vonalair%C3%B3l&amp;rft.volume=43&amp;rft.pages=129-140&amp;rft.date=1936&amp;rft.aulast=Erd%C3%B5s&amp;rft.aufirst=P%C3%A1l&amp;rft.au=Gr%C3%BCnwald%2C+Tibor&amp;rft.au=Weiszfeld%2C+Endre&amp;rft_id=https%3A%2F%2Fwww.renyi.hu%2F~p_erdos%2F1936-11.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEulerian+path"></span>.  Translated as <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2 cs1-prop-foreign-lang-source" id="CITEREFErdősGrünwaldVázsonyi1938">Erdős, P.; Grünwald, T.; Vázsonyi, E. (1938), "Über Euler-Linien unendlicher Graphen" [On Eulerian lines in infinite graphs] <span class="cs1-format">(PDF)</span>, <i>J. Math. Phys.</i> (in German), <b>17</b> (1–4): 59–75, doi:10.1002/sapm193817159</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=J.+Math.+Phys.&amp;rft.atitle=%C3%9Cber+Euler-Linien+unendlicher+Graphen&amp;rft.volume=17&amp;rft.issue=1%E2%80%934&amp;rft.pages=59-75&amp;rft.date=1938&amp;rft_id=info%3Adoi%2F10.1002%2Fsapm193817159&amp;rft.aulast=Erd%C5%91s&amp;rft.aufirst=P.&amp;rft.au=Gr%C3%BCnwald%2C+T.&amp;rft.au=V%C3%A1zsonyi%2C+E.&amp;rft_id=http%3A%2F%2Fwww.renyi.hu%2F~p_erdos%2F1938-15.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEulerian+path"></span>.</li>
<li>Euler, L., "Solutio problematis ad geometriam situs pertinentis", <i>Comment. Academiae Sci. I. Petropolitanae</i> <b>8</b> (1736), 128–140.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFHierholzer1873">Hierholzer, Carl (1873), "Ueber die Möglichkeit, einen Linienzug ohne Wiederholung und ohne Unterbrechung zu umfahren", <i>Mathematische Annalen</i>, <b>6</b> (1): 30–32, doi:10.1007/BF01442866, S2CID 119885172</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Mathematische+Annalen&amp;rft.atitle=Ueber+die+M%C3%B6glichkeit%2C+einen+Linienzug+ohne+Wiederholung+und+ohne+Unterbrechung+zu+umfahren&amp;rft.volume=6&amp;rft.issue=1&amp;rft.pages=30-32&amp;rft.date=1873&amp;rft_id=info%3Adoi%2F10.1007%2FBF01442866&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A119885172%23id-name%3DS2CID&amp;rft.aulast=Hierholzer&amp;rft.aufirst=Carl&amp;rft_id=https%3A%2F%2Fzenodo.org%2Frecord%2F1447429&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEulerian+path"></span>.</li>
<li>Lucas, E., <i>Récréations Mathématiques IV</i>, Paris, 1921.</li>
<li>Fleury, "Deux problemes de geometrie de situation", <i>Journal de mathematiques elementaires</i> (1883), 257–261.</li>
<li>T. van Aardenne-Ehrenfest and N. G. de Bruijn (1951) "Circuits and trees in oriented linear graphs", Simon Stevin 28: 203–217.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFThorup2000">Thorup, Mikkel (2000), "Near-optimal fully-dynamic graph connectivity", <i>Proc. 32nd ACM Symposium on Theory of Computing</i>, pp. 343–350, doi:10.1145/335305.335345, S2CID 128282</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Near-optimal+fully-dynamic+graph+connectivity&amp;rft.btitle=Proc.+32nd+ACM+Symposium+on+Theory+of+Computing&amp;rft.pages=343-350&amp;rft.date=2000&amp;rft_id=info%3Adoi%2F10.1145%2F335305.335345&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A128282%23id-name%3DS2CID&amp;rft.aulast=Thorup&amp;rft.aufirst=Mikkel&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEulerian+path"></span></li>
<li>W. T. Tutte and C. A. B. Smith (1941) "On Unicursal Paths in a Network of Degree 4", American Mathematical Monthly 48: 233–237.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Discussion of early mentions of Fleury's algorithm.</li>
<li><i>Euler tour</i> at Encyclopedia of Mathematics.</li></ul>
<!-- 
NewPP limit report
Parsed by mw2311
Cached time: 20221223231432
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.389 seconds
Real time usage: 0.556 seconds
Preprocessor visited node count: 2001/1000000
Post‐expand include size: 48847/2097152 bytes
Template argument size: 1767/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 63790/5000000 bytes
Lua time usage: 0.185/10.000 seconds
Lua memory usage: 8336532/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  407.816      1 -total
 45.49%  185.521      1 Template:Reflist
 19.25%   78.499      7 Template:Cite_journal
 15.36%   62.651      1 Template:Short_description
 11.43%   46.597     10 Template:Citation
 10.71%   43.691      1 Template:ISBN
  8.78%   35.786      1 Template:Catalog_lookup_link
  8.67%   35.356      1 Template:Commons_category
  8.56%   34.923      2 Template:Harvtxt
  8.20%   33.425      1 Template:Sister_project
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:333219-0!canonical and timestamp 20221223231432 and revision id 1127100342.
 -->
</div></body>
</html>