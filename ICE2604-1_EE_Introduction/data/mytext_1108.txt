work-depth_modelIn computer science, the analysis of parallel algorithms is the process of finding the computational complexity of algorithms executed in parallel â€“ the amount of time, storage, or other resources needed to execute them. In many respects, analysis of parallel algorithms is similar to the analysis of sequential algorithms, but is generally more involved because one must reason about the behavior of multiple cooperating threads of execution. One of the primary goals of parallel analysis is to understand how a parallel algorithm's use of resources (speed, space, etc.) changes as the number of processors is changed.A so-called work-time (WT) (sometimes called work-depth, or work-span) framework was originally introduced by Shiloach and Vishkin [1]for conceptualizing and describing parallel algorithms. In the WT framework, a parallel algorithm is first described in terms of parallel rounds. For each round, the operations to be performed are characterized, but several issues can be suppressed. For example, the number of operations at each round need not be clear, processors need not be mentioned and any information that may help with the assignment of processors to jobs need not be accounted for. Second, the suppressed information is provided. The inclusion of the suppressed information is guided by the proof of a scheduling theorem due to Brent,[2] which is explained later in this article. The WT framework is useful since while it can greatly simplify the initial description of a parallel algorithm, inserting the details suppressed by that initial description is often not very difficult. For example, the WT framework was adopted as the basic presentation framework in the parallel algorithms books (for the Parallel random-access machine PRAM model) [3]and, [4] as well as in the class notes .[5] The overview below explains how the WT framework can be used for analyzing more general parallel algorithms, even when their description is not available within the WT framework.Suppose computations are executed on a machine that has  processors. Let  denote the time that expires between the start of the computation and its end. Analysis of the computation's running time focuses on the following notions:The work of a computation executed by  processors is the total number of primitive operations that the processors perform.[6] Ignoring communication overhead from synchronizing the processors, this is equal to the time used to run the computation on a single processor, denoted .The depth or span is the length of the longest series of operations that have to be performed sequentially due to data dependencies (the critical path). The depth may also be called the critical path length of the computation.[7] Minimizing the depth/span is important in designing parallel algorithms, because the depth/span determines the shortest possible execution time.[8] Alternatively, the span can be defined as the time  spent computing using an idealized machine with an infinite number of processors.[9]The cost of the computation is the quantity . This expresses the total time spent, by all processors, in both computing and waiting.[6]Several useful results follow from the definitions of work, span and cost:Work law. The cost is always at least the work: . This follows from the fact that  processors can perform at most  operations in parallel.[6][9]Span law. A finite number  of processors cannot outperform an infinite number, so that .[9]Using these definitions and laws, the following measures of performance can be given:Speedup is the gain in speed made by parallel execution compared to sequential execution: . When the speedup is  for input size  (using big O notation), the speedup is linear, which is optimal in simple models of computation because the work law implies that  (super-linear speedup can occur in practice due to memory hierarchy effects). The situation  is called perfect linear speedup.[9] An algorithm that exhibits linear speedup is said to be scalable.[6]Efficiency is the speedup per processor, .[6]Parallelism is the ratio . It represents the maximum possible speedup on any number of processors. By the span law, the parallelism bounds the speedup: if , then: .[9]The slackness is . A slackness less than one implies (by the span law) that perfect linear speedup is impossible on  processors.[9]Analysis of parallel algorithms is usually carried out under the assumption that an unbounded number of processors is available. This is unrealistic, but not a problem, since any computation that can run in parallel on  processors can be executed on  processors by letting each processor execute multiple units of work. A result called Brent's law states that one can perform such a "simulation" in time , bounded by[10]or, less precisely,[6]An alternative statement of the law bounds  above and below by.showing that the span (depth)  and the work  together provide reasonable bounds on the computation time.[2]