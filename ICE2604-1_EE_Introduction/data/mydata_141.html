<!DOCTYPE html>
<html>
<head>
<title>Boyer-Moore-Horspool</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-One_source plainlinks metadata ambox ambox-content ambox-one_source" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Boyer–Moore–Horspool algorithm</caption><tbody><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Substring searching</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">String</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(nm)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>m</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(nm)}</annotation>
</semantics>
</math></span><img alt="O(nm)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/051245e657739f572fe7902c817ea9103c687fb7" style="vertical-align: -0.838ex; width:7.018ex; height:2.843ex;"/></span></td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \Theta (n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">Θ<!-- Θ --></mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \Theta (n)}</annotation>
</semantics>
</math></span><img alt="\Theta (n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a6351206e27071559aa4472579095994f650d76b" style="vertical-align: -0.838ex; width:5.012ex; height:2.843ex;"/></span></td></tr></tbody></table>
<p>In computer science, the <b>Boyer–Moore–Horspool algorithm</b> or <b>Horspool's algorithm</b> is an algorithm for finding substrings in strings. It was published by Nigel Horspool in 1980 as SBM.<sup class="reference" id="cite_ref-SBM_1-0">[1]</sup>
</p><p>It is a simplification of the Boyer–Moore string search algorithm which is related to the Knuth–Morris–Pratt algorithm. The algorithm trades space for time in order to obtain an average-case complexity of <i>O(n)</i> on random text, although it has <i>O(nm)</i> in the worst case, where the length of the pattern is <i>m</i> and the length of the search string is <i>n</i>.
</p>

<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"></span></h2>
<p>Like Boyer–Moore, Boyer–Moore–Horspool preprocesses the pattern to produce a table containing, for each symbol in the alphabet, the number of characters that can safely be skipped. The preprocessing phase, in pseudocode, is as follows (for an alphabet of 256 symbols, i.e., bytes):
</p>
<pre><i>Unlike the original, we use zero-based indices here.</i>
<b>function</b> preprocess(pattern)
    T ← new table of 256 integers
    <b>for</b> i <b>from</b> 0 <b>to</b> 256 <b>exclusive</b>
        T[i] ← length(pattern)
    <b>for</b> i <b>from</b> 0 <b>to</b> length(pattern) - 1 <b>exclusive</b>
        T[pattern[i]] ← length(pattern) - 1 - i
    <b>return</b> T
</pre>
<p>Pattern search proceeds as follows. The procedure <style data-mw-deduplicate="TemplateStyles:r886049734">.mw-parser-output .monospaced{font-family:monospace,monospace}</style><span class="monospaced">search</span> reports the index of the first occurrence of <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">needle</span> in <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">haystack</span>.
</p>
<pre><b>function</b> same(str1, str2, len)              <i>Compares two strings, up to the first len characters.</i>
    i ← len - 1
    <b>while</b> str1[i] = str2[i]               <i>Note: this is equivalent to !memcmp(str1, str2, len).</i>
        <b>if</b> i = 0                            <i>The original algorithm tries to play smart here: it checks for the</i>
            <b>return</b> true                     <i>last character, and then starts from the first to the second-last.</i>
        i ← i - 1
    <b>return</b> false

<b>function</b> search(needle, haystack)
    T ← preprocess(needle)
    skip ← 0
    <b>while</b> length(haystack) - skip ≥ length(needle)
        <i>haystack[skip:] -- substring starting with "skip". &amp;haystack[skip] in C.</i>
        <b>if</b> same(haystack[skip:], needle, length(needle))   
            <b>return</b> skip  
        skip ← skip + T[haystack[skip + length(needle) - 1]]
    <b>return</b> <i>not-found</i>
</pre>
<h2><span class="mw-headline" id="Performance">Performance</span><span class="mw-editsection"></span></h2>
<p>The algorithm performs best with long needle strings, when it consistently hits a non-matching character at or near the final byte of the current position in the haystack and the final byte of the needle does not occur elsewhere within the needle. For instance a 32 byte needle ending in "z" searching through a 255 byte haystack which does not have a 'z' byte in it would take up to 224 byte comparisons.
</p><p>The best case is the same as for the Boyer–Moore string search algorithm in big O notation, although the constant overhead of initialization and for each loop is less.
</p><p>The worst case behavior happens when the bad character skip is consistently low (with the lower limit of 1 byte movement) and a large portion of the needle matches the haystack. The bad character skip is only low, on a partial match, when the final character of the needle also occurs elsewhere within the needle, with 1 byte movement happening when the same byte is in both of the last two positions.
</p><p>The canonical degenerate case similar to the above "best" case is a needle of an 'a' byte followed by 31 'z' bytes in a haystack consisting of 255 'z' bytes. This will do 31 successful byte comparisons, a 1 byte comparison that fails and then move forward 1 byte. This process will repeat 223 more times (255 − 32), bringing the total byte comparisons to 7,168 (32 × 224). (A different byte-comparison loop will have a different behavior.)
</p><p>The worst case is significantly higher than for the Boyer–Moore string search algorithm, although obviously this is hard to achieve in normal use cases. It is also worth noting that this worst case is also the worst case for the naive (but usual) <code>memcmp()</code> algorithm, although the implementation of that tends to be significantly optimized (and is more cache friendly).
</p>
<h3><span class="mw-headline" id="Tuning_the_comparison_loop">Tuning the comparison loop</span><span class="mw-editsection"></span></h3>
<p>The original algorithm had a more sophisticated same() loop. It uses an extra pre-check before proceeding in the positive direction:<sup class="reference" id="cite_ref-SBM_1-1">[1]</sup>
</p>
<pre><b>function</b> same_orig(str1, str2, len)
    i ← 0
    <b>if</b> str1[len - 1] = str2[len - 1]
        <b>while</b> str1[i] = str2[i]
            <b>if</b> i = len - 2
                <b>return</b> true
            i ← i + 1
    <b>return</b> false
</pre>
<p>A tuned version of the BMH algorithm is the Raita algorithm. It adds an additional precheck for the middle character, in the order of last-first-middle. The algorithm enters the full loop only when the check passes:<sup class="reference" id="cite_ref-RAITA_2-0">[2]</sup>
</p>
<pre><b>function</b> same_raita(str1, str2, len)
    i ← 0
    mid ← len / 2
    
    <i>Three prechecks.</i>
    <b>if</b> len ≥ 3
        <b>if</b> str[mid] != str2[mid]
            <b>return</b> false
    <b>if</b> len ≥ 1
        <b>if</b> str[0] != str2[0]
            <b>return</b> false
    <b>if</b> len ≥ 2
        <b>if</b> str[len - 1] != str2[len - 1]
            <b>return</b> false

    <i>Any old comparison loop.</i>
    <b>return</b> len &lt; 3 <i>or</i> SAME(&amp;str1[1], &amp;str2[1], len - 2)
</pre>
<p>It is unclear whether this 1992 tuning still holds its performance advantage on modern machines. The rationale by the authors is that actual text usually contains some patterns which can be effectively prefiltered by these three characters. It appears that Raita is not aware of the old last-character precheck (he believed that the backward-only <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">same</span> routine is the Horspool implementation), so readers are advised to take the results with a grain of salt.<sup class="reference" id="cite_ref-RAITA_2-1">[2]</sup>
</p><p>On modern machines, library functions like <link href="mw-data:TemplateStyles:r886049734" rel="mw-deduplicated-inline-style"/><span class="monospaced">memcmp</span> tends to provide better throughput than any of the hand-written comparison loops. The behavior of an "SFC" loop (Horspool's terminology) both in libstdc++ and libc++ seems to suggest that a modern Raita implementation should not include any of the one-character shifts, since they have detrimental effects on data alignment.<sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup> Also see String-searching algorithm which has detailed analysis of other string searching algorithms.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Description of the algorithm</li>
<li>An implementation from V8 JavaScript engine written in C++</li></ul>

<!-- 
NewPP limit report
Parsed by mw2303
Cached time: 20221220233918
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.209 seconds
Real time usage: 0.309 seconds
Preprocessor visited node count: 681/1000000
Post‐expand include size: 33072/2097152 bytes
Template argument size: 534/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 19408/5000000 bytes
Lua time usage: 0.128/10.000 seconds
Lua memory usage: 4427894/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  242.616      1 -total
 36.09%   87.550      1 Template:Reflist
 29.42%   71.381      1 Template:One_source
 26.58%   64.485      2 Template:Cite_journal
 24.38%   59.153      1 Template:Ambox
 16.49%   40.011      1 Template:Strings
 15.63%   37.909      1 Template:Navbox
 13.21%   32.038      1 Template:Infobox_algorithm
 10.41%   25.261      1 Template:Infobox
  4.37%   10.602      1 Template:Find_sources_mainspace
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1753472-0!canonical and timestamp 20221220233918 and revision id 1090848731.
 -->
</div></body>
</html>