<!DOCTYPE html>
<html>
<head>
<title>superimposed_code</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>A <b>superimposed code</b> such as <b>Zatocoding</b> is a kind of hash code that was popular in marginal punched-card systems.
</p>

<h2><span class="mw-headline" id="Marginal_punched-card_systems">Marginal punched-card systems</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Many names, some of them trademarked, have been used for marginal punched-card systems:
edge-notched cards, slotted cards, E-Z Sort, Zatocards, McBee, McBee Keysort, Flexisort, Velom, Rocket, etc.
The center of each card held the relevant information—typically the name and author of a book, research paper, or journal article on a nearby shelf; and a list of subjects and keywords.
Some sets of cards contained all the information required by the user on the card itself, handwritten, typewritten, or on microfilm (aperture card).
Every card in a stack had the same set of pre-punched holes.
The user would find the particular cards relevant to a search by aligning the holes in the set of cards (using a card holder or card tray), inserting one or more knitting-needle-like rods all the way through the stack, so the desired cards (which had been notched or cut open) fell out from the irrelevant cards in the collection (left un-notched), which remain on the needle(s).
A user could repeat this selection many times to form a complex Boolean searching query.
A card that was relevant to 2 or more subjects would have the slot(s) for each of those subjects cut out, so that card would drop out when either one or the other or both subjects was selected .
The "superimposed code" coding systems, such as Zatocoding, saved space by entering several or all subjects in the same field; such a "superimposed code" stores much more information in less space, but at the cost of occasional "false" selections.<sup class="reference" id="cite_ref-1">[1]</sup>
</p><p>Once you have a collection of index cards, one per book, research paper, or journal article in a library, with a list of keywords (subjects) discussed in a particular book written on that book's card, the "obvious way" to code those subjects is to count up the total number of subjects used in the entire collection R, make a row of R holes near the top of every card, and for each subject actually discussed in a particular book, cut a slot from the hole corresponding to that subject in the card corresponding to that book.
<sup class="reference" id="cite_ref-ashby_2-0">[2]</sup>
Naturally, this also requires a separate list of every subject used in the collection that indicates which hole is punched for each subject.
Unfortunately, there may be thousands of distinct subjects in the collection,
and it is impractical to punch thousands of holes in every card.
While it may not seem possible to use less than 1 hole per subject,
superimposed code systems can solve this problem.
</p>
<h2><span class="mw-headline" id="Superimposed_codes">Superimposed codes</span><span class="mw-editsection"></span></h2>
<p>The Zatocoding system of information retrieval was developed by Calvin Mooers in 1947.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>Calvin Mooers invented <b>Zatocoding</b> at M.I.T., a mechanical information retrieval system based on superimposed codes, and formed the Zator Company in 1947 to commercialize its applications.<sup class="reference" id="cite_ref-4">[4]</sup>
The particular superimposed code used in that system is called <b>Zatocoding</b>,
while the marginal-punched card information retrieval system as a whole is called "<b>Zator</b>".<sup class="reference" id="cite_ref-ohlman_5-0">[5]</sup>
</p><p>Setting up a superimposed code for a particular library goes something like this:
</p>
<ul><li>Going through every card in the index, a list of all R subjects used in this particular library is created, and the maximum number of subjects r actually written on a single card is noted. (For example, say we have 8000 subjects, and the librarian decides to index only the top r=4 subjects per book).</li>
<li>The librarian looks at the physical edge-notched card, and notes the number of holes N in each card. (If N &gt;= R, then we could use the "obvious way" mentioned above—the whole point of Zatocoding is that it works even when N is much less than R).</li>
<li>The librarian chooses some number n of slots per subject—typically <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n=N(1-2^{-{\frac {1}{r}}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>=</mo>
<mi>N</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>−<!-- − --></mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo>−<!-- − --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mi>r</mi>
</mfrac>
</mrow>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n=N(1-2^{-{\frac {1}{r}}})}</annotation>
</semantics>
</math></span><img alt="n=N(1-2^{{-{\frac  {1}{r}}}})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1dce03faa8f24f79163e6d4773b8df8c3da94c9c" style="vertical-align: -0.838ex; width:16.546ex; height:3.843ex;"/></span><sup class="reference" id="cite_ref-ashby_2-1">[2]</sup></li>
<li>On the list of all R subjects, for each subject write down which holes will be slotted for that subject. Rather than slotting one hole per subject in "the obvious way", a superimposed code will slot n holes per subject. (There are several ways to pick these patterns—those distinguish between the various superimposed codes; we discuss them below).</li>
<li>When a new book comes in, make a new card for it:
<ul><li>Get a blank card with the standard N holes in it and write down the name of the book, etc. in the middle.</li>
<li>Write down the subjects covered by the book on the card.</li>
<li>For each of the top r subjects, look up that subject in the big list, and see which n slots to cut for that subject, and cut them.</li>
<li>When the card is finished, it may have up to r*n slots cut into it—but more likely at least some of the subject slot patterns overlapped, resulting in only v &lt; r*n slots.</li></ul></li></ul>
<p>Later, when we need to find books on some particular subject, we look up that subject in our list of all R subjects, find the corresponding slot pattern of n slots,
and put n needles are through the whole stack in that pattern.
All of the cards that have been cut with that pattern will fall out.
It is possible that a few other, undesired cards may also fall out—cards who have several subjects whose hole patterns overlap in such a way as to mimic the desired pattern.
The probability F of some undesired card with v slots cut in it falling through when we select some pattern of n needles is
approximately <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F=\left({\frac {v}{N}}\right)^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo>=</mo>
<msup>
<mrow>
<mo>(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>v</mi>
<mi>N</mi>
</mfrac>
</mrow>
<mo>)</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F=\left({\frac {v}{N}}\right)^{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle F=\left({\frac {v}{N}}\right)^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3385a61f81957b7c88c07f8358776b74d332250b" style="vertical-align: -1.838ex; width:11.733ex; height:4.843ex;"/></span>.
Most systems have a N large enough and r small enough such that, v &lt; N/2 (i.e., the card is less than half-punched),
so that probability of an undesired card falling through is less than
<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle F&lt;\left({\frac {1}{2}}\right)^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>F</mi>
<mo>&lt;</mo>
<msup>
<mrow>
<mo>(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mrow>
<mo>)</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle F&lt;\left({\frac {1}{2}}\right)^{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle F&lt;\left({\frac {1}{2}}\right)^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f580c7abe73a2e9d57bd75c2ebbf2ba79d5465f7" style="vertical-align: -2.505ex; width:11.477ex; height:6.176ex;"/></span>.<sup class="reference" id="cite_ref-ashby_2-2">[2]</sup>
</p><p>There are several different ways to choose which holes will be slotted for each subject.
</p><p>(Several variations of Zatocoding were developed. Bourne describes a variant "for newer retrieval systems that require high performance of the superimposed coding system",<sup class="reference" id="cite_ref-6">[6]</sup> using an approach Mooers published in 1959.<sup class="reference" id="cite_ref-7">[7]</sup>)
</p>
<h3><span class="mw-headline" id="Zatocoding">Zatocoding</span><span class="mw-editsection"></span></h3>
<p>Setting up a Zatocode for a particular list of R subjects goes something like this:<sup class="reference" id="cite_ref-ashby_2-3">[2]</sup>
</p>
<ul><li>For the first subject, pick n of the N slots randomly.</li>
<li>For the second subject, pick n of the N slots randomly—but make sure this pattern is not identical to the first subject.</li>
<li>...</li>
<li>For the R'th subject, pick n of the N slots randomly—but make sure it's not identical to any previous subject.</li></ul>
<h3><span class="mw-headline" id="Other_superimposed_codes">Other superimposed codes</span><span class="mw-editsection"></span></h3>
<p>A Zatocode requires a code book that lists every subject and a randomly generated notch code associated with each one.
Other "direct" superimposed codes
have a fixed hash function for transforming the letters in (one spelling of) a subject into a notch code.
Such codes require a much shorter code book that describes the translation of letters in a word to the corresponding notch code, and can in principle easily add new subjects without changing the code book.<sup class="reference" id="cite_ref-ohlman_5-1">[5]</sup>
</p><p>A Bloom filter can be considered a kind of superimposed code.<sup class="reference" id="cite_ref-8">[8]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Calvin N. Mooers. "Application of random codes to the gathering of statistical information". Thesis (M.S.) Massachusetts Institute of Technology. Dept. of Mathematics, 1948.</li>
<li>Calvin N. Mooers. "Zatocoding applied to mechanical organization of knowledge". Journal of the American Society for Information Science and Technology. 2007.</li></ul>
<!-- 
NewPP limit report
Parsed by mw1474
Cached time: 20221214161307
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.140 seconds
Real time usage: 0.212 seconds
Preprocessor visited node count: 286/1000000
Post‐expand include size: 3226/2097152 bytes
Template argument size: 81/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 10573/5000000 bytes
Lua time usage: 0.080/10.000 seconds
Lua memory usage: 2451447/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  153.629      1 -total
 66.85%  102.698      1 Template:Reflist
 53.23%   81.776      2 Template:Cite_book
 23.63%   36.307      1 Template:Confuse
  5.11%    7.857      1 Template:Main
  0.86%    1.317      1 Template:Main_other
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:31382490-0!canonical and timestamp 20221214161307 and revision id 1061934000.
 -->
</div></body>
</html>