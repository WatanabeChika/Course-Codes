<!DOCTYPE html>
<html>
<head>
<title>competitive_ratio</title>
</head>
<body>
<div class="mw-parser-output"><p><b>Competitive analysis</b> is a method invented for analyzing online algorithms, in which the performance of an online algorithm (which must satisfy an unpredictable sequence of requests, completing each request without being able to see the future) is compared to the performance of an optimal <i>offline algorithm</i> that can view the sequence of requests in advance.  An algorithm is <i>competitive</i> if its <i>competitive ratio</i>—the ratio between its performance and the offline algorithm's performance—is bounded.  Unlike traditional worst-case analysis, where the performance of an algorithm is measured only for "hard" inputs, competitive analysis requires that an algorithm perform well both on hard and easy inputs, where "hard" and "easy" are defined by the performance of the optimal offline algorithm.
</p><p>For many algorithms, performance is dependent not only on the size of the inputs, but also on their values.  For example, sorting an array of elements varies in difficulty depending on the initial order.  Such data-dependent algorithms are analysed for average-case and worst-case data.  Competitive analysis is a way of doing worst case analysis for on-line and randomized algorithms, which are typically data dependent.
</p><p>In competitive analysis, one imagines an "adversary" which deliberately chooses difficult data, to maximize the ratio of the cost of the algorithm being studied and some optimal algorithm.  When considering a randomized algorithm, one must further distinguish between an <i>oblivious adversary</i>, which has no knowledge of the random choices made by the algorithm pitted against it, and an <i>adaptive adversary</i> which has full knowledge of the algorithm's internal state at any point during its execution.  (For a deterministic algorithm, there is no difference; either adversary can simply compute what state that algorithm must have at any time in the future, and choose difficult data accordingly.)
</p><p>For example, the quicksort algorithm chooses one element, called the "pivot", that is, on average, not too far from the center value of the data being sorted. Quicksort then separates the data into two piles, one of which contains all elements with value less than the value of the pivot, and the other containing the rest of the elements.  If quicksort chooses the pivot in some deterministic fashion (for instance, always choosing the first element in the list), then it is easy for an adversary to arrange the data beforehand so that quicksort will perform in worst-case time.  If, however, quicksort chooses some random element to be the pivot, then an adversary without knowledge of what random numbers are coming up cannot arrange the data to guarantee worst-case execution time for quicksort.
</p><p>The classic on-line problem first analysed with competitive analysis (Sleator &amp; Tarjan 1985) is the list update problem: Given a list of items and a sequence of requests for the various items, minimize the cost of accessing the list where the elements closer to the front of the list cost less to access.  (Typically, the cost of accessing an item is equal to its position in the list.)  After an access, the list may be rearranged.  Most rearrangements have a cost.  The <i>Move-To-Front algorithm</i> simply moves the requested item to the front after the access, at no cost.  The <i>Transpose algorithm</i> swaps the accessed item with the item immediately before it, also at no cost.  Classical methods of analysis showed that Transpose is optimal in certain contexts.  In practice, Move-To-Front performed much better.  Competitive analysis was used to show that an adversary can make Transpose perform arbitrarily badly compared to an optimal algorithm, whereas Move-To-Front can never be made to incur more than twice the cost of an optimal algorithm.
</p><p>In the case of online requests from a server, competitive algorithms are used to overcome uncertainties about the future. That is, the algorithm does not "know" the future, while the imaginary adversary (the "competitor") "knows". Similarly, competitive algorithms were developed for distributed systems, where the algorithm has to react to a request arriving at one location, without "knowing" what has just happened in a remote location. This setting was presented in (Awerbuch, Kutten &amp; Peleg 1992).
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Adversary (online algorithm)</li>
<li>Amortized analysis</li>
<li>K-server problem</li>
<li>List update problem</li>
<li>Online algorithm</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><style data-mw-deduplicate="TemplateStyles:r1067248974">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style><cite class="citation cs2" id="CITEREFSleatorTarjan1985">Sleator, D.; Tarjan, R. (1985), "Amortized efficiency of list update and paging rules", <i>Communications of the ACM</i>, <b>28</b> (2): 202–208, doi:10.1145/2786.2793</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Amortized+efficiency+of+list+update+and+paging+rules&amp;rft.volume=28&amp;rft.issue=2&amp;rft.pages=202-208&amp;rft.date=1985&amp;rft_id=info%3Adoi%2F10.1145%2F2786.2793&amp;rft.aulast=Sleator&amp;rft.aufirst=D.&amp;rft.au=Tarjan%2C+R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACompetitive+analysis+%28online+algorithm%29"></span>.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFAspnes1998">Aspnes, James (1998), "Competitive analysis of distributed algorithms",  in Fiat, A.; Woeginger, G. J. (eds.), <i>Online Algorithms: The State of the Art</i>, Lecture Notes in Computer Science, vol. 1442, pp. 118–146, doi:10.1007/BFb0029567</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Competitive+analysis+of+distributed+algorithms&amp;rft.btitle=Online+Algorithms%3A+The+State+of+the+Art&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=118-146&amp;rft.date=1998&amp;rft_id=info%3Adoi%2F10.1007%2FBFb0029567&amp;rft.aulast=Aspnes&amp;rft.aufirst=James&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACompetitive+analysis+%28online+algorithm%29"></span>.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFBorodinEl-Yaniv1998">Borodin, A.; El-Yaniv, R. (1998), <i>Online Computation and Competitive Analysis</i>, Cambridge University Press, ISBN <bdi>0-521-56392-5</bdi></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Online+Computation+and+Competitive+Analysis&amp;rft.pub=Cambridge+University+Press&amp;rft.date=1998&amp;rft.isbn=0-521-56392-5&amp;rft.aulast=Borodin&amp;rft.aufirst=A.&amp;rft.au=El-Yaniv%2C+R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACompetitive+analysis+%28online+algorithm%29"></span>.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFAwerbuchKuttenPeleg1992">Awerbuch, B.; Kutten, S.; Peleg, D. (1992), "Competitive Distributed Job Scheduling", <i>ACM STOC, Victoria, BC, Canada</i></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Competitive+Distributed+Job+Scheduling&amp;rft.btitle=ACM+STOC%2C+Victoria%2C+BC%2C+Canada&amp;rft.date=1992&amp;rft.aulast=Awerbuch&amp;rft.aufirst=B.&amp;rft.au=Kutten%2C+S.&amp;rft.au=Peleg%2C+D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACompetitive+analysis+%28online+algorithm%29"></span>.</li></ul>
<!-- 
NewPP limit report
Parsed by mw2377
Cached time: 20221214211955
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.097 seconds
Real time usage: 0.125 seconds
Preprocessor visited node count: 189/1000000
Post‐expand include size: 6434/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 4/100
Expensive parser function count: 0/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 7172/5000000 bytes
Lua time usage: 0.074/10.000 seconds
Lua memory usage: 3976822/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  112.249      1 -total
 68.18%   76.532      4 Template:Citation
 31.42%   35.269      2 Template:Harv
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:8198743-0!canonical and timestamp 20221214211955 and revision id 1002299044.
 -->
</div></body>
</html>