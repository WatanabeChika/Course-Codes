<!DOCTYPE html>
<html>
<head>
<title>Monte_Carlo_algorithm</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_footnotes plainlinks metadata ambox ambox-style ambox-More_footnotes" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computing, a <b>Monte Carlo algorithm</b> is a randomized algorithm whose output may be incorrect with a certain (typically small) probability. Two examples of such algorithms are Karger–Stein algorithm<sup class="reference" id="cite_ref-1">[1]</sup> and Monte Carlo algorithm for minimum Feedback arc set.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>The name refers to the grand casino in the Principality of Monaco at Monte Carlo, which is well-known around the world as an icon of gambling. The term "Monte Carlo" was first introduced in 1947 by Nicholas Metropolis.<sup class="reference" id="cite_ref-3">[3]</sup>
</p><p>Las Vegas algorithms are a dual of Monte Carlo algorithms that never return an incorrect answer. However, they may make random choices as part of their work. As a result, the time taken might vary between runs, even with the same input.
</p><p>If there is a procedure for verifying whether the answer given by a Monte Carlo algorithm is correct, and the probability of a correct answer is bounded above zero, then with probability, one running the algorithm repeatedly while testing the answers will eventually give a correct answer. Whether this process is a Las Vegas algorithm depends on whether halting with probability one is considered to satisfy the definition.
</p>

<h2><span class="mw-headline" id="One-sided_vs_two-sided_error">One-sided vs two-sided error</span><span class="mw-editsection"></span></h2>
<p>While the answer returned by a deterministic algorithm is always expected to be correct, this is not the case for Monte Carlo algorithms. For decision problems, these algorithms are generally classified as either <b>false</b>-biased or <b>true</b>-biased. A <b>false</b>-biased Monte Carlo algorithm is always correct when it returns <b>false</b>; a <b>true</b>-biased algorithm is always correct when it returns <b>true</b>. While this describes algorithms with <i>one-sided errors</i>, others might have no bias; these are said to have <i>two-sided errors</i>. The answer they provide (either <b>true</b> or <b>false</b>) will be incorrect, or correct, with some bounded probability.
</p><p>For instance, the Solovay–Strassen primality test is used to determine whether a given number is a prime number. It always answers <b>true</b> for prime number inputs; for composite inputs, it answers <b>false</b> with probability at least <style data-mw-deduplicate="TemplateStyles:r1020198016">.mw-parser-output .frac{white-space:nowrap}.mw-parser-output .frac .num,.mw-parser-output .frac .den{font-size:80%;line-height:0;vertical-align:super}.mw-parser-output .frac .den{vertical-align:sub}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span> and <b>true</b> with probability less than <link href="mw-data:TemplateStyles:r1020198016" rel="mw-deduplicated-inline-style"/><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>. Thus, <b>false</b> answers from the algorithm are certain to be correct, whereas the <b>true</b> answers remain uncertain; this is said to be a <i><link href="mw-data:TemplateStyles:r1020198016" rel="mw-deduplicated-inline-style"/><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>-correct false-biased algorithm</i>.
</p>
<h2><span class="mw-headline" id="Amplification">Amplification</span><span class="mw-editsection"></span></h2>
<p>For a Monte Carlo algorithm with one-sided errors, the failure probability can be reduced (and the success probability amplified) by running the algorithm <i>k</i> times. Consider again the Solovay–Strassen algorithm which is <i><link href="mw-data:TemplateStyles:r1020198016" rel="mw-deduplicated-inline-style"/><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>-correct false-biased</i>. One may run this algorithm multiple times returning a <b>false</b> answer if it reaches a <b>false</b> response within <i>k</i> iterations, and otherwise returning <b>true</b>. Thus, if the number is prime then the answer is always correct, and if the number is composite then the answer is correct with probability at least 1−(1−<link href="mw-data:TemplateStyles:r1020198016" rel="mw-deduplicated-inline-style"/><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>)<sup><i>k</i></sup> = 1−2<sup><i>−k</i></sup>.
</p><p>For Monte Carlo decision algorithms with two-sided error, the failure probability may again be reduced by running the algorithm <i>k</i> times and returning the majority function of the answers.
</p>
<h2><span class="mw-headline" id="Complexity_classes">Complexity classes</span><span class="mw-editsection"></span></h2>
<p>The complexity class BPP describes decision problems that can be solved by polynomial-time Monte Carlo algorithms with a bounded probability of two-sided errors, and the complexity class RP describes problems that can be solved by a Monte Carlo algorithm with a bounded probability of one-sided error: if the correct answer is <b>false</b>, the algorithm always says so, but it may answer <b>false</b> incorrectly for some instances where the correct answer is <b>true</b>. In contrast, the complexity class ZPP describes problems solvable by polynomial expected time Las Vegas algorithms. <span class="nowrap">ZPP ⊆ RP ⊆ BPP</span>, but it is not known whether any of these complexity classes is distinct from each other; that is, Monte Carlo algorithms may have more computational power than Las Vegas algorithms, but this has not been proven. Another complexity class, PP, describes decision problems with a polynomial-time Monte Carlo algorithm that is more accurate than flipping a coin but where the error probability cannot necessarily be bounded away from <link href="mw-data:TemplateStyles:r1020198016" rel="mw-deduplicated-inline-style"/><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>.
</p>
<h2><span class="mw-headline" id="Applications_in_computational_number_theory">Applications in computational number theory</span><span class="mw-editsection"></span></h2>
<p>Well-known Monte Carlo algorithms include the Solovay–Strassen primality test, the Baillie–PSW primality test, the Miller–Rabin primality test, and certain fast variants of the Schreier–Sims algorithm in computational group theory.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Monte Carlo methods, algorithms used in physical simulation and computational statistics based on taking random samples</li>
<li>Atlantic City algorithm</li>
<li>Las Vegas algorithm</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Citations">Citations</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h3><span class="mw-headline" id="Sources">Sources</span><span class="mw-editsection"></span></h3>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<!-- 
NewPP limit report
Parsed by mw1351
Cached time: 20221214142047
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.202 seconds
Real time usage: 0.256 seconds
Preprocessor visited node count: 675/1000000
Post‐expand include size: 17538/2097152 bytes
Template argument size: 228/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 20759/5000000 bytes
Lua time usage: 0.122/10.000 seconds
Lua memory usage: 4251396/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  225.652      1 -total
 39.34%   88.773      1 Template:Reflist
 33.73%   76.110      3 Template:Cite_journal
 25.26%   57.003      1 Template:More_footnotes
 20.33%   45.882      1 Template:Ambox
 18.06%   40.743      1 Template:Distinguish
  7.72%   17.431      3 Template:Cite_book
  3.68%    8.305      1 Template:Refbegin
  3.47%    7.821      6 Template:Frac
  1.28%    2.885      2 Template:Yesno-no
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:624839-0!canonical and timestamp 20221214142047 and revision id 1110192836.
 -->
</div></body>
</html>