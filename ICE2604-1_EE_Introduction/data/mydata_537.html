<!DOCTYPE html>
<html>
<head>
<title>Kripke_structure</title>
</head>
<body>
<div class="mw-parser-output"><dl><dd><i>This article describes Kripke structures as used in model checking. For a more general description, see Kripke semantics</i>.</dd></dl>
<p>A <b>Kripke structure</b> is a variation of the transition system, originally proposed by Saul Kripke,<sup class="reference" id="cite_ref-1">[1]</sup> used in model checking<sup class="reference" id="cite_ref-2">[2]</sup> to represent the behavior of a system.
It consists of a graph whose nodes represent the reachable states of the system and whose edges represent state transitions, together with a labelling function which maps each node to a set of properties that hold in the corresponding state. Temporal logics are traditionally interpreted in terms of Kripke structures.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (March 2011)">citation needed</span></i>]</sup>
</p>

<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"></span></h2>
<p>Let <span class="texhtml mvar" style="font-style:italic;">AP</span> be a set of <i>atomic propositions</i>, i.e. boolean expressions over variables, constants and predicate symbols. Clarke et al.<sup class="reference" id="cite_ref-Clarke1999_3-0">[3]</sup> define a Kripke structure over <span class="texhtml mvar" style="font-style:italic;">AP</span> as a 4-tuple <span class="texhtml"><i>M</i> = (<i>S</i>, <i>I</i>, <i>R</i>, <i>L</i>)</span> consisting of
</p>
<ul><li>a finite set of states <span class="texhtml mvar" style="font-style:italic;">S</span>.</li>
<li>a set of initial states <span class="texhtml"><i>I</i> ⊆ <i>S</i></span>.</li>
<li>a transition relation <span class="texhtml"><i>R</i> ⊆ <i>S</i> × <i>S</i></span> such that <span class="texhtml mvar" style="font-style:italic;">R</span> is left-total, i.e., <span class="texhtml">∀s ∈ <i>S</i> ∃s' ∈ <i>S</i></span> such that <span class="texhtml">(s,s') ∈ <i>R</i></span>.</li>
<li>a labeling (or <i>interpretation</i>) function <span class="texhtml"><i>L</i>: <i>S</i> → 2<sup><i>AP</i></sup></span>.</li></ul>
<p>Since <span class="texhtml mvar" style="font-style:italic;">R</span> is left-total, it is always possible to construct an infinite path through the Kripke structure. A deadlock state can be modeled by a single outgoing edge back to itself.
The labeling function <span class="texhtml mvar" style="font-style:italic;">L</span> defines for each state <span class="texhtml"><i>s</i> ∈ <i>S</i></span> the set <span class="texhtml"><i>L</i>(<i>s</i>)</span> of all atomic propositions that are valid in <span class="texhtml mvar" style="font-style:italic;">s</span>.
</p><p>A <i>path</i> of the structure <span class="texhtml mvar" style="font-style:italic;">M</span> is a sequence of states <span class="texhtml">ρ = s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, ...</span> such that for each <span class="texhtml">i &gt; 0</span>,  <span class="texhtml"><i>R</i>(s<sub>i</sub>, s<sub>i+1</sub>)</span> holds. 
The <i>word</i> on the path <span class="texhtml mvar" style="font-style:italic;">ρ</span> is a sequence of sets of the atomic propositions 
<span class="texhtml"><i>w</i> = <i>L</i>(s<sub>1</sub>), <i>L</i>(s<sub>2</sub>), <i>L</i>(s<sub>3</sub>), ...</span>,
which is an ω-word over alphabet <span class="texhtml">2<sup><i>AP</i></sup></span>.
</p><p>With this definition, a Kripke structure (say, having only one initial state <span class="texhtml"><i>i</i> ∈ <i>I</i>)</span> may be identified with a Moore machine with a singleton input alphabet, and with the output function being its labeling function.<sup class="reference" id="cite_ref-Schneider2004_4-0">[4]</sup>
</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"></span></h2>

<p>Let the set of atomic propositions <span class="texhtml"><i>AP</i> = {p, q}</span>.
<span class="texhtml mvar" style="font-style:italic;">p</span> and <span class="texhtml mvar" style="font-style:italic;">q</span> can model arbitrary boolean properties of the system that the Kripke structure is 
modelling.
</p><p>The figure at right illustrates a Kripke structure <span class="texhtml"><i>M</i> = (<i>S</i>, <i>I</i>, <i>R</i>, <i>L</i>)</span>,
where
</p>
<ul><li><span class="texhtml"><i>S</i> = {s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>}</span>.</li>
<li><span class="texhtml"><i>I</i> = {s<sub>1</sub>}</span>.</li>
<li><span class="texhtml"><i>R</i> = {(s<sub>1</sub>, s<sub>2</sub>), (s<sub>2</sub>, s<sub>1</sub>) (s<sub>2</sub>, s<sub>3</sub>), (s<sub>3</sub>, s<sub>3</sub>)}</span>.</li>
<li><span class="texhtml"><i>L</i> = {(s<sub>1</sub>, {p, q}), (s<sub>2</sub>, {q}), (s<sub>3</sub>, {p})}</span>.</li></ul>
<p><span class="texhtml mvar" style="font-style:italic;">M</span> may produce a path <span class="texhtml">ρ = s<sub>1</sub>, s<sub>2</sub>, s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, s<sub>3</sub>, s<sub>3</sub>, ...</span> and <span class="texhtml"><i>w</i> = {p, q}, {q}, {p, q}, {q}, {p}, {p}, {p}, ...</span> is the execution word over the path <span class="texhtml mvar" style="font-style:italic;">ρ</span>.
<span class="texhtml mvar" style="font-style:italic;">M</span> can produce execution words belonging to the language <span class="texhtml">({p, q}{q})*({p})<sup>ω</sup> ∪ ({p, q}{q})<sup>ω</sup></span>.
</p>
<h2><span class="mw-headline" id="Relation_to_other_notions">Relation to other notions</span><span class="mw-editsection"></span></h2>
<p>Although this terminology is widespread in the model checking community, some textbooks on model checking do not define "Kripke structure" in this extended way (or at all in fact), but simply use the concept of a (labelled) transition system, which additionally has a set <span class="texhtml mvar" style="font-style:italic;">Act</span> of actions, and the transition relation is defined as a subset of <span class="texhtml"><i>S</i> × <i>Act</i> × <i>S</i></span>, which they additionally extend to include a set of atomic propositions and a labeling function for the states as well (<span class="texhtml mvar" style="font-style:italic;">L</span> as defined above.) In this approach, the binary relation obtained by abstracting away the action labels is called a <b>state graph</b>.<sup class="reference" id="cite_ref-BaierKatoen2008_5-0">[5]</sup>
</p><p>Clarke et al. redefine a Kripke structure as a set of transitions (instead of just one), which is equivalent to the labeled transitions above, when they define the semantics of modal μ-calculus.<sup class="reference" id="cite_ref-6">[6]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Temporal logic</li>
<li>Model checking</li>
<li>Kripke semantics</li>
<li>Linear temporal logic</li>
<li>Computation tree logic</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw1405
Cached time: 20221214145111
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.191 seconds
Real time usage: 0.255 seconds
Preprocessor visited node count: 2008/1000000
Post‐expand include size: 16714/2097152 bytes
Template argument size: 3773/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 12429/5000000 bytes
Lua time usage: 0.106/10.000 seconds
Lua memory usage: 3838967/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  230.212      1 -total
 37.31%   85.889      1 Template:Reflist
 30.96%   71.281      3 Template:Cite_book
 24.41%   56.198      1 Template:Commons_category
 23.69%   54.529      1 Template:Sister_project
 22.98%   52.914      1 Template:Side_box
 22.60%   52.029      1 Template:Citation_needed
 15.51%   35.699      1 Template:Fix
 13.23%   30.457     24 Template:Math
 10.57%   24.344      2 Template:Category_handler
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1591127-0!canonical and timestamp 20221214145110 and revision id 1068734877.
 -->
</div></body>
</html>