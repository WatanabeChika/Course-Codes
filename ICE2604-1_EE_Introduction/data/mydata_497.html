<!DOCTYPE html>
<html>
<head>
<title>internal_node</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In computer science, a <b>tree</b> is a widely used abstract data type that represents a hierarchical tree structure with a set of connected nodes. Each node in the tree can be connected to many children (depending on the type of tree), but must be connected to exactly one parent, except for the <i>root</i> node, which has no parent. These constraints mean there are no cycles or "loops" (no node can be its own ancestor), and also that each child can be treated like the root node of its own subtree, making recursion a useful technique for tree traversal. In contrast to linear data structures, many trees cannot be represented by relationships between neighboring nodes in a single straight line.
</p><p>Binary trees are a commonly used type, which constrain the number of children for each parent to exactly two. When the order of the children is specified, this data structure corresponds to an  ordered tree in graph theory. A value or pointer to other data may be associated with every node in the tree, or sometimes only with the <i>leaf nodes</i>, which have no children.
</p><p>The abstract data type can be represented in a number of ways, including a list of parents with pointers to children, a list of children with pointers to parents, or a list of nodes and a separate list of parent-child relations (a specific type of adjacency list). Representations might also be more complicated, for example using indexes or ancestor lists for performance.
</p><p>Trees as used in computing are similar to but can be different from mathematical constructs of trees in graph theory, trees in set theory, and trees in descriptive set theory.
</p>

<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Trees are commonly used to represent or manipulate hierarchical data in applications such as:
</p>
<ul><li>File systems for:
<ul><li>Directory structure used to organize subdirectories and files (symbolic links create non-tree graphs, as do multiple hard links to the same file or directory)</li>
<li>The mechanism used to allocate and link blocks of data on the storage device</li></ul></li>
<li>Class hierarchy or "inheritance tree" showing the relationships among classes in object-oriented programming; multiple inheritance produces non-tree graphs</li>
<li>Abstract syntax trees for computer languages</li>
<li>Natural language processing:
<ul><li>Parse trees</li>
<li>Modeling utterances in a generative grammar</li>
<li>Dialogue tree for generating conversations</li></ul></li>
<li>Document Object Models ("DOM tree") of XML and HTML documents</li>
<li>Search trees store data in a way that makes an efficient search algorithm possible via tree traversal
<ul><li>A binary search tree is a type of binary tree</li></ul></li>
<li>Representing sorted lists of data</li>
<li>Computer-generated imagery:
<ul><li>Space partitioning, including binary space partitioning</li>
<li>Digital compositing</li></ul></li>
<li>Storing Barnes–Hut trees used to simulate galaxies</li>
<li>Implementing heaps</li>
<li>Nested sets</li>
<li>Hierarchical taxonomies such as the Dewey Decimal Classification with sections of increasing specificity.</li>
<li>Hierarchical temporal memory</li>
<li>Genetic programming</li>
<li>Hierarchical clustering</li></ul>
<p>Trees can be used to represent and manipulate various mathematical structures, such as:
</p>
<ul><li>Paths through an arbitrary node-and-edge graph (including multigraphs), by making multiple nodes in the tree for each graph node used in multiple paths</li>
<li>Any mathematical hierarchy</li></ul>
<p>Tree structures are often used for mapping the relationships between things, such as:
</p>
<ul><li>Components and subcomponents which can be visualized in an exploded-view drawing</li>
<li>Subroutine calls used to identify which subroutines in a program call other subroutines non recursively</li>
<li>Inheritance of DNA among species by evolution, of source code by software projects (e.g. Linux distribution timeline), of designs in various types of cars, etc.</li>
<li>The contents of hierarchical namespaces</li></ul>
<p>JSON and YAML documents can be thought of as trees, but are typically represented by nested lists and dictionaries.
</p>
<h2><span class="mw-headline" id="Terminology">Terminology</span><span class="mw-editsection"></span></h2>
<p>A node is a structure which may contain data and connections to other nodes, sometimes called <b>edges</b> or <b>links</b>. Each node in a tree has zero or more <b>child nodes</b>, which are below it in the tree (by convention, trees are drawn with <i>descendants</i> going downwards). A node that has a child is called the child's <b>parent node</b> (or superior). All nodes have exactly one parent, except the topmost <b>root node</b>, which has none. A node might have many <b>ancestor nodes</b>, such as the parent's parent.  Child nodes with the same parent are <b>sibling nodes</b>. Typically siblings have an order, with the first one conventionally drawn on the left. Some definitions allow a tree to have no nodes at all, in which case it is called <i>empty</i>. 
</p><p>An <b>internal node</b> (also known as an <b>inner node</b>, <b>inode</b> for short, or <b>branch node</b>) is any node of a tree that has child nodes. Similarly, an <b>external node</b> (also known as an <b>outer node</b>, <b>leaf node</b>, or <b>terminal node</b>) is any node that does not have child nodes.
</p><p>The <b>height</b> of a node is the length of the longest downward path to a leaf from that node. The height of the root is the height of the tree. The <b>depth</b> of a node is the length of the path to its root (i.e., its <i>root path</i>). When using zero-based counting, the root node has depth zero, leaf nodes have height zero, and a tree with only a single node (hence both a root and leaf) has depth and height zero. Conventionally, an empty tree (tree with no nodes, if such are allowed) has height −1.
</p><p>Each non-root node can be treated as the root node of its own <b>subtree</b>, which includes that node and all its descendants.<sup class="reference" id="cite_ref-1">[a]</sup><sup class="reference" id="cite_ref-2">[1]</sup>
</p><p>Other terms used with trees:
</p>
<dl class="glossary">
<dt class="glossary" id="neighbor" style="margin-top: 0.4em;"><dfn class="glossary">Neighbor</dfn></dt> <dd class="glossary">Parent or child.</dd>
<dt class="glossary" id="ancestor" style="margin-top: 0.4em;"><dfn class="glossary">Ancestor</dfn></dt> <dd class="glossary">A node reachable by repeated proceeding from child to parent.</dd>
<dt class="glossary" id="descendant" style="margin-top: 0.4em;"><dfn class="glossary">Descendant</dfn></dt> <dd class="glossary">A node reachable by repeated proceeding from parent to child. Also known as <i>subchild</i>.</dd>
<dt class="glossary" id="degree" style="margin-top: 0.4em;"><dfn class="glossary">Degree</dfn></dt> <dd class="glossary">For a given node, its number of children. A leaf has necessarily degree zero.</dd>
<dt class="glossary" id="degree_of_tree" style="margin-top: 0.4em;"><dfn class="glossary">Degree of tree</dfn></dt> <dd class="glossary">The degree of a tree is the maximum degree of a node in the tree.</dd>
<dt class="glossary" id="distance" style="margin-top: 0.4em;"><dfn class="glossary">Distance</dfn></dt> <dd class="glossary">The number of edges along the shortest path between two nodes.</dd>
<dt class="glossary" id="level" style="margin-top: 0.4em;"><dfn class="glossary">Level</dfn></dt> <dd class="glossary">The level of a node is the number of edges along the
unique path between it and the root node.<sup class="reference" id="cite_ref-3">[2]</sup></dd> This is the same as depth when using zero-based counting.
<dt class="glossary" id="width" style="margin-top: 0.4em;"><dfn class="glossary">Width</dfn></dt> <dd class="glossary">The number of nodes in a level.</dd>
<dt class="glossary" id="breadth" style="margin-top: 0.4em;"><dfn class="glossary">Breadth</dfn></dt> <dd class="glossary">The number of leaves.</dd>
<dt class="glossary" id="forest" style="margin-top: 0.4em;"><dfn class="glossary">Forest</dfn></dt> <dd class="glossary">A set of one or more disjoint trees.</dd>
<dt class="glossary" id="ordered_tree" style="margin-top: 0.4em;"><dfn class="glossary">Ordered tree</dfn></dt> <dd class="glossary">A rooted tree in which an ordering is specified for the children of each vertex. The book <i>The Art of Computer Programming</i> uses the term <i>oriented tree</i>.<sup class="reference" id="cite_ref-TAoCP_oriented_trees_4-0">[3]</sup></dd>
<dt class="glossary" id="size_of_a_tree" style="margin-top: 0.4em;"><dfn class="glossary">Size of a tree</dfn></dt> <dd class="glossary">Number of nodes in the tree.</dd>
</dl>
<h2><span class="mw-headline" id="Examples_of_trees_and_non-trees">Examples of trees and non-trees</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1096954695/mw-parser-output/.tmulti">.mw-parser-output .tmulti .multiimageinner{display:flex;flex-direction:column}.mw-parser-output .tmulti .trow{display:flex;flex-direction:row;clear:left;flex-wrap:wrap;width:100%;box-sizing:border-box}.mw-parser-output .tmulti .tsingle{margin:1px;float:left}.mw-parser-output .tmulti .theader{clear:both;font-weight:bold;text-align:center;align-self:center;background-color:transparent;width:100%}.mw-parser-output .tmulti .thumbcaption{background-color:transparent}.mw-parser-output .tmulti .text-align-left{text-align:left}.mw-parser-output .tmulti .text-align-right{text-align:right}.mw-parser-output .tmulti .text-align-center{text-align:center}@media all and (max-width:720px){.mw-parser-output .tmulti .thumbinner{width:100%!important;box-sizing:border-box;max-width:none!important;align-items:center}.mw-parser-output .tmulti .trow{justify-content:center}.mw-parser-output .tmulti .tsingle{float:none!important;max-width:100%!important;box-sizing:border-box;text-align:center}.mw-parser-output .tmulti .tsingle .thumbcaption{text-align:left}.mw-parser-output .tmulti .trow>.thumbcaption{text-align:center}}</style>
<h2><span class="mw-headline" id="Common_operations">Common operations</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<ul><li>Enumerating all the items</li>
<li>Enumerating a section of a tree</li>
<li>Searching for an item</li>
<li>Adding a new item at a certain position on the tree</li>
<li>Deleting an item</li>
<li>Pruning: Removing a whole section of a tree</li>
<li>Grafting: Adding a whole section to a tree</li>
<li>Finding the root for any node</li>
<li>Finding the lowest common ancestor of two nodes</li></ul>
<h3><span class="mw-headline" id="Traversal_and_search_methods">Traversal and search methods</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Stepping through the items of a tree, by means of the connections between parents and children, is called <b>walking the tree</b>, and the action is a <i>walk</i> of the tree. Often, an operation might be performed when a pointer arrives at a particular node. A walk in which each parent node is traversed before its children is called a <b>pre-order</b> walk; a walk in which the children are traversed before their respective parents are traversed is called a <b>post-order</b> walk; a walk in which a node's left subtree, then the node itself, and finally its right subtree are traversed is called an <b>in-order</b> traversal. (This last scenario, referring to exactly two subtrees, a left subtree and a right subtree, assumes specifically a binary tree.) A <b>level-order</b> walk effectively performs a breadth-first search over the entirety of a tree; nodes are traversed level by level, where the root node is visited first, followed by its direct child nodes and their siblings, followed by its grandchild nodes and their siblings, etc., until all nodes in the tree have been traversed.
</p>
<h2><span class="mw-headline" id="Representations">Representations</span><span class="mw-editsection"></span></h2>
<p>There are many different ways to represent trees. In working memory, nodes are typically dynamically allocated records with pointers to their children, their parents, or both, as well as any associated data.  If of a fixed size, the nodes might be stored in a list. Nodes and relationships between nodes might be stored in a separate special type of adjacency list. In relational databases, nodes are typically represented as table rows, with indexed row IDs facilitating pointers between parents and children. 
</p><p>Nodes can also be stored as items in an array, with relationships between them determined by their positions in the array (as in a binary heap).
</p><p>A binary tree can be implemented as a list of lists: the head of a list (the value of the first term) is the left child (subtree), while the tail (the list of second and subsequent terms) is the right child (subtree). This can be modified to allow values as well, as in Lisp S-expressions, where the head (value of first term) is the value of the node, the head of the tail (value of second term) is the left child, and the tail of the tail (list of third and subsequent terms) is the right child.
</p><p>Ordered trees can be naturally encoded by finite sequences, for example with natural numbers.<sup class="reference" id="cite_ref-Afanasiev2005_5-0">[4]</sup>
</p>
<h2><span class="mw-headline" id="Type_theory">Type theory</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Unreferenced_section plainlinks metadata ambox ambox-content ambox-Unreferenced" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>As an abstract data type, the abstract tree type <span class="texhtml mvar" style="font-style:italic;">T</span> with values of some type <span class="texhtml mvar" style="font-style:italic;">E</span> is defined, using the abstract forest type <span class="texhtml mvar" style="font-style:italic;">F</span> (list of trees), by the functions:
</p>
<dl><dd>value: <span class="texhtml mvar" style="font-style:italic;">T</span> → <span class="texhtml mvar" style="font-style:italic;">E</span></dd>
<dd>children: <span class="texhtml mvar" style="font-style:italic;">T</span> → <span class="texhtml mvar" style="font-style:italic;">F</span></dd>
<dd>nil: () → <span class="texhtml mvar" style="font-style:italic;">F</span></dd>
<dd>node: <span class="texhtml mvar" style="font-style:italic;">E</span> × <span class="texhtml mvar" style="font-style:italic;">F</span> → <span class="texhtml mvar" style="font-style:italic;">T</span></dd></dl>
<p>with the axioms:
</p>
<dl><dd>value(node(<span class="texhtml mvar" style="font-style:italic;">e</span>, <span class="texhtml mvar" style="font-style:italic;">f</span>)) = <span class="texhtml mvar" style="font-style:italic;">e</span></dd>
<dd>children(node(<span class="texhtml mvar" style="font-style:italic;">e</span>, <span class="texhtml mvar" style="font-style:italic;">f</span>)) = <span class="texhtml mvar" style="font-style:italic;">f</span></dd></dl>
<p>In terms of type theory, a tree is an inductive type defined by the constructors <span class="texhtml">nil</span> (empty forest) and <span class="texhtml">node</span> (tree with root node with given value and children).
</p>
<h2><span class="mw-headline" id="Mathematical_terminology">Mathematical terminology</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Unreferenced_section plainlinks metadata ambox ambox-content ambox-Unreferenced" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>Viewed as a whole, a tree data structure is an ordered tree, generally with values attached to each node. Concretely, it is (if required to be non-empty):
</p>
<ul><li>A rooted tree with the "away from root" direction (a more narrow term is an "arborescence"), meaning:
<ul><li>A directed graph,</li>
<li>whose underlying undirected graph is a tree (any two vertices are connected by exactly one simple path),</li>
<li>with a distinguished root (one vertex is designated as the root),</li>
<li>which determines the direction on the edges (arrows point away from the root; given an edge, the node that the edge points from is called the <i>parent</i> and the node that the edge points to is called the <i>child</i>), together with:</li></ul></li>
<li>an ordering on the child nodes of a given node, and</li>
<li>a value (of some data type) at each node.</li></ul>
<p>Often trees have a fixed (more properly, bounded) branching factor (outdegree), particularly always having two child nodes (possibly empty, hence <i>at most</i> two <i>non-empty</i> child nodes), hence a "binary tree".
</p><p>Allowing empty trees makes some definitions simpler, some more complicated: a rooted tree must be non-empty, hence if empty trees are allowed the above definition instead becomes "an empty tree or a rooted tree such that ...". On the other hand, empty trees simplify defining fixed branching factor: with empty trees allowed, a binary tree is a tree such that every node has exactly two children, each of which is a tree (possibly empty). The complete sets of operations on the tree must include the fork operation.<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (April 2022)">clarification needed</span></i>]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Tree structure (general)</li>
<li>Category:Trees (data structures) (catalogs types of computational trees)</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li>Donald Knuth. <i>The Art of Computer Programming: Fundamental Algorithms</i>, Third Edition. Addison-Wesley, 1997. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-201-89683-4 . Section 2.3: Trees, pp. 308–423.</li>
<li>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. <i>Introduction to Algorithms</i>, Second Edition. MIT Press and McGraw-Hill, 2001. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-262-03293-7. Section 10.4: Representing rooted trees, pp. 214–217. Chapters 12–14 (Binary Search Trees, Red–Black Trees, Augmenting Data Structures), pp. 253–320.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Data Trees as a Means of Presenting Complex Data Analysis by Sally Knipe on August 8, 2013</li>
<li>Description from the Dictionary of Algorithms and Data Structures</li>
<li>CRAN package data.tree – implementation of a tree data structure in the R programming language</li>
<li>WormWeb.org: Interactive Visualization of the <i>C. elegans</i> Cell Tree – Visualize the entire cell lineage tree of the nematode <i>C. elegans</i> (javascript)</li>
<li><i>Binary Trees</i> by L. Allison</li></ul>


<!-- 
NewPP limit report
Parsed by mw2412
Cached time: 20221224002009
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.389 seconds
Real time usage: 0.555 seconds
Preprocessor visited node count: 2906/1000000
Post‐expand include size: 70549/2097152 bytes
Template argument size: 4022/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 34468/5000000 bytes
Lua time usage: 0.208/10.000 seconds
Lua memory usage: 6095160/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  446.792      1 -total
 24.97%  111.559      2 Template:Reflist
 17.85%   79.759      1 Template:MathWorld
 11.10%   49.595      1 Template:Short_description
  9.66%   43.173      2 Template:Unreferenced_section
  9.22%   41.215      1 Template:Commons_category
  8.81%   39.354      1 Template:Sister_project
  8.75%   39.109      1 Template:Graph_search_algorithm
  8.63%   38.574      2 Template:Unreferenced
  8.46%   37.814      1 Template:Side_box
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:30806-0!canonical and timestamp 20221224002008 and revision id 1125686020.
 -->
</div></body>
</html>