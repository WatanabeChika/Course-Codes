<!DOCTYPE html>
<html>
<head>
<title>comb_sort</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1066479718">.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}</style><table class="infobox"><caption class="infobox-title">Comb sort</caption><tbody><tr><td class="infobox-image" colspan="2"><img alt="Visualisation of comb sort" data-file-height="257" data-file-width="269" decoding="async" height="257" src="//upload.wikimedia.org/wikipedia/commons/4/46/Comb_sort_demo.gif" width="269"/></td></tr><tr><th class="infobox-label" scope="row">Class</th><td class="infobox-data">Sorting algorithm</td></tr><tr><th class="infobox-label" scope="row">Data structure</th><td class="infobox-data">Array</td></tr><tr><th class="infobox-label" scope="row">Worst-case performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(n^{2})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(n^{2})}</annotation>
</semantics>
</math></span><img alt="O(n^{2})" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6cd9594a16cb898b8f2a2dff9227a385ec183392" style="vertical-align: -0.838ex; width:6.032ex; height:3.176ex;"/></span><sup class="reference" id="cite_ref-BB_1-0">[1]</sup></td></tr><tr><th class="infobox-label" scope="row">Best-case performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \Theta (n\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">Θ<!-- Θ --></mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \Theta (n\log n)}</annotation>
</semantics>
</math></span><img alt="\Theta(n \log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1b8781cea4259c3bd43204e02d08b9b9ce8fe0ff" style="vertical-align: -0.838ex; width:10.153ex; height:2.843ex;"/></span></td></tr><tr><th class="infobox-label" scope="row">Average performance</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \Omega (n^{2}/2^{p})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi mathvariant="normal">Ω<!-- Ω --></mi>
<mo stretchy="false">(</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \Omega (n^{2}/2^{p})}</annotation>
</semantics>
</math></span><img alt="\Omega(n^2/2^p)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e46c3bcb243a7c198840f5d4f79f09fa64fa3888" style="vertical-align: -0.838ex; width:9.32ex; height:3.176ex;"/></span>, where <span class="texhtml"><i>p</i></span> is the number of increments<sup class="reference" id="cite_ref-BB_1-1">[1]</sup></td></tr><tr><th class="infobox-label" scope="row">Worst-case space complexity</th><td class="infobox-data"><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
</semantics>
</math></span><img alt="O(1)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;"/></span></td></tr></tbody></table>
<p><b>Comb sort</b> is a relatively simple sorting algorithm originally designed by Włodzimierz Dobosiewicz and Artur Borowy in 1980,<sup class="reference" id="cite_ref-BB_1-2">[1]</sup><sup class="reference" id="cite_ref-2">[2]</sup> later rediscovered (and given the name "Combsort") by Stephen Lacey and Richard Box in 1991.<sup class="reference" id="cite_ref-3">[3]</sup> Comb sort improves on bubble sort in the same way that Shellsort improves on insertion sort.<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (November 2022)">clarification needed</span></i>]</sup>
</p><p><i>nist.gov'</i>s "diminishing increment sort" definition mentions the term 'comb sort' as visualizing iterative passes of the data, "where the teeth of a comb touch;" the former term is linked to Don Knuth.<sup class="reference" id="cite_ref-4">[4]</sup>
</p>

<h2><span class="mw-headline" id="Algorithm">Algorithm</span><span class="mw-editsection"></span></h2>
<p>The basic idea is to eliminate <i>turtles</i>, or small values near the end of the list, since in a bubble sort these slow the sorting down tremendously. <i>Rabbits</i>, large values around the beginning of the list, do not pose a problem in bubble sort.
</p><p>In bubble sort, when any two elements are compared, they always have a <i>gap</i> (distance from each other) of 1.<sup class="reference" id="cite_ref-5">[5]</sup> The basic idea of comb sort is that the gap can be much more than 1. The inner loop of bubble sort, which does the actual <i>swap</i>, is modified such that the gap between swapped elements goes down (for each iteration of outer loop) in steps of a "shrink factor" <i>k</i>: <span class="texhtml">[<style data-mw-deduplicate="TemplateStyles:r1050945101">.mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="sfrac tion" role="math"><span class="num"><i>n</i></span><span class="sr-only">/</span><span class="den"><i>k</i></span></span>, <link href="mw-data:TemplateStyles:r1050945101" rel="mw-deduplicated-inline-style"/><span class="sfrac tion" role="math"><span class="num"><i>n</i></span><span class="sr-only">/</span><span class="den"><i>k</i><sup>2</sup></span></span>, <link href="mw-data:TemplateStyles:r1050945101" rel="mw-deduplicated-inline-style"/><span class="sfrac tion" role="math"><span class="num"><i>n</i></span><span class="sr-only">/</span><span class="den"><i>k</i><sup>3</sup></span></span>, ..., 1]</span>.
</p><p>The gap starts out as the length of the list <i>n</i> being sorted divided by the shrink factor <i>k</i> (generally 1.3; see below) and one pass of the aforementioned modified bubble sort is applied with that gap. Then the gap is divided by the shrink factor again, the list is sorted with this new gap, and the process repeats until the gap is 1. At this point, comb sort continues using a gap of 1 until the list is fully sorted. The final stage of the sort is thus equivalent to a bubble sort, but by this time most turtles have been dealt with, so a bubble sort will be efficient.
</p><p>The shrink factor has a great effect on the efficiency of comb sort. <i>k</i> = 1.3 has been suggested as an ideal shrink factor by the authors of the original article after empirical testing on over 200,000 random lists. A value too small slows the algorithm down by making unnecessarily many comparisons, whereas a value too large fails to effectively deal with turtles, making it require many passes with 1 gap size.
</p><p>The pattern of repeated sorting passes with decreasing gaps is similar to Shellsort, but in Shellsort the array is sorted completely each pass before going on to the next-smallest gap.  Comb sort's passes do not completely sort the elements.  This is the reason that Shellsort gap sequences have a larger optimal shrink factor of about 2.2.
</p>
<h3><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h3>
<pre><b>function</b> combsort(<b>array</b> input) <b>is</b>

    gap := input.size <span style="color:green">// Initialize gap size</span>
    shrink := 1.3 <span style="color:green">// Set the gap shrink factor</span>
    sorted := false

    <b>loop while</b> sorted = false
        <span style="color:green">// Update the gap value for a next comb</span>
        gap := floor(gap / shrink)
        <b>if</b> gap ≤ 1 <b>then</b>
            gap := 1
            sorted := true <span style="color:green">// If there are no swaps this pass, we are done</span>
        <b>end if</b>

        <span style="color:green">// A single "comb" over the input list</span>
        i := 0
        <b>loop while</b> i + gap &lt; input.size<span style="color:green"> // See Shell sort for a similar idea</span>
            <b>if</b> input[i] &gt; input[i+gap] <b>then</b>
                swap(input[i], input[i+gap])
                sorted := false
                <span style="color:green">// If this assignment never happens within the loop,
                // then there have been no swaps and the list is sorted.</span>
             <b>end if</b>
    
             i := i + 1
         <b>end loop</b>
     <b>end loop</b>
<b>end function</b>
</pre>
<h3><span class="mw-headline" id="Python_code">Python code</span><span class="mw-editsection"></span></h3>
<p>Plus, two quick Python implementations: one works on the list (or array, or other mutable type where the operations used on it make sense to the language) in-place, the other makes a list with the same values as the given data and returns that after sorting it (similar to the builtin `sorted` function).
</p>

<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1097025294">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:#f9f9f9}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style>
<ul><li>Bubble sort, a generally slower algorithm, is the basis of comb sort.</li>
<li>Cocktail sort, or bidirectional bubble sort, is a variation of bubble sort that also addresses the problem of turtles, albeit less effectively.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>

<!-- 
NewPP limit report
Parsed by mw2335
Cached time: 20221224062746
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.240 seconds
Real time usage: 0.373 seconds
Preprocessor visited node count: 1165/1000000
Post‐expand include size: 33312/2097152 bytes
Template argument size: 2620/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 27808/5000000 bytes
Lua time usage: 0.133/10.000 seconds
Lua memory usage: 4272923/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  297.279      1 -total
 31.49%   93.627      1 Template:Reflist
 22.05%   65.540      2 Template:Cite_journal
 17.08%   50.787      1 Template:Short_description
 16.75%   49.782      1 Template:Infobox_algorithm
 15.62%   46.444      1 Template:Infobox
 13.39%   39.813      1 Template:Sorting
 12.70%   37.763      1 Template:Navbox
 10.33%   30.717      1 Template:Clarification_needed
  9.61%   28.582      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:159439-0!canonical and timestamp 20221224062746 and revision id 1124725248.
 -->
</div></body>
</html>