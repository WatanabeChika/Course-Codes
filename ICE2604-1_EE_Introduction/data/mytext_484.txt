linear_hashingLinear hashing (LH) is a dynamic data structure which implements a hash table and grows or shrinks one bucket at a time. It was invented by Witold Litwin in 1980.[1][2]  It has been analyzed by Baeza-Yates and Soza-Pollman.[3] It is the first in a number of schemes known as dynamic hashing[3][4] such as Larson's Linear Hashing with Partial Extensions, [5]Linear Hashing with Priority Splitting,[6]Linear Hashing with Partial Expansions and Priority Splitting,[7]or Recursive Linear Hashing.[8]The file structure of a dynamic hashing data structure adapts itself to changes in the size of the file, so expensive periodic file reorganization is avoided.[4] A Linear Hashing file expands by splittinga pre-determined bucket into two and contracts by merging two predetermined buckets into one. The trigger for a reconstruction depends on the flavor of the scheme; it could be an overflow at a bucket or load factor (number of records divided by the number of buckets) moving outside of a predetermined range.[1]In Linear Hashing there are two types of buckets, those that are to be split and those already split. While extendible hashing splits only overflowing buckets,spiral hashing (a.k.a. spiral storage) distributes records unevenly over the buckets suchthat buckets with high costs of insertion, deletion, or retrieval are earliest in linefor a split.[5]Linear Hashing has also been made into a scalable distributed data structure, LH*. In LH*, each bucket resides at a different server.[9] LH* itself has been expanded to provide data availability in the presence offailed buckets.[10] Key based operations (inserts, deletes, updates, reads) in LH and LH* take maximum constant time independent of the number of buckets and hence of records.[1][10]Records in LH or LH* consists of a key and a content, the latter basically all the other attributes of the record.[1][10]  They are stored in buckets. For example, in Ellis' implementation, a bucket is a linked list of records.[2] The file allows the key based CRUD operations create or insert, read, update, and delete as well as a scan operations that scans all records, for example to do a database select operation on a non-key attribute.[10] Records are stored in buckets whose numbering starts with 0.[10]In order to access a record with key , a family of hash functions, calledcollectively a dynamic hash function is applied to the key . At any time, at most two hash functions  and  are used. A typicalexample uses the division modulo x operation. If the original number of buckets is, then the family of hash functions is [10]As the file grows through insertions, it expands gracefully through the splittingof one bucket into two buckets. The sequence of buckets to split is predetermined.This is the fundamental difference to schemes like Fagin's extendible hashing.[11]For the two new buckets, the hash function  is replaced with . The number of the bucket to be split is part of the file state and called the split pointer .[10]A split can be performed whenever a bucket overflows.  This is an uncontrolled split.Alternatively, the file can monitor the load factor and performs a split wheneverthe load factor exceeds a threshold. This was controlled splitting.[10]Addressing is based on the file state, consisting of the split pointer and the level .  If the level is , then the hash functionsused are  and .The LH algorithm for hashing key  is[10]if When a bucket is split, split pointer and possibly the level are updated according to[10]if : If under controlled splitting the load factor sinks below a threshold, a merge operationis triggered. The merge operation undoes the last split, also resetting the file state.[10]The file state consists of split pointer  and level . If the original file started with  buckets, then the number of buckets  and the file state are related via[12]The main contribution of LH* is to allow a client of an LH* file to find the bucket wherethe record resides even if the client does not know the file state. Clients in fact storetheir version of the file state, which is initially just the knowledge of the first bucket, namely Bucket 0. Based on their file state, a client calculates the address of akey and sends a request to that bucket. At the bucket, the request is checked and ifthe record is not at the bucket, it is forwarded.  In a reasonably stable system, that is, if there is only one split or merge going on while the request is processed, it canbe shown that there are at most two forwards. After a forward, the final bucket sends an Image Adjustment Message to the client whose state is now closer to the state of the distributed file.[10]  While forwards are reasonably rare for active clients, their number can be even further reduced by additional information exchange between servers and clients [12]Griswold and Townsend [13] discussed the adoption of linear hashing in the Icon language. They discussed the implementation alternatives of dynamic array algorithm used in linear hashing, and presented performance comparisons using a list of Icon benchmark applications.Linear hashing is used in the Berkeley database system (BDB), which in turn is used by many software systems, using a C implementation derived from the CACM article and first published on the Usenet in 1988 by Esmond Pitt.TommyDS, C implementation of a Linear HashtableAn in Memory Go Implementation with ExplanationA C++ Implementation of Linear Hashtable which Supports Both Filesystem and In-Memory storageExtendible hashingConsistent hashingSpiral Hashing