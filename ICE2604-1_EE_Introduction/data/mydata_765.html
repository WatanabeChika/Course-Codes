<!DOCTYPE html>
<html>
<head>
<title>pointer_machine</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-Tone plainlinks metadata ambox ambox-style ambox-Tone" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In theoretical computer science a <b>pointer machine</b> is an "atomistic" <i>abstract computational machine</i> model akin to the random-access machine. A <b>pointer algorithm</b> is an algorithm restricted to the pointer machine model.<sup class="reference" id="cite_ref-1">[1]</sup>
</p><p>Depending on the type, a pointer machine may be called a linking automaton, a KU-machine, an SMM, an atomistic LISP machine, a tree-pointer machine, etc. (cf Ben-Amram 1995). At least three major varieties exist in the literature—the Kolmogorov-Uspenskii model (KUM, KU-machine), the Knuth linking automaton, and the Schönhage Storage Modification Machine model (SMM). The SMM seems to be the most common.
</p><p>From its "read-only tape" (or equivalent) a pointer machine receives <i>input</i>—bounded symbol-sequences ("words") made of at least two symbols e.g. { 0, 1 } -- and it writes <i>output</i> symbol-sequences on an output "write-only" tape (or equivalent). To transform a symbol-sequence (input word) to an output symbol-sequence the machine is equipped with a "program"—a finite-state machine (memory and list of instructions). Via its state machine the program <i>reads</i> the input symbols, <i>operates</i> on its <i>storage structure</i>—a collection of "nodes" (registers) interconnected by "edges" (pointers labelled with the symbols e.g. { 0, 1 }), and <i>writes</i> symbols on the output tape.
</p><p>Pointer machines cannot do arithmetic in normal ways. Computation proceeds only by reading input symbols, modifying and doing various tests on its storage structure—the pattern of nodes and pointers, and outputting symbols based on the tests. "Information" is in the storage <i>structure</i>.
</p>

<h2><span id="Types_of_.22pointer_machines.22"></span><span class="mw-headline" id='Types_of_"pointer_machines"'>Types of "pointer machines"</span><span class="mw-editsection"></span></h2>
<p>Both Gurevich and Ben-Amram list a number of very similar "atomistic" models of "abstract machines"; Ben-Amram believes that the 6 "atomistic models" must be distinguished from "High-level" models. This article will discuss the following 3 atomistic models in particular:
</p>
<ul><li>Schönhage's storage modification machines (SMM),</li>
<li>Kolmogorov–Uspenskii machines (KUM or KU-Machines),</li>
<li>Knuth's "linking automaton"</li></ul>
<p>But Ben-Amram add more:
</p>
<ul><li>Atomistic pure-LISP machine (APLM)</li>
<li>Atomistic full-LISP machine (AFLM),</li>
<li>General atomistic pointer machines,</li>
<li>Jone's I language (two types)</li></ul>
<h2><span class="mw-headline" id="Problems_with_the_pointer-machine_model">Problems with the pointer-machine model</span><span class="mw-editsection"></span></h2>
<p><b>Use of the model in complexity theory</b>:
van Emde Boas (1990) expresses concern that this form of abstract model is:
</p>
<dl><dd>"an interesting theoretical model, but ... its attractiveness as a fundamental model for complexity theory is questionable. Its time measure is based on uniform time in a context where this measure is known to underestimate the true time complexity. The same observation holds for the space measure for the machine" (van Emde Boas (1990) p. 35)</dd></dl>
<p>Gurevich 1988 also expresses concern:
</p>
<dl><dd>"Pragmatically speaking, the Schönhage model provides a good measure of time complexity at the current state of the art (though I would prefer something along the lines of the random access computers of Angluin and Valiant)" (Gurevich (1988) p. 6 with reference to Angluin D. and Valiant L. G., "Fast Probabilistic Algorithms for Hamiltonian Circuits and Matchings", <i>Journal of Computer and System Sciences</i> 18 (1979) 155-193.)</dd></dl>
<p>The fact that, in §3 and §4 (pp. 494–497), Schönhage himself (1980) demonstrates the real-time equivalences of his two random-access machine models "RAM0" and "RAM1" leads one to question the necessity of the SMM for complexity studies.
</p><p><b>Potential uses for the model</b>: However, Schönhage (1980) demonstrates in his §6, <i>Integer-multiplication in linear time</i>. And Gurevich wonders whether or not the "parallel KU machine" "resembles somewhat the human brain" (Gurevich (1988) p. 5)
</p>
<h2><span id="Sch.C3.B6nhage.27s_storage_modification_machine_.28SMM.29_model"></span><span class="mw-headline" id="Schönhage's_storage_modification_machine_(SMM)_model">Schönhage's storage modification machine (SMM) model</span><span class="mw-editsection"></span></h2>
<p>Schönhage's SMM model seems to be the most common and most accepted. It is quite unlike the register machine model and other common computational models e.g. the tape-based Turing machine or the labeled holes and indistinguishable pebbles of the counter machine.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>The computer consists of a fixed alphabet of input symbols, and a mutable directed graph (aka a state diagram) with its arrows labelled by alphabet symbols. Each node of the graph has exactly one outgoing arrow labelled with each symbol, although some of these may loop back into the original node. One fixed node of the graph is identified as the start or "active" node.
</p><p>Each word of symbols in the alphabet can then be translated to a pathway through the machine; for example, 10011 would translate to taking path 1 from the start node, then path 0 from the resulting node, then path 0, then path 1, then path 1. The path can, in turn, be identified with the resulting node, but this identification will change as the graph changes during the computation.
</p><p>The machine can receive instructions which change the layout of the graph. The basic instructions are the <b>new <i>w</i></b> instruction, which creates a new node which is the "result" of following the string <i>w</i>, and the <b>set <i>w</i> to <i>v</i></b> instruction which (re)directs an edge to a different node. Here <i>w</i> and <i>v</i> represent <i>words</i>. <i>v</i> is a <i>former</i> word—i.e. a previously-created string of symbols—so that the redirected edge will point "backwards" to an old node that is the "result" of that string.
</p>

<p>(1) <b>new</b> <i>w</i>: creates a new node. <i>w</i> represents the new <i>word</i> that creates the new node. The machine reads the word <i>w</i>, following the path represented by the symbols of <i>w</i> until the machine comes to the last, "additional" symbol in the word. The additional symbol instead forces the last state to create a new node, and "flip" its corresponding arrow (the one labelled with  that symbol) from its old position to point to the new node. The new node in turn points all its edges back to the old last-state, where they just "rest" until redirected by another <b>new</b> or <b>set</b>. In a sense the new nodes are "sleeping", waiting for an assignment. In the case of the starting or center node we likewise would begin with both of its edges pointing back to itself.
</p>
<ul><li>Example: Let "w" be 10110[1], where the final character is in brackets to denote its special status. We take the 1 edge of the node reached by 10110 (at the end of a five-edge, hence six-node, pathway), and point it to a new 7th node. The two edges of this new node then point "backward" to the 6th node of the path.</li></ul>
<p>(2)<b>Set</b> <i>w</i> <b>to</b> <i>v</i>: redirects (moves) an edge (arrow) from the path represented by word <i>w</i> to a former node that represents word <i>v</i>. Again it is the last arrow in the path that is redirected.
</p>
<ul><li>Example: <b>Set 1011011 to 1011</b>, after the above instruction, would change the 1 arrow of the new node at 101101 to point to the fifth node in the pathway, reached at 1011. Thus the path 1011011 would now have the same result as 1011.</li></ul>
<p>(3)<b>If</b> <i>v = w</i> <b>then</b> instruction <b>z</b> : Conditional instruction that compares two paths represented by words <i>w</i> and <i>v</i> to see if they end at the same node; if so jump to instruction <b>z</b> else continue. This instruction serves the same purpose as its counterpart in a register machine or Wang b-machine, corresponding to a Turing machine's ability to jump to a new state.
</p>

<h2><span id="Knuth.27s_.22linking_automaton.22_model"></span><span class="mw-headline" id="Knuth's_&quot;linking_automaton&quot;_model">Knuth's "linking automaton" model</span><span class="mw-editsection"></span></h2>
<p>According to Schoenhage, Knuth noted that the SMM model coincides with a special type of "linking automata" briefly explained in volume one of The Art of Computer Programming (cf. [4, pp. 462–463])
</p>
<h2><span id="Kolmogorov.E2.80.93Uspenskii_machine_.28KU-machine.29_model"></span><span class="mw-headline" id="Kolmogorov–Uspenskii_machine_(KU-machine)_model">Kolmogorov–Uspenskii machine (KU-machine) model</span><span class="mw-editsection"></span></h2>
<p>KUM differs from SMM in allowing only invertible pointers: for every pointer from a node x to a node y, an inverse pointer from y to x must be present. Since outgoing pointers must be labeled by distinct symbols of the alphabet, both KUM and SMM graphs have O(1) outdegree. However, KUM pointers' invertibility restricts the in-degree to O(1), as well. This addresses some concerns for physical (as opposite to purely informational) realism, like those in the above van Emde Boas quote.
</p><p>An additional difference is that the KUM was intended as a generalization of the Turing machine, and so it allows the currently "active" node to be moved around the graph. Accordingly, nodes can be specified by individual characters instead of words, and the action to be taken can be determined by a state table instead of a fixed list of instructions.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<p>Register machine—generic register-based abstract machine computational model
</p>
<ul><li>Counter machine—most primitive machine, base models' instruction-sets are used throughout the class of register machines</li>
<li>Random-access machine—RAM: counter machine with added indirect addressing capability</li>
<li>Random-access stored-program machine—RASP: counter-based or RAM-based machine with a "program of instructions" to be found in the registers themselves in the matter of a Universal Turing machine i.e. the von Neumann architecture.</li></ul>
<p>Turing machine—generic tape-based abstract machine computational model
</p>
<ul><li>Post–Turing machine—minimalist one-tape, two-direction, 1 symbol { blank, mark } Turing-like machine but with default sequential instruction execution in a manner similar to the basic 3-instruction counter machines.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style><link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-More_footnotes plainlinks metadata ambox ambox-style ambox-More_footnotes" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>Most references and a bibliography are to be found at the article Register machine. The following are particular to this article:
</p>
<ul><li>Amir Ben-Amram (1995), <i>What is a "Pointer machine"?</i>, SIGACTN: SIGACT News (ACM Special Interest Group on Automata and Computability Theory)", volume 26, 1995. also: DIKU, Department of Computer Science, University of Copenhagen, amirben@diku.dk. Wherein Ben-Amram describes the types and subtypes: (type 1a) Abstract Machines: Atomistic models including Kolmogorov-Uspenskii Machines (KUM), Schönhage's Storage Modification Machines (SMM), Knuth's "Linking Automaton", APLM and AFLM (Atomistic Pure-LISP Machine) and (Atomistic Full-LISP machine), General atomistic Pointer Machines, Jone's I Language; (type 1b) Abstract Machines: High-level models, (type 2) Pointer algorithms.</li>
<li>Andrey Kolmogorov and V. Uspenskii, <i>On the definition of an algorithm,</i> Uspekhi Mat. Nauk 13 (1958), 3-28. English translation in American Mathematical Society Translations, Series II, Volume 29 (1963), pp. 217–245.</li>
<li>Yuri Gurevich (2000), <i>Sequential Abstract State Machines Capture Sequential Algorithms</i>, ACM Transactions on Computational Logic, vol. 1, no. 1, (July 2000), pages 77–111. In a single sentence Gurevich compares the Schönhage [1980] "storage modification machines" to Knuth's "pointer machines." For more, similar models such as "random access machines" Gurevich references:
<ul><li>John E. Savage (1998), <i>Models of Computation: Exploring the Power of Computing</i>. Addison Wesley Longman.</li></ul></li>
<li>Yuri Gurevich (1988), <i>On Kolmogorov Machines and Related Issues</i>, the column on "Logic in Computer Science", Bulletin of European Association for Theoretical Computer Science, Number 35, June 1988, 71-82. Introduced the unified description of Schönhage and Kolmogorov-Uspenskii machines used here.</li>
<li>Arnold Schönhage (1980), <i>Storage Modification Machines</i>, Society for Industrial and Applied Mathematics, SIAM J. Comput. Vol. 9, No. 3, August 1980. Wherein Schönhage shows the equivalence of his SMM with the "successor RAM" (Random Access Machine), etc. He refers to an earlier paper where he introduces the SMM:
<ul><li>Arnold Schönhage (1970), <i>Universelle Turing Speicherung</i>, Automatentheorie und Formale Sprachen, Dörr, Hotz, eds. Bibliogr. Institut, Mannheim, 1970, pp. 69–383.</li></ul></li>
<li>Peter van Emde Boas, <i>Machine Models and Simulations</i> pp. 3–66, appearing in:</li></ul>
<dl><dd><dl><dd>Jan van Leeuwen, ed. "Handbook of Theoretical Computer Science. Volume A: Algorithms and Complexity<i>, The MIT PRESS/Elsevier, 1990. <link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/>ISBN 0-444-88071-2 (volume A). QA 76.H279 1990.</i></dd></dl></dd>
<dd>van Emde Boas' treatment of SMMs appears on pp. 32-35. This treatment clarifies Schönhage 1980 -- it closely follows but expands slightly the Schönhage treatment. Both references may be needed for effective understanding.</dd></dl>
<!-- 
NewPP limit report
Parsed by mw2309
Cached time: 20221214161048
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.140 seconds
Real time usage: 0.199 seconds
Preprocessor visited node count: 639/1000000
Post‐expand include size: 11469/2097152 bytes
Template argument size: 604/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 9278/5000000 bytes
Lua time usage: 0.077/10.000 seconds
Lua memory usage: 2708084/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  162.537      1 -total
 44.72%   72.689      1 Template:Reflist
 36.28%   58.964      1 Template:Cite_web
 31.67%   51.468      1 Template:Tone
 31.54%   51.271      2 Template:Ambox
 14.66%   23.834      1 Template:More_footnotes_needed
  8.00%   13.003      1 Template:ISBN
  5.27%    8.562      1 Template:DMCA
  4.47%    7.259      1 Template:Dated_maintenance_category
  4.12%    6.700      1 Template:Catalog_lookup_link
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:6144616-0!canonical and timestamp 20221214161047 and revision id 1102623526.
 -->
</div></body>
</html>