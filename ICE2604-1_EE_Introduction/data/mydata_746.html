<!DOCTYPE html>
<html>
<head>
<title>Pearson's_hash</title>
</head>
<body>
<div class="mw-parser-output">
<p><b>Pearson hashing</b> is a hash function designed for fast execution on processors with 8-bit registers. Given an input consisting of any number of bytes, it produces as output a single byte that is strongly dependent on every byte of the input. Its implementation requires only a few instructions, plus a 256-byte lookup table containing a permutation of the values 0 through 255.<sup class="reference" id="cite_ref-acmref_1-0">[1]</sup>
</p><p>This hash function is a CBC-MAC that uses an 8-bit substitution cipher implemented via the substitution table. An 8-bit cipher has negligible cryptographic security, so the Pearson hash function is not cryptographically strong, but it is useful for implementing hash tables or as a data integrity check code, for which purposes it offers these benefits:
</p>
<ul><li>It is extremely simple.</li>
<li>It executes quickly on resource-limited processors.</li>
<li>There is no simple class of inputs for which collisions (identical outputs) are especially likely.</li>
<li>Given a small, privileged set of inputs (e.g., reserved words for a compiler), the permutation table can be adjusted so that those inputs yield distinct hash values, producing what is called a perfect hash function.</li>
<li>Two input strings differing by exactly one character never collide.<sup class="reference" id="cite_ref-univ_2-0">[2]</sup> E.g., applying the algorithm on the strings ABC and AEC will never produce the same value.</li></ul>
<p>One of its drawbacks when compared with other hashing algorithms designed for 8-bit processors is the suggested 256 byte lookup table, which can be prohibitively large for a small microcontroller with a program memory size on the order of hundreds of bytes. A workaround to this is to use a simple permutation function instead of a table stored in program memory. However, using a too simple function, such as <code>T[i] = 255-i</code>, partly defeats the usability as a hash function as anagrams will result in the same hash value; using a too complex function, on the other hand, will affect speed negatively. Using a function rather than a table also allows extending the block size. Such functions naturally have to be bijective, like their table variants.
</p><p>The algorithm can be described by the following pseudocode, which computes the hash of message <i>C</i> using the permutation table <i>T</i>:
</p>
<pre><b>algorithm</b> pearson hashing <b>is</b>
    h := 0

    <b>for each</b> c <b>in</b> C <b>loop</b>
        h := T[ h <b>xor</b> c ]
    <b>end loop</b>

    <b>return</b> h
</pre>
<p>The hash variable (<code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">h</code>) may be initialized differently, e.g. to the length of the data (<code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">C</code>) modulo 256; this particular choice is used in the Python implementation example below.
</p>

<h2><span class="mw-headline" id="Example_implementations">Example implementations</span><span class="mw-editsection"></span></h2>
<h3><span id="Python.2C_8-bit_output"></span><span class="mw-headline" id="Python,_8-bit_output"> Python, 8-bit output</span><span class="mw-editsection"></span></h3>
<p>The 'table' parameter requires a pseudo-randomly shuffled list of range [0..255]. This may easily be generated by using python's builtin <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">range</code> function and using <code class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr" id="" style="">random.shuffle</code> to permutate it:
</p>

<h3><span id="C.23.2C_8-bit"></span><span class="mw-headline" id="C#,_8-bit">C#, 8-bit</span><span class="mw-editsection"></span></h3>

<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Non-cryptographic hash functions</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<!-- 
NewPP limit report
Parsed by mw1413
Cached time: 20221224001754
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.111 seconds
Real time usage: 0.917 seconds
Preprocessor visited node count: 387/1000000
Post‐expand include size: 5654/2097152 bytes
Template argument size: 350/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 13175/5000000 bytes
Lua time usage: 0.062/10.000 seconds
Lua memory usage: 2595866/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  899.178      1 -total
 38.39%  345.182      4 Template:Code
  7.10%   63.823      2 Template:Citation
  5.56%   49.990      1 Template:Short_description
  2.98%   26.775      2 Template:Pagetype
  1.41%   12.637      2 Template:Main_other
  1.22%   10.971      1 Template:SDcat
  0.22%    1.961      1 Template:Short_description/lowercasecheck
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:101219-0!canonical and timestamp 20221224001753 and revision id 1104376353.
 -->
</div></body>
</html>