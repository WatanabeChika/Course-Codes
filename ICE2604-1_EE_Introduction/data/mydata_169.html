<!DOCTYPE html>
<html>
<head>
<title>calendar_queue</title>
</head>
<body>
<div class="mw-parser-output"><p>A <b>calendar queue</b> (CQ) is a priority queue (queue in which every element has associated priority and the dequeue operation removes the highest priority element). It is analogous to desk calendar, which is used by humans for ordering future events by date. Discrete event simulations require a future event list (FEL) structure that sorts pending events according to their time. Such simulators require a good and efficient data structure as time spent on queue management can be significant. The calendar queue (with optimum bucket size) can approach O(1) average performance. Calendar queues are closely related to bucket queues but differ from them in how they are searched and in being dynamically resized.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<p>Theoretically, like a bucket queue, a calendar queue consists of an array of linked lists. Sometimes each index in the array is also referred to as a bucket. The bucket has specified width and its linked list holds events whose timestamp maps to that bucket.  A desk calendar has 365 buckets for each day with a width of one day. Each array element contains one pointer that is the head of the corresponding linked list. If the array name is “month” then month[11] is a pointer to the list of events scheduled for the 12th month of the year (the vector index starts from 0). The complete calendar thus consists of an array of 12 pointers and a collection of up to 12 linked lists. In calendar queue, enqueue (addition in a queue) and dequeue (deleting from a queue) of events in FEL is based on event time.
</p><p>Let the calendar queue with <i>n</i> buckets with <i>w</i> width. Then enqueue of an event with time <i>t</i> operates on bucket <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\frac {t}{w}}\mod n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mi>t</mi>
<mi>w</mi>
</mfrac>
</mrow>
<mspace width="1em"></mspace>
<mi>mod</mi>
<mspace width="thinmathspace"></mspace>
<mspace width="thinmathspace"></mspace>
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\frac {t}{w}}\mod n}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\frac {t}{w}}\mod n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a0862fbe1d99417a7ed160bfea7b9c2b1eb2b025" style="vertical-align: -1.838ex; width:12.157ex; height:5.176ex;"/></span> . And more than two events scheduled in the bucket according to the increased timestamp. To dequeue events from the calendar queue, it keeps track of current year and day. Then it searches for the earliest event within that bucket and dequeue it. (In contrast, a bucket queue would merely return any element from the first nonempty bucket, without determining which element in that bucket is earliest.)
</p>
<h2><span class="mw-headline" id="Calendar_Queue_Resize_Operation">Calendar Queue Resize Operation</span><span class="mw-editsection"></span></h2>
<p>If the number of events in the queue is much smaller or much larger than the number of buckets, it will not function efficiently. The solution is to allow the number of buckets to correspondingly grow and shrink as the queue grows and shrinks. To simplify the resize operation, the <i>Nb</i> (number of buckets) in a CQ is often chosen to be the power of two, i.e., <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Nb=2^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>N</mi>
<mi>b</mi>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Nb=2^{n}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Nb=2^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd9483b568df60b4fe0a2dc1bed266bba48720c9" style="vertical-align: -0.338ex; width:8.541ex; height:2.343ex;"/></span>;↵
</p><p>The number of buckets is doubled or halved each time the <i>Ne</i> (number of events) exceeds 2<i>Nb</i> or decreases below <i>Nb</i>/2 respectively. When <i>Nb</i> is resized, the new width <i>w</i> has to be calculated as well. The new <i>w</i> that is adopted will be estimated by sampling the average inter-event time gap from the first few hundred events starting at the current bucket position. Thereafter, a new Calendar queue is created and all the events in the old calendar will be recopied over.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<ul><li><style data-mw-deduplicate="TemplateStyles:r1067248974">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style><cite class="citation cs2" id="CITEREFBrown1988">Brown, R. (October 1988), "Calendar queues: a fast <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(1)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(1)}</annotation>
</semantics>
</math></span><img alt="O(1)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" style="vertical-align: -0.838ex; width:4.745ex; height:2.843ex;"/></span> priority queue implementation for the simulation event set problem", <i>Communications of the ACM</i>, <b>31</b> (10): 1220–1227, doi:10.1145/63039.63045</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Calendar+queues%3A+a+fast+MATH+RENDER+ERROR+priority+queue+implementation+for+the+simulation+event+set+problem&amp;rft.volume=31&amp;rft.issue=10&amp;rft.pages=1220-1227&amp;rft.date=1988-10&amp;rft_id=info%3Adoi%2F10.1145%2F63039.63045&amp;rft.aulast=Brown&amp;rft.aufirst=R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACalendar+queue"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFEricksonLadnerLaMarca2000">Erickson, K. Bruce; Ladner, Richard E.; LaMarca, Anthony (2000), "Optimizing static calendar queues", <i>ACM Transactions on Modeling and Computer Simulation</i>, <b>10</b> (3): 179–214, doi:10.1145/361026.361028</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=ACM+Transactions+on+Modeling+and+Computer+Simulation&amp;rft.atitle=Optimizing+static+calendar+queues&amp;rft.volume=10&amp;rft.issue=3&amp;rft.pages=179-214&amp;rft.date=2000&amp;rft_id=info%3Adoi%2F10.1145%2F361026.361028&amp;rft.aulast=Erickson&amp;rft.aufirst=K.+Bruce&amp;rft.au=Ladner%2C+Richard+E.&amp;rft.au=LaMarca%2C+Anthony&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACalendar+queue"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFFujimoto1990">Fujimoto, Richard M. (October 1990), "Parallel discrete event simulation", <i>Communications of the ACM</i>, <b>33</b> (10): 30–53, doi:10.1145/84537.84545</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Parallel+discrete+event+simulation&amp;rft.volume=33&amp;rft.issue=10&amp;rft.pages=30-53&amp;rft.date=1990-10&amp;rft_id=info%3Adoi%2F10.1145%2F84537.84545&amp;rft.aulast=Fujimoto&amp;rft.aufirst=Richard+M.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACalendar+queue"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation cs2" id="CITEREFTanThng">Tan, Kah Leong; Thng, Li-Jin, "SNOOPy Calendar Queue", <i>2000 Winter Simulation Conference Proceedings</i>, IEEE, doi:10.1109/wsc.2000.899756</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=SNOOPy+Calendar+Queue&amp;rft.btitle=2000+Winter+Simulation+Conference+Proceedings&amp;rft.pub=IEEE&amp;rft_id=info%3Adoi%2F10.1109%2Fwsc.2000.899756&amp;rft.aulast=Tan&amp;rft.aufirst=Kah+Leong&amp;rft.au=Thng%2C+Li-Jin&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACalendar+queue"></span></li></ul>
<!-- 
NewPP limit report
Parsed by mw1376
Cached time: 20221214213131
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.105 seconds
Real time usage: 0.153 seconds
Preprocessor visited node count: 159/1000000
Post‐expand include size: 6268/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 4/100
Expensive parser function count: 0/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 7280/5000000 bytes
Lua time usage: 0.070/10.000 seconds
Lua memory usage: 2933134/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  105.256      1 -total
 99.67%  104.908      4 Template:Citation
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:50075217-0!canonical and timestamp 20221214213131 and revision id 1011132080.
 -->
</div></body>
</html>