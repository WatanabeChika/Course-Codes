<!DOCTYPE html>
<html>
<head>
<title>open_addressing</title>
</head>
<body>
<div class="mw-parser-output">

<p><b>Open addressing</b>, or <b>closed hashing</b>, is a method of collision resolution in hash tables.  With this method a hash collision is resolved by <b>probing</b>, or searching through alternative locations in the array (the <i>probe sequence</i>) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table.<sup class="reference" id="cite_ref-tenenbaum90_1-0">[1]</sup> Well-known probe sequences include:
</p>
<dl><dt>Linear probing</dt>
<dd>in which the interval between probes is fixed — often set to 1.</dd>
<dt>Quadratic probing</dt>
<dd>in which the interval between probes increases quadratically (hence, the indices are described by a quadratic function).</dd>
<dt>Double hashing</dt>
<dd>in which the interval between probes is fixed for each record but is computed by another hash function.</dd></dl>
<p>The main trade offs between these methods are that linear probing has the best cache performance but is most sensitive to clustering, while double hashing has poor cache performance but exhibits virtually no clustering; quadratic probing falls in-between in both areas. Double hashing can also require more computation than other forms of probing.
</p><p>Some open addressing methods, such as
Hopscotch hashing,
 Robin Hood hashing,
last-come-first-served hashing and cuckoo hashing move existing keys around in the array to make room for the new key. This gives better maximum search times than the methods based on probing.
<sup class="reference" id="cite_ref-2">[2]</sup><sup class="reference" id="cite_ref-3">[3]</sup><sup class="reference" id="cite_ref-4">[4]</sup><sup class="reference" id="cite_ref-5">[5]</sup><sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>A critical influence on performance of an open addressing hash table is the <i>load factor</i>; that is, the proportion of the slots in the array that are used. As the load factor increases towards 100%, the number of probes that may be required to find or insert a given key rises dramatically. Once the table becomes full, probing algorithms may even fail to terminate. Even with good hash functions, load factors are normally limited to 80%. A poor hash function can exhibit poor performance even at very low load factors by generating significant clustering, especially with the simplest linear addressing method. Generally typical load factors with most open addressing methods are 50%, whilst separate chaining typically can use up to 100%.
</p>
<h2><span class="mw-headline" id="Example_pseudocode">Example pseudocode</span><span class="mw-editsection"></span></h2>
<p>The following pseudocode is an implementation of an open addressing hash table with linear probing and single-slot stepping, a common approach that is effective if the hash function is good. Each of the <b>lookup</b>, <b>set</b> and <b>remove</b> functions use a common internal function <b>find_slot</b> to locate the array slot that either does or should contain a given key.
</p>
<pre><b>record</b> pair { key, value }
<b>var</b> <i>pair array</i> slot[0..num_slots-1]
</pre>
<pre><b>function</b> find_slot(key)
    i := hash(key) modulo num_slots
    <i>// search until we either find the key, or find an empty slot.</i>
    <b>while</b> (slot[i] is occupied) and ( slot[i].key ≠ key )
        i = (i + 1) modulo num_slots
    <b>return</b> i
</pre>
<pre><b>function</b> lookup(key)
    i := find_slot(key)
    <b>if</b> slot[i] is occupied   <i>// key is in table</i>
        <b>return</b> slot[i].value
    <b>else</b>                     <i>// key is not in table</i>
        <b>return</b> not found
</pre>
<pre><b>function</b> set(key, value)
    i := find_slot(key)
    <b>if</b> slot[i] is occupied   <i>// we found our key</i>
        slot[i].value = value
        <b>return</b>
    <b>if</b> the table is almost full
        rebuild the table larger <i>(note 1)</i>
        i = find_slot(key)
    slot[i].key   = key
    slot[i].value = value
</pre>
<dl><dt>note 1</dt>
<dd>Rebuilding the table requires allocating a larger array and recursively using the <b>set</b> operation to insert all the elements of the old array into the new larger array. It is common to increase the array size exponentially, for example by doubling the old array size.</dd></dl>
<pre><b>function</b> remove(key)
    i := find_slot(key)
    <b>if</b> slot[i] is unoccupied
        return   <i>// key is not in the table</i>
    j := i
    <b>loop</b>
        mark slot[i] as unoccupied
       r2: <i>(note 2)</i>
        j := (j+1) modulo num_slots
        <b>if</b> slot[j] is unoccupied
            <b>exit loop</b>
        k := hash(slot[j].key) modulo num_slots
        // determine if k lies cyclically in (i,j]
        // |    i.k.j |
        // |....j i.k.| or  |.k..j i...|
        <b>if</b> ( (i&lt;=j) ? ((i&lt;k)&amp;&amp;(k&lt;=j)) : ((i&lt;k)||(k&lt;=j)) )
            goto r2;
        slot[i] := slot[j]
        i := j
</pre>
<dl><dt>note 2</dt>
<dd>For all records in a cluster, there must be no vacant slots between their natural hash position and their current position (else lookups will terminate before finding the record). At this point in the pseudocode, <var style="padding-right: 1px;">i</var> is a vacant slot that might be invalidating this property for subsequent records in the cluster. <var style="padding-right: 1px;">j</var> is such a subsequent record. <var style="padding-right: 1px;">k</var> is the raw hash where the record at <var style="padding-right: 1px;">j</var> would naturally land in the hash table if there were no collisions. This test is asking if the record at <var style="padding-right: 1px;">j</var> is invalidly positioned with respect to the required properties of a cluster now that <var style="padding-right: 1px;">i</var> is vacant.</dd></dl>
<p>Another technique for removal is simply to mark the slot as deleted. However this eventually requires rebuilding the table simply to remove deleted records. The methods above provide <i>O</i>(1) updating and removal of existing records, with occasional rebuilding if the high-water mark of the table size grows.
</p><p>The <i>O</i>(1) remove method above is only possible in linearly probed hash tables with single-slot stepping.  In the case where many records are to be deleted in one operation, marking the slots for deletion and later rebuilding may be more efficient.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Lazy deletion – a method of deleting from a hash table using open addressing.</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>

<!-- 
NewPP limit report
Parsed by mw2412
Cached time: 20221224001951
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.096 seconds
Real time usage: 0.141 seconds
Preprocessor visited node count: 354/1000000
Post‐expand include size: 2762/2097152 bytes
Template argument size: 433/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 5269/5000000 bytes
Lua time usage: 0.057/10.000 seconds
Lua memory usage: 2594341/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  119.073      1 -total
 51.15%   60.905      1 Template:Citation
 44.01%   52.401      1 Template:Short_description
 21.61%   25.733      2 Template:Pagetype
 14.66%   17.458      2 Template:Main_other
 13.20%   15.716      1 Template:SDcat
  1.57%    1.865      6 Template:Var
  1.49%    1.779      1 Template:Short_description/lowercasecheck
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:1583843-0!canonical and timestamp 20221224001951 and revision id 1083106369.
 -->
</div></body>
</html>