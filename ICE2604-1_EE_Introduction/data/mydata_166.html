<!DOCTYPE html>
<html>
<head>
<title>Byzantine_generals</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>A <b>Byzantine fault</b> (also <b>Byzantine generals problem</b>, <b>interactive consistency</b>, <b>source congruency</b>, <b>error avalanche</b>, <b>Byzantine agreement problem</b>, and <b>Byzantine failure</b><sup class="reference" id="cite_ref-1">[1]</sup>) is a condition of a computer system, particularly distributed computing systems, where components may fail and there is imperfect information on whether a component has failed. The term takes its name from an allegory, the "Byzantine generals problem",<sup class="reference" id="cite_ref-2">[2]</sup> developed to describe a situation in which, in order to avoid catastrophic failure of the system, the system's actors must agree on a concerted strategy, but some of these actors are unreliable.
</p><p>In a Byzantine fault, a component such as a server can inconsistently appear both failed and functioning to failure-detection systems, presenting different symptoms to different observers. It is difficult for the other components to declare it failed and shut it out of the network, because they need to first reach a consensus regarding which component has failed in the first place. <b>Byzantine fault tolerance</b> (<b>BFT</b>) is the resiliency of a fault-tolerant computer system to such conditions.
</p>

<h2><span class="mw-headline" id="Analogy">Analogy</span><span class="mw-editsection"></span></h2>

<p>In its simplest form, a number of generals are attacking a fortress and they must decide as a group whether to attack or retreat. Some generals may prefer to attack, while others prefer to retreat. The important thing is that all generals agree on a common decision, for a halfhearted attack by a few generals would become a rout, and would be worse than either a coordinated attack or a coordinated retreat.
</p><p>The problem is complicated by the presence of treacherous generals who may not only cast a vote for a suboptimal strategy, they may do so selectively. For instance, if nine generals are voting, four of whom support attacking while four others are in favor of retreat, the ninth general may send a vote of retreat to those generals in favor of retreat, and a vote of attack to the rest. Those who received a retreat vote from the ninth general will retreat, while the rest will attack (which may not go well for the attackers). The problem is complicated further by the generals being physically separated and having to send their votes via messengers who may fail to deliver votes or may forge false votes.
</p>
<h3><span class="mw-headline" id="Resolution">Resolution</span><span class="mw-editsection"></span></h3>
<p>Byzantine fault tolerance can be achieved if the loyal (non-faulty) generals have a majority agreement on their strategy. There can be a default vote value given to missing messages. For example, missing messages can be given a "null" value. Further, if the agreement is that the null votes are in the majority, a pre-assigned default strategy can be used (e.g. retreat).<sup class="reference" id="cite_ref-BGP_Paper_3-0">[3]</sup>
</p><p>The typical mapping of this story onto computer systems is that the computers are the generals and their digital communication system links are the messengers. Although the problem is formulated in the analogy as a decision-making and security problem, in electronics, it cannot be solved by cryptographic digital signatures alone, because failures such as incorrect voltages can propagate through the encryption process. Thus, a component may appear functioning to one component and faulty to another, which prevents forming a consensus as to whether the component is faulty or not.
</p>
<h2><span class="mw-headline" id="Characteristics">Characteristics</span><span class="mw-editsection"></span></h2>
<p>A Byzantine fault is any fault presenting different symptoms to different observers.<sup class="reference" id="cite_ref-DriscollHall2004_4-0">[4]</sup> A Byzantine failure is the loss of a system service due to a Byzantine fault in systems that require consensus among distributed nodes.<sup class="reference" id="cite_ref-DriscollHall2003_5-0">[5]</sup>
</p><p>The objective of Byzantine fault tolerance is to be able to defend against failures of system components with or without symptoms that prevent other components of the system from reaching an agreement among themselves, where such an agreement is needed for the correct operation of the system.
</p><p>The remaining operationally correct components of a Byzantine fault tolerant system will be able to continue providing the system's service as originally intended, assuming there are a sufficient number of accurately-operating components to maintain the service.
</p><p>Byzantine failures are considered the most general and most difficult class of failures among the failure modes. The so-called fail-stop failure mode occupies the simplest end of the spectrum. Whereas fail-stop failure mode simply means that the only way to fail is a node crash, detected by other nodes, Byzantine failures imply no restrictions, which means that the failed node can generate arbitrary data, including data that makes it appear like a functioning node. Thus, Byzantine failures can confuse failure detection systems, which makes fault tolerance difficult. Despite the analogy, a Byzantine failure is not necessarily a security problem involving hostile human interference: it can arise purely from electrical or software faults.
</p><p>The terms fault and failure are used here according to the standard definitions<sup class="reference" id="cite_ref-AvizienisLaprie2004_6-0">[6]</sup> originally created by a joint committee on "Fundamental Concepts and Terminology" formed by the IEEE Computer Society's Technical Committee on Dependable Computing and Fault-Tolerance and IFIP Working Group 10.4 on Dependable Computing and Fault Tolerance.<sup class="reference" id="cite_ref-7">[7]</sup> See also dependability.
</p>
<h3><span class="mw-headline" id="Caveat">Caveat</span><span class="mw-editsection"></span></h3>
<p>Byzantine fault tolerance is only concerned with broadcast consistency, that is, the property that when one component broadcasts a single consistent value to other components (i.e., sends the same value to the other components), they all receive exactly the same value, or in the case that the broadcaster is not consistent, the other components agree on a common value. This kind of fault tolerance does not encompass the correctness of the value itself; for example, an adversarial component that deliberately sends an incorrect value, but sends that same value consistently to all components, will not be caught in the Byzantine fault tolerance scheme.
</p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"></span></h2>
<p><b>Setting:</b><sup class="reference" id="cite_ref-8">[8]</sup>
Given a system of <span class="texhtml mvar" style="font-style:italic;">n</span> components, <span class="texhtml mvar" style="font-style:italic;">t</span> of which are dishonest, and assuming only point-to-point channel between all the components.
</p><p>Whenever a component <span class="texhtml mvar" style="font-style:italic;">A</span>  tries to broadcast a value <span class="texhtml mvar" style="font-style:italic;">x</span>, the other components are allowed to discuss with each other and verify the consistency of <span class="texhtml mvar" style="font-style:italic;">A</span>'s broadcast, and eventually settle on a common value <span class="texhtml mvar" style="font-style:italic;">y</span>.
</p><p><b>Property:</b> The system is said to resist Byzantine faults if a component <span class="texhtml mvar" style="font-style:italic;">A</span> can broadcast a value <span class="texhtml mvar" style="font-style:italic;">x</span>, and then:
</p>
<ol><li>If <span class="texhtml mvar" style="font-style:italic;">A</span> is honest, then all honest components agree on  the value  <span class="texhtml mvar" style="font-style:italic;">x</span>.</li>
<li>In any case, all honest components agree on the same value  <span class="texhtml mvar" style="font-style:italic;">y</span>.</li></ol>
<p><b>Variants:</b> The problem has been studied in the case of both synchronous and asynchronous communications.
</p><p>The communication graph above is assumed to be the complete graph (i.e. each component can discuss with every other), but the communication graph can be restricted.
</p><p>It can also be relaxed in a more "realistic" problem where the faulty components do not collude together in an attempt to lure the others into error. It is in this setting that practical algorithms have been devised.
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>The problem of obtaining Byzantine consensus was conceived and formalized by Robert Shostak, who dubbed it the <i>interactive consistency</i> problem. This work was done in 1978 in the context of the NASA-sponsored SIFT<sup class="reference" id="cite_ref-:0_9-0">[9]</sup> project in the Computer Science Lab at SRI International. SIFT (for Software Implemented Fault Tolerance) was the brain child of John Wensley, and was based on the idea of using multiple general-purpose computers that would communicate through pairwise messaging in order to reach a consensus, even if some of the computers were faulty.
</p><p>At the beginning of the project, it was not clear how many computers in total were needed to guarantee that a conspiracy of <i>n</i> faulty computers could not "thwart" the efforts of the correctly-operating ones to reach consensus. Shostak showed that a minimum of 3<i>n+</i>1 are needed, and devised a two-round 3<i>n+1</i> messaging protocol that would work for <i>n</i>=1. His colleague Marshall Pease generalized the algorithm for any n &gt; 0, proving that 3<i>n</i>+1 is both necessary and sufficient. These results, together with a later proof by Leslie Lamport of the sufficiency of 3<i>n</i> using digital signatures, were published in the seminal paper, <i>Reaching Agreement in the Presence of Faults.</i><sup class="reference" id="cite_ref-10">[10]</sup> The authors were awarded the 2005 Edsger W. Dijkstra Prize for this paper.
</p><p>To make the interactive consistency problem easier to understand, Lamport devised a colorful allegory in which a group of army generals formulate a plan for attacking a city. In its original version, the story cast the generals as commanders of the Albanian army. The name was changed, eventually settling on "Byzantine", at the suggestion of Jack Goldberg to future-proof any potential offense giving.<sup class="reference" id="cite_ref-11">[11]</sup> This formulation of the problem, together with some additional results, were presented by the same authors in their 1982 paper, "The Byzantine Generals Problem".<sup class="reference" id="cite_ref-BGP_Paper_3-1">[3]</sup>
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>Several examples of Byzantine failures that have occurred are given in two equivalent journal papers.<sup class="reference" id="cite_ref-DriscollHall2004_4-1">[4]</sup><sup class="reference" id="cite_ref-DriscollHall2003_5-1">[5]</sup> These and other examples are described on the NASA DASHlink web pages.<sup class="reference" id="cite_ref-12">[12]</sup>
</p><p>Byzantine errors were observed infrequently and at irregular points during endurance testing for the newly constructed <i>Virginia</i> class submarines, at least through 2005 (when the issues were publicly reported).<sup class="reference" id="cite_ref-WalterEllis2005_13-0">[13]</sup>
</p>
<h3><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"></span></h3>
<p>One example of BFT in use is Bitcoin, a peer-to-peer digital cash system.<sup class="reference" id="cite_ref-14">[14]</sup> The Bitcoin network works in parallel to generate a blockchain with proof-of-work allowing the system to overcome Byzantine failures and reach a coherent global view of the system's state. Some proof of stake blockchains also use BFT algorithms.<sup class="reference" id="cite_ref-FOOTNOTEDeirmentzoglouPapakyriakopoulosPatsakis201928716_15-0">[15]</sup>
</p><p>Some aircraft systems, such as the Boeing 777 Aircraft Information Management System (via its ARINC 659 SAFEbus network),
the Boeing 777 flight control system, and the Boeing 787 flight control systems use Byzantine fault tolerance; because these are real-time systems, their Byzantine fault tolerance solutions must have very low latency. For example, SAFEbus can achieve Byzantine fault tolerance within the order of a microsecond of added latency.<sup class="reference" id="cite_ref-Zurawski2015_16-0">[16]</sup><sup class="reference" id="cite_ref-HenzingerKirsch2001_17-0">[17]</sup><sup class="reference" id="cite_ref-Yeh2001_18-0">[18]</sup> The SpaceX Dragon considers Byzantine fault tolerance in its design.<sup class="reference" id="cite_ref-19">[19]</sup>
</p><p>Byzantine fault tolerance mechanisms use components that repeat an incoming message (or just its signature) to other recipients of that incoming message. All these mechanisms make the assumption that the act of repeating a message blocks the propagation of Byzantine symptoms. For systems that have a high degree of safety or security criticality, these assumptions must be proven to be true to an acceptable level of fault coverage. When providing proof through testing, one difficulty is creating a sufficiently wide range of signals with Byzantine symptoms.<sup class="reference" id="cite_ref-NanyaGoosen1989_20-0">[20]</sup> Such testing likely will require specialized fault injectors.<sup class="reference" id="cite_ref-MartinsGandhi2013_21-0">[21]</sup><sup class="reference" id="cite_ref-22">[22]</sup>
</p>
<h2><span class="mw-headline" id="Solutions">Solutions</span><span class="mw-editsection"></span></h2>
<p>Several early solutions were described by Lamport, Shostak, and Pease in 1982.<sup class="reference" id="cite_ref-BGP_Paper_3-2">[3]</sup> They began by noting that the Generals' Problem can be reduced to solving a "Commander and Lieutenants" problem where loyal Lieutenants must all act in unison and that their action must correspond to what the Commander ordered in the case that the Commander is loyal:
</p>
<ul><li>One solution considers scenarios in which messages may be forged, but which will be <i>Byzantine-fault-tolerant</i> as long as the number of disloyal generals is less than one third of the generals. The impossibility of dealing with one-third or more traitors ultimately reduces to proving that the one Commander and two Lieutenants problem cannot be solved, if the Commander is traitorous. To see this, suppose we have a traitorous Commander A, and two Lieutenants, B and C: when A tells B to attack and C to retreat, and B and C send messages to each other, forwarding A's message, neither B nor C can figure out who is the traitor, since it is not necessarily A—the other Lieutenant could have forged the message purportedly from A. It can be shown that if <i>n</i> is the number of generals in total, and <i>t</i> is the number of traitors in that <i>n</i>, then there are solutions to the problem only when <i>n</i> &gt; 3<i>t</i> and the communication is synchronous (bounded delay).<sup class="reference" id="cite_ref-23">[23]</sup></li>
<li>A second solution requires unforgeable message signatures. For security-critical systems, digital signatures (in modern computer systems, this may be achieved in practice using public-key cryptography) can provide Byzantine fault tolerance in the presence of an arbitrary number of traitorous generals. However, for safety-critical systems (where "security" addresses intelligent threats while "safety" addresses the inherent dangers of an activity or mission), simple error detecting codes, such as CRCs, provide weaker but often sufficient coverage at a much lower cost. This is true for both Byzantine and non-Byzantine faults. Furthermore, sometimes security measures weaken safety and vice versa. Thus, cryptographic digital signature methods are not a good choice for safety-critical systems, unless there is also a specific security threat as well.<sup class="reference" id="cite_ref-PaulitschMorris2005_24-0">[24]</sup> While error detecting codes, such as CRCs, are better than cryptographic techniques, neither provide adequate coverage for active electronics in safety-critical systems. This is illustrated by the <i>Schrödinger CRC</i> scenario where a CRC-protected message with a single Byzantine faulty bit presents different data to different observers and each observer sees a valid CRC.<sup class="reference" id="cite_ref-DriscollHall2004_4-2">[4]</sup><sup class="reference" id="cite_ref-DriscollHall2003_5-2">[5]</sup></li>
<li>Also presented is a variation on the first two solutions allowing Byzantine-fault-tolerant behavior in some situations where not all generals can communicate directly with each other.</li></ul>
<p>Several system architectures were designed c. 1980 that implemented Byzantine fault tolerance. These include: Draper's FTMP,<sup class="reference" id="cite_ref-HopkinsLala1987_25-0">[25]</sup> Honeywell's MMFCS,<sup class="reference" id="cite_ref-MMFCS_26-0">[26]</sup> and SRI's SIFT.<sup class="reference" id="cite_ref-:0_9-1">[9]</sup>
</p>
<h3><span class="mw-headline" id="Advanced_solutions">Advanced solutions</span><span class="mw-editsection"></span></h3>
<p>In 1999, Miguel Castro and Barbara Liskov introduced the "Practical Byzantine Fault Tolerance" (PBFT) algorithm,<sup class="reference" id="cite_ref-27">[27]</sup> which provides high-performance Byzantine state machine replication, processing thousands of requests per second with sub-millisecond increases in latency.
</p><p>After PBFT, several BFT protocols were introduced to improve its robustness and performance. For instance, Q/U,<sup class="reference" id="cite_ref-28">[28]</sup> HQ,<sup class="reference" id="cite_ref-29">[29]</sup> Zyzzyva,<sup class="reference" id="cite_ref-30">[30]</sup> and ABsTRACTs,<sup class="reference" id="cite_ref-31">[31]</sup> addressed the performance and cost issues; whereas other protocols, like Aardvark<sup class="reference" id="cite_ref-32">[32]</sup> and RBFT,<sup class="reference" id="cite_ref-33">[33]</sup> addressed its robustness issues. Furthermore, Adapt<sup class="reference" id="cite_ref-34">[34]</sup> tried to make use of existing BFT protocols, through switching between them in an adaptive way, to improve system robustness and performance as the underlying conditions change. Furthermore, BFT protocols were introduced that leverage trusted components to reduce the number of replicas, e.g., A2M-PBFT-EA<sup class="reference" id="cite_ref-35">[35]</sup> and MinBFT.<sup class="reference" id="cite_ref-36">[36]</sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Sources">Sources</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1" id="CITEREFDeirmentzoglouPapakyriakopoulosPatsakis2019">Deirmentzoglou, Evangelos; Papakyriakopoulos, Georgios; Patsakis, Constantinos (2019). "A Survey on Long-Range Attacks for Proof of Stake Protocols". <i>IEEE Access</i>. <b>7</b>: 28712–28725. doi:10.1109/ACCESS.2019.2901858. eISSN 2169-3536.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IEEE+Access&amp;rft.atitle=A+Survey+on+Long-Range+Attacks+for+Proof+of+Stake+Protocols&amp;rft.volume=7&amp;rft.pages=28712-28725&amp;rft.date=2019&amp;rft.eissn=2169-3536&amp;rft_id=info%3Adoi%2F10.1109%2FACCESS.2019.2901858&amp;rft.aulast=Deirmentzoglou&amp;rft.aufirst=Evangelos&amp;rft.au=Papakyriakopoulos%2C+Georgios&amp;rft.au=Patsakis%2C+Constantinos&amp;rft_id=https%3A%2F%2Fieeexplore.ieee.org%2Fstamp%2Fstamp.jsp%3Farnumber%3D8653269&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AByzantine+fault"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Byzantine Fault Tolerance in the RKBExplorer</li></ul>
<!-- 
NewPP limit report
Parsed by mw2414
Cached time: 20221223233800
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.442 seconds
Real time usage: 0.518 seconds
Preprocessor visited node count: 2797/1000000
Post‐expand include size: 87175/2097152 bytes
Template argument size: 2069/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 121507/5000000 bytes
Lua time usage: 0.289/10.000 seconds
Lua memory usage: 8053522/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  470.831      1 -total
 66.90%  314.977      1 Template:Reflist
 21.07%   99.184      6 Template:Cite_web
 17.51%   82.446     15 Template:Cite_journal
 11.07%   52.129      9 Template:Cite_book
 10.43%   49.115      1 Template:Short_description
  9.81%   46.167      1 Template:Sfn
  5.76%   27.130      2 Template:Pagetype
  5.05%   23.778      1 Template:Redirect
  4.91%   23.124      4 Template:Cite_conference
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:970031-0!canonical and timestamp 20221223233800 and revision id 1125034931.
 -->
</div></body>
</html>