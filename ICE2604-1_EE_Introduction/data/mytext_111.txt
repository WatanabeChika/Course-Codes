bin_packing_problemCovering/packing-problem pairs Covering problems Packing problems Minimum set cover Maximum set packing Minimum edge cover Maximum matching Minimum vertex cover Maximum independent set Bin covering Bin packing Polygon covering Rectangle packingThe bin packing problem[1][2][3][4] is an optimization problem, in which items of different sizes must be packed into a finite number of bins or containers, each of a fixed given capacity, in a way that minimizes the number of bins used. The problem has many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file backups in media and technology mapping in FPGA semiconductor chip design.Computationally, the problem is NP-hard, and the corresponding decision problem - deciding if items can fit into a specified number of bins - is NP-complete. Despite its worst-case hardness, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many approximation algorithms exist. For example, the first fit algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires Θ(n log n) time, where n is the number of items to be packed. The algorithm can be made much more effective by first sorting the list of items into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution, and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.[5]There are many variations of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. The bin packing problem can also be seen as a special case of the cutting stock problem. When the number of bins is restricted to 1 and each item is characterised by both a volume and a value, the problem of maximizing the value of items that can fit in the bin is known as the knapsack problem.A variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically,  a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing[6] since when virtual machines (VMs) are packed in a server, their total memory requirement could decrease due to pages shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if the space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.Another variant of bin packing of interest in practice is the so-called online bin packing. Here the items of different volume are supposed to arrive sequentially, and the decision maker has to decide whether to select and pack the currently observed item, or else to let it pass. Each decision is without recall. In contrast, offline bin packing allows rearranging the items in the hope of achieving a better packing once additional items arrive. This of course requires additional storage for holding the items to be rearranged.In Computers and Intractability[7] Garey and Johnson list the bin packing problem under the reference [SR1]. They define its decision variant as follows.Instance: Finite set  of items, a size  for each , a positive integer bin capacity , and a positive integer .Question: Is there a partition of  into disjoint sets  such that the sum of the sizes of the items in each  is  or less?Note that in the literature often an equivalent notation is used, where  and  for each . Furthermore, research is mostly interested in the optimization variant, which asks for the smallest possible value of . A solution is optimal if it has minimal . The -value for an optimal solution for a set of items  is denoted by  or just  if the set of items is clear from the context.A possible integer linear programming formulation of the problem is:minimize subject towhere  if bin  is used and  if item  is put into bin .[8]The bin packing problem is strongly NP-complete. This can be proven by reducing the strongly NP-complete 3-partition problem to bin packing.[7]Furthermore, there can be no approximation algorithm with absolute approximation ratio smaller than  unless . This can be proven by a reduction from the partition problem:[9] given an instance of Partition where the sum of all input numbers is ,  construct an instance of bin-packing in which the bin size is . If there exists an equal partition of the inputs, then the optimal packing needs 2 bins; therefore, every algorithm with approximation ratio smaller than  must return less than 3 bins, which must be 2 bins. In contrast, if there is no equal partition of the inputs, then the optimal packing needs at least 3 bins.On the other hand, bin packing is solvable in pseudo-polynomial time for any fixed number of bins , and solvable in polynomial time for any fixed bin capacity .[7]To measure the performance of an approximation algorithm there are two approximation ratios considered in the literature. For a given list of items  the number  denotes the number of bins used when algorithm  is applied to list , while  denotes the optimum number for this list. The absolute worst-case performance ratio  for an algorithm  is defined asOn the other hand, the asymptotic worst-case ratio  is defined asEquivalently,  is the smallest number such that, for some constant K, for all lists L:[4].Additionally, one can restrict the lists to those for which all items have a size of at most .  For such lists, the bounded size performance ratios are denoted as  and .Approximation algorithms for bin packing can be classified into two categories:Online heuristics, that consider the items in a given order and place them one by one inside the bins.  These heuristics are also applicable to the online version of this problem.Offline heuristics, that modify the given list of items e.g. by sorting the items by size. These algorithms are no longer applicable to the online variant of this problem. However, they have an improved approximation guarantee while maintaining the advantage of their small time-complexity. A sub-category of offline heuristics is asymptotic approximation schemes. These algorithms have an approximation guarantee of the form  for some constant that may depend on . For an arbitrarily large  these algorithms get arbitrarily close to . However, this comes at the cost of a (drastically) increased time complexity compared to the heuristical approaches.In the online version of the bin packing problem, the items arrive one after another and the (irreversible) decision where to place an item has to be made before knowing the next item or even if there will be another one. A diverse set of offline and online heuristics for bin-packing have been studied by David S. Johnson on his Ph.D. thesis.[10]There are many simple algorithms that use the following general scheme:For each item in the input list:If the item fits into one of the currently open bins, then put it in one of these bins;Otherwise, open a new bin and put the new item in it.The algorithms differ in the criterion by which they choose the open bin for the new item in step 1 (see the linked pages for more information):Next Fit (NF) always keeps a single open bin. When the new item does not fit into it, it closes the current bin and opens a new bin. Its advantage is that it is a bounded-space algorithm, since it only needs to keep a single open bin in memory. Its disadvantage is that its asymptotic approximation ratio is 2. In particular, , and for each  there exists a list  such that  and .[10] Its asymptotic approximation ratio can be somewhat improved based on the item sizes:  for all  and  for all . For each algorithm  that is an AnyFit-algorithm it holds that .Next-k-Fit (NkF) is a variant of Next-Fit, but instead of keeping only one bin open, the algorithm keeps the last  bins open and chooses the first bin in which the item fits. Therefore, it is called a k-bounded space algorithm.[11] For  the NkF delivers results that are improved compared to the results of NF, however, increasing  to constant values larger than  improves the algorithm no further in its worst-case behavior.  If algorithm  is an AlmostAnyFit-algorithm and  then .[10]First-Fit (FF) keeps all bins open, in the order in which they were opened. It attempts to place each new item into the first bin in which it fits. Its approximation ratio is , and there is a family of input lists  for which  matches this bound.[12]Best-Fit (BF), too, keeps all bins open, but attempts to place each new item into the bin with the maximum load in which it fits. Its approximation ratio is identical to that of FF, that is: , and there is a family of input lists  for which  matches this bound.[13]Worst-Fit (WF) attempts to place each new item into the bin with the minimum load. It can behave as badly as Next-Fit, and will do so on the worst-case list for that . Furthermore, it holds that . Since WF is an AnyFit-algorithm, there exists an AnyFit-algorithm such that .[10]Almost Worst-Fit (AWF) attempts to place each new item inside the second most empty open bin (or emptiest bin if there are two such bins). If it does not fit, it tries the most empty one. It has an asymptotic worst-case ratio of .[10]In order to generalize these results, Johnson introduced two classes of online heuristics called any-fit algorithm and almost-any-fit algorithm:[4]In an AnyFit (AF) algorithm, if the current nonempty bins are B1,...,Bj, then the current item will not be packed into Bj+1 unless it does not fit in any of B1,...,Bj. The FF, WF, BF and AWF algorithms satisfy this condition. Johnson proved that, for any AnyFit algorithm A and any :.In an AlmostAnyFit (AAF) algorithm, if the current nonempty bins are B1,...,Bj, and of these bins, Bk is the unique bin with the smallest load, then the current item will not be packed into Bk, unless it does not fit into any of the bins to its left. The FF, BF and AWF algorithms satisfy this condition, but WF does not. Johnson proved that, for any AAF algorithm A and any :  In particular: .Better approximation ratios are possible with heuristics that are not AnyFit. These heuristics usually keep several classes of open bins, devoted to items of different size-ranges (see the linked pages for more information):Refined-first-fit bin packing (RFF) partitions the item sizes into four ranges: , , , and . Similarly, the bins are categorized into four classes. The next item  is first assigned to its corresponding class. Inside that class, it is assigned to a bin using first-fit. Note that this algorithm is not an Any-Fit algorithm since it may open a new bin despite the fact that the current item fits inside an open bin. This algorithm was first presented by Andrew Chi-Chih Yao,[14] who proved that it has an approximation guarantee of  and presented a family of lists  with  for .Harmonic-k partitions the interval of sizes  based on a Harmonic progression into  pieces  for  and  such that . This algorithm was first described by Lee and Lee.[15]  It has a time complexity of  and at each step, there are at most  open bins that can be potentially used to place items, i.e., it is a -bounded space algorithm. For , its approximation ratio satisfies , and it is asymptotically tight.Refined-harmonic combines ideas from Harmonic-k with ideas from Refined-First-Fit. It places the items larger than  similar as in Refined-First-Fit, while the smaller items are placed using Harmonic-k. The intuition for this strategy is to reduce the huge waste for bins containing pieces that are just larger than . This algorithm was first described by Lee and Lee.[15]  They proved that for  it holds that .Yao[14] proved 1980 that there can be no online algorithm with asymptotic competitive ratio smaller than . Brown[16] and Liang[17] improved this bound to 1.536. Afterward, this bound was improved to 1.540 by Vliet.[18]  In 2012, this lower bound was again improved by Békési and Galambos[19] to .AlgorithmApproximation guaranteeWorst case list Time-complexityNext-fit (NF)[10][10]First-fit (FF)[12][12][10]Best-fit (BF)[13][13][10]Worst-Fit (WF)[10][10][10]Almost-Worst-Fit (AWF)[10][10][10]Refined-First-Fit (RFF)[14] (for )[14][14]Harmonic-k (Hk) for [15][15][15]Refined Harmonic (RH)[15][15]Modified Harmonic (MH)[20]Modified Harmonic 2 (MH2)[20]Harmonic + 1 (H+1)[21]Harmonic ++ (H++)[21][21]In the offline version of bin packing, the algorithm can see all the items before starting to place them into bins. This allows to attain improved approximation ratios.The simplest technique used by offline algorithms is:Ordering the input list by descending size;Run an online algorithm on the ordered list.Johnson[10] proved that any AnyFit algorithm A that runs on a list ordered by descending size has an asymptotic approximation ratio of.Some algorithms in this family are (see the linked pages for more information):First-fit-decreasing (FFD) - orders the items by descending size, then calls First-Fit. Its approximation ratio is , and this is tight.[22]Next-fit-decreasing (NFD) - orders the items by descending size, then calls Next-Fit.  Its approximate ratio is slightly less than 1.7 in the worst case.[23] It has also been analyzed probabilistically.[24] Next-Fit packs a list and its inverse into the same number of bins. Therefore, Next-Fit-Increasing has the same performance as Next-Fit-Decreasing.[25]Modified first-fit-decreasing (MFFD)[26] - improves on FFD for items larger than half a bin by classifying items by size into four size classes large, medium, small, and tiny, corresponding to items with size &gt; 1/2 bin, &gt; 1/3 bin, &gt; 1/6 bin, and smaller items respectively.  Its approximation guarantee is .[27]Fernandez de la Vega and Lueker[28] presented a PTAS for bin packing. For every , their algorithm finds a solution with size at most  and runs in time  , where  denotes a function only dependent on . For this algorithm, they invented the method of adaptive input rounding: the input numbers are grouped and rounded up to the value of the maximum in each group. This yields an instance with a small number of different sizes, which can be solved exactly using the configuration linear program.[29]The Karmarkar-Karp bin packing algorithm finds a solution with size at most , and runs in time polynomial in  (the polynomial has a high degree - at least 8).Rothvoss[30] presented an algorithm that generates a solution with at most  bins.Hoberg and Rothvoss[31] improved this algorithm to generate a solution with at most  bins. The algorithm is randomized, and its running-time is polynomial in .AlgorithmApproximation guaranteeWorst case instanceFirst-fit-decreasing (FFD)[22][22]Modified-first-fit-decreasing (MFFD)[27][26]Karmarkar and Karp[32]Rothvoss[30]Hoberg and Rothvoss[31]Martello and Toth[33] developed an exact algorithm for the 1-dimensional bin-packing problem, called MTP. A faster alternative is the Bin Completion algorithm proposed by Korf in 2002[34] and later improved.[35]A further improvement was presented by Schreiber and Korf in 2013.[36] The new Improved Bin Completion algorithm is shown to be up to five orders of magnitude faster than Bin Completion on non-trivial problems with 100 items, and outperforms the BCP (branch-and-cut-and-price) algorithm by Belov and Scheithauer on problems that have fewer than 20 bins as the optimal solution. Which algorithm performs best depends on problem properties like number of items, optimal number of bins, unused space in the optimal solution and value precision.A special case of bin packing is when there is a small number d of different item sizes. There can be many different items of each size. This case is also called high-multiplicity bin packing, and It admits more efficient algorithms than the general problem.There is a variant of bin packing in which there are cardinality constraints on the bins: each bin can contain at most k items, for some fixed integer k.Krause, Shen and Schwetman[37] introduce this problem as a variant of optimal job scheduling: a computer has some k processors. There are some n jobs that take unit time (1), but have different memory requirements. Each time-unit is considered a single bin. The goal is to use as few bins (=time units) as possible, while ensuring that in each bin, at most k jobs run. They present several heuristic algorithms that find a solution with at most  bins.Kellerer and Pferschy[38] present an algorithm with run-time , that finds a solution with at most  bins. Their algorithm performs a binary search for OPT. For every searched value m, it tries to pack the items into 3m/2 bins.There are various ways to extend the bin-packing model to more general cost and load functions:Anily, Bramel and Simchi-Levi[39] study a setting where the cost of a bin is a concave function of the number of items in the bin. The objective is to minimize the total cost rather than the number of bins. They show that next-fit-increasing bin packing attains an absolute worst-case approximation ratio of at most 7/4, and an asymptotic worst-case ratio 1.691 for any concave and monotone cost function.Cohen, Keller, Mirrokni and Zadimoghaddam[40] study a setting where  the size of the items is not known in advance, but it is a random variable. This is particularly common in cloud computing environments. While there is an upper bound on the amount of resources a certain user needs, most users use much less than the capacity. Therefore, the cloud manager may gain a lot by slight overcommitment. This induces a variant of bin packing with chance constraints: the probability that the sum of sizes in each bin is at most B should be at least p, where p is a fixed constant (standard bin packing corresponds to p=1). They show that, under mild assumptions, this problem is equivalent to a submodular bin packing problem, in which the "load" in each bin is not equal to the sum of items, but to a certain submodular function of it.In the bin packing problem, the size of the bins is fixed and their number can be enlarged (but should be as small as possible).In contrast, in the multiway number partitioning problem, the number of bins is fixed and their size can be enlarged. The objective is to find a partition in which the bin sizes are as nearly equal is possible (in the variant called multiprocessor scheduling problem or minimum makespan problem, the goal is specifically to minimize the size of the largest bin).In the inverse bin packing problem,[41] both the number of bins and their sizes are fixed, but the item sizes can be changed. The objective is to achieve the minimum perturbation to the item size vector so that all the items can be packed into the prescribed number of bins.In the maximum resource bin packing problem,[42] the goal is to maximize the number of bins used, such that, for some ordering of the bins, no item in a later bin fits in an earlier bin. In a dual problem, the number of bins is fixed, and the goal is to minimize the total number or the total size of items placed into the bins, such that no remaining item fits into an unfilled bin.In the bin covering problem, the bin size is bounded from below: the goal is to maximize the number of bins used such that the total size in each bin is at least a given threshold.In the fair indivisible chore allocation problem (a variant of fair item allocation), the items represents chores, and there are different people each of whom attributes a different difficulty-value to each chore. The goal is to allocate to each person a set of chores with an upper bound on its total difficulty-value (thus, each person corresponds to a bin). Many techniques from bin packing are used in this problem too.[43]In the guillotine cutting problem, both the items and the "bins" are two-dimensional rectangles rather than one-dimensional numbers, and the items have to be cut from the bin using end-to-end cuts.In the selfish bin packing problem, each item is a player who wants to minimize its cost.[44]There is also a variant of bin packing in which the cost that should be minimized is not the number of bins, but rather a certain concave function of the number of items in each bin.[39]Other variants are two-dimensional bin packing,[45] three-dimensional bin packing,[46] bin packing with delivery,[47]BPPLIB - a library of surveys, codes, benchmarks, generators, solvers, and bibliography.Online:  visualization of heuristics for 1D and 2D bin packingPython: The prtpy package contains code for various number-partitioning, bin-packing and bin-covering algorithms. The binpacking package contains greedy algorithms for solving two typical bin packing problems.[48]C++: The bin-packing package contains various greedy algorithms as well as test data. The OR-tools package contains bin packing algorithms in C++, with wrappers in Python, C# and Java.C: Implementation of 7 classic approximate bin packing algorithms in C with results and imagesPHP: PHP Class to pack files without exceeding a given size limitHaskell: An implementation of several bin packing heuristics, including FFD and MFFD.C: Fpart : open-source command-line tool to pack files (C, BSD-licensed)C#: Bin Packing and Cutting Stock SolverJava: caparf - Cutting And Packing Algorithms Research Framework, including a number of bin packing algorithms and test data.