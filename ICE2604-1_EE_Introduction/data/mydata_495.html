<!DOCTYPE html>
<html>
<head>
<title>interactive_proof_system</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<p>In computational complexity theory, an <b>interactive proof system</b> is an abstract machine that models computation as the exchange of messages between two parties: a <i>prover</i> and a <i>verifier</i>. The parties interact by exchanging messages in order to ascertain whether a given string belongs to a language or not. The prover possesses unlimited computational resources but cannot be trusted, while the verifier has bounded computation power but is assumed to be always honest. Messages are sent between the verifier and prover until the verifier has an answer to the problem and has "convinced" itself that it is correct.
</p><p>All interactive proof systems have two requirements:
</p>
<ul><li><b>Completeness</b>: if the statement is true, the honest prover (that is, one following the protocol properly) can convince the honest verifier that it is indeed true.</li>
<li><b>Soundness</b>: if the statement is false, no prover, even if it doesn't follow the protocol, can convince the honest verifier that it is true, except with some small probability.</li></ul>
<p>The specific nature of the system, and so the complexity class of languages it can recognize, depends on what sort of bounds are put on the verifier, as well as what abilities it is given—for example, most interactive proof systems depend critically on the verifier's ability to make random choices. It also depends on the nature of the messages exchanged—how many and what they can contain. Interactive proof systems have been found to have some important implications for traditional complexity classes defined using only one machine. The main complexity classes describing interactive proof systems are <b>AM</b> and <b>IP</b>.
</p>

<h2><span class="mw-headline" id="Background">Background</span><span class="mw-editsection"></span></h2>
<p>Every interactive proof system defines a formal language of strings <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle L}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>L</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle L}</annotation>
</semantics>
</math></span><img alt="L" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8" style="vertical-align: -0.338ex; width:1.583ex; height:2.176ex;"/></span>. <b>Soundness</b> of the proof system refers to the property that no prover can make the verifier accept for the wrong statement <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle y\not \in L}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>y</mi>
<mo>∉</mo>
<mi>L</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle y\not \in L}</annotation>
</semantics>
</math></span><img alt="y \not\in L" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1ef8c38cb6d7b9d763f46ac2204ec57186ad980e" style="vertical-align: -0.838ex; width:5.579ex; height:2.676ex;"/></span> except with some small probability. The upper bound of this probability is referred to as the <b>soundness error</b> of a proof system. More formally, for every prover <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle ({\tilde {\mathcal {P}}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">P</mi>
</mrow>
<mo stretchy="false">~<!-- ~ --></mo>
</mover>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle ({\tilde {\mathcal {P}}})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle ({\tilde {\mathcal {P}}})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08ab9f1ca974b0c26040e2927830a1502bb95cd4" style="vertical-align: -0.838ex; width:3.513ex; height:3.176ex;"/></span>, and every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle y\not \in L}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>y</mi>
<mo>∉</mo>
<mi>L</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle y\not \in L}</annotation>
</semantics>
</math></span><img alt="y \not\in L" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1ef8c38cb6d7b9d763f46ac2204ec57186ad980e" style="vertical-align: -0.838ex; width:5.579ex; height:2.676ex;"/></span>:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \Pr[(\perp ,({\text{accept}}))\gets ({\tilde {\mathcal {P}}})(y)\leftrightarrow ({\mathcal {V}})(y)]&lt;\epsilon .}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo form="prefix" movablelimits="true">Pr</mo>
<mo stretchy="false">[</mo>
<mo stretchy="false">(</mo>
<mo>⊥<!-- ⊥ --></mo>
<mo>,</mo>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mtext>accept</mtext>
</mrow>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
<mo stretchy="false">←<!-- ← --></mo>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mover>
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">P</mi>
</mrow>
<mo stretchy="false">~<!-- ~ --></mo>
</mover>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">↔<!-- ↔ --></mo>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">V</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">]</mo>
<mo>&lt;</mo>
<mi>ϵ<!-- ϵ --></mi>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \Pr[(\perp ,({\text{accept}}))\gets ({\tilde {\mathcal {P}}})(y)\leftrightarrow ({\mathcal {V}})(y)]&lt;\epsilon .}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \Pr[(\perp ,({\text{accept}}))\gets ({\tilde {\mathcal {P}}})(y)\leftrightarrow ({\mathcal {V}})(y)]&lt;\epsilon .}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89775f36bd79764d20bcbb10051edc1470cf8baa" style="vertical-align: -0.838ex; width:41.404ex; height:3.176ex;"/></span></dd></dl>
<p>for some <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \epsilon \ll 1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ϵ<!-- ϵ --></mi>
<mo>≪<!-- ≪ --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \epsilon \ll 1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \epsilon \ll 1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af8a5f6f8c1c9a39f03629ed4b80c31fb7ecdaa5" style="vertical-align: -0.338ex; width:5.721ex; height:2.176ex;"/></span>.
As long as the soundness error is bounded by a polynomial fraction of the potential running time of the verifier (i.e. <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \epsilon \leq 1/\mathrm {poly} (|y|)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ϵ<!-- ϵ --></mi>
<mo>≤<!-- ≤ --></mo>
<mn>1</mn>
<mrow class="MJX-TeXAtom-ORD">
<mo>/</mo>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="normal">p</mi>
<mi mathvariant="normal">o</mi>
<mi mathvariant="normal">l</mi>
<mi mathvariant="normal">y</mi>
</mrow>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mi>y</mi>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \epsilon \leq 1/\mathrm {poly} (|y|)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \epsilon \leq 1/\mathrm {poly} (|y|)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89495e27d54948cf2085d5e369375485095d6051" style="vertical-align: -0.838ex; width:14.955ex; height:2.843ex;"/></span>), it is always possible to amplify soundness until the soundness error becomes negligible function relative to the running time of the verifier. This is achieved by repeating the proof and accepting only if all proofs verify. After <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \ell }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ℓ<!-- ℓ --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \ell }</annotation>
</semantics>
</math></span><img alt="\ell " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f066e981e530bacc07efc6a10fa82deee985929e" style="vertical-align: -0.338ex; width:0.97ex; height:2.176ex;"/></span> repetitions, a soundness error <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \epsilon }" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>ϵ<!-- ϵ --></mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \epsilon }</annotation>
</semantics>
</math></span><img alt="\epsilon " aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3837cad72483d97bcdde49c85d3b7b859fb3fd2" style="vertical-align: -0.338ex; width:0.944ex; height:1.676ex;"/></span> will be reduced to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \epsilon ^{\ell }}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msup>
<mi>ϵ<!-- ϵ --></mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>ℓ<!-- ℓ --></mi>
</mrow>
</msup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \epsilon ^{\ell }}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \epsilon ^{\ell }}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0a5b61b8f9e665941e1aa520a3437a894e7aa365" style="vertical-align: -0.338ex; width:1.862ex; height:2.676ex;"/></span>.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Classes_of_interactive_proofs">Classes of interactive proofs</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="NP">NP</span><span class="mw-editsection"></span></h3>
<p>The complexity class NP may be viewed as a very simple proof system. In this system, the verifier is a deterministic, polynomial-time machine (a P machine). The protocol is:
</p>
<ul><li>The prover looks at the input and computes the solution using its unlimited power and returns a polynomial-size proof certificate.</li>
<li>The verifier verifies that the certificate is valid in deterministic polynomial time. If it is valid, it accepts; otherwise, it rejects.</li></ul>
<p>In the case where a valid proof certificate exists, the prover is always able to make the verifier accept by giving it that certificate. In the case where there is no valid proof certificate, however, the input is not in the language, and no prover, however malicious it is, can convince the verifier otherwise, because any proof certificate will be rejected.
</p>
<h3><span id="Arthur.E2.80.93Merlin_and_Merlin.E2.80.93Arthur_protocols"></span><span class="mw-headline" id="Arthur–Merlin_and_Merlin–Arthur_protocols">Arthur–Merlin and Merlin–Arthur protocols</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Although NP may be viewed as using interaction, it wasn't until 1985 that the concept of computation through interaction was conceived (in the context of complexity theory) by two independent groups of researchers. One approach, by  László Babai, who published "Trading group theory for randomness",<sup class="reference" id="cite_ref-2">[2]</sup> defined the <i>Arthur–Merlin</i> (<b>AM</b>) class hierarchy. In this presentation, Arthur (the verifier) is a probabilistic, polynomial-time machine, while Merlin (the prover) has unbounded resources.
</p><p>The class <b>MA</b> in particular is a simple generalization of the NP interaction above in which the verifier is probabilistic instead of deterministic. Also, instead of requiring that the verifier always accept valid certificates and reject invalid certificates, it is more lenient:
</p>
<ul><li><b>Completeness:</b> if the string is in the language, the prover must be able to give a certificate such that the verifier will accept with probability at least 2/3 (depending on the verifier's random choices).</li>
<li><b>Soundness:</b> if the string is not in the language, no prover, however malicious, will be able to convince the verifier to accept the string with probability exceeding 1/3.</li></ul>
<p>This machine is potentially more powerful than an ordinary NP interaction protocol, and the certificates are no less practical to verify, since <b>BPP</b> algorithms are considered as abstracting practical computation (see BPP).
</p>
<h3><span class="mw-headline" id="Public_coin_protocol_versus_private_coin_protocol">Public coin protocol versus private coin protocol</span><span class="mw-editsection"></span></h3>
<p>In a <i>public coin</i> protocol, the random choices made by the verifier are made public. They remain private in a private coin protocol.
</p><p>In the same conference where Babai defined his proof system for <b>MA</b>, Shafi Goldwasser, Silvio Micali and Charles Rackoff<sup class="reference" id="cite_ref-3">[3]</sup> published a paper defining the interactive proof system <b>IP</b>[<i>f</i>(<i>n</i>)]. This has the same machines as the <b>MA</b> protocol, except that <i>f</i>(<i>n</i>) <i>rounds</i> are allowed for an input of size <i>n</i>. In each round, the verifier performs computation and passes a message to the prover, and the prover performs computation and passes information back to the verifier. At the end the verifier must make its decision. For example, in an <b>IP</b>[3] protocol, the sequence would be VPVPVPV, where V is a verifier turn and P is a prover turn.
</p><p>In Arthur–Merlin protocols, Babai defined a similar class <b>AM</b>[<i>f</i>(<i>n</i>)] which allowed <i>f</i>(<i>n</i>) rounds, but he put one extra condition on the machine: the verifier must show the prover all the random bits it uses in its computation. The result is that the verifier cannot "hide" anything from the prover, because the prover is powerful enough to simulate everything the verifier does if it knows what random bits it used. This is called a <i>public coin</i> protocol, because the random bits ("coin flips") are visible to both machines. The <b>IP</b> approach is called a <i>private coin</i> protocol by contrast.
</p><p>The essential problem with public coins is that if the prover wishes to maliciously convince the verifier to accept a string which is not in the language, it seems like the verifier might be able to thwart its plans if it can hide its internal state from it. This was a primary motivation in defining the <b>IP</b> proof systems.
</p><p>In 1986, Goldwasser and Sipser<sup class="reference" id="cite_ref-4">[4]</sup>  showed, perhaps surprisingly, that the verifier's ability to hide coin flips from the prover does it little good after all, in that an Arthur–Merlin public coin protocol with only two more rounds can recognize all the same languages. The result is that public-coin and private-coin protocols are roughly equivalent.  In fact, as Babai shows in 1988, <b>AM</b>[<i>k</i>]=<b>AM</b> for all constant <i>k</i>, so the <b>IP</b>[<i>k</i>] have no advantage over <b>AM</b>.<sup class="reference" id="cite_ref-5">[5]</sup>
</p><p>To demonstrate the power of these classes, consider the graph isomorphism problem, the problem of determining whether it is possible to permute the vertices of one graph so that it is identical to another graph. This problem is in <b>NP</b>, since the proof certificate is the permutation which makes the graphs equal. It turns out that the 
complement of the graph isomorphism problem, a co-<b>NP</b> problem not known to be in <b>NP</b>, has an <b>AM</b> algorithm and the best way to see it is via a private coins algorithm.<sup class="reference" id="cite_ref-O._Goldreich,_S._Micali_1991_6-0">[6]</sup>
</p>
<h3><span class="mw-headline" id="IP">IP</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Private coins may not be helpful, but more rounds of interaction are helpful. If we allow the probabilistic verifier machine and the all-powerful prover to interact for a polynomial number of rounds, we get the class of problems called <b>IP</b>.
In 1992, Adi Shamir revealed in one of the central results of complexity theory that <b>IP</b> equals <b>PSPACE</b>, the class of problems solvable by an ordinary deterministic Turing machine in polynomial space.<sup class="reference" id="cite_ref-7">[7]</sup>
</p>
<h3><span class="mw-headline" id="QIP">QIP</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>If we allow the elements of the system to use quantum computation, the system is called a <b>quantum interactive proof system</b>, and the corresponding complexity class is called <b>QIP</b>.<sup class="reference" id="cite_ref-8">[8]</sup> A series of results culminated in a 2010 breakthrough that <b>QIP</b> = <b>PSPACE</b>.<sup class="reference" id="cite_ref-9">[9]</sup><sup class="reference" id="cite_ref-10">[10]</sup>
</p>
<h3><span class="mw-headline" id="Zero_knowledge">Zero knowledge</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Not only can interactive proof systems solve problems not believed to be in <b>NP</b>, but under assumptions about the existence of one-way functions, a prover can convince the verifier of the solution without ever giving the verifier information about the solution. This is important when the verifier cannot be trusted with the full solution.  At first it seems impossible that the verifier could be convinced that there is a solution when the verifier has not seen a certificate, but such proofs, known as zero-knowledge proofs are in fact believed to exist for all problems in <b>NP</b> and are valuable in cryptography. Zero-knowledge proofs were first mentioned in the original 1985 paper on <b>IP</b> by Goldwasser, Micali and Rackoff, but the extent of their power was shown by Oded Goldreich, Silvio Micali and Avi Wigderson.<sup class="reference" id="cite_ref-O._Goldreich,_S._Micali_1991_6-1">[6]</sup>
</p>
<h3><span class="mw-headline" id="MIP">MIP</span><span class="mw-editsection"></span></h3>
<p>One goal of <b>IP'</b>s designers was to create the most powerful possible interactive proof system, and at first it seems like it cannot be made more powerful without making the verifier more powerful and so impractical. Goldwasser et al. overcame this in their 1988 "Multi prover interactive proofs: How to remove intractability assumptions", which defines a variant of <b>IP</b> called <b>MIP</b> in which there are <i>two</i> independent provers.<sup class="reference" id="cite_ref-M._Ben-or,_Shafi_Goldwasser_1988_11-0">[11]</sup> The two provers cannot communicate once the verifier has begun sending messages to them. Just as it's easier to tell if a criminal is lying if he and his partner are interrogated in separate rooms, it's considerably easier to detect a malicious prover trying to trick the verifier into accepting a string not in the language if there is another prover it can double-check with.
</p><p>In fact, this is so helpful that Babai, Fortnow, and Lund were able to show that <b>MIP</b> = <b>NEXPTIME</b>, the class of all problems solvable by a nondeterministic machine in <i>exponential time</i>, a very large class.<sup class="reference" id="cite_ref-12">[12]</sup> NEXPTIME contains PSPACE, and is believed to strictly contain PSPACE. Adding a constant number of additional provers beyond two does not enable recognition of any more languages. This result paved the way for the celebrated PCP theorem,  which can be considered to be a "scaled-down" version of this theorem.
</p><p><b>MIP</b> also has the helpful property that zero-knowledge proofs for every language in <b>NP</b> can be described without the assumption of one-way functions that <b>IP</b> must make. This has bearing on the design of provably unbreakable cryptographic algorithms.<sup class="reference" id="cite_ref-M._Ben-or,_Shafi_Goldwasser_1988_11-1">[11]</sup> Moreover, a <b>MIP</b> protocol can recognize all languages in <b>IP</b> in only a constant number of rounds, and if a third prover is added, it can recognize all languages in <b>NEXPTIME</b> in a constant number of rounds, showing again its power over <b>IP</b>.
</p><p>It is known that for any constant <i>k</i>, a MIP system with <i>k</i> provers and polynomially many rounds can be turned into an equivalent system with only 2 provers, and a constant number of rounds.<sup class="reference" id="cite_ref-13">[13]</sup>
</p>
<h3><span class="mw-headline" id="PCP">PCP</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>While the designers of <b>IP</b> considered generalizations of Babai's interactive proof systems, others considered restrictions. A very useful interactive proof system is <b>PCP</b>(<i>f</i>(<i>n</i>), <i>g</i>(<i>n</i>)), which is a restriction of <b>MA</b> where Arthur can only use <i>f</i>(<i>n</i>) random bits and can only examine <i>g</i>(<i>n</i>) bits of the proof certificate sent by Merlin (essentially using random access).
</p><p>There are a number of easy-to-prove results about various <b>PCP</b> classes. <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {PCP}}(0,{\mathsf {poly}})}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">C</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>,</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">p</mi>
<mi mathvariant="sans-serif">o</mi>
<mi mathvariant="sans-serif">l</mi>
<mi mathvariant="sans-serif">y</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {PCP}}(0,{\mathsf {poly}})}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {PCP}}(0,{\mathsf {poly}})}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3e4fa6a15dc8b52db0b59307f4f21bec0671bf5b" style="vertical-align: -0.838ex; width:12.454ex; height:2.843ex;"/></span>, the class of polynomial-time machines with no randomness but access to a certificate,  is just <b>NP</b>. <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {PCP}}({\mathsf {poly}},0)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">C</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">p</mi>
<mi mathvariant="sans-serif">o</mi>
<mi mathvariant="sans-serif">l</mi>
<mi mathvariant="sans-serif">y</mi>
</mrow>
</mrow>
<mo>,</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {PCP}}({\mathsf {poly}},0)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {PCP}}({\mathsf {poly}},0)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5e73e181964aea6f3841dd6aa4c952e02a3bf8f9" style="vertical-align: -0.838ex; width:12.454ex; height:2.843ex;"/></span>, the class of polynomial-time machines with access to polynomially many random bits is <b>co-RP</b>. Arora and Safra's first major result was that <span style="font-family:sans-serif;">PCP(log, log) = NP</span>; put another way, if the verifier in the <b>NP</b> protocol is constrained to choose only <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log n)}</annotation>
</semantics>
</math></span><img alt="O(\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" style="vertical-align: -0.838ex; width:8.336ex; height:2.843ex;"/></span> bits of the proof certificate to look at, this won't make any difference as long as it has <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log n)}</annotation>
</semantics>
</math></span><img alt="O(\log n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" style="vertical-align: -0.838ex; width:8.336ex; height:2.843ex;"/></span> random bits to use.<sup class="reference" id="cite_ref-14">[14]</sup>
</p><p>Furthermore, the PCP theorem asserts that the number of proof accesses can be brought all the way down to a constant. That is, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle {\mathsf {NP}}={\mathsf {PCP}}({\mathsf {log}},O(1))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">N</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">P</mi>
<mi mathvariant="sans-serif">C</mi>
<mi mathvariant="sans-serif">P</mi>
</mrow>
</mrow>
<mo stretchy="false">(</mo>
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi mathvariant="sans-serif">l</mi>
<mi mathvariant="sans-serif">o</mi>
<mi mathvariant="sans-serif">g</mi>
</mrow>
</mrow>
<mo>,</mo>
<mi>O</mi>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle {\mathsf {NP}}={\mathsf {PCP}}({\mathsf {log}},O(1))}</annotation>
</semantics>
</math></span><img alt="{\displaystyle {\mathsf {NP}}={\mathsf {PCP}}({\mathsf {log}},O(1))}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0b29a5751e14d42c27c9f4f296d08fef1b316dbb" style="vertical-align: -0.838ex; width:21.155ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-15">[15]</sup> They used this valuable characterization of <b>NP</b> to prove that approximation algorithms do not exist for the optimization versions of certain NP-complete problems unless P = NP. Such problems are now studied in the field known as hardness of approximation.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Oracle machine</li>
<li>Proof of knowledge</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Textbooks">Textbooks</span><span class="mw-editsection"></span></h2>
<ul><li>Arora, Sanjeev; Barak, Boaz, "Complexity Theory: A Modern Approach", Cambridge University Press, March 2009.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFMichael_Sipser1997">Michael Sipser (1997). <span class="cs1-lock-registration" title="Free registration required"><i>Introduction to the Theory of Computation</i></span>. PWS Publishing. ISBN <bdi>978-0-534-94728-6</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+the+Theory+of+Computation&amp;rft.pub=PWS+Publishing&amp;rft.date=1997&amp;rft.isbn=978-0-534-94728-6&amp;rft.au=Michael+Sipser&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fintroductiontoth00sips&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteractive+proof+system"></span> Section 10.4: Interactive Proof Systems, pp. 354–366.</li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFChristos_Papadimitriou1993">Christos Papadimitriou (1993). <i>Computational Complexity</i> (1st ed.). Addison Wesley. ISBN <bdi>978-0-201-53082-7</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computational+Complexity&amp;rft.edition=1st&amp;rft.pub=Addison+Wesley&amp;rft.date=1993&amp;rft.isbn=978-0-201-53082-7&amp;rft.au=Christos+Papadimitriou&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteractive+proof+system"></span> Section 19.2: Games against nature and interactive protocols, pp. 469–480.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>Dexter Kozen. Interactive Proofs. CS682 Spring 2004 lecture notes. Department of Computer Science, Cornell University.</li>
<li>Complexity Zoo:
<ul><li>MA, MA', MAEXP, MAE</li>
<li>AM, AMEXP, AM intersect co-AM, AM[polylog], coAM, BP•NP</li>
<li>QMA, QMA+, QMA(2), QMA<sub>log</sub>, QMAM</li>
<li>IP, MIP, IPP, QIP, QIP(2), compIP, frIP</li>
<li>PCP(r(n),q(n))</li></ul></li>
<li>Larry Gonick. "Proof Positive?". A comic strip about interactive proof systems.</li></ul>

<!-- 
NewPP limit report
Parsed by mw2363
Cached time: 20221220231622
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.216 seconds
Real time usage: 0.342 seconds
Preprocessor visited node count: 888/1000000
Post‐expand include size: 29162/2097152 bytes
Template argument size: 301/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 34382/5000000 bytes
Lua time usage: 0.113/10.000 seconds
Lua memory usage: 4564113/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  209.725      1 -total
 51.97%  108.995      1 Template:Reflist
 29.18%   61.204      1 Template:Citation
 19.21%   40.289      1 Template:ComplexityClasses
 17.70%   37.114      1 Template:Navbox
 14.13%   29.636      1 Template:Distinguish
  6.96%   14.607      3 Template:Cite_journal
  6.41%   13.436      5 Template:Main
  6.16%   12.929      3 Template:Cite_book
  2.56%    5.374      1 Template:Cite_arXiv
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:160255-0!canonical and timestamp 20221220231622 and revision id 1122361775.
 -->
</div></body>
</html>