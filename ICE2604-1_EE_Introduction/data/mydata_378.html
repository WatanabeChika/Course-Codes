<!DOCTYPE html>
<html>
<head>
<title>Ferguson-Forcade_algorithm</title>
</head>
<body>
<div class="mw-parser-output"><p>An <b>integer relation</b> between a set of real numbers <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, ..., <i>x</i><sub><i>n</i></sub> is a set of integers <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, ..., <i>a</i><sub><i>n</i></sub>, not all 0, such that
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle a_{1}x_{1}+a_{2}x_{2}+\cdots +a_{n}x_{n}=0.\,}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msub>
<mo>+</mo>
<mo>⋯<!-- ⋯ --></mo>
<mo>+</mo>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>n</mi>
</mrow>
</msub>
<mo>=</mo>
<mn>0.</mn>
<mspace width="thinmathspace"></mspace>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle a_{1}x_{1}+a_{2}x_{2}+\cdots +a_{n}x_{n}=0.\,}</annotation>
</semantics>
</math></span><img alt="a_{1}x_{1}+a_{2}x_{2}+\cdots +a_{n}x_{n}=0.\," aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1793d9554b46d92bdafcdf645ee2922418411045" style="vertical-align: -0.671ex; width:30.872ex; height:2.509ex;"/></span></dd></dl>
<p>An <b>integer relation algorithm</b> is an algorithm for finding integer relations. Specifically, given a set of real numbers known to a given precision, an integer relation algorithm will either find an integer relation between them, or will determine that no integer relation exists with coefficients whose magnitudes are less than a certain upper bound.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>

<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"></span></h2>
<p>For the case <i>n</i> = 2, an extension of the Euclidean algorithm can find any integer relation that exists between any two real numbers <i>x</i><sub>1</sub> and <i>x</i><sub>2</sub>. The algorithm generates successive terms of the continued fraction expansion of <i>x</i><sub>1</sub>/<i>x</i><sub>2</sub>; if there is an integer relation between the numbers, then their ratio is rational and the algorithm eventually terminates.
</p>
<ul><li>The Ferguson–Forcade algorithm was published in 1979 by Helaman Ferguson and R.W. Forcade.<sup class="reference" id="cite_ref-2">[2]</sup> Although the paper treats general <i>n</i>, it is not clear if the paper fully solves the problem because it lacks the detailed steps, proofs, and a precision bound that are crucial for a reliable implementation.</li>
<li>The first algorithm with complete proofs was the <b>LLL algorithm</b>, developed by Arjen Lenstra, Hendrik Lenstra and László Lovász in 1982.<sup class="reference" id="cite_ref-3">[3]</sup></li>
<li>The <b>HJLS algorithm</b>, developed by Johan Håstad, Bettina Just, Jeffrey Lagarias, and Claus-Peter Schnorr in 1986.<sup class="reference" id="cite_ref-4">[4]</sup><sup class="reference" id="cite_ref-5">[5]</sup></li>
<li>The <b>PSOS algorithm</b>, developed by Ferguson in 1988.<sup class="reference" id="cite_ref-6">[6]</sup></li>
<li>The <b>PSLQ algorithm</b>, developed by Ferguson and Bailey in 1992 and substantially simplified by Ferguson, Bailey, and Arno in 1999.<sup class="reference" id="cite_ref-7">[7]</sup><sup class="reference" id="cite_ref-8">[8]</sup> In 2000 the PSLQ algorithm was selected as one of the "Top Ten Algorithms of the Century" by Jack Dongarra and Francis Sullivan<sup class="reference" id="cite_ref-9">[9]</sup> even though it is considered essentially equivalent to HJLS.<sup class="reference" id="cite_ref-10">[10]</sup><sup class="reference" id="cite_ref-11">[11]</sup></li>
<li>The LLL algorithm has been improved by numerous authors. Modern LLL implementations can solve integer relation problems with <i>n</i> above 500.</li></ul>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"></span></h2>
<p>Integer relation algorithms have numerous applications. The first application is to determine whether a given real number <i>x</i> is likely to be algebraic, by searching for an integer relation between a set of powers of <i>x</i> {1, <i>x</i>, <i>x</i><sup>2</sup>, ..., <i>x</i><sup><i>n</i></sup>}. The second application is to search for an integer relation between a real number <i>x</i> and a set of mathematical constants such as <i>e</i>, π and ln(2), which will lead to an expression for <i>x</i> as a linear combination of these constants.
</p><p>A typical approach in experimental mathematics is to use numerical methods and arbitrary precision arithmetic to find an approximate value for an infinite series, infinite product or an integral to a high degree of precision (usually at least 100 significant figures), and then use an integer relation algorithm to search for an integer relation between this value and a set of mathematical constants. If an integer relation is found, this suggests a possible closed-form expression for the original series, product or integral. This conjecture can then be validated by formal algebraic methods. The higher the precision to which the inputs to the algorithm are known, the greater the level of confidence that any integer relation that is found is not just a numerical artifact.
</p><p>A notable success of this approach was the use of the PSLQ algorithm to find the integer relation that led to the Bailey–Borwein–Plouffe formula for the value of <span class="texhtml mvar" style="font-style:italic;">π</span>.  PSLQ has also helped find new identities involving multiple zeta functions and their appearance in quantum field theory; and in identifying bifurcation points of the logistic map.  For example, where B<sub>4</sub> is the logistic map's fourth bifurcation point, the constant α = −<i>B</i><sub>4</sub>(<i>B</i><sub>4</sub> − 2) is a root of a 120th-degree polynomial whose largest coefficient is 257<sup>30</sup>.<sup class="reference" id="cite_ref-12">[12]</sup><sup class="reference" id="cite_ref-13">[13]</sup> Integer relation algorithms are combined with tables of high precision mathematical constants and heuristic search methods in applications such as the Inverse Symbolic Calculator or Plouffe's Inverter.
</p><p>Integer relation finding can be used to factor polynomials of high degree.<sup class="reference" id="cite_ref-14">[14]</sup>
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li><i>Recognizing Numerical Constants</i> by David H. Bailey and Simon Plouffe</li>
<li><i>Ten Problems in Experimental Mathematics</i> by David H. Bailey, Jonathan M. Borwein, Vishaal Kapoor, and Eric W. Weisstein</li></ul>

<!-- 
NewPP limit report
Parsed by mw2384
Cached time: 20221220225559
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.169 seconds
Real time usage: 0.238 seconds
Preprocessor visited node count: 763/1000000
Post‐expand include size: 30878/2097152 bytes
Template argument size: 382/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 24237/5000000 bytes
Lua time usage: 0.100/10.000 seconds
Lua memory usage: 4730796/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  168.472      1 -total
 71.50%  120.457      1 Template:Reflist
 56.06%   94.440      5 Template:MathWorld
 26.27%   44.261      1 Template:Number_theoretic_algorithms
 24.32%   40.977      1 Template:Navbox
  5.11%    8.610      5 Template:SfnRef
  2.88%    4.852      1 Template:Cite_journal
  1.50%    2.528      1 Template:Pi
  0.94%    1.580      1 Template:Main_other
  0.73%    1.233      1 Template:Mvar
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:13644054-0!canonical and timestamp 20221220225559 and revision id 1081697113.
 -->
</div></body>
</html>