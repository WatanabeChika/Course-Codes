Simon's_algorithmIn computational complexity theory and quantum computing, Simon's problem is a computational problem that is proven to be solved exponentially faster on a quantum computer than on a classical (that is, traditional) computer. The quantum algorithm solving Simon's problem, usually called Simon's algorithm, served as the inspiration for Shor's algorithm.[1] Both problems are special cases of the abelian hidden subgroup problem, which is now known to have efficient quantum algorithms.The problem is set in the model of decision tree complexity or query complexity and was conceived by Daniel Simon in 1994.[2] Simon exhibited a quantum algorithm that solves Simon's problem exponentially faster and with exponentially fewer queries than the best probabilistic (or deterministic) classical algorithm. In particular, Simon's algorithm uses a linear number of queries and any classical probabilistic algorithm must use an exponential number of queries. This problem yields an oracle separation between the complexity classes BPP (bounded-error classical query complexity) and BQP (bounded-error quantum query complexity).[3] This is the same separation that the Bernstein–Vazirani algorithm achieves, and different from the separation provided by the Deutsch–Jozsa algorithm, which separates P and EQP. Unlike the Bernstein–Vazirani algorithm, Simon's algorithm's separation is exponential.Because this problem assumes the existence of a highly-structured "black box" oracle to achieve its speedup, this problem has little practical value.[4] However, without such an oracle, exponential speedups cannot easily be proven, since this would prove that P is different from PSPACE.Given a function (implemented by a black box or oracle)  with the promise that, for some unknown , for all ,  if and only if ,where  denotes bitwise XOR. The goal is to identify  by making as few queries to  as possible. Note that if and only if Furthermore, for some  and  in ,  is unique (not equal to ) if and only if . This means that  is two-to-one when , and one-to-one when . It is also the case that  implies , meaning thatwhich shows how  is periodic.The associated decision problem formulation of Simon's problem is to distinguish when  ( is one-to-one), and when  ( is two-to-one).For example, if , then the following function is an example of a function that satisfies the required and just mentioned property:000101001010010000011110100000101110110101111010In this case,  (i.e. the solution). It can easily be verified that every output of  occurs twice, and the two input strings corresponding to any one given output have bitwise XOR equal to . For example, the input strings  and  are both mapped (by ) to the same output string .  and . If we apply XOR to 010 and 100 we obtain 110, that is  can also be verified using input strings 001 and 111 that are both mapped (by f) to the same output string 010. If we apply XOR to 001 and 111, we obtain 110, that is . This gives the same solution  we solved for before.In this example the function f is indeed a two-to-one function where .Intuitively, this is a very hard problem to solve in a "classical" way, even if one uses randomness and accepts a small probability of error. The intuition behind the hardness is reasonably simple: if you want to solve the problem classically, you need to find two different inputs  and  for which . There is not necessarily any structure in the function  that would help us to find two such inputs: more specifically, we can discover something about  (or what it does) only when, for two different inputs, we obtain the same output. In any case, we would need to guess  different inputs before being likely to find a pair on which  takes the same output, as per the birthday problem. Since, classically to find s with a 100% certainty it would require checking up to  inputs, Simon's problem seeks to find s using fewer queries than this classical method.The algorithm as a whole uses this subroutine in the following two steps:Run the quantum subroutine an expected  times to get a list of linearly independent bitstrings .Each  satisfies , so we can solve the system of equations this produces to get .The quantum circuit (see the picture) is the implementation of the quantum part of Simon's algorithm. The quantum subroutine of the algorithm makes use of the Hadamard transformwhere , where  denotes XOR.First, the algorithm starts with two registers, initialized to . Then, we apply the Hadamard transform to the first register, which gives the state Query the oracle  to get the state .Apply another Hadamard transform to the first register. This will produce the state Finally, we measure the first register (the algorithm also works if the second register is measured before the first, but this is unnecessary). The probability of measuring a state  isThis is due to the fact that taking the magnitude of this vector and squaring it sums up all the probabilities of all the possible measurements of the second register that must have the first register as . There are two cases for our measurement:    and  is one-to-one. and  is two-to-one.For the first case, sincesince in this case,  is one-to-one, implying that the range of  is , meaning that the summation is over every basis vector. For the second case, note that there exist two strings,  and , such that , where . We can thus writeFurthermore, since we know that , we know that , and soThis expression is now easy to evaluate. Recall that we are measuring . When , then this expression will evaluate to , and when , then this expression will be .Thus, both when  and when , our measured  satisfies .We run the quantum part of the algorithm until we have a linearly independent list of bitstrings , and each  satisfies . Thus, we can efficiently solve this system of equations classically to find .The probability that  are linearly independent is at leastOnce we solve the system of equations, and produce a solution , we can test if . If this is true, then we know , since . If it is the case that , then that means that , and  since  is one-to-one.We can repeat Simon's algorithm a constant number of times to up the probabilities of success arbitrarily, while still having the same time complexity.Simon's algorithm requires  queries to the black box, whereas a classical algorithm would need at least  queries. It is also known that Simon's algorithm is optimal in the sense that any quantum algorithm to solve this problem requires  queries.[5][6]Deutsch–Jozsa algorithm