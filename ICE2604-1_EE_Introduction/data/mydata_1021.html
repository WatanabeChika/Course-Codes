<!DOCTYPE html>
<html>
<head>
<title>topological_sort</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<p>In computer science, a <b>topological sort</b> or <b>topological ordering</b> of a directed graph is a linear ordering of its vertices such that for every directed edge <i>uv</i> from vertex <i>u</i> to vertex <i>v</i>, <i>u</i> comes before <i>v</i> in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks. Precisely, a topological sort is a graph traversal in which each node <i>v</i> is visited only after all its dependencies are visited<i>.</i> A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time. Topological sorting has many applications especially in ranking problems such as feedback arc set. Topological sorting is possible even when the DAG has disconnected components.
</p>

<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>The canonical application of topological sorting is in scheduling a sequence of jobs or tasks based on their dependencies. The jobs are represented by vertices, and there is an edge from <i>x</i> to <i>y</i> if job <i>x</i> must be completed before job <i>y</i> can be started (for example, when washing clothes, the washing machine must finish before we put the clothes in the dryer). Then, a topological sort gives an order in which to perform the jobs.  A closely related application of topological sorting algorithms was first studied in the early 1960s in the context of the PERT technique for scheduling in project management.<sup class="reference" id="cite_ref-Jarnagin_1-0">[1]</sup> In this application, the vertices of a graph represent the milestones of a project, and the edges represent tasks that must be performed between one milestone and another. Topological sorting forms the basis of linear-time algorithms for finding the critical path of the project, a sequence of milestones and tasks that controls the length of the overall project schedule.
</p><p>In computer science, applications of this type arise in instruction scheduling, ordering of formula cell evaluation when recomputing formula values in spreadsheets, logic synthesis, determining the order of compilation tasks to perform in makefiles, data serialization, and resolving symbol dependencies in linkers. It is also used to decide in which order to load tables with foreign keys in databases.
</p>
<table>
<tbody><tr>
<td>
</td>
<td>The graph shown to the left has many valid topological sorts, including:
<ul><li>5, 7, 3, 11, 8, 2, 9, 10 (visual top-to-bottom, left-to-right)</li>
<li>3, 5, 7, 8, 11, 2, 9, 10 (smallest-numbered available vertex first)</li>
<li>5, 7, 3, 8, 11, 10, 9, 2 (fewest edges first)</li>
<li>7, 5, 11, 3, 10, 8, 9, 2 (largest-numbered available vertex first)</li>
<li>5, 7, 11, 2, 3, 8, 9, 10 (attempting top-to-bottom, left-to-right)</li>
<li>3, 7, 8, 5, 11, 10, 2, 9 (arbitrary)</li></ul>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>The usual algorithms for topological sorting have running time linear in the number of nodes plus the number of edges, asymptotically, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\left|{V}\right|+\left|{E}\right|).}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mrow>
<mo>|</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>V</mi>
</mrow>
<mo>|</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo>|</mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>E</mi>
</mrow>
<mo>|</mo>
</mrow>
<mo stretchy="false">)</mo>
<mo>.</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\left|{V}\right|+\left|{E}\right|).}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(\left|{V}\right|+\left|{E}\right|).}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f40de423f10d77a2da65bcc82f0f94944de04ef1" style="vertical-align: -0.838ex; width:13.22ex; height:2.843ex;"/></span>
</p>
<h3><span id="Kahn.27s_algorithm"></span><span class="mw-headline" id="Kahn's_algorithm">Kahn's algorithm</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>One of these algorithms, first described by Kahn (1962), works by choosing vertices in the same order as the eventual topological sort.<sup class="reference" id="cite_ref-Kahn_2-0">[2]</sup> First, find a list of "start nodes" which have no incoming edges and insert them into a set S; at least one such node must exist in a non-empty acyclic graph. Then:
</p>
<pre><i>L</i> ← Empty list that will contain the sorted elements
<i>S</i> ← Set of all nodes with no incoming edge

<b>while</b> <i>S</i> <b>is not</b> empty <b>do</b>
    remove a node <i>n</i> from <i>S</i>
    add <i>n</i> to <i>L</i>
    <b>for each</b> node <i>m</i> with an edge <i>e</i> from <i>n</i> to <i>m</i> <b>do</b>
        remove edge <i>e</i> from the graph
        <b>if</b> <i>m</i> has no other incoming edges <b>then</b>
            insert <i>m</i> into <i>S</i>

<b>if</b> <i>graph</i> has edges <b>then</b>
    <b>return</b> error   <i>(graph has at least one cycle)</i>
<b>else</b> 
    <b>return</b> <i>L</i>   <i>(a topologically sorted order)</i>
</pre>
<p>If the graph is a DAG, a solution will be contained in the list L (the solution is not necessarily unique). Otherwise, the graph must have at least one cycle and therefore a topological sort is impossible.
</p><p>Reflecting the non-uniqueness of the resulting sort, the structure S can be simply a set or a queue or a stack. Depending on the order that nodes n are removed from set S, a different solution is created. A variation of Kahn's algorithm that breaks ties lexicographically forms a key component of the Coffman–Graham algorithm for parallel scheduling and layered graph drawing.
</p>
<h3><span class="mw-headline" id="Depth-first_search">Depth-first search</span><span class="mw-editsection"></span></h3>
<p>An alternative algorithm for topological sorting is based on depth-first search. The algorithm loops through each node of the graph, in an arbitrary order, initiating a depth-first search that terminates when it hits any node that has already been visited since the beginning of the topological sort or the node has no outgoing edges (i.e. a leaf node):
</p>
<pre><i>L</i> ← Empty list that will contain the sorted nodes
<b>while</b> exists nodes without a permanent mark <b>do</b>
    select an unmarked node <i>n</i>
    visit(<i>n</i>)

<b>function</b> visit(node <i>n</i>)
    <b>if</b> <i>n</i> has a permanent mark <b>then</b>
        <b>return</b>
    <b>if</b> <i>n</i> has a temporary mark <b>then</b>
        <b>stop</b>   <i>(graph has at least one cycle)</i>

    mark <i>n</i> with a temporary mark

    <b>for each</b> node <i>m</i> with an edge from <i>n</i> to <i>m</i> <b>do</b>
        visit(<i>m</i>)

    remove temporary mark from <i>n</i>
    mark <i>n</i> with a permanent mark
    add <i>n</i> to head of <i>L</i>
</pre>
<p>Each node <i>n</i> gets <i>prepended</i> to the output list L only after considering all other nodes which depend on <i>n</i> (all descendants of <i>n</i> in the graph).  Specifically, when the algorithm adds node <i>n</i>, we are guaranteed that all nodes which depend on <i>n</i> are already in the output list L: they were added to L either by the recursive call to visit() which ended before the call to visit <i>n</i>, or by a call to visit() which started even before the call to visit <i>n</i>.  Since each edge and node is visited once, the algorithm runs in linear time. This depth-first-search-based algorithm is the one described by Cormen et al. (2001);<sup class="reference" id="cite_ref-CLRS_3-0">[3]</sup> it seems to have been first described in print by Tarjan in 1976.<sup class="reference" id="cite_ref-Tarjan_4-0">[4]</sup>
</p>
<h3><span class="mw-headline" id="Parallel_algorithms">Parallel algorithms</span><span class="mw-editsection"></span></h3>
<p>On a parallel random-access machine, a topological ordering can be constructed in <i>O</i>(log<sup>2</sup> <i>n</i>) time using a polynomial number of processors, putting the problem into the complexity class <b>NC<sup>2</sup></b>.<sup class="reference" id="cite_ref-Cook_5-0">[5]</sup>
One method for doing this is to repeatedly square the adjacency matrix of the given graph, logarithmically many times, using min-plus matrix multiplication with maximization in place of minimization. The resulting matrix describes the longest path distances in the graph. Sorting the vertices by the lengths of their longest incoming paths produces a topological ordering.<sup class="reference" id="cite_ref-DNS_6-0">[6]</sup>
</p><p>An algorithm for parallel topological sorting on distributed memory machines parallelizes the algorithm of Kahn for a DAG <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle G=(V,E)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>G</mi>
<mo>=</mo>
<mo stretchy="false">(</mo>
<mi>V</mi>
<mo>,</mo>
<mi>E</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle G=(V,E)}</annotation>
</semantics>
</math></span><img alt="G=(V,E)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/644a8d85ee410b6159ca2bdb5dcb9097e2c8f182" style="vertical-align: -0.838ex; width:11.331ex; height:2.843ex;"/></span>.<sup class="reference" id="cite_ref-SMDD_7-0">[7]</sup> On a high level, the algorithm of Kahn repeatedly removes the vertices of indegree 0 and adds them to the topological sorting in the order in which they were removed. Since the outgoing edges of the removed vertices are also removed, there will be a new set of vertices of indegree 0, where the procedure is repeated until no vertices are left. This algorithm performs <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle D+1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>D</mi>
<mo>+</mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle D+1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle D+1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6a2a5ae5a26d2595babc37427927b0cf26f9235f" style="vertical-align: -0.505ex; width:5.927ex; height:2.343ex;"/></span> iterations, where <span class="texhtml mvar" style="font-style:italic;">D</span> is the longest path in <span class="texhtml mvar" style="font-style:italic;">G</span>. Each iteration can be parallelized, which is the idea of the following algorithm.
</p><p>In the following it is assumed that the graph partition is stored on <span class="texhtml mvar" style="font-style:italic;">p</span> processing elements (PE) which are labeled <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle 0,\dots ,p-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mn>0</mn>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle 0,\dots ,p-1}</annotation>
</semantics>
</math></span><img alt="{\displaystyle 0,\dots ,p-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/350871b5980d758f5a36ecc7b1dba63c20724f0d" style="vertical-align: -0.671ex; width:11.513ex; height:2.509ex;"/></span>. Each PE <span class="texhtml mvar" style="font-style:italic;">i</span> initializes a set of local vertices <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{i}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{i}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{i}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c3ac9c76e43c749c88818ace54d0ce79c4ebc23" style="vertical-align: -1.005ex; width:2.893ex; height:3.176ex;"/></span> with indegree 0, where the upper index represents the current iteration. Since all vertices in the local sets <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a13fb14f805a8fe8b5f2f6b929539fdb6f4bbe5" style="vertical-align: -1.338ex; width:13.069ex; height:3.509ex;"/></span> have indegree 0, i.e. they are not adjacent, they can be given in an arbitrary order for a valid topological sorting. To assign a global index to each vertex, a prefix sum is calculated over the sizes of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{0}^{1},\dots ,Q_{p-1}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a13fb14f805a8fe8b5f2f6b929539fdb6f4bbe5" style="vertical-align: -1.338ex; width:13.069ex; height:3.509ex;"/></span>. So each step, there are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \sum _{i=0}^{p-1}|Q_{i}|}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msub>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
</msub>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \sum _{i=0}^{p-1}|Q_{i}|}</annotation>
</semantics>
</math></span><img alt="{\textstyle \sum _{i=0}^{p-1}|Q_{i}|}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c47c838aa5d281e4ff2c5854e976a0399801eb4b" style="vertical-align: -1.005ex; width:9.932ex; height:3.509ex;"/></span> vertices added to the topological sorting.
</p>

<p>In the first step, PE <span class="texhtml mvar" style="font-style:italic;">j</span> assigns the indices <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \sum _{i=0}^{j-1}|Q_{i}^{1}|,\dots ,\left(\sum _{i=0}^{j}|Q_{i}^{1}|\right)-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<mrow>
<mo>(</mo>
<mrow>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \sum _{i=0}^{j-1}|Q_{i}^{1}|,\dots ,\left(\sum _{i=0}^{j}|Q_{i}^{1}|\right)-1}</annotation>
</semantics>
</math></span><img alt="{\textstyle \sum _{i=0}^{j-1}|Q_{i}^{1}|,\dots ,\left(\sum _{i=0}^{j}|Q_{i}^{1}|\right)-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/63a79a820bd39172be3a325720109ef7c6cefd12" style="vertical-align: -1.838ex; width:31.921ex; height:4.843ex;"/></span> to the local vertices in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{j}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{j}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{j}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8a6910292344848e4f98b55de54dfc6ef3b5bc95" style="vertical-align: -1.338ex; width:2.893ex; height:3.509ex;"/></span>. These vertices in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{j}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{j}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{j}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8a6910292344848e4f98b55de54dfc6ef3b5bc95" style="vertical-align: -1.338ex; width:2.893ex; height:3.509ex;"/></span> are removed, together with their corresponding outgoing edges. For each outgoing edge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (u,v)}</annotation>
</semantics>
</math></span><img alt="(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eadf12294edccd7a29c99cfc1765e4a14bf47e58" style="vertical-align: -0.838ex; width:5.301ex; height:2.843ex;"/></span> with endpoint <span class="texhtml mvar" style="font-style:italic;">v</span> in another PE <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle l,j\neq l}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>l</mi>
<mo>,</mo>
<mi>j</mi>
<mo>≠<!-- ≠ --></mo>
<mi>l</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle l,j\neq l}</annotation>
</semantics>
</math></span><img alt="{\displaystyle l,j\neq l}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e7191b8105913470a4a1ae3748fe3375d2e79453" style="vertical-align: -0.838ex; width:6.477ex; height:2.676ex;"/></span>, the message <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (u,v)}</annotation>
</semantics>
</math></span><img alt="(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eadf12294edccd7a29c99cfc1765e4a14bf47e58" style="vertical-align: -0.838ex; width:5.301ex; height:2.843ex;"/></span> is posted to PE <span class="texhtml mvar" style="font-style:italic;">l</span>. After all vertices in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{j}^{1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>1</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{j}^{1}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{j}^{1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8a6910292344848e4f98b55de54dfc6ef3b5bc95" style="vertical-align: -1.338ex; width:2.893ex; height:3.509ex;"/></span> are removed, the posted messages are sent to their corresponding PE. Each message <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (u,v)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo>,</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (u,v)}</annotation>
</semantics>
</math></span><img alt="(u,v)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eadf12294edccd7a29c99cfc1765e4a14bf47e58" style="vertical-align: -0.838ex; width:5.301ex; height:2.843ex;"/></span> received updates the indegree of the local vertex <span class="texhtml mvar" style="font-style:italic;">v</span>. If the indegree drops to zero, <span class="texhtml mvar" style="font-style:italic;">v</span> is added to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle Q_{j}^{2}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msubsup>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle Q_{j}^{2}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle Q_{j}^{2}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a193d4505b0f293d868e551e9bf2cf2184bf96a4" style="vertical-align: -1.338ex; width:2.893ex; height:3.509ex;"/></span>. Then the next iteration starts.
</p><p>In step <span class="texhtml mvar" style="font-style:italic;">k</span>, PE <span class="texhtml mvar" style="font-style:italic;">j</span> assigns the indices <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<mrow>
<mo>(</mo>
<mrow>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}</annotation>
</semantics>
</math></span><img alt="{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7dbbd5c704c1c882ef0b21b8b89c7658a38dc530" style="vertical-align: -1.838ex; width:46.509ex; height:4.843ex;"/></span>, where  <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle a_{k-1}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle a_{k-1}}</annotation>
</semantics>
</math></span><img alt="a_{{k-1}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9b56e9e10d3cbe93addd3eba751f36913155ad33" style="vertical-align: -0.671ex; width:4.419ex; height:2.009ex;"/></span>is the total amount of processed vertices after step <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle k-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle k-1}</annotation>
</semantics>
</math></span><img alt="k-1" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/21363ebd7038c93aae93127e7d910fc1b2e2c745" style="vertical-align: -0.505ex; width:5.214ex; height:2.343ex;"/></span>. This procedure repeats until there are no vertices left to process, hence <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle \sum _{i=0}^{p-1}|Q_{i}^{D+1}|=0}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>p</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>D</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle \sum _{i=0}^{p-1}|Q_{i}^{D+1}|=0}</annotation>
</semantics>
</math></span><img alt="{\textstyle \sum _{i=0}^{p-1}|Q_{i}^{D+1}|=0}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8e1be13101642fb1389aa0849c4730686c619aa3" style="vertical-align: -1.005ex; width:17.087ex; height:3.509ex;"/></span>. Below is a high level, single program, multiple data pseudo code overview of this algorithm.
</p><p>Note that the prefix sum for the local offsets <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<mo>,</mo>
<mo>…<!-- … --></mo>
<mo>,</mo>
<msub>
<mi>a</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mrow>
</msub>
<mo>+</mo>
<mrow>
<mo>(</mo>
<mrow>
<munderover>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>j</mi>
</mrow>
</munderover>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
<msubsup>
<mi>Q</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
</mrow>
<mrow class="MJX-TeXAtom-ORD">
<mi>k</mi>
</mrow>
</msubsup>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mo>−<!-- − --></mo>
<mn>1</mn>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}</annotation>
</semantics>
</math></span><img alt="{\textstyle a_{k-1}+\sum _{i=0}^{j-1}|Q_{i}^{k}|,\dots ,a_{k-1}+\left(\sum _{i=0}^{j}|Q_{i}^{k}|\right)-1}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7dbbd5c704c1c882ef0b21b8b89c7658a38dc530" style="vertical-align: -1.838ex; width:46.509ex; height:4.843ex;"/></span> can be efficiently calculated in parallel.
</p>
<pre><b>p</b> processing elements with IDs from 0 to <i>p</i>-1
<b>Input:</b> G = (V, E) DAG, distributed to PEs, PE index j = 0, ..., p - 1
<b>Output:</b> topological sorting of G

<b>function</b> traverseDAGDistributed
    δ incoming degree of local vertices <i>V</i>
    <span class="texhtml"><i>Q</i> = {<i>v</i> ∈ <i>V</i> | δ[<i>v</i>] = 0}</span>                     // All vertices with indegree 0
    nrOfVerticesProcessed = 0

    <b>do</b>                 
        <b>global</b> build prefix sum over size of <i>Q</i>     // get offsets and total amount of vertices in this step
        offset = nrOfVerticesProcessed + sum(Q<sub>i</sub>, i = 0 to j - 1)          // <i>j</i> is the processor index
        <b>foreach</b> u <b>in</b> Q                                       
            localOrder[u] = index++;
            <b>foreach</b> (u,v) in E <b>do</b> post message (<i>u, v</i>) to PE owning vertex <i>v</i>
        nrOfVerticesProcessed += sum(|Q<sub>i</sub>|, i = 0 to p - 1)
        deliver all messages to neighbors of vertices in Q  
        receive messages for local vertices V
        remove all vertices in Q
        <b>foreach</b> message (<i>u, v</i>) received:
            <b>if</b> --δ[v] = 0
                add <i>v</i> to <i>Q</i>
    <b>while</b> global size of <i>Q</i> &gt; 0

    <b>return</b> localOrder
</pre>
<p>The communication cost depends heavily on the given graph partition. As for runtime, on a CRCW-PRAM model that allows fetch-and-decrement in constant time, this algorithm runs in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle {\mathcal {O}}\left({\frac {m+n}{p}}+D(\Delta +\log n)\right)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<mrow class="MJX-TeXAtom-ORD">
<mrow class="MJX-TeXAtom-ORD">
<mi class="MJX-tex-caligraphic" mathvariant="script">O</mi>
</mrow>
</mrow>
<mrow>
<mo>(</mo>
<mrow>
<mrow class="MJX-TeXAtom-ORD">
<mfrac>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
<mi>p</mi>
</mfrac>
</mrow>
<mo>+</mo>
<mi>D</mi>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Δ<!-- Δ --></mi>
<mo>+</mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>)</mo>
</mrow>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle {\mathcal {O}}\left({\frac {m+n}{p}}+D(\Delta +\log n)\right)}</annotation>
</semantics>
</math></span><img alt="{\textstyle {\mathcal {O}}\left({\frac {m+n}{p}}+D(\Delta +\log n)\right)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c633a9209ad4683fe90e9431cd56ac33dd62236" style="vertical-align: -1.838ex; width:25.66ex; height:4.843ex;"/></span>, where <span class="texhtml mvar" style="font-style:italic;">D</span> is again the longest path in <span class="texhtml mvar" style="font-style:italic;">G</span> and <span class="texhtml mvar" style="font-style:italic;">Δ</span> the maximum degree.<sup class="reference" id="cite_ref-SMDD_7-1">[7]</sup>
</p>
<h2><span class="mw-headline" id="Application_to_shortest_path_finding">Application to shortest path finding</span><span class="mw-editsection"></span></h2>
<p>The topological ordering can also be used to quickly compute shortest paths through a weighted directed acyclic graph. Let <span class="texhtml mvar" style="font-style:italic;">V</span> be the list of vertices in such a graph, in topological order. Then the following algorithm computes the shortest path from some source vertex <span class="texhtml mvar" style="font-style:italic;">s</span> to all other vertices:<sup class="reference" id="cite_ref-CLRS_3-1">[3]</sup>
</p>

<p>Equivalently:
</p>

<p>On a graph of <span class="texhtml mvar" style="font-style:italic;">n</span> vertices and <span class="texhtml mvar" style="font-style:italic;">m</span> edges, this algorithm takes <span class="texhtml">Θ(<i>n</i> + <i>m</i>)</span>, i.e., linear, time.<sup class="reference" id="cite_ref-CLRS_3-2">[3]</sup>
</p>
<h2><span class="mw-headline" id="Uniqueness">Uniqueness</span><span class="mw-editsection"></span></h2>
<p>If a topological sort has the property that all pairs of consecutive vertices in the sorted order are connected by edges, then these edges form a directed Hamiltonian path in the DAG. If a Hamiltonian path exists, the topological sort order is unique; no other order respects the edges of the path. Conversely, if a topological sort does not form a Hamiltonian path, the DAG will have two or more valid topological orderings, for in this case it is always possible to form a second valid ordering by swapping two consecutive vertices that are not connected by an edge to each other. Therefore, it is possible to test in linear time whether a unique ordering exists, and whether a Hamiltonian path exists, despite the NP-hardness of the Hamiltonian path problem for more general directed graphs (i.e. cyclic directed graphs).<sup class="reference" id="cite_ref-VM_8-0">[8]</sup>
</p>
<h2><span class="mw-headline" id="Relation_to_partial_orders">Relation to partial orders</span><span class="mw-editsection"></span></h2>
<p>Topological orderings are also closely related to the concept of a linear extension of a partial order in mathematics. A partially ordered set is just a set of objects together with a definition of the "≤" inequality relation, satisfying the axioms of reflexivity (<i>x</i> ≤ <i>x</i>), antisymmetry (if <i>x</i> ≤ <i>y</i> and <i>y</i> ≤ <i>x</i> then <i>x</i> = <i>y</i>) and transitivity (if <i>x</i> ≤ <i>y</i> and <i>y</i> ≤ <i>z</i>, then <i>x</i> ≤ <i>z</i>). A total order is a partial order in which, for every two objects <i>x</i> and <i>y</i> in the set, either <i>x</i> ≤ <i>y</i> or <i>y</i> ≤ <i>x</i>. Total orders are familiar in computer science as the comparison operators needed to perform comparison sorting algorithms. For finite sets, total orders may be identified with linear sequences of objects, where the "≤" relation is true whenever the first object precedes the second object in the order; a comparison sorting algorithm may be used to convert a total order into a sequence in this way. A linear extension of a partial order is a total order that is compatible with it, in the sense that, if <i>x</i> ≤ <i>y</i> in the partial order, then  <i>x</i> ≤ <i>y</i> in the total order as well.
</p><p>One can define a partial ordering from any DAG by letting the set of objects be the vertices of the DAG, and defining <i>x</i> ≤ <i>y</i> to be true, for any two vertices <i>x</i> and <i>y</i>, whenever there exists a directed path from <i>x</i> to <i>y</i>; that is,  whenever <i>y</i> is reachable from <i>x</i>. With these definitions, a topological ordering of the DAG is the same thing as a linear extension of this partial order. Conversely, any partial ordering may be defined as the reachability relation in a DAG. One way of doing this is to define a DAG that has a vertex for every object in the partially ordered set, and an edge <i>xy</i> for every pair of objects for which <i>x</i> ≤ <i>y</i>. An alternative way of doing this is to use the transitive reduction of the partial ordering; in general, this produces DAGs with fewer edges, but the reachability relation in these DAGs is still the same partial order. By using these constructions, one can use topological ordering algorithms to find linear extensions of partial orders.
</p>
<h2><span class="mw-headline" id="Relation_to_scheduling_optimisation">Relation to scheduling optimisation</span><span class="mw-editsection"></span></h2>
<p>By definition, the solution of a scheduling problem that includes a precedence graph is a valid solution to topological sort (irrespective of the number of machines), however, topological sort in itself is <i>not</i> enough to optimally solve a scheduling optimisation problem. Hu's algorithm is a popular method used to solve scheduling problems that require a precedence graph and involve processing times (where the goal is to minimise the largest completion time amongst all the jobs). Like topological sort, Hu's algorithm is not unique and can be solved using DFS (by finding the largest path length and then assigning the jobs). 
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>tsort, a Unix program for topological sorting</li>
<li>Feedback arc set, a set of edges whose removal allows the remaining subgraph to be topologically sorted</li>
<li>Tarjan's strongly connected components algorithm, an algorithm that gives the topologically sorted list of strongly connected components in a graph</li>
<li>Pre-topological order</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li>D. E. Knuth, The Art of Computer Programming, Volume 1, section 2.2.3, which gives an algorithm for topological sorting of a partial ordering, and a brief history.</li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>NIST Dictionary of Algorithms and Data Structures: topological sort</li>
<li><span class="citation mathworld" id="Reference-Mathworld-Topological_Sort"><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation web cs2" id="CITEREFWeisstein">Weisstein, Eric W., "Topological Sort", <i>MathWorld</i></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=MathWorld&amp;rft.atitle=Topological+Sort&amp;rft.au=Weisstein%2C+Eric+W.&amp;rft_id=https%3A%2F%2Fmathworld.wolfram.com%2FTopologicalSort.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATopological+sorting"></span></span></li></ul>

<!-- 
NewPP limit report
Parsed by mw2337
Cached time: 20221224000735
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.336 seconds
Real time usage: 0.549 seconds
Preprocessor visited node count: 4744/1000000
Post‐expand include size: 42080/2097152 bytes
Template argument size: 2453/2097152 bytes
Highest expansion depth: 11/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 33014/5000000 bytes
Lua time usage: 0.163/10.000 seconds
Lua memory usage: 6016743/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  366.012      1 -total
 33.28%  121.822      1 Template:Reflist
 27.91%  102.138      8 Template:Citation
 14.59%   53.384      1 Template:Short_description
 11.18%   40.914     11 Template:R
 11.13%   40.741      1 Template:Sorting
 10.53%   38.537      1 Template:Navbox
  9.44%   34.540     11 Template:R/ref
  7.96%   29.143      2 Template:Harvp
  7.91%   28.969      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:897064-0!canonical and timestamp 20221224000735 and revision id 1123299686.
 -->
</div></body>
</html>