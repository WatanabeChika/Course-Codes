<!DOCTYPE html>
<html>
<head>
<title>abstract_data_type</title>
</head>
<body>
<div class="mw-parser-output">
<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><style data-mw-deduplicate="TemplateStyles:r1086701767">.mw-parser-output .multiple-issues-text{width:95%;margin:0.2em 0}.mw-parser-output .multiple-issues-text>.mw-collapsible-content{margin-top:0.3em}.mw-parser-output .compact-ambox .ambox{border:none;border-collapse:collapse;background-color:transparent;margin:0 0 0 1.6em!important;padding:0!important;width:auto;display:block}body.mediawiki .mw-parser-output .compact-ambox .ambox.mbox-small-left{font-size:100%;width:auto;margin:0}.mw-parser-output .compact-ambox .ambox .mbox-text{padding:0!important;margin:0!important}.mw-parser-output .compact-ambox .ambox .mbox-text-span{display:list-item;line-height:1.5em;list-style-type:disc}.mw-parser-output .compact-ambox .ambox .mbox-image,.mw-parser-output .compact-ambox .ambox .mbox-imageright,.mw-parser-output .compact-ambox .ambox .mbox-empty-cell,.mw-parser-output .compact-ambox .hide-when-compact{display:none}</style><table class="box-Multiple_issues plainlinks metadata ambox ambox-content ambox-multiple_issues compact-ambox" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computer science, an <b>abstract data type</b> (<b>ADT</b>) is a mathematical model for data types. An abstract data type is defined by its behavior (semantics) from the point of view of a <i>user</i>, of the data, specifically in terms of possible values, possible operations on data of this type, and the behavior of these operations. This mathematical model contrasts with data structures, which are concrete representations of data, and are the point of view of an implementer, not a user.
</p><p>Formally, an ADT may be defined as a "class of objects whose logical behavior is defined by a set of values and a set of operations";<sup class="reference" id="cite_ref-FOOTNOTEDaleWalker19963_1-0">[1]</sup> this is analogous to an algebraic structure in mathematics. What is meant by "behaviour" varies by author, with the two main types of formal specifications for behavior being <i>axiomatic (algebraic) specification</i> and an <i>abstract model;</i><sup class="reference" id="cite_ref-FOOTNOTEDaleWalker19964_2-0">[2]</sup> these correspond to axiomatic semantics and operational semantics of an abstract machine, respectively. Some authors also include the computational complexity ("cost"), both in terms of time (for computing operations) and space (for representing values). In practice, many common data types are not ADTs, as the abstraction is not perfect, and users must be aware of issues like arithmetic overflow that are due to the representation. For example, integers are often stored as fixed-width values (32-bit or 64-bit binary numbers), and thus experience integer overflow if the maximum value is exceeded.
</p><p>ADTs are a theoretical concept, in computer science, used in the design and analysis of algorithms, data structures, and software systems, and do not correspond to specific features of computer languages—mainstream computer languages do not directly support formally specified ADTs. However, various language features correspond to certain aspects of ADTs, and are easily confused with ADTs proper; these include abstract types, opaque data types, protocols, and design by contract. ADTs were first proposed by Barbara Liskov and Stephen N. Zilles in 1974, as part of the development of the CLU language.<sup class="reference" id="cite_ref-FOOTNOTELiskovZilles1974_3-0">[3]</sup>
</p>

<h2><span class="mw-headline" id="Abstract_data_types">Abstract data types</span><span class="mw-editsection"></span></h2>
<p>For example, integers are an ADT, defined as the values ..., −2, −1, 0, 1, 2, ..., and by the operations of addition, subtraction, multiplication, and division, together with greater than, less than, etc., which behave according to familiar mathematics (with care for integer division), independently of how the integers are represented by the computer. <sup class="reference" id="cite_ref-4">[a]</sup> Explicitly, "behavior" includes obeying various axioms (associativity and commutativity of addition, etc.), and preconditions on operations (cannot divide by zero). Typically integers are represented in a data structure as binary numbers, most often as two's complement, but might be binary-coded decimal or in ones' complement, but for most purposes the user can work with the abstraction rather than the concrete choice of representation, and can simply use the data as if the type were truly abstract.
</p><p>An ADT consists not only of operations but also of a domain of values, and of constraints on the defined operations. An "interface" typically refers only to the operations, and perhaps some of the constraints on the operations, such as pre-conditions and post-conditions; but not to other constraints such as relations between the operations.
</p><p>For example, an abstract stack, which is a last-in-first-out structure, could be defined by three operations: <kbd>push</kbd>, that inserts a data item onto the stack; <kbd>pop</kbd>, that removes a data item from it; and <kbd>peek</kbd> or <kbd>top</kbd>, that accesses a data item on top of the stack without removal. An abstract queue, which is a first-in-first-out structure, would also have three operations: <kbd>enqueue</kbd>, that inserts a data item into the queue; <kbd>dequeue</kbd>, that removes the first data item from it; and <kbd>front</kbd>, that accesses and serves the first data item in the queue. If these were the entire definitions, there would be no way of differentiating these two data types and their very different expected ordering behavior. Thus, a constraint is introduced that for a stack specifies that each pop always returns (and removes) the most recently pushed item that has not been popped yet, and for a queue (in contrast) specifies that pop operates on the least recently pushed item. 
</p><p>When analyzing the efficiency of algorithms, one may also specify that all operations take the same time no matter how many data items have been pushed into the stack, and that the stack uses a constant amount of storage for each element. However, time bounds are not always considered part of the definition of an ADT.
</p>
<h2><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"></span></h2>
<p>Abstract data types are purely theoretical entities, used (among other things) to simplify the description of abstract algorithms, to classify and evaluate data structures, and to formally describe the type systems of programming languages. However, an ADT may be implemented by specific data types or data structures, in many ways and in many programming languages; or described in a formal specification language. ADTs are often implemented as modules: the module's interface declares procedures that correspond to the ADT operations, sometimes with comments that describe the constraints. This information hiding strategy allows the implementation of the module to be changed without disturbing the client programs.
</p><p>The term abstract data type can also be regarded as a generalized approach of a number of algebraic structures, such as lattices, groups, and rings.<sup class="reference" id="cite_ref-5">[4]</sup> The notion of abstract data types is related to the concept of data abstraction, important in object-oriented programming and design by contract methodologies for software development.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (September 2022)">citation needed</span></i>]</sup>
</p>
<h2><span class="mw-headline" id="Defining_an_abstract_data_type">Defining an abstract data type</span><span class="mw-editsection"></span></h2>
<p>An abstract data type is defined as a mathematical model of the data objects that make up a data type as well as the functions that operate on these objects.
There are no standard conventions for defining them. A broad division may be drawn between "imperative" (or "operational") and "functional" (or "axiomatic") definition styles.
</p>
<h3><span class="mw-headline" id="Imperative-style_definition">Imperative-style definition</span><span class="mw-editsection"></span></h3>
<p>In the theory of imperative programming languages, an abstract data structure is conceived as an entity that is <i>mutable</i>—meaning that it may be in different <i>states</i> at different times. Some operations may change the state of the ADT; therefore, the order in which operations are evaluated is important, and the same operation on the same entities may have different effects if executed at different times. This is analogous to the instructions of a computer, or the commands and procedures of an imperative language. To underscore this view it is customary to say that the operations are <i>executed</i> or <i>applied</i>, rather than <i>evaluated</i>, similar to the imperative style often used when describing abstract algorithms. (See The Art of Computer Programming by Donald Knuth for more details).
</p>
<h4><span class="mw-headline" id="Abstract_variable">Abstract variable</span><span class="mw-editsection"></span></h4>
<p>Imperative-style definitions of ADT often depend on the concept of an <i>abstract variable</i>, which may be regarded as the simplest non-trivial ADT. An abstract variable <i>V</i> is a mutable entity that admits two operations:
</p>
<ul><li><kbd>store</kbd>(<i>V</i>, <i>x</i>) where <i>x</i> is a <i>value</i> of unspecified nature;</li>
<li><kbd>fetch</kbd>(<i>V</i>), that yields a value,</li></ul>
<p>with the constraint that
</p>
<ul><li><kbd>fetch</kbd>(<i>V</i>) always returns the value <i>x</i> used in the most recent <kbd>store</kbd>(<i>V</i>, <i>x</i>) operation on the same variable <i>V</i>.</li></ul>
<p>Fetching before storing can be disallowed, defined to have a certain result, or (less desirably), leave the behavior unspecified.
</p><p>As in many programming languages, the operation <kbd>store</kbd>(<i>V</i>, <i>x</i>) is often written <i>V</i> ← <i>x</i> (or some similar notation), and <kbd>fetch</kbd>(<i>V</i>) is implied whenever a variable <i>V</i> is used in a context where a value is required. Thus, for example, <i>V</i> ← <i>V</i> + 1 is commonly understood to be a shorthand for <kbd>store</kbd>(<i>V</i>,<kbd>fetch</kbd>(<i>V</i>) + 1).
</p><p>In this definition, it is implicitly assumed that names are always distinct: storing a value into a variable <i>U</i> has no effect on the state of a distinct variable <i>V</i>. To make this assumption explicit, one could add the constraint that
</p>
<ul><li>if <i>U</i> and <i>V</i> are distinct variables, the sequence { <kbd>store</kbd>(<i>U</i>, <i>x</i>); <kbd>store</kbd>(<i>V</i>, <i>y</i>) } is equivalent to { <kbd>store</kbd>(<i>V</i>, <i>y</i>); <kbd>store</kbd>(<i>U</i>, <i>x</i>) }.</li></ul>
<p>More generally, ADT definitions often assume that any operation that changes the state of one ADT instance has no effect on the state of any other instance of the same ADT, unless the ADT axioms define certain instances as connected (see aliased) in a specific way. The most common such connections include:
</p>
<ul><li>Aliasing, in which two or more names refer to the exact same data object.</li>
<li>Composition, in which an ADT is defined to contain instances of (the same or other) ADTs.</li>
<li>Reference, in which an ADT is defined to refer to instance of (the same or other) ADTs.</li></ul>
<p>For example, when extending the definition of an abstract variable to include abstract records, operations upon a field <i>F</i> of a record variable <i>R</i>, clearly involve <i>F</i>, which is distinct from, but also a part of, <i>R</i>.
</p><p>The definition of an ADT may restrict the stored value(s) for its instances, to members of a specific set <i>X</i> called the <i>range</i> of those variables. For example, an ADT for an aggregate such as a Stack or Queue, may constrain all items in the queue to be integers, or at least to all be of a single type (see homogeneity). As in programming languages, such restrictions may simplify the description and analysis of algorithms, and improve its readability.
</p><p>Note that this definition does not imply anything about the result of evaluating <kbd>fetch</kbd>(<i>V</i>) when <i>V</i> is <i>un-initialized</i>, that is, before performing any <kbd>store</kbd> operation on <i>V</i>. An algorithm that does so may be considered invalid, either (a) because the ADT prohibits such an operation, or (b) simply because its effect is not defined by the ADT. However, there are some important algorithms whose efficiency strongly depends on the assumption that such a <kbd>fetch</kbd> is legal, and returns some arbitrary value in the variable's range.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><span title="This claim needs references to reliable sources. (May 2009)">citation needed</span></i>]</sup>)
</p>
<h4><span class="mw-headline" id="Instance_creation">Instance creation</span><span class="mw-editsection"></span></h4>
<p>Some algorithms need to create new instances of some ADT (such as new variables, or new stacks). To describe such algorithms, one usually includes in the ADT definition a <kbd>create</kbd>() operation that yields an instance of the ADT, usually with axioms equivalent to
</p>
<ul><li>the result of <kbd>create</kbd>() is distinct from any instance already in use by the algorithm.</li></ul>
<p>This axiom may be strengthened to exclude also partial aliasing with other instances<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><span title="The text near this tag may need clarification or removal of jargon. (January 2022)">clarification needed</span></i>]</sup>. For practical use, such as axiom may still allow implementations of <kbd>create</kbd>() to yield a previously created instance that has become inaccessible to the program; however, defining that such an instance even is "the same" is difficult, especially in the abstract (though even a re-used block of memory is only "the same object" in certain senses).
</p>
<h4><span id="Example:_abstract_stack_.28imperative.29"></span><span class="mw-headline" id="Example:_abstract_stack_(imperative)">Example: abstract stack (imperative)</span><span class="mw-editsection"></span></h4>
<p>As another example, an imperative-style definition of an abstract stack could specify that the state of a stack <i>S</i> can be modified only by the operations
</p>
<ul><li><kbd>push</kbd>(<i>S</i>, <i>x</i>), where <i>x</i> is some <i>value</i> of unspecified nature;</li>
<li><kbd>pop</kbd>(<i>S</i>), that yields a value as a result,</li></ul>
<p>with the constraint that
</p>
<ul><li>For any value <i>x</i> and any abstract variable <i>V</i>, the sequence of operations { <kbd>push</kbd>(<i>S</i>, <i>x</i>); <i>V</i> ← <kbd>pop</kbd>(<i>S</i>) } is equivalent to <i>V</i> ← <i>x</i>.</li></ul>
<p>Since the assignment <i>V</i> ← <i>x</i>, by definition, cannot change the state of <i>S</i>, this condition implies that <i>V</i> ← <kbd>pop</kbd>(<i>S</i>) restores <i>S</i> to the state it had before the <kbd>push</kbd>(<i>S</i>, <i>x</i>). From this condition and from the properties of abstract variables, it follows, for example, that the sequence
</p>
<dl><dd>{ <kbd>push</kbd>(<i>S</i>, <i>x</i>); <kbd>push</kbd>(<i>S</i>, <i>y</i>); <i>U</i> ← <kbd>pop</kbd>(<i>S</i>); <kbd>push</kbd>(<i>S</i>, <i>z</i>); <i>V</i> ← <kbd>pop</kbd>(<i>S</i>); <i>W</i> ← <kbd>pop</kbd>(<i>S</i>) }</dd></dl>
<p>where <i>x</i>, <i>y</i>, and <i>z</i> are any values, and <i>U</i>, <i>V</i>, <i>W</i> are pairwise distinct variables, is equivalent to
</p>
<dl><dd>{ <i>U</i> ← <i>y</i>; <i>V</i> ← <i>z</i>; <i>W</i> ← <i>x</i> }</dd></dl>
<p>Here it is implicitly assumed that operations on a stack instance do not modify the state of any other ADT instance, including other stacks; that is,
</p>
<ul><li>For any values <i>x</i>, <i>y</i>, and any distinct stacks <i>S</i> and <i>T</i>, the sequence { <kbd>push</kbd>(<i>S</i>, <i>x</i>); <kbd>push</kbd>(<i>T</i>, <i>y</i>) } is equivalent to { <kbd>push</kbd>(<i>T</i>, <i>y</i>); <kbd>push</kbd>(<i>S</i>, <i>x</i>) }.</li></ul>
<p>An abstract stack definition usually includes also a Boolean-valued function <kbd>empty</kbd>(<i>S</i>) and a <kbd>create</kbd>() operation that returns a stack instance, with axioms equivalent to
</p>
<ul><li><kbd>create</kbd>() ≠ <i>S</i> for any prior stack <i>S</i> (a newly created stack is distinct from all previous stacks);</li>
<li><kbd>empty</kbd>(<kbd>create</kbd>()) (a newly created stack is empty);</li>
<li><kbd>not</kbd> <kbd>empty</kbd>(<kbd>push</kbd>(<i>S</i>, <i>x</i>)) (pushing something into a stack makes it non-empty).</li></ul>
<h4><span class="mw-headline" id="Single-instance_style">Single-instance style</span><span class="mw-editsection"></span></h4>
<p>Sometimes an ADT is defined as if only one instance of it existed during the execution of the algorithm, and all operations were applied to that instance, which is not explicitly notated. For example, the abstract stack above could have been defined with operations <kbd>push</kbd>(<i>x</i>) and <kbd>pop</kbd>(), that operate on <i>the</i> only existing stack. ADT definitions in this style can be easily rewritten to admit multiple coexisting instances of the ADT, by adding an explicit instance parameter (like <i>S</i> in the previous example) to every operation that uses or modifies the implicit instance.
</p><p>On the other hand, some ADTs cannot be meaningfully defined without assuming multiple instances. This is the case when a single operation takes two distinct instances of the ADT as parameters. For an example, consider augmenting the definition of the abstract stack with an operation <kbd>compare</kbd>(<i>S</i>, <i>T</i>) that checks whether the stacks <i>S</i> and <i>T</i> contain the same items in the same order.
</p>
<h3><span class="mw-headline" id="Functional-style_definition">Functional-style definition</span><span class="mw-editsection"></span></h3>
<p>Another way to define an ADT, closer to the spirit of functional programming, is to consider each state of the structure as a separate entity. In this view, any operation that modifies the ADT is modelled as a mathematical function that takes the old state as an argument and returns the new state as part of the result. Unlike the imperative operations, these functions have no side effects. Therefore, the order in which they are evaluated is immaterial, and the same operation applied to the same arguments (including the same input states) will always return the same results (and output states).
</p><p>In the functional view, in particular, there is no way (or need) to define an "abstract variable" with the semantics of imperative variables (namely, with <kbd>fetch</kbd> and <kbd>store</kbd> operations). Instead of storing values into variables, one passes them as arguments to functions.
</p>
<h4><span id="Example:_abstract_stack_.28functional.29"></span><span class="mw-headline" id="Example:_abstract_stack_(functional)">Example: abstract stack (functional)</span><span class="mw-editsection"></span></h4>
<p>For example, a complete functional-style definition of an abstract stack could use the three operations:
</p>
<ul><li><kbd>push</kbd>: takes a stack state and an arbitrary value, returns a stack state;</li>
<li><kbd>top</kbd>: takes a stack state, returns a value;</li>
<li><kbd>pop</kbd>: takes a stack state, returns a stack state.</li></ul>
<p>In a functional-style definition there is no need for a <kbd>create</kbd> operation. Indeed, there is no notion of "stack instance". The stack states can be thought of as being potential states of a single stack structure, and two-stack states that contain the same values in the same order are considered to be identical states. This view actually mirrors the behavior of some concrete implementations, such as linked lists with hash cons.
</p><p>Instead of <kbd>create</kbd>(), a functional-style definition of an abstract stack may assume the existence of a special stack state, the <i>empty stack</i>, designated by a special symbol like Λ or "()"; or define a <kbd>bottom</kbd>() operation that takes no arguments and returns this special stack state. Note that the axioms imply that
</p>
<ul><li><kbd>push</kbd>(Λ, <i>x</i>) ≠ Λ.</li></ul>
<p>In a functional-style definition of a stack one does not need an <kbd>empty</kbd> predicate: instead, one can test whether a stack is empty by testing whether it is equal to Λ.
</p><p>Note that these axioms do not define the effect of <kbd>top</kbd>(<i>s</i>) or <kbd>pop</kbd>(<i>s</i>), unless <i>s</i> is a stack state returned by a <kbd>push</kbd>. Since <kbd>push</kbd> leaves the stack non-empty, those two operations are undefined (hence invalid) when <i>s</i> = Λ. On the other hand, the axioms (and the lack of side effects) imply that <kbd>push</kbd>(<i>s</i>, <i>x</i>) = <kbd>push</kbd>(<i>t</i>, <i>y</i>) if and only if <i>x</i> = <i>y</i> and <i>s</i> = <i>t</i>.
</p><p>As in some other branches of mathematics, it is customary to assume also that the stack states are only those whose existence can be proved from the axioms in a finite number of steps. In the abstract stack example above, this rule means that every stack is a <i>finite</i> sequence of values, that becomes the empty stack (Λ) after a finite number of <kbd>pop</kbd>s. By themselves, the axioms above do not exclude the existence of infinite stacks (that can be <kbd>pop</kbd>ped forever, each time yielding a different state) or circular stacks (that return to the same state after a finite number of <kbd>pop</kbd>s). In particular, they do not exclude states <i>s</i> such that <kbd>pop</kbd>(<i>s</i>) = <i>s</i> or <kbd>push</kbd>(<i>s</i>, <i>x</i>) = <i>s</i> for some <i>x</i>. However, since one cannot obtain such stack states with the given operations, they are assumed "not to exist".
</p>
<h3><span class="mw-headline" id="Whether_to_include_complexity">Whether to include complexity</span><span class="mw-editsection"></span></h3>
<p>Aside from the behavior in terms of axioms, it is also possible to include, in the definition of an ADT operation, their algorithmic complexity. Alexander Stepanov, designer of the C++ Standard Template Library, included complexity guarantees in the STL specification, arguing:
</p>
<style data-mw-deduplicate="TemplateStyles:r996844942">.mw-parser-output .templatequote{overflow:hidden;margin:1em 0;padding:0 40px}.mw-parser-output .templatequote .templatequotecite{line-height:1.5em;text-align:left;padding-left:1.6em;margin-top:0}</style><blockquote class="templatequote"><p>The reason for introducing the notion of abstract data types was to allow interchangeable software modules. You cannot have interchangeable modules unless these modules share similar complexity behavior. If I replace one module with another module with the same functional behavior but with different complexity tradeoffs, the user of this code will be unpleasantly surprised. I could tell him anything I like about data abstraction, and he still would not want to use the code. Complexity assertions have to be part of the interface.</p></blockquote>
<h2><span class="mw-headline" id="Advantages_of_abstract_data_typing">Advantages of abstract data typing</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-More_citations_needed_section plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<h3><span class="mw-headline" id="Encapsulation">Encapsulation</span><span class="mw-editsection"></span></h3>
<p>Abstraction provides a promise that any implementation of the ADT has certain properties and abilities; knowing these is all that is required to make use of an ADT object.it make to used with Data type in programming language
Perimitive and non perimitive data type.
</p>
<h3><span class="mw-headline" id="Localization_of_change">Localization of change</span><span class="mw-editsection"></span></h3>
<p>Code that uses an ADT object will not need to be edited if the implementation of the ADT is changed. Since any changes to the implementation must still comply with the interface, and since code using an ADT object may only refer to properties and abilities specified in the interface, changes may be made to the implementation without requiring any changes in code where the ADT is used.
</p>
<h3><span class="mw-headline" id="Flexibility">Flexibility</span><span class="mw-editsection"></span></h3>
<p>Different implementations of the ADT, having all the same properties and abilities, are equivalent and may be used somewhat interchangeably in code that uses the ADT. This gives a great deal of flexibility when using ADT objects in different situations. For example, different implementations of the ADT may be more efficient in different situations; it is possible to use each in the situation where they are preferable, thus increasing overall efficiency.
</p>
<h2><span class="mw-headline" id="Typical_operations">Typical operations</span><span class="mw-editsection"></span></h2>
<p>Some operations that are often specified for ADTs (possibly under other names) are
</p>
<ul><li><kbd>compare</kbd>(<i>s</i>, <i>t</i>), that tests whether two instances' states are equivalent in some sense;</li>
<li><kbd>hash</kbd>(<i>s</i>), that computes some standard hash function from the instance's state;</li>
<li><kbd>print</kbd>(<i>s</i>) or <kbd>show</kbd>(<i>s</i>), that produces a human-readable representation of the instance's state.</li></ul>
<p>In imperative-style ADT definitions, one often finds also
</p>
<ul><li><kbd>create</kbd>(), that yields a new instance of the ADT;</li>
<li><kbd>initialize</kbd>(<i>s</i>), that prepares a newly created instance <i>s</i> for further operations, or resets it to some "initial state";</li>
<li><kbd>copy</kbd>(<i>s</i>, <i>t</i>), that puts instance <i>s</i> in a state equivalent to that of <i>t</i>;</li>
<li><kbd>clone</kbd>(<i>t</i>), that performs <i>s</i> ← <kbd>create</kbd>(), <kbd>copy</kbd>(<i>s</i>, <i>t</i>), and returns <i>s</i>;</li>
<li><kbd>free</kbd>(<i>s</i>) or <kbd>destroy</kbd>(<i>s</i>), that reclaims the memory and other resources used by <i>s</i>.</li></ul>
<p>The <kbd>free</kbd> operation is not normally relevant or meaningful, since ADTs are theoretical entities that do not "use memory". However, it may be necessary when one needs to analyze the storage used by an algorithm that uses the ADT. In that case, one needs additional axioms that specify how much memory each ADT instance uses, as a function of its state, and how much of it is returned to the pool by <kbd>free</kbd>.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>Some common ADTs, which have proved useful in a great variety of applications, are
</p>
<style data-mw-deduplicate="TemplateStyles:r998391716">.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}</style>
<p>Each of these ADTs may be defined in many ways and variants, not necessarily equivalent. For example, an abstract stack may or may not have a <kbd>count</kbd> operation that tells how many items have been pushed and not yet popped. This choice makes a difference not only for its clients but also for the implementation.
</p>
<dl><dt>Abstract graphical data type</dt></dl>
<p>An extension of ADT for computer graphics was proposed in 1979:<sup class="reference" id="cite_ref-7">[6]</sup> an abstract graphical data type (AGDT). It was introduced by Nadia Magnenat Thalmann, and Daniel Thalmann. AGDTs provide the advantages of ADTs with facilities to build graphical objects in a structured way.
</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Implementing an ADT means providing one procedure or function for each abstract operation. The ADT instances are represented by some concrete data structure that is manipulated by those procedures, according to the ADT's specifications.
</p><p>Usually, there are many ways to implement the same ADT, using several different concrete data structures. Thus, for example, an abstract stack can be implemented by a linked list or by an array.
</p><p>In order to prevent clients from depending on the implementation, an ADT is often packaged as an <i>opaque data type</i> in one or more modules, whose interface contains only the signature (number and types of the parameters and results) of the operations. The implementation of the module—namely, the bodies of the procedures and the concrete data structure used—can then be hidden from most clients of the module. This makes it possible to change the implementation without affecting the clients. If the implementation is exposed, it is known instead as a <i>transparent data type.</i>
</p><p>When implementing an ADT, each instance (in imperative-style definitions) or each state (in functional-style definitions) is usually represented by a handle of some sort.<sup class="reference" id="cite_ref-8">[7]</sup>
</p><p>Modern object-oriented languages, such as C++ and Java, support a form of abstract data types. When a class is used as a type, it is an abstract type that refers to a hidden representation. In this model, an ADT is typically implemented as a class, and each instance of the ADT is usually an object of that class. The module's interface typically declares the constructors as ordinary procedures, and most of the other ADT operations as methods of that class. However, such an approach does not easily encapsulate multiple representational variants found in an ADT. It also can undermine the extensibility of object-oriented programs. In a pure object-oriented program that uses interfaces as types, types refer to behaviours, not representations.
</p>
<h3><span class="mw-headline" id="Example:_implementation_of_the_abstract_stack">Example: implementation of the abstract stack</span><span class="mw-editsection"></span></h3>
<p>As an example, here is an implementation of the abstract stack above in the C programming language.
</p>
<h4><span class="mw-headline" id="Imperative-style_interface">Imperative-style interface</span><span class="mw-editsection"></span></h4>
<p>An imperative-style interface might be:
</p>

<p>This interface could be used in the following manner:
</p>

<p>This interface can be implemented in many ways. The implementation may be arbitrarily inefficient, since the formal definition of the ADT, above, does not specify how much space the stack may use, nor how long each operation should take. It also does not specify whether the stack state <i>s</i> continues to exist after a call <i>x</i> ← <kbd>pop</kbd>(<i>s</i>).
</p><p>In practice the formal definition should specify that the space is proportional to the number of items pushed and not yet popped; and that every one of the operations above must finish in a constant amount of time, independently of that number. To comply with these additional specifications, the implementation could use a linked list, or an array (with dynamic resizing) together with two integers (an item count and the array size).
</p>
<h4><span class="mw-headline" id="Functional-style_interface">Functional-style interface</span><span class="mw-editsection"></span></h4>
<p>Functional-style ADT definitions are more appropriate for functional programming languages, and vice versa. However, one can provide a functional-style interface even in an imperative language like C. For example:
</p>

<h3><span class="mw-headline" id="ADT_libraries">ADT libraries</span><span class="mw-editsection"></span></h3>
<p>Many modern programming languages, such as C++ and Java, come with standard libraries that implement several common ADTs, such as those listed above.
</p>
<h3><span class="mw-headline" id="Built-in_abstract_data_types">Built-in abstract data types</span><span class="mw-editsection"></span></h3>
<p>The specification of some programming languages is intentionally vague about the representation of certain built-in data types, defining only the operations that can be done on them. Therefore, those types can be viewed as "built-in ADTs". Examples are the arrays in many scripting languages, such as Awk, Lua, and Perl, which can be regarded as an implementation of the abstract list.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Concept (generic programming)</li>
<li>Formal methods</li>
<li>Functional specification</li>
<li>Generalized algebraic data type</li>
<li>Initial algebra</li>
<li>Liskov substitution principle</li>
<li>Type theory</li>
<li><i>Walls and Mirrors</i></li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="Citations">Citations</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-More_footnotes plainlinks metadata ambox ambox-style ambox-More_footnotes" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation journal cs1" id="CITEREFMitchellPlotkin1988">Mitchell, John C.; Plotkin, Gordon (July 1988). "Abstract Types Have Existential Type" <span class="cs1-format">(PDF)</span>. <i>ACM Transactions on Programming Languages and Systems</i>. <b>10</b> (3): 470–502. doi:10.1145/44501.45065. S2CID 1222153. Archived <span class="cs1-format">(PDF)</span> from the original on 2022-10-09.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=ACM+Transactions+on+Programming+Languages+and+Systems&amp;rft.atitle=Abstract+Types+Have+Existential+Type&amp;rft.volume=10&amp;rft.issue=3&amp;rft.pages=470-502&amp;rft.date=1988-07&amp;rft_id=info%3Adoi%2F10.1145%2F44501.45065&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A1222153%23id-name%3DS2CID&amp;rft.aulast=Mitchell&amp;rft.aufirst=John+C.&amp;rft.au=Plotkin%2C+Gordon&amp;rft_id=http%3A%2F%2Ftheory.stanford.edu%2F~jcm%2Fpapers%2Fmitch-plotkin-88.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbstract+data+type"></span></li></ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li><img alt="" class="noviewer" data-file-height="1376" data-file-width="1024" decoding="async" height="16" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/12px-Commons-logo.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/18px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/24px-Commons-logo.svg.png 2x" width="12"/> Media related to Abstract data types at Wikimedia Commons</li>
<li>Abstract data type in NIST Dictionary of Algorithms and Data Structures</li></ul>



<!-- 
NewPP limit report
Parsed by mw2371
Cached time: 20221223235442
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.450 seconds
Real time usage: 0.604 seconds
Preprocessor visited node count: 2573/1000000
Post‐expand include size: 110539/2097152 bytes
Template argument size: 15131/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 18/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 47890/5000000 bytes
Lua time usage: 0.245/10.000 seconds
Lua memory usage: 7551425/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  494.060      1 -total
 23.95%  118.306      6 Template:Ambox
 22.28%  110.058      2 Template:Reflist
 17.36%   85.760      3 Template:Cite_book
 14.71%   72.684      1 Template:Multiple_issues
 10.20%   50.387      1 Template:Short_description
  8.44%   41.686      2 Template:Navbox
  8.19%   40.442      1 Template:Data_structures
  6.85%   33.851      3 Template:Sfn
  5.97%   29.518      1 Template:Original_research
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:2349-0!canonical and timestamp 20221223235442 and revision id 1125380213.
 -->
</div></body>
</html>