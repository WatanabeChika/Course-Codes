<!DOCTYPE html>
<html>
<head>
<title>best-case_cost</title>
</head>
<body>
<div class="mw-parser-output"><style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>

<style data-mw-deduplicate="TemplateStyles:r1097763485">.mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}html.client-js body.skin-minerva .mw-parser-output .mbox-text-span{margin-left:23px!important}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}</style><table class="box-More_citations_needed plainlinks metadata ambox ambox-content ambox-Refimprove" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<p>In computer science, <b>best</b>, <b>worst</b>, and <b>average cases</b> of a given algorithm express what the resource usage is <i>at least</i>, <i>at most</i> and <i>on average</i>, respectively. Usually the resource being considered is running time, i.e. time complexity, but could also be memory or some other resource.
Best case is the function which performs the minimum number of steps on input data of n elements. Worst case is the function which performs the maximum number of steps on input data of size n. Average case is the function which performs an average number of steps on input data of n elements.
</p><p>In real-time computing, the worst-case execution time is often of particular concern since it is important to know how much time might be needed <i>in the worst case</i> to guarantee that the algorithm will always finish on time.
</p><p>Average performance and worst-case performance are the most used in algorithm analysis. Less widely found is best-case performance, but it does have uses: for example, where the best cases of individual tasks are known, they can be used to improve the accuracy of an overall worst-case analysis.  Computer scientists use probabilistic analysis techniques, especially expected value, to determine expected running times.
</p><p>The terms are used in other contexts; for example the worst- and best-case outcome of an epidemic, worst-case temperature to which an electronic circuit element is exposed, etc. Where components of specified tolerance are used, devices must be designed to work properly with the worst-case combination of tolerances and external conditions.
</p>

<h2><span class="mw-headline" id="Best-case_performance_for_algorithm">Best-case performance for algorithm</span><span class="mw-editsection"></span></h2>
<p><span class="anchor" id="BCET"></span>
</p><p>The term <i>best-case performance</i> is used in computer science to describe an algorithm's behavior under optimal conditions. For example, the best case for a simple linear search on a list occurs when the desired element is the first element of the list.
</p><p>Development and choice of algorithms is rarely based on best-case performance: most academic and commercial enterprises are more interested in improving Average-case complexity and  worst-case performance. Algorithms may also be trivially modified to have good best-case running time by hard-coding solutions to a finite set of inputs, making the measure almost meaningless.<sup class="reference" id="cite_ref-1">[1]</sup>
</p>
<h2><span class="mw-headline" id="Worst-case_versus_amortized_versus_average-case_performance">Worst-case versus amortized versus average-case performance</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1097763485" rel="mw-deduplicated-inline-style"/><table class="box-Unreferenced_section plainlinks metadata ambox ambox-content ambox-Unreferenced" role="presentation"><tbody><tr><td class="mbox-image"></td><td class="mbox-text"></td></tr></tbody></table>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<p>Worst-case performance analysis and average-case performance analysis have some similarities, but in practice usually require different tools and approaches.
</p><p>Determining what <i>typical input</i> means is difficult, and often that average input has properties which make it difficult to characterise mathematically (consider, for instance, algorithms that are designed to operate on strings of text). Similarly, even when a sensible description of a particular "average case" (which will probably only be applicable for some uses of the algorithm) is possible, they tend to result in more difficult analysis of equations.<sup class="reference" id="cite_ref-2">[2]</sup>
</p><p>Worst-case analysis gives a <i>safe</i> analysis (the worst case is never underestimated), but one which can be overly <i>pessimistic</i>, since there may be no (realistic) input that would take this many steps.
</p><p>In some situations it may be necessary to use a pessimistic analysis in order to guarantee safety. Often however, a pessimistic analysis may be too pessimistic, so an analysis that gets closer to the real value but may be optimistic (perhaps with some known low probability of failure) can be a much more practical approach. One modern approach in academic theory to bridge the gap between worst-case and average-case analysis is called smoothed analysis.
</p><p>When analyzing algorithms which often take a small time to complete, but periodically require a much larger time, amortized analysis can be used to determine the worst-case running time over a (possibly infinite) series of operations. This <b>amortized</b> cost can be much closer to the average cost, while still providing a guaranteed upper limit on the running time. So e.g. online algorithms are frequently based on amortized analysis.
</p><p>The worst-case analysis is related to the worst-case complexity.<sup class="reference" id="cite_ref-3">[3]</sup>
</p>
<h2><span class="mw-headline" id="Practical_consequences">Practical consequences</span><span class="mw-editsection"></span></h2>
<p>Many algorithms with bad worst-case performance have good average-case performance.  For problems we want to solve, this is a good thing: we can hope that the particular instances we care about are average.  For cryptography, this is very bad: we want typical instances of a cryptographic problem to be hard.  Here methods like random self-reducibility can be used for some specific problems to show that the worst case is no harder than the average case, or, equivalently, that the average case is no easier than the worst case.
</p><p>On the other hand, some data structures like hash tables have very poor worst-case behaviors, but a well written hash table of sufficient size will statistically never give the worst case; the average number of operations performed follows an exponential decay curve, and so the run time of an operation is statistically bounded.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<h3><span class="mw-headline" id="Sorting_algorithms">Sorting algorithms</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<table class="wikitable">
<tbody><tr>
<th>Algorithm</th>
<th>Data structure</th>
<th>Time complexity:Best</th>
<th>Time complexity:Average</th>
<th>Time complexity:Worst</th>
<th>Space complexity:Worst
</th></tr>
<tr>
<td>Quick sort</td>
<td>Array</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Merge sort</td>
<td>Array</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Heap sort</td>
<td>Array</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(1)
</td></tr>
<tr>
<td>Smooth sort</td>
<td>Array</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(<i>n</i> log(<i>n</i>))</td>
<td>O(1)
</td></tr>
<tr>
<td>Bubble sort</td>
<td>Array</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(1)
</td></tr>
<tr>
<td>Insertion sort</td>
<td>Array</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(1)
</td></tr>
<tr>
<td>Selection sort</td>
<td>Array</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(<i>n</i><sup>2</sup>)</td>
<td>O(1)
</td></tr>
<tr>
<td>Bogo sort</td>
<td>Array</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i> <i>n</i>!)</td>
<td>O(∞)</td>
<td>O(1)
</td></tr></tbody></table>

<ul><li>Insertion sort applied to a list of <i>n</i> elements, assumed to be all different and initially in random order. On average, half the elements in a list <i>A</i><sub>1</sub> ... <i>A</i><sub><i>j</i></sub> are less than element <i>A</i><sub><i>j</i>+1</sub>, and half are greater. Therefore, the algorithm compares the (<i>j</i> + 1)<sup>th</sup> element to be inserted on the average with half the already sorted sub-list, so <i>t</i><sub><i>j</i></sub> = <i>j</i>/2. Working out the resulting average-case running time yields a quadratic function of the input size, just like the worst-case running time.</li>
<li>Quicksort applied to a list of <i>n</i> elements, again assumed to be all different and initially in random order. This popular sorting algorithm has an average-case performance of O(<i>n</i> log(<i>n</i>)), which contributes to making it a very fast algorithm in practice. But given a worst-case input, its performance degrades to O(<i>n</i><sup>2</sup>). Also, when implemented with the "shortest first" policy, the worst-case space complexity is instead bounded by O(log(<i>n</i>)).</li>
<li>Heapsort has O(n) time when all elements are the same. Heapify takes O(n) time and then removing elements from the heap is O(1) time for each of the n elements. The run time grows to O(nlog(n)) if all elements must be distinct.</li>
<li>Bogosort has O(n) time when the elements are sorted on the first iteration. In each iteration all elements are checked if in order. There are n! possible permutations; with a balanced random number generator, almost each permutation of the array is yielded in n! iterations. Computers have limited memory, so the generated numbers cycle; it might not be possible to reach each permutation. In the worst case this leads to O(∞) time, an infinite loop.</li></ul>
<p><br/>
</p>
<h3><span class="mw-headline" id="Data_structures">Data structures</span><span class="mw-editsection"></span></h3>
<link href="mw-data:TemplateStyles:r1033289096" rel="mw-deduplicated-inline-style"/>
<table class="wikitable">
<tbody><tr>
<th rowspan="2">Data structure
</th>
<th colspan="8">Time complexity
</th>
<th>Space complexity
</th></tr>
<tr>
<th>Avg: Indexing</th>
<th>Avg: Search</th>
<th>Avg: Insertion</th>
<th>Avg: Deletion</th>
<th>Worst: Indexing</th>
<th>Worst: Search</th>
<th>Worst: Insertion</th>
<th>Worst: Deletion</th>
<th>Worst
</th></tr>
<tr>
<td>Basic array</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Dynamic array</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Stack</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Queue</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Singly linked list</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Doubly linked list</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Skip list</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>log (<i>n</i>))
</td></tr>
<tr>
<td>Hash table</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Binary search tree</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Cartesian tree</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>B-tree</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Red–black tree</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>Splay tree</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td class="table-na" data-sort-value="" style="vertical-align:middle; text-align:center">—</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>AVL tree</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)
</td></tr>
<tr>
<td>K-d tree</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(log (<i>n</i>))</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)</td>
<td>O(<i>n</i>)
</td></tr></tbody></table>
<ul><li>Linear search on a list of <i>n</i> elements. In the absolute worst case, the search must visit every element once. This happens when the value being searched for is either the last element in the list, or is not in the list. However, on average, assuming the value searched for is in the list and each list element is equally likely to be the value searched for, the search visits only <i>n</i>/2 elements.</li></ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Sorting algorithm – an area where there is a great deal of performance analysis of various algorithms.</li>
<li>Search data structure – any data structure that allows the efficient retrieval of specific items</li>
<li>Worst-case circuit analysis</li>
<li>Smoothed analysis</li>
<li>Interval finite element</li>
<li>Big O notation</li></ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<!-- 
NewPP limit report
Parsed by mw2413
Cached time: 20221224002326
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.178 seconds
Real time usage: 0.263 seconds
Preprocessor visited node count: 675/1000000
Post‐expand include size: 25096/2097152 bytes
Template argument size: 770/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 10/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 12330/5000000 bytes
Lua time usage: 0.102/10.000 seconds
Lua memory usage: 4253422/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  226.342      1 -total
 33.35%   75.475      1 Template:Reflist
 26.38%   59.711      1 Template:Citation
 22.46%   50.847      1 Template:Refimprove
 21.13%   47.815      2 Template:Ambox
 17.98%   40.706      1 Template:Short_description
 13.77%   31.175      1 Template:Redirect
  6.88%   15.579      2 Template:Pagetype
  6.65%   15.059      3 Template:Main_other
  5.83%   13.191      1 Template:SDcat
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:37956-0!canonical and timestamp 20221224002326 and revision id 1113464102.
 -->
</div></body>
</html>