<!DOCTYPE html>
<html>
<head>
<title>backtracking</title>
</head>
<body>
<div class="mw-parser-output"><p class="mw-empty-elt">
</p>

<style data-mw-deduplicate="TemplateStyles:r1033289096">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}</style>
<style data-mw-deduplicate="TemplateStyles:r1045330069">.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}</style><table class="sidebar nomobile nowraplinks hlist"><tbody><tr><th class="sidebar-title">Graph and tree<br/>search algorithms</th></tr><tr><td class="sidebar-content">
<ul><li>α–β pruning</li>
<li>Backtracking</li>
<li>Beam search</li>
<li>Best-first search</li>
<li>Branch &amp; bound</li>
<li>Breadth-First Search (<b>BFS</b>)</li>
<li>British Museum</li>
<li>Depth-First Search (<b>DFS</b>)</li>
<li>Hill climbing</li>
<li>Iterative Deepening DFS (IDDFS)</li>
<li>Lexicographic BFS</li></ul></td>
</tr><tr><th class="sidebar-heading">
Shortest path</th></tr><tr><td class="sidebar-content">
<ul><li><b>A*</b></li>
<li>B*</li>
<li>Bellman–Ford</li>
<li>Bidirectional search</li>
<li>D*</li>
<li><b>Dijkstra's</b></li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Iterative Deepening (IDA*)</li>
<li>Johnson's</li>
<li>Jump point search</li>
<li>Kruskal's</li>
<li>Lifelong Planning A* (LPA*)</li>
<li>Pathfinding</li>
<li>SMA*</li></ul></td>
</tr><tr><th class="sidebar-heading">
Lists</th></tr><tr><td class="sidebar-content">
<ul><li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li></ul></td>
</tr><tr><th class="sidebar-heading">
Related topics</th></tr><tr><td class="sidebar-content">
<ul><li>Dynamic programming</li>
<li>Graph coloring</li>
<li>Graph traversal</li>
<li>Minimum spanning tree</li>
<li>Search games</li>
<li>Threaded binary tree</li>
<li>Tree traversal</li></ul></td>
</tr><tr><td class="sidebar-navbar"><style data-mw-deduplicate="TemplateStyles:r1063604349">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}</style></td></tr></tbody></table>
<p><b>Backtracking</b> is a class of algorithms for finding solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.<sup class="reference" id="cite_ref-1">[1]</sup>
</p><p>The classic textbook example of the use of backtracking is the eight queens puzzle, that asks for all arrangements of eight chess queens on a standard chessboard so that no queen attacks any other.  In the common backtracking approach, the partial candidates are arrangements of <i>k</i> queens in the first <i>k</i> rows of the board, all in different rows and columns.  Any partial solution that contains two mutually attacking queens can be abandoned.
</p><p>Backtracking can be applied only for problems which admit the concept of a "partial candidate solution" and a relatively quick test of whether it can possibly be completed to a valid solution.  It is useless, for example, for locating a given value in an unordered table.  When it is applicable, however, backtracking is often much faster than brute-force enumeration of all complete candidates, since it can eliminate many candidates with a single test.
</p><p>Backtracking is an important tool for solving constraint satisfaction problems,<sup class="reference" id="cite_ref-BiereHeule2009_2-0">[2]</sup> such as crosswords, verbal arithmetic, Sudoku, and many other puzzles.  It is often the most convenient technique for parsing,<sup class="reference" id="cite_ref-Watson2017_3-0">[3]</sup> for the knapsack problem and other combinatorial optimization problems.  It is also the basis of the so-called logic programming languages such as  Icon, Planner and Prolog.
</p><p>Backtracking depends on user-given "black box procedures" that define the problem to be solved, the nature of the partial candidates, and how they are extended into complete candidates.  It is therefore a metaheuristic rather than a specific algorithm – although, unlike many other meta-heuristics, it is guaranteed to find all solutions to a finite problem in a bounded amount of time.
</p><p>The term "backtrack" was coined by American mathematician D. H. Lehmer in the 1950s.<sup class="reference" id="cite_ref-4">[4]</sup> The pioneer string-processing language SNOBOL (1962) may have been the first to provide a built-in general backtracking facility.
</p>

<h2><span class="mw-headline" id="Description_of_the_method">Description of the method</span><span class="mw-editsection"></span></h2>
<p>The backtracking algorithm enumerates a set of <i>partial candidates</i> that, in principle, could be <i>completed</i> in various ways to give all the possible solutions to the given problem. The completion is done incrementally, by a sequence of <i>candidate extension steps.</i>
</p><p>Conceptually, the partial candidates are represented as the nodes of a tree structure, the <i>potential search tree.</i> Each partial candidate is the parent of the candidates that differ from it by a single extension step; the leaves of the tree are the partial candidates that cannot be extended any further.
</p><p>The backtracking algorithm traverses this search tree recursively, from the root down, in depth-first order.  At each node <i>c</i>, the algorithm checks whether <i>c</i> can be completed to a valid solution.  If it cannot, the whole sub-tree rooted at <i>c</i> is skipped (<i>pruned</i>).  Otherwise, the algorithm (1) checks whether <i>c</i> itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees  of <i>c</i>.  The two tests and the children of each node are defined by user-given procedures.
</p><p>Therefore, the <i>actual search tree</i> that is traversed by the algorithm is only a part of the potential tree.  The total cost of the algorithm is the number of nodes of the actual tree times the cost of obtaining and processing each node.  This fact should be considered when choosing the potential search tree and implementing the pruning test.
</p>
<h3><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"></span></h3>
<p>In order to apply backtracking to a specific class of problems, one must provide the data <i>P</i> for the particular instance of the problem that is to be solved, and  six procedural parameters, <i>root</i>, <i>reject</i>, <i>accept</i>, <i>first</i>, <i>next</i>, and <i>output</i>. These procedures should take the instance data <i>P</i> as a parameter and should do the following:
</p>
<ol><li><i>root</i>(<i>P</i>):  return the partial candidate at the root of the search tree.</li>
<li><i>reject</i>(<i>P</i>,<i>c</i>):  return <i>true</i> only if the partial candidate <i>c</i> is not worth completing.</li>
<li><i>accept</i>(<i>P</i>,<i>c</i>): return <i>true</i> if <i>c</i> is a solution of <i>P</i>, and <i>false</i> otherwise.</li>
<li><i>first</i>(<i>P</i>,<i>c</i>): generate the first extension of candidate <i>c</i>.</li>
<li><i>next</i>(<i>P</i>,<i>s</i>): generate the next alternative extension of a candidate, after the extension <i>s</i>.</li>
<li><i>output</i>(<i>P</i>,<i>c</i>):  use the solution <i>c</i> of <i>P</i>, as appropriate to the application.</li></ol>
<p>The backtracking algorithm reduces the problem to the call <i>backtrack</i>(<i>root</i>(<i>P</i>)), where <i>backtrack</i> is the following recursive procedure:
</p>
<pre><b>procedure</b> backtrack(P, c) <b>is</b>
    <b>if</b> reject(P, c) <b>then</b> return
    <b>if</b> accept(P, c) <b>then</b> output(P, c)
    s ← first(P, c)
    <b>while</b> s ≠ NULL <b>do</b>
        backtrack(P, s)
        s ← next(P, s)
</pre>
<h3><span class="mw-headline" id="Usage_considerations">Usage considerations</span><span class="mw-editsection"></span></h3>
<p>The <i>reject</i> procedure should be a boolean-valued function that returns <i>true</i> only if it is certain that no possible extension of <i>c</i> is a valid solution for <i>P</i>.  If the procedure cannot reach a definite conclusion, it should return <i>false</i>. An incorrect <i>true</i> result may  cause the <i>backtrack</i> procedure to miss some valid solutions.  The procedure may assume that <i>reject</i>(<i>P</i>,<i>t</i>) returned <i>false</i> for every ancestor <i>t</i> of <i>c</i> in the search tree.
</p><p>On the other hand, the efficiency of the backtracking algorithm depends on <i>reject</i> returning <i>true</i> for candidates that are as close to the root as possible.  If <i>reject</i> always returns <i>false</i>, the algorithm will still find all solutions, but it will be equivalent to a brute-force search.
</p><p>The <i>accept</i> procedure should return <i>true</i> if <i>c</i> is a complete and valid solution for the problem instance <i>P</i>, and <i>false</i> otherwise.  It may assume that the partial candidate <i>c</i> and all its ancestors in the tree have passed the <i>reject</i> test.
</p><p>The general pseudo-code above does not assume that the valid solutions are always leaves of the potential search tree.  In other words, it admits the possibility that a valid solution for <i>P</i> can be further extended to yield other valid solutions.
</p><p>The <i>first</i> and <i>next</i> procedures are used by the backtracking algorithm to enumerate the children of a node <i>c</i> of the tree, that is, the candidates that differ from <i>c</i> by a single  extension step.  The call <i>first</i>(<i>P</i>,<i>c</i>) should yield the first child of <i>c</i>, in some order; and the call <i>next</i>(<i>P</i>,<i>s</i>) should return the next sibling of node <i>s</i>, in that order.  Both functions should return a distinctive "NULL" candidate, if the requested child does not exist.
</p><p>Together, the <i>root</i>, <i>first</i>, and <i>next</i> functions define the set of partial candidates and the potential search tree.  They should be chosen so that every  solution of <i>P</i> occurs somewhere in the tree, and no partial candidate occurs more than once.  Moreover, they should admit an efficient and effective <i>reject</i> predicate.
</p>
<h3><span class="mw-headline" id="Early_stopping_variants">Early stopping variants</span><span class="mw-editsection"></span></h3>
<p>The pseudo-code above will call <i>output</i> for all candidates that are a solution to the given instance <i>P</i>. The algorithm can be modified to stop after finding the first solution, or a specified number of solutions; or after testing a specified number of partial candidates, or after spending a given amount of CPU time.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>

<p>Examples where backtracking can be used to solve puzzles or problems include:
</p>
<ul><li>Puzzles such as eight queens puzzle, crosswords, verbal arithmetic, Sudoku<sup class="reference" id="cite_ref-5">[nb 1]</sup>, and Peg Solitaire.</li>
<li>Combinatorial optimization problems such as parsing and the knapsack problem.</li>
<li>Logic programming languages such as Icon, Planner and Prolog, which use backtracking internally to generate answers.</li></ul>
<p>The following is an example where backtracking is used for the constraint satisfaction problem:
</p>
<h3><span class="mw-headline" id="Constraint_satisfaction">Constraint satisfaction</span><span class="mw-editsection"></span></h3>
<p>The general constraint satisfaction problem consists in finding a list of integers <span class="nowrap"><i>x</i> = (<i>x</i>[1], <i>x</i>[2], …, <i>x</i>[<i>n</i>])</span>, each in some range <span class="nowrap">{1, 2, …, <i>m</i></span>}, that satisfies some arbitrary constraint (boolean function) <i>F</i>.
</p><p>For this class of problems, the instance data <i>P</i> would be the integers <i>m</i> and <i>n</i>, and the predicate <i>F</i>. In a typical backtracking solution to this problem, one could define a partial candidate as a list of integers <span class="nowrap"><i>c</i> = (<i>c</i>[1], <i>c</i>[2], …, <i>c</i>[k])</span>, for any <i>k</i> between 0 and <i>n</i>, that are to be assigned to the first <i>k</i> variables <span class="nowrap"><i>x</i>[1], <i>x</i>[2], …, <i>x</i>[<i>k</i>]</span>. The root candidate would then be the empty list (). The <i>first</i> and <i>next</i> procedures would then be
</p>
<pre><b>function</b> first(P, c) <b>is</b>
    k ← length(c)
    <b>if</b> k = n <b>then</b>
        <b>return</b> NULL
    <b>else</b>
        <b>return</b> (c[1], c[2], …, c[k], 1)
</pre>
<pre><b>function</b> next(P, s) <b>is</b>
    k ← length(s)
    <b>if</b> s[k] = m <b>then</b>
        <b>return</b> NULL
    <b>else</b>
        <b>return</b> (s[1], s[2], …, s[k − 1], 1 + s[k])
</pre>
<p>Here <i>length</i>(<i>c</i>) is the number of elements in the list <i>c</i>.
</p><p>The call <i>reject</i>(<i>P</i>, <i>c</i>) should return <i>true</i> if the constraint <i>F</i> cannot be satisfied by any list of <i>n</i> integers that begins with the <i>k</i> elements of <i>c</i>. For backtracking to be effective, there must be a way to detect this situation, at least for some candidates <i>c</i>, without enumerating all those <i>m</i><sup><i>n</i> − <i>k</i></sup> <i>n</i>-tuples.
</p><p>For example, if <i>F</i> is the conjunction of several boolean predicates, <span class="nowrap"><i>F</i> = <i>F</i>[1] ∧ <i>F</i>[2] ∧ … ∧ <i>F</i>[<i>p</i>]</span>, and each <i>F</i>[<i>i</i>] depends only on a small subset of the variables <span class="nowrap"><i>x</i>[1], …, <i>x</i>[<i>n</i>]</span>, then the <i>reject</i> procedure could simply check the terms <i>F</i>[<i>i</i>] that depend only on variables <span class="nowrap"><i>x</i>[1], …, <i>x</i>[<i>k</i>]</span>, and return <i>true</i> if any of those terms returns <i>false</i>. In fact, <i>reject</i> needs only check those terms that do depend on <i>x</i>[<i>k</i>], since the terms that depend only on <span class="nowrap"><i>x</i>[1], …, <i>x</i>[<i>k</i> − 1]</span> will have been tested further up in the search tree.
</p><p>Assuming that <i>reject</i> is implemented as above, then <i>accept</i>(<i>P</i>, <i>c</i>) needs only check whether <i>c</i> is complete, that is, whether it has <i>n</i> elements.
</p><p>It is generally better to order the list of variables so that it begins with the most critical ones (i.e. the ones with fewest value options, or which have a greater impact on subsequent choices).
</p><p>One could also allow the <i>next</i> function to choose which variable should be assigned when extending a partial candidate, based on the values of the variables already assigned by it. Further improvements can be obtained by the technique of constraint propagation.
</p><p>In addition to retaining minimal recovery values used in backing up, backtracking implementations commonly keep a variable trail, to record value change history. An efficient implementation will avoid creating a variable trail entry between two successive changes when there is no choice point, as the backtracking will erase all of the changes as a single operation.
</p><p>An alternative to the variable trail is to keep a timestamp of when the last change was made to the variable. The timestamp is compared to the timestamp of a choice point. If the choice point has an associated time later than that of the variable, it is unnecessary to revert the variable when the choice point is backtracked, as it was changed before the choice point occurred.
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Ariadne's thread (logic)</li>
<li>Backjumping</li>
<li>Backward chaining</li>
<li>Enumeration algorithm</li>
<li>Sudoku solving algorithms</li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"></span></h2>
<link href="mw-data:TemplateStyles:r1011085734" rel="mw-deduplicated-inline-style"/>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1054258005">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}</style>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"></span></h2>
<ul><li>HBmeyer.de, Interactive animation of a backtracking algorithm</li>
<li>Solving Combinatorial Problems with STL and Backtracking, Article and C++ source code for a generic implementation of backtracking</li></ul>

<!-- 
NewPP limit report
Parsed by mw2412
Cached time: 20221220214642
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.253 seconds
Real time usage: 0.338 seconds
Preprocessor visited node count: 974/1000000
Post‐expand include size: 35829/2097152 bytes
Template argument size: 986/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 26461/5000000 bytes
Lua time usage: 0.151/10.000 seconds
Lua memory usage: 4811872/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  289.461      1 -total
 34.98%  101.259      2 Template:Reflist
 24.84%   71.898      1 Template:Cite_web
 16.81%   48.671      1 Template:Short_description
 13.83%   40.042      1 Template:Graph_search_algorithm
 13.29%   38.460      1 Template:Sidebar
 11.30%   32.719      2 Template:Navbox
  9.14%   26.466      1 Template:Parsers
  8.24%   23.841      1 Template:Use_dmy_dates
  7.44%   21.546      2 Template:Pagetype
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:238867-0!canonical and timestamp 20221220214642 and revision id 1124328239.
 -->
</div></body>
</html>