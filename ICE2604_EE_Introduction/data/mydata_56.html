<!DOCTYPE html>
<html>
<head>
<title>assignment_problem</title>
</head>
<body>
<div class="mw-parser-output">
<p>The <b>assignment problem</b> is a fundamental combinatorial optimization problem. In its most general form, the problem is as follows:
</p>
<dl><dd>The problem instance has a number of <i>agents</i> and a number of <i>tasks</i>. Any agent can be assigned to perform any task, incurring some <i>cost</i> that may vary depending on the agent-task assignment. It is required to perform as many tasks as possible by assigning at most one agent to each task and at most one task to each agent, in such a way that the <i>total cost</i> of the assignment is minimized.</dd></dl>
<p>Alternatively, describing the problem using graph theory:
</p>
<dl><dd>The assignment problem consists of finding, in a weighted bipartite graph, a matching of a given size, in which the sum of weights of the edges is minimum.</dd></dl>
<p>If the numbers of agents and tasks are equal, then the problem is called <i>balanced assignment</i>. Otherwise, it is called <i>unbalanced assignment</i>.<sup class="reference" id="cite_ref-:0_1-0">[1]</sup> If the total cost of the assignment for all tasks is equal to the sum of the costs for each agent (or the sum of the costs for each task, which is the same thing in this case), then the problem is called <i>linear assignment</i>. Commonly, when speaking of the <i>assignment problem</i> without any additional qualification, then the <i>linear balanced assignment problem</i> is meant.
</p>

<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"></span></h2>
<p>Suppose that a taxi firm has three taxis (the agents) available, and three customers (the tasks) wishing to be picked up as soon as possible. The firm prides itself on speedy pickups, so for each taxi the "cost" of picking up a particular customer will depend on the time taken for the taxi to reach the pickup point. This is a <i>balanced assignment</i> problem. Its solution is whichever combination of taxis and customers results in the least total cost.
</p><p>Now, suppose that there are <i>four</i> taxis available, but still only three customers. This is an <i>unbalanced assignment</i> problem. One way to solve it is to invent a fourth dummy task, perhaps called "sitting still doing nothing", with a cost of 0 for the taxi assigned to it. This reduces the problem to a balanced assignment problem, which can then be solved in the usual way and still give the best solution to the problem.
</p><p>Similar adjustments can be done in order to allow more tasks than agents, tasks to which multiple agents must be assigned (for instance, a group of more customers than will fit in one taxi), or maximizing profit rather than minimizing cost.
</p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"></span></h2>
<p>The formal definition of the <b>assignment problem</b> (or <b>linear assignment problem</b>) is
</p>
<dl><dd>Given two sets, <i>A</i> and <i>T</i>, of equal size, together with a weight function <i>C</i> : <i>A</i> × <i>T</i> → <b>R</b>. Find a bijection <i>f</i> : <i>A</i> → <i>T</i> such that the cost function:
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \sum _{a\in A}C(a,f(a))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>a</mi>
<mo>∈<!-- ∈ --></mo>
<mi>A</mi>
</mrow>
</munder>
<mi>C</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>,</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \sum _{a\in A}C(a,f(a))}</annotation>
</semantics>
</math></span><img alt="\sum _{{a\in A}}C(a,f(a))" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/16b7eda822426d7a5f813f22e4905432c4ba79ac" style="vertical-align: -3.171ex; width:13.899ex; height:5.676ex;"/></span></dd></dl></dd></dl>
<p>is minimized.
</p><p>Usually the weight function is viewed as a square real-valued matrix <i>C</i>, so that the cost function is written down as:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \sum _{a\in A}C_{a,f(a)}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mi>a</mi>
<mo>∈<!-- ∈ --></mo>
<mi>A</mi>
</mrow>
</munder>
<msub>
<mi>C</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>a</mi>
<mo>,</mo>
<mi>f</mi>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \sum _{a\in A}C_{a,f(a)}}</annotation>
</semantics>
</math></span><img alt="\sum _{{a\in A}}C_{{a,f(a)}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3f06886751101bfff9065533c5c9f2d755ac2148" style="vertical-align: -3.171ex; width:10.016ex; height:5.676ex;"/></span></dd></dl>
<p>The problem is "linear" because the cost function to be optimized as well as all the constraints contain only linear terms.
</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"></span></h2>
<p>A naive solution for the assignment problem is to check all the assignments and calculate the cost of each one. This may be very inefficient since, with <i>n</i> agents and <i>n</i> tasks, there are <i>n</i>! (factorial of <i>n</i>) different assignments. Fortunately, there are many algorithms for solving the problem in time polynomial in <i>n</i>.
</p><p>The assignment problem is a special case of the transportation problem, which is a special case of the minimum cost flow problem, which in turn is a special case of a linear program.  While it is possible to solve any of these problems using the simplex algorithm, each specialization has a smaller solution space and thus more efficient algorithms designed to take advantage of its special structure.
</p>
<h3><span class="mw-headline" id="Balanced_assignment">Balanced assignment</span><span class="mw-editsection"></span></h3>
<p>In the balanced assignment problem, both parts of the bipartite graph have the same number of vertices, denoted by <i>n</i>.
</p><p>One of the first polynomial-time algorithms for balanced assignment was the Hungarian algorithm. It is a <i>global</i> algorithm – it is based on improving a matching along augmenting paths (alternating paths between unmatched vertices). Its run-time complexity, when using Fibonacci heaps, is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(mn+n^{2}\log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mi>n</mi>
<mo>+</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(mn+n^{2}\log n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(mn+n^{2}\log n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e6c65ba1ec52875d490e86d8eed282c87ce738a0" style="vertical-align: -0.838ex; width:17.448ex; height:3.176ex;"/></span>,<sup class="reference" id="cite_ref-2">[2]</sup> where <i>m</i> is a number of edges.  This is currently the fastest run-time of a strongly polynomial algorithm for this problem. If all weights are integers, then the run-time can be improved to  <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(mn+n^{2}\log \log n)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mi>n</mi>
<mo>+</mo>
<msup>
<mi>n</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(mn+n^{2}\log \log n)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(mn+n^{2}\log \log n)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c8661bb2aae62d3f69c0b65e6b3a7abc1a6604c0" style="vertical-align: -0.838ex; width:20.807ex; height:3.176ex;"/></span>, but the resulting algorithm is only weakly-polynomial.<sup class="reference" id="cite_ref-3">[3]</sup> If the weights are integers, and all weights are at most <i>C</i> (where <i>C</i>&gt;1 is some integer), then the problem can be solved in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(m{\sqrt {n}}\log(n\cdot C))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mrow class="MJX-TeXAtom-ORD">
<msqrt>
<mi>n</mi>
</msqrt>
</mrow>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>⋅<!-- ⋅ --></mo>
<mi>C</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(m{\sqrt {n}}\log(n\cdot C))}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(m{\sqrt {n}}\log(n\cdot C))}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b22cc76eb3e123874160f7726485fad7410a840" style="vertical-align: -1.005ex; width:18.962ex; height:3.009ex;"/></span> weakly-polynomial time in a method called <i>weight scaling</i>.<sup class="reference" id="cite_ref-4">[4]</sup><sup class="reference" id="cite_ref-5">[5]</sup><sup class="reference" id="cite_ref-6">[6]</sup>
</p><p>In addition to the global methods, there are <i>local methods</i> which are based on finding local updates (rather than full augmenting paths). These methods have worse asymptotic runtime guarantees, but they often work better in practice. These algorithms are called auction algorithms, push-relabel algorithms, or preflow-push algorithms. Some of these algorithms were shown to be equivalent.<sup class="reference" id="cite_ref-7">[7]</sup>
</p><p>Some of the local methods assume that the graph admits a <i>perfect matching</i>; if this is not the case, then some of these methods might run forever.<sup class="reference" id="cite_ref-:0_1-1">[1]</sup><sup class="reference nowrap"><span title="Page / location: 3">: 3 </span></sup>  A simple technical way to solve this problem is to extend the input graph to a <i>complete bipartite graph,</i> by adding artificial edges with very large weights. These weights should exceed the weights of all existing matchings, to prevent appearance of artificial edges in the possible solution.
</p><p>As shown by Mulmuley, Vazirani and Vazirani,<sup class="reference" id="cite_ref-8">[8]</sup> the problem of minimum weight perfect matching is converted to finding minors in the adjacency matrix of a graph. Using the isolation lemma, a minimum weight perfect matching in a graph can be found with probability at least <style data-mw-deduplicate="TemplateStyles:r1020198016">.mw-parser-output .frac{white-space:nowrap}.mw-parser-output .frac .num,.mw-parser-output .frac .den{font-size:80%;line-height:0;vertical-align:super}.mw-parser-output .frac .den{vertical-align:sub}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}</style><span class="frac" role="math"><span class="num">1</span>⁄<span class="den">2</span></span>. For a graph with <i>n</i> vertices, it requires <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(\log ^{2}(n))}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<msup>
<mi>log</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mo>⁡<!-- ⁡ --></mo>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(\log ^{2}(n))}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(\log ^{2}(n))}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3504e9a0325bc9a82cfe4889213e0c3008dd1b54" style="vertical-align: -0.838ex; width:10.813ex; height:3.176ex;"/></span> time.
</p>
<h3><span class="mw-headline" id="Unbalanced_assignment">Unbalanced assignment</span><span class="mw-editsection"></span></h3>
<p>In the unbalanced assignment problem, the larger part of the bipartite graph has <i>n</i> vertices and the smaller part has <i>r</i>&lt;<i>n</i> vertices. There is also a constant <i>s</i> which is at most the cardinality of a maximum matching in the graph. The goal is to find a minimum-cost matching of size exactly <i>s</i>. The most common case is the case in which the graph admits a one-sided-perfect matching (i.e., a matching of size <i>r</i>), and <i>s</i>=<i>r</i>.
</p><p>Unbalanced assignment can be reduced to a balanced assignment. The naive reduction is to add <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n-r}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>−<!-- − --></mo>
<mi>r</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n-r}</annotation>
</semantics>
</math></span><img alt="n-r" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/86c0aa8d9c52b096540edd6e6a91eb8f790a8b7e" style="vertical-align: -0.505ex; width:5.284ex; height:2.176ex;"/></span> new vertices to the smaller part and connect them to the larger part using edges of cost 0. However, this requires <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n(n-r)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>−<!-- − --></mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n(n-r)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle n(n-r)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/137dd4aae523a75f5dd223b67951b0b8eab6f324" style="vertical-align: -0.838ex; width:8.488ex; height:2.843ex;"/></span> new edges. A more efficient reduction is called the <i>doubling technique</i>. Here, a new graph <i>G'</i> is built from two copies of the original graph <i>G</i>: a forward copy <i>Gf</i> and a backward copy <i>Gb.</i> The backward copy is "flipped", so that, in each side of <i>G'</i>, there are now <i>n</i>+<i>r</i> vertices. Between the copies, we need to add two kinds of linking edges:<sup class="reference" id="cite_ref-:0_1-2">[1]</sup><sup class="reference nowrap"><span title="Page / location: 4–6">: 4–6 </span></sup>
</p>
<ul><li>Large-to-large: from each vertex in the larger part of <i>Gf</i>, add a zero-cost edge to the corresponding vertex in <i>Gb</i>.</li>
<li>Small-to-small: if the original graph does not have a one-sided-perfect matching, then from each vertex in the smaller part of <i>Gf</i>, add a very-high-cost edge to the corresponding vertex in <i>Gb</i>.</li></ul>
<p>All in all, at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n+r}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>+</mo>
<mi>r</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n+r}</annotation>
</semantics>
</math></span><img alt="n+r" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d6a5e6925440ca0c67b8608c15b3fc842d6b3199" style="vertical-align: -0.505ex; width:5.284ex; height:2.176ex;"/></span> new edges are required. The resulting graph always has a perfect matching of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle n+r}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>n</mi>
<mo>+</mo>
<mi>r</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle n+r}</annotation>
</semantics>
</math></span><img alt="n+r" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d6a5e6925440ca0c67b8608c15b3fc842d6b3199" style="vertical-align: -0.505ex; width:5.284ex; height:2.176ex;"/></span>. A minimum-cost perfect matching in this graph must consist of minimum-cost maximum-cardinality matchings in <i>Gf</i> and <i>Gb.</i>  The main problem with this doubling technique is that there is no speed gain when <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle r\ll n}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>r</mi>
<mo>≪<!-- ≪ --></mo>
<mi>n</mi>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle r\ll n}</annotation>
</semantics>
</math></span><img alt="{\displaystyle r\ll n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d2e3eba9748707971ca5eff9ebdd7367035a18c8" style="vertical-align: -0.338ex; width:6.057ex; height:1.843ex;"/></span>.
</p><p>Instead of using reduction, the unbalanced assignment problem can be solved by directly generalizing existing algorithms for balanced assignment. The Hungarian algorithm can be generalized to solve the problem in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(ms+s^{2}\log r)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mi>s</mi>
<mo>+</mo>
<msup>
<mi>s</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(ms+s^{2}\log r)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(ms+s^{2}\log r)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/643abc1cc3b267708c031535dacebaea3763f1ee" style="vertical-align: -0.838ex; width:16.493ex; height:3.176ex;"/></span> strongly-polynomial time. In particular, if <i>s</i>=<i>r</i> then the runtime is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(mr+r^{2}\log r)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mi>r</mi>
<mo>+</mo>
<msup>
<mi>r</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(mr+r^{2}\log r)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(mr+r^{2}\log r)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2d539da2c847e451f6ffffd2c27224aab018c6b4" style="vertical-align: -0.838ex; width:16.41ex; height:3.176ex;"/></span>.   If the weights are integers, then Thorup's method can be used to get a runtime of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle O(ms+s^{2}\log \log r)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mi>O</mi>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mi>s</mi>
<mo>+</mo>
<msup>
<mi>s</mi>
<mrow class="MJX-TeXAtom-ORD">
<mn>2</mn>
</mrow>
</msup>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>log</mi>
<mo>⁡<!-- ⁡ --></mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle O(ms+s^{2}\log \log r)}</annotation>
</semantics>
</math></span><img alt="{\displaystyle O(ms+s^{2}\log \log r)}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f91967a0cd5e7e446df7e713569c23afe3548ee1" style="vertical-align: -0.838ex; width:19.852ex; height:3.176ex;"/></span>.<sup class="reference" id="cite_ref-:0_1-3">[1]</sup><sup class="reference nowrap"><span title="Page / location: 6">: 6 </span></sup>
</p>
<h3><span class="mw-headline" id="Solution_by_linear_programming">Solution by linear programming</span><span class="mw-editsection"></span></h3>
<p>The assignment problem can be solved by presenting it as a linear program. For convenience we will present the maximization problem. Each edge <span class="texhtml">(<i>i</i>,<i>j</i>)</span>, where <i>i</i> is in A and <i>j</i> is in T, has a weight <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle w_{ij}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle w_{ij}}</annotation>
</semantics>
</math></span><img alt="{\textstyle w_{ij}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7250b6181b9bba7a8edf5845fb59dfc7fe1f722f" style="vertical-align: -1.005ex; width:3.141ex; height:2.343ex;"/></span>. For each edge <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle (i,j)}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo stretchy="false">)</mo>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle (i,j)}</annotation>
</semantics>
</math></span><img alt="(i,j)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ef21910f980c6fca2b15bee102a7a0d861ed712" style="vertical-align: -0.838ex; width:4.604ex; height:2.843ex;"/></span> we have a variable <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\textstyle x_{ij}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="false" scriptlevel="0">
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\textstyle x_{ij}}</annotation>
</semantics>
</math></span><img alt="{\textstyle x_{ij}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a350feefa817472ab65b8e836c3149be3cffedf4" style="vertical-align: -1.005ex; width:2.807ex; height:2.343ex;"/></span><sub>.</sub> The variable is 1 if the edge is contained in the matching and 0 otherwise, so we set the domain constraints:  
</p> 
<p>The total weight of the matching is: <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\displaystyle \sum _{(i,j)\in A\times T}w_{ij}x_{ij}}" xmlns="http://www.w3.org/1998/Math/MathML">
<semantics>
<mrow class="MJX-TeXAtom-ORD">
<mstyle displaystyle="true" scriptlevel="0">
<munder>
<mo>∑<!-- ∑ --></mo>
<mrow class="MJX-TeXAtom-ORD">
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo stretchy="false">)</mo>
<mo>∈<!-- ∈ --></mo>
<mi>A</mi>
<mo>×<!-- × --></mo>
<mi>T</mi>
</mrow>
</munder>
<msub>
<mi>w</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
<msub>
<mi>x</mi>
<mrow class="MJX-TeXAtom-ORD">
<mi>i</mi>
<mi>j</mi>
</mrow>
</msub>
</mstyle>
</mrow>
<annotation encoding="application/x-tex">{\displaystyle \sum _{(i,j)\in A\times T}w_{ij}x_{ij}}</annotation>
</semantics>
</math></span><img alt="{\displaystyle \sum _{(i,j)\in A\times T}w_{ij}x_{ij}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1de09cfde145ed0c829f6ccfd701a6db67e8cab" style="vertical-align: -3.505ex; width:14.081ex; height:6.009ex;"/></span>. The goal is to find a maximum-weight perfect matching.
</p><p>To guarantee that the variables indeed represent a perfect matching, we add constraints saying that each vertex is adjacent to exactly one edge in the matching, i.e.,  
</p>.
<p>All in all we have the following LP:
</p><p></p>This is an integer linear program.  However, we can solve it without the integrality constraints (i.e., drop the last constraint), using standard methods for solving continuous linear programs. While this formulation allows also fractional variable values, in this special case, the LP always has an optimal solution where the variables take integer values.  This is because the constraint matrix of the fractional LP is totally unimodular – it satisfies the four conditions of Hoffman and Gale.

<h3><span class="mw-headline" id="Other_methods_and_approximation_algorithms">Other methods and approximation algorithms</span><span class="mw-editsection"></span></h3>
<p>Other approaches for the assignment problem exist and are reviewed by Duan and Pettie<sup class="reference" id="cite_ref-9">[9]</sup> (see Table II). Their work proposes an approximation algorithm for the assignment problem (and the more general maximum weight matching problem), which runs in linear time for any fixed error bound.
</p>
<h2><span class="mw-headline" id="Generalization">Generalization</span><span class="mw-editsection"></span></h2>
<p>When phrased as a graph theory problem, the assignment problem can be extended from bipartite graphs to arbitrary graphs. The corresponding problem, of finding a matching in a weighted graph where the sum of weights is maximized, is called the maximum weight matching problem.
</p><p>Another generalization of the assignment problem is extending the number of sets to be matched from two to many. So that rather than matching agents to tasks, the problem is extended to matching agents to tasks to time intervals to locations. This results in Multidimensional assignment problem (MAP).
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"></span></h2>
<ul><li>Auction algorithm</li>
<li>Generalized assignment problem</li>
<li>Linear bottleneck assignment problem</li>
<li>Monge-Kantorovich transportation problem, a more general formulation</li>
<li>National Resident Matching Program</li>
<li>Quadratic assignment problem</li>
<li>Rank-maximal matching</li>
<li>Secretary problem</li>
<li>Stable marriage problem</li>
<li>Stable roommates problem</li>
<li>Weapon target assignment problem</li>
<li>House allocation problem</li>
<li>Multidimensional assignment problem (MAP)</li></ul>
<h2><span class="mw-headline" id="References_and_further_reading">References and further reading</span><span class="mw-editsection"></span></h2>
<style data-mw-deduplicate="TemplateStyles:r1011085734">.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style>
<ul><li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBrualdi2006">Brualdi, Richard A. (2006). <span class="cs1-lock-registration" title="Free registration required"><i>Combinatorial matrix classes</i></span>. Encyclopedia of Mathematics and Its Applications. Vol. 108. Cambridge: Cambridge University Press. ISBN <bdi>978-0-521-86565-4</bdi>. Zbl 1106.05001.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Combinatorial+matrix+classes&amp;rft.place=Cambridge&amp;rft.series=Encyclopedia+of+Mathematics+and+Its+Applications&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2006&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A1106.05001%23id-name%3DZbl&amp;rft.isbn=978-0-521-86565-4&amp;rft.aulast=Brualdi&amp;rft.aufirst=Richard+A.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fcombinatorialmat0000brua&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAssignment+problem"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBurkardM._Dell'AmicoS._Martello2012">Burkard, Rainer; M. Dell'Amico; S. Martello (2012). <i>Assignment Problems (Revised reprint)</i>. SIAM. ISBN <bdi>978-1-61197-222-1</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Assignment+Problems+%28Revised+reprint%29&amp;rft.pub=SIAM&amp;rft.date=2012&amp;rft.isbn=978-1-61197-222-1&amp;rft.aulast=Burkard&amp;rft.aufirst=Rainer&amp;rft.au=M.+Dell%27Amico&amp;rft.au=S.+Martello&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAssignment+problem"></span></li>
<li><link href="mw-data:TemplateStyles:r1067248974" rel="mw-deduplicated-inline-style"/><cite class="citation book cs1" id="CITEREFBertsekas1998">Bertsekas, Dimitri (1998). <i>Network Optimization: Continuous and Discrete Models</i>. Athena Scientific. ISBN <bdi>978-1-886529-02-1</bdi>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Network+Optimization%3A+Continuous+and+Discrete+Models&amp;rft.pub=Athena+Scientific&amp;rft.date=1998&amp;rft.isbn=978-1-886529-02-1&amp;rft.aulast=Bertsekas&amp;rft.aufirst=Dimitri&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAssignment+problem"></span></li></ul>

<!-- 
NewPP limit report
Parsed by mw2408
Cached time: 20221224021130
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.270 seconds
Real time usage: 0.395 seconds
Preprocessor visited node count: 1798/1000000
Post‐expand include size: 29279/2097152 bytes
Template argument size: 762/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 38912/5000000 bytes
Lua time usage: 0.148/10.000 seconds
Lua memory usage: 6304736/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  289.576      1 -total
 40.51%  117.320      1 Template:Reflist
 21.84%   63.257      1 Template:Cite_web
 18.93%   54.816      1 Template:Short_description
 17.73%   51.343      1 Template:Authority_control
 12.91%   37.376      8 Template:Cite_journal
 10.35%   29.978      2 Template:Pagetype
 10.29%   29.809      3 Template:Rp
  9.41%   27.244      3 Template:R/superscript
  5.18%   15.004      3 Template:Cite_book
-->
<!-- Saved in parser cache with key enwiki:pcache:idhash:140592-0!canonical and timestamp 20221224021129 and revision id 1120341860.
 -->
</div></body>
</html>